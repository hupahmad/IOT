/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2Fhome%2Fjon%2FIOT%2FIOT%2Ffrontend%2FV%201.0%2Fmy-app%2Fsrc%2Fapp%2Fpage.jsx&server=false!":
/*!**********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2Fhome%2Fjon%2FIOT%2FIOT%2Ffrontend%2FV%201.0%2Fmy-app%2Fsrc%2Fapp%2Fpage.jsx&server=false! ***!
  \**********************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.jsx */ \"(app-pages-browser)/./src/app/page.jsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZob21lJTJGam9uJTJGSU9UJTJGSU9UJTJGZnJvbnRlbmQlMkZWJTIwMS4wJTJGbXktYXBwJTJGc3JjJTJGYXBwJTJGcGFnZS5qc3gmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2M4NzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9qb24vSU9UL0lPVC9mcm9udGVuZC9WIDEuMC9teS1hcHAvc3JjL2FwcC9wYWdlLmpzeFwiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2Fhome%2Fjon%2FIOT%2FIOT%2Ffrontend%2FV%201.0%2Fmy-app%2Fsrc%2Fapp%2Fpage.jsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/image.js":
/*!*********************************************!*\
  !*** ./node_modules/next/dist/api/image.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=image.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWOztBQUU3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9pbWFnZS5qcz82ZjNiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWxcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/link.js":
/*!********************************************!*\
  !*** ./node_modules/next/dist/api/link.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _client_link__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/link */ \"(app-pages-browser)/./node_modules/next/dist/client/link.js\");\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_link__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_link__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_link__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=link.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlDO0FBQ1Y7O0FBRS9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanM/ZjBkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi4uL2NsaWVudC9saW5rXCI7XG5leHBvcnQgKiBmcm9tIFwiLi4vY2xpZW50L2xpbmtcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/micromatch/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../node_modules/process/browser.js\");\n(()=>{\"use strict\";var e={333:(e,t,r)=>{const n=r(137);const u=r(179);const s=r(13);const o=r(719);const braces=(e,t={})=>{let r=[];if(Array.isArray(e)){for(let n of e){let e=braces.create(n,t);if(Array.isArray(e)){r.push(...e)}else{r.push(e)}}}else{r=[].concat(braces.create(e,t))}if(t&&t.expand===true&&t.nodupes===true){r=[...new Set(r)]}return r};braces.parse=(e,t={})=>o(e,t);braces.stringify=(e,t={})=>{if(typeof e===\"string\"){return n(braces.parse(e,t),t)}return n(e,t)};braces.compile=(e,t={})=>{if(typeof e===\"string\"){e=braces.parse(e,t)}return u(e,t)};braces.expand=(e,t={})=>{if(typeof e===\"string\"){e=braces.parse(e,t)}let r=s(e,t);if(t.noempty===true){r=r.filter(Boolean)}if(t.nodupes===true){r=[...new Set(r)]}return r};braces.create=(e,t={})=>{if(e===\"\"||e.length<3){return[e]}return t.expand!==true?braces.compile(e,t):braces.expand(e,t)};e.exports=braces},179:(e,t,r)=>{const n=r(783);const u=r(617);const compile=(e,t={})=>{let walk=(e,r={})=>{let s=u.isInvalidBrace(r);let o=e.invalid===true&&t.escapeInvalid===true;let i=s===true||o===true;let a=t.escapeInvalid===true?\"\\\\\":\"\";let l=\"\";if(e.isOpen===true){return a+e.value}if(e.isClose===true){return a+e.value}if(e.type===\"open\"){return i?a+e.value:\"(\"}if(e.type===\"close\"){return i?a+e.value:\")\"}if(e.type===\"comma\"){return e.prev.type===\"comma\"?\"\":i?e.value:\"|\"}if(e.value){return e.value}if(e.nodes&&e.ranges>0){let r=u.reduce(e.nodes);let s=n(...r,{...t,wrap:false,toRegex:true});if(s.length!==0){return r.length>1&&s.length>1?`(${s})`:s}}if(e.nodes){for(let t of e.nodes){l+=walk(t,e)}}return l};return walk(e)};e.exports=compile},457:e=>{e.exports={MAX_LENGTH:1024*64,CHAR_0:\"0\",CHAR_9:\"9\",CHAR_UPPERCASE_A:\"A\",CHAR_LOWERCASE_A:\"a\",CHAR_UPPERCASE_Z:\"Z\",CHAR_LOWERCASE_Z:\"z\",CHAR_LEFT_PARENTHESES:\"(\",CHAR_RIGHT_PARENTHESES:\")\",CHAR_ASTERISK:\"*\",CHAR_AMPERSAND:\"&\",CHAR_AT:\"@\",CHAR_BACKSLASH:\"\\\\\",CHAR_BACKTICK:\"`\",CHAR_CARRIAGE_RETURN:\"\\r\",CHAR_CIRCUMFLEX_ACCENT:\"^\",CHAR_COLON:\":\",CHAR_COMMA:\",\",CHAR_DOLLAR:\"$\",CHAR_DOT:\".\",CHAR_DOUBLE_QUOTE:'\"',CHAR_EQUAL:\"=\",CHAR_EXCLAMATION_MARK:\"!\",CHAR_FORM_FEED:\"\\f\",CHAR_FORWARD_SLASH:\"/\",CHAR_HASH:\"#\",CHAR_HYPHEN_MINUS:\"-\",CHAR_LEFT_ANGLE_BRACKET:\"<\",CHAR_LEFT_CURLY_BRACE:\"{\",CHAR_LEFT_SQUARE_BRACKET:\"[\",CHAR_LINE_FEED:\"\\n\",CHAR_NO_BREAK_SPACE:\" \",CHAR_PERCENT:\"%\",CHAR_PLUS:\"+\",CHAR_QUESTION_MARK:\"?\",CHAR_RIGHT_ANGLE_BRACKET:\">\",CHAR_RIGHT_CURLY_BRACE:\"}\",CHAR_RIGHT_SQUARE_BRACKET:\"]\",CHAR_SEMICOLON:\";\",CHAR_SINGLE_QUOTE:\"'\",CHAR_SPACE:\" \",CHAR_TAB:\"\\t\",CHAR_UNDERSCORE:\"_\",CHAR_VERTICAL_LINE:\"|\",CHAR_ZERO_WIDTH_NOBREAK_SPACE:\"\\ufeff\"}},13:(e,t,r)=>{const n=r(783);const u=r(137);const s=r(617);const append=(e=\"\",t=\"\",r=false)=>{let n=[];e=[].concat(e);t=[].concat(t);if(!t.length)return e;if(!e.length){return r?s.flatten(t).map((e=>`{${e}}`)):t}for(let u of e){if(Array.isArray(u)){for(let e of u){n.push(append(e,t,r))}}else{for(let e of t){if(r===true&&typeof e===\"string\")e=`{${e}}`;n.push(Array.isArray(e)?append(u,e,r):u+e)}}}return s.flatten(n)};const expand=(e,t={})=>{let r=t.rangeLimit===void 0?1e3:t.rangeLimit;let walk=(e,o={})=>{e.queue=[];let i=o;let a=o.queue;while(i.type!==\"brace\"&&i.type!==\"root\"&&i.parent){i=i.parent;a=i.queue}if(e.invalid||e.dollar){a.push(append(a.pop(),u(e,t)));return}if(e.type===\"brace\"&&e.invalid!==true&&e.nodes.length===2){a.push(append(a.pop(),[\"{}\"]));return}if(e.nodes&&e.ranges>0){let o=s.reduce(e.nodes);if(s.exceedsLimit(...o,t.step,r)){throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\")}let i=n(...o,t);if(i.length===0){i=u(e,t)}a.push(append(a.pop(),i));e.nodes=[];return}let l=s.encloseBrace(e);let c=e.queue;let p=e;while(p.type!==\"brace\"&&p.type!==\"root\"&&p.parent){p=p.parent;c=p.queue}for(let t=0;t<e.nodes.length;t++){let r=e.nodes[t];if(r.type===\"comma\"&&e.type===\"brace\"){if(t===1)c.push(\"\");c.push(\"\");continue}if(r.type===\"close\"){a.push(append(a.pop(),c,l));continue}if(r.value&&r.type!==\"open\"){c.push(append(c.pop(),r.value));continue}if(r.nodes){walk(r,e)}}return c};return s.flatten(walk(e))};e.exports=expand},719:(e,t,r)=>{const n=r(137);const{MAX_LENGTH:u,CHAR_BACKSLASH:s,CHAR_BACKTICK:o,CHAR_COMMA:i,CHAR_DOT:a,CHAR_LEFT_PARENTHESES:l,CHAR_RIGHT_PARENTHESES:c,CHAR_LEFT_CURLY_BRACE:p,CHAR_RIGHT_CURLY_BRACE:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_RIGHT_SQUARE_BRACKET:R,CHAR_DOUBLE_QUOTE:_,CHAR_SINGLE_QUOTE:h,CHAR_NO_BREAK_SPACE:g,CHAR_ZERO_WIDTH_NOBREAK_SPACE:E}=r(457);const parse=(e,t={})=>{if(typeof e!==\"string\"){throw new TypeError(\"Expected a string\")}let r=t||{};let C=typeof r.maxLength===\"number\"?Math.min(u,r.maxLength):u;if(e.length>C){throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${C})`)}let y={type:\"root\",input:e,nodes:[]};let d=[y];let x=y;let b=y;let S=0;let H=e.length;let v=0;let $=0;let m;let T={};const advance=()=>e[v++];const push=e=>{if(e.type===\"text\"&&b.type===\"dot\"){b.type=\"text\"}if(b&&b.type===\"text\"&&e.type===\"text\"){b.value+=e.value;return}x.nodes.push(e);e.parent=x;e.prev=b;b=e;return e};push({type:\"bos\"});while(v<H){x=d[d.length-1];m=advance();if(m===E||m===g){continue}if(m===s){push({type:\"text\",value:(t.keepEscaping?m:\"\")+advance()});continue}if(m===R){push({type:\"text\",value:\"\\\\\"+m});continue}if(m===A){S++;let e=true;let t;while(v<H&&(t=advance())){m+=t;if(t===A){S++;continue}if(t===s){m+=advance();continue}if(t===R){S--;if(S===0){break}}}push({type:\"text\",value:m});continue}if(m===l){x=push({type:\"paren\",nodes:[]});d.push(x);push({type:\"text\",value:m});continue}if(m===c){if(x.type!==\"paren\"){push({type:\"text\",value:m});continue}x=d.pop();push({type:\"text\",value:m});x=d[d.length-1];continue}if(m===_||m===h||m===o){let e=m;let r;if(t.keepQuotes!==true){m=\"\"}while(v<H&&(r=advance())){if(r===s){m+=r+advance();continue}if(r===e){if(t.keepQuotes===true)m+=r;break}m+=r}push({type:\"text\",value:m});continue}if(m===p){$++;let e=b.value&&b.value.slice(-1)===\"$\"||x.dollar===true;let t={type:\"brace\",open:true,close:false,dollar:e,depth:$,commas:0,ranges:0,nodes:[]};x=push(t);d.push(x);push({type:\"open\",value:m});continue}if(m===f){if(x.type!==\"brace\"){push({type:\"text\",value:m});continue}let e=\"close\";x=d.pop();x.close=true;push({type:e,value:m});$--;x=d[d.length-1];continue}if(m===i&&$>0){if(x.ranges>0){x.ranges=0;let e=x.nodes.shift();x.nodes=[e,{type:\"text\",value:n(x)}]}push({type:\"comma\",value:m});x.commas++;continue}if(m===a&&$>0&&x.commas===0){let e=x.nodes;if($===0||e.length===0){push({type:\"text\",value:m});continue}if(b.type===\"dot\"){x.range=[];b.value+=m;b.type=\"range\";if(x.nodes.length!==3&&x.nodes.length!==5){x.invalid=true;x.ranges=0;b.type=\"text\";continue}x.ranges++;x.args=[];continue}if(b.type===\"range\"){e.pop();let t=e[e.length-1];t.value+=b.value+m;b=t;x.ranges--;continue}push({type:\"dot\",value:m});continue}push({type:\"text\",value:m})}do{x=d.pop();if(x.type!==\"root\"){x.nodes.forEach((e=>{if(!e.nodes){if(e.type===\"open\")e.isOpen=true;if(e.type===\"close\")e.isClose=true;if(!e.nodes)e.type=\"text\";e.invalid=true}}));let e=d[d.length-1];let t=e.nodes.indexOf(x);e.nodes.splice(t,1,...x.nodes)}}while(d.length>0);push({type:\"eos\"});return y};e.exports=parse},137:(e,t,r)=>{const n=r(617);e.exports=(e,t={})=>{let stringify=(e,r={})=>{let u=t.escapeInvalid&&n.isInvalidBrace(r);let s=e.invalid===true&&t.escapeInvalid===true;let o=\"\";if(e.value){if((u||s)&&n.isOpenOrClose(e)){return\"\\\\\"+e.value}return e.value}if(e.value){return e.value}if(e.nodes){for(let t of e.nodes){o+=stringify(t)}}return o};return stringify(e)}},617:(e,t)=>{t.isInteger=e=>{if(typeof e===\"number\"){return Number.isInteger(e)}if(typeof e===\"string\"&&e.trim()!==\"\"){return Number.isInteger(Number(e))}return false};t.find=(e,t)=>e.nodes.find((e=>e.type===t));t.exceedsLimit=(e,r,n=1,u)=>{if(u===false)return false;if(!t.isInteger(e)||!t.isInteger(r))return false;return(Number(r)-Number(e))/Number(n)>=u};t.escapeNode=(e,t=0,r)=>{let n=e.nodes[t];if(!n)return;if(r&&n.type===r||n.type===\"open\"||n.type===\"close\"){if(n.escaped!==true){n.value=\"\\\\\"+n.value;n.escaped=true}}};t.encloseBrace=e=>{if(e.type!==\"brace\")return false;if(e.commas>>0+e.ranges>>0===0){e.invalid=true;return true}return false};t.isInvalidBrace=e=>{if(e.type!==\"brace\")return false;if(e.invalid===true||e.dollar)return true;if(e.commas>>0+e.ranges>>0===0){e.invalid=true;return true}if(e.open!==true||e.close!==true){e.invalid=true;return true}return false};t.isOpenOrClose=e=>{if(e.type===\"open\"||e.type===\"close\"){return true}return e.open===true||e.close===true};t.reduce=e=>e.reduce(((e,t)=>{if(t.type===\"text\")e.push(t.value);if(t.type===\"range\")t.type=\"text\";return e}),[]);t.flatten=(...e)=>{const t=[];const flat=e=>{for(let r=0;r<e.length;r++){let n=e[r];Array.isArray(n)?flat(n,t):n!==void 0&&t.push(n)}return t};flat(e);return t}},783:(e,t,r)=>{\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\nconst n=r(837);const u=r(492);const isObject=e=>e!==null&&typeof e===\"object\"&&!Array.isArray(e);const transform=e=>t=>e===true?Number(t):String(t);const isValidValue=e=>typeof e===\"number\"||typeof e===\"string\"&&e!==\"\";const isNumber=e=>Number.isInteger(+e);const zeros=e=>{let t=`${e}`;let r=-1;if(t[0]===\"-\")t=t.slice(1);if(t===\"0\")return false;while(t[++r]===\"0\");return r>0};const stringify=(e,t,r)=>{if(typeof e===\"string\"||typeof t===\"string\"){return true}return r.stringify===true};const pad=(e,t,r)=>{if(t>0){let r=e[0]===\"-\"?\"-\":\"\";if(r)e=e.slice(1);e=r+e.padStart(r?t-1:t,\"0\")}if(r===false){return String(e)}return e};const toMaxLen=(e,t)=>{let r=e[0]===\"-\"?\"-\":\"\";if(r){e=e.slice(1);t--}while(e.length<t)e=\"0\"+e;return r?\"-\"+e:e};const toSequence=(e,t)=>{e.negatives.sort(((e,t)=>e<t?-1:e>t?1:0));e.positives.sort(((e,t)=>e<t?-1:e>t?1:0));let r=t.capture?\"\":\"?:\";let n=\"\";let u=\"\";let s;if(e.positives.length){n=e.positives.join(\"|\")}if(e.negatives.length){u=`-(${r}${e.negatives.join(\"|\")})`}if(n&&u){s=`${n}|${u}`}else{s=n||u}if(t.wrap){return`(${r}${s})`}return s};const toRange=(e,t,r,n)=>{if(r){return u(e,t,{wrap:false,...n})}let s=String.fromCharCode(e);if(e===t)return s;let o=String.fromCharCode(t);return`[${s}-${o}]`};const toRegex=(e,t,r)=>{if(Array.isArray(e)){let t=r.wrap===true;let n=r.capture?\"\":\"?:\";return t?`(${n}${e.join(\"|\")})`:e.join(\"|\")}return u(e,t,r)};const rangeError=(...e)=>new RangeError(\"Invalid range arguments: \"+n.inspect(...e));const invalidRange=(e,t,r)=>{if(r.strictRanges===true)throw rangeError([e,t]);return[]};const invalidStep=(e,t)=>{if(t.strictRanges===true){throw new TypeError(`Expected step \"${e}\" to be a number`)}return[]};const fillNumbers=(e,t,r=1,n={})=>{let u=Number(e);let s=Number(t);if(!Number.isInteger(u)||!Number.isInteger(s)){if(n.strictRanges===true)throw rangeError([e,t]);return[]}if(u===0)u=0;if(s===0)s=0;let o=u>s;let i=String(e);let a=String(t);let l=String(r);r=Math.max(Math.abs(r),1);let c=zeros(i)||zeros(a)||zeros(l);let p=c?Math.max(i.length,a.length,l.length):0;let f=c===false&&stringify(e,t,n)===false;let A=n.transform||transform(f);if(n.toRegex&&r===1){return toRange(toMaxLen(e,p),toMaxLen(t,p),true,n)}let R={negatives:[],positives:[]};let push=e=>R[e<0?\"negatives\":\"positives\"].push(Math.abs(e));let _=[];let h=0;while(o?u>=s:u<=s){if(n.toRegex===true&&r>1){push(u)}else{_.push(pad(A(u,h),p,f))}u=o?u-r:u+r;h++}if(n.toRegex===true){return r>1?toSequence(R,n):toRegex(_,null,{wrap:false,...n})}return _};const fillLetters=(e,t,r=1,n={})=>{if(!isNumber(e)&&e.length>1||!isNumber(t)&&t.length>1){return invalidRange(e,t,n)}let u=n.transform||(e=>String.fromCharCode(e));let s=`${e}`.charCodeAt(0);let o=`${t}`.charCodeAt(0);let i=s>o;let a=Math.min(s,o);let l=Math.max(s,o);if(n.toRegex&&r===1){return toRange(a,l,false,n)}let c=[];let p=0;while(i?s>=o:s<=o){c.push(u(s,p));s=i?s-r:s+r;p++}if(n.toRegex===true){return toRegex(c,null,{wrap:false,options:n})}return c};const fill=(e,t,r,n={})=>{if(t==null&&isValidValue(e)){return[e]}if(!isValidValue(e)||!isValidValue(t)){return invalidRange(e,t,n)}if(typeof r===\"function\"){return fill(e,t,1,{transform:r})}if(isObject(r)){return fill(e,t,0,r)}let u={...n};if(u.capture===true)u.wrap=true;r=r||u.step||1;if(!isNumber(r)){if(r!=null&&!isObject(r))return invalidStep(r,u);return fill(e,t,1,r)}if(isNumber(e)&&isNumber(t)){return fillNumbers(e,t,r,u)}return fillLetters(e,t,Math.max(Math.abs(r),1),u)};e.exports=fill},357:e=>{\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\ne.exports=function(e){if(typeof e===\"number\"){return e-e===0}if(typeof e===\"string\"&&e.trim()!==\"\"){return Number.isFinite?Number.isFinite(+e):isFinite(+e)}return false}},971:(e,t,r)=>{const n=r(837);const u=r(333);const s=r(251);const o=r(513);const isEmptyString=e=>e===\"\"||e===\"./\";const micromatch=(e,t,r)=>{t=[].concat(t);e=[].concat(e);let n=new Set;let u=new Set;let o=new Set;let i=0;let onResult=e=>{o.add(e.output);if(r&&r.onResult){r.onResult(e)}};for(let o=0;o<t.length;o++){let a=s(String(t[o]),{...r,onResult:onResult},true);let l=a.state.negated||a.state.negatedExtglob;if(l)i++;for(let t of e){let e=a(t,true);let r=l?!e.isMatch:e.isMatch;if(!r)continue;if(l){n.add(e.output)}else{n.delete(e.output);u.add(e.output)}}}let a=i===t.length?[...o]:[...u];let l=a.filter((e=>!n.has(e)));if(r&&l.length===0){if(r.failglob===true){throw new Error(`No matches found for \"${t.join(\", \")}\"`)}if(r.nonull===true||r.nullglob===true){return r.unescape?t.map((e=>e.replace(/\\\\/g,\"\"))):t}}return l};micromatch.match=micromatch;micromatch.matcher=(e,t)=>s(e,t);micromatch.isMatch=(e,t,r)=>s(t,r)(e);micromatch.any=micromatch.isMatch;micromatch.not=(e,t,r={})=>{t=[].concat(t).map(String);let n=new Set;let u=[];let onResult=e=>{if(r.onResult)r.onResult(e);u.push(e.output)};let s=micromatch(e,t,{...r,onResult:onResult});for(let e of u){if(!s.includes(e)){n.add(e)}}return[...n]};micromatch.contains=(e,t,r)=>{if(typeof e!==\"string\"){throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`)}if(Array.isArray(t)){return t.some((t=>micromatch.contains(e,t,r)))}if(typeof t===\"string\"){if(isEmptyString(e)||isEmptyString(t)){return false}if(e.includes(t)||e.startsWith(\"./\")&&e.slice(2).includes(t)){return true}}return micromatch.isMatch(e,t,{...r,contains:true})};micromatch.matchKeys=(e,t,r)=>{if(!o.isObject(e)){throw new TypeError(\"Expected the first argument to be an object\")}let n=micromatch(Object.keys(e),t,r);let u={};for(let t of n)u[t]=e[t];return u};micromatch.some=(e,t,r)=>{let n=[].concat(e);for(let e of[].concat(t)){let t=s(String(e),r);if(n.some((e=>t(e)))){return true}}return false};micromatch.every=(e,t,r)=>{let n=[].concat(e);for(let e of[].concat(t)){let t=s(String(e),r);if(!n.every((e=>t(e)))){return false}}return true};micromatch.all=(e,t,r)=>{if(typeof e!==\"string\"){throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`)}return[].concat(t).every((t=>s(t,r)(e)))};micromatch.capture=(e,t,r)=>{let n=o.isWindows(r);let u=s.makeRe(String(e),{...r,capture:true});let i=u.exec(n?o.toPosixSlashes(t):t);if(i){return i.slice(1).map((e=>e===void 0?\"\":e))}};micromatch.makeRe=(...e)=>s.makeRe(...e);micromatch.scan=(...e)=>s.scan(...e);micromatch.parse=(e,t)=>{let r=[];for(let n of[].concat(e||[])){for(let e of u(String(n),t)){r.push(s.parse(e,t))}}return r};micromatch.braces=(e,t)=>{if(typeof e!==\"string\")throw new TypeError(\"Expected a string\");if(t&&t.nobrace===true||!/\\{.*\\}/.test(e)){return[e]}return u(e,t)};micromatch.braceExpand=(e,t)=>{if(typeof e!==\"string\")throw new TypeError(\"Expected a string\");return micromatch.braces(e,{...t,expand:true})};e.exports=micromatch},251:(e,t,r)=>{e.exports=r(683)},356:(e,t,r)=>{const n=r(17);const u=\"\\\\\\\\/\";const s=`[^${u}]`;const o=\"\\\\.\";const i=\"\\\\+\";const a=\"\\\\?\";const l=\"\\\\/\";const c=\"(?=.)\";const p=\"[^/]\";const f=`(?:${l}|$)`;const A=`(?:^|${l})`;const R=`${o}{1,2}${f}`;const _=`(?!${o})`;const h=`(?!${A}${R})`;const g=`(?!${o}{0,1}${f})`;const E=`(?!${R})`;const C=`[^.${l}]`;const y=`${p}*?`;const d={DOT_LITERAL:o,PLUS_LITERAL:i,QMARK_LITERAL:a,SLASH_LITERAL:l,ONE_CHAR:c,QMARK:p,END_ANCHOR:f,DOTS_SLASH:R,NO_DOT:_,NO_DOTS:h,NO_DOT_SLASH:g,NO_DOTS_SLASH:E,QMARK_NO_DOT:C,STAR:y,START_ANCHOR:A};const x={...d,SLASH_LITERAL:`[${u}]`,QMARK:s,STAR:`${s}*?`,DOTS_SLASH:`${o}{1,2}(?:[${u}]|$)`,NO_DOT:`(?!${o})`,NO_DOTS:`(?!(?:^|[${u}])${o}{1,2}(?:[${u}]|$))`,NO_DOT_SLASH:`(?!${o}{0,1}(?:[${u}]|$))`,NO_DOTS_SLASH:`(?!${o}{1,2}(?:[${u}]|$))`,QMARK_NO_DOT:`[^.${u}]`,START_ANCHOR:`(?:^|[${u}])`,END_ANCHOR:`(?:[${u}]|$)`};const b={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};e.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:b,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,SEP:n.sep,extglobChars(e){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${e.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(e){return e===true?x:d}}},754:(e,t,r)=>{const n=r(356);const u=r(513);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:o,REGEX_NON_SPECIAL_CHARS:i,REGEX_SPECIAL_CHARS_BACKREF:a,REPLACEMENTS:l}=n;const expandRange=(e,t)=>{if(typeof t.expandRange===\"function\"){return t.expandRange(...e,t)}e.sort();const r=`[${e.join(\"-\")}]`;try{new RegExp(r)}catch(t){return e.map((e=>u.escapeRegex(e))).join(\"..\")}return r};const syntaxError=(e,t)=>`Missing ${e}: \"${t}\" - use \"\\\\\\\\${t}\" to match literal characters`;const parse=(e,t)=>{if(typeof e!==\"string\"){throw new TypeError(\"Expected a string\")}e=l[e]||e;const r={...t};const c=typeof r.maxLength===\"number\"?Math.min(s,r.maxLength):s;let p=e.length;if(p>c){throw new SyntaxError(`Input length: ${p}, exceeds maximum allowed length: ${c}`)}const f={type:\"bos\",value:\"\",output:r.prepend||\"\"};const A=[f];const R=r.capture?\"\":\"?:\";const _=u.isWindows(t);const h=n.globChars(_);const g=n.extglobChars(h);const{DOT_LITERAL:E,PLUS_LITERAL:C,SLASH_LITERAL:y,ONE_CHAR:d,DOTS_SLASH:x,NO_DOT:b,NO_DOT_SLASH:S,NO_DOTS_SLASH:H,QMARK:v,QMARK_NO_DOT:$,STAR:m,START_ANCHOR:T}=h;const globstar=e=>`(${R}(?:(?!${T}${e.dot?x:E}).)*?)`;const L=r.dot?\"\":b;const O=r.dot?v:$;let w=r.bash===true?globstar(r):m;if(r.capture){w=`(${w})`}if(typeof r.noext===\"boolean\"){r.noextglob=r.noext}const N={input:e,index:-1,start:0,dot:r.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};e=u.removePrefix(e,N);p=e.length;const k=[];const I=[];const M=[];let P=f;let B;const eos=()=>N.index===p-1;const G=N.peek=(t=1)=>e[N.index+t];const D=N.advance=()=>e[++N.index];const remaining=()=>e.slice(N.index+1);const consume=(e=\"\",t=0)=>{N.consumed+=e;N.index+=t};const append=e=>{N.output+=e.output!=null?e.output:e.value;consume(e.value)};const negate=()=>{let e=1;while(G()===\"!\"&&(G(2)!==\"(\"||G(3)===\"?\")){D();N.start++;e++}if(e%2===0){return false}N.negated=true;N.start++;return true};const increment=e=>{N[e]++;M.push(e)};const decrement=e=>{N[e]--;M.pop()};const push=e=>{if(P.type===\"globstar\"){const t=N.braces>0&&(e.type===\"comma\"||e.type===\"brace\");const r=e.extglob===true||k.length&&(e.type===\"pipe\"||e.type===\"paren\");if(e.type!==\"slash\"&&e.type!==\"paren\"&&!t&&!r){N.output=N.output.slice(0,-P.output.length);P.type=\"star\";P.value=\"*\";P.output=w;N.output+=P.output}}if(k.length&&e.type!==\"paren\"&&!g[e.value]){k[k.length-1].inner+=e.value}if(e.value||e.output)append(e);if(P&&P.type===\"text\"&&e.type===\"text\"){P.value+=e.value;P.output=(P.output||\"\")+e.value;return}e.prev=P;A.push(e);P=e};const extglobOpen=(e,t)=>{const n={...g[t],conditions:1,inner:\"\"};n.prev=P;n.parens=N.parens;n.output=N.output;const u=(r.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:e,value:t,output:N.output?\"\":d});push({type:\"paren\",extglob:true,value:D(),output:u});k.push(n)};const extglobClose=e=>{let t=e.close+(r.capture?\")\":\"\");if(e.type===\"negate\"){let n=w;if(e.inner&&e.inner.length>1&&e.inner.includes(\"/\")){n=globstar(r)}if(n!==w||eos()||/^\\)+$/.test(remaining())){t=e.close=`)$))${n}`}if(e.prev.type===\"bos\"){N.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:B,output:t});decrement(\"parens\")};if(r.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(e)){let n=false;let s=e.replace(a,((e,t,r,u,s,o)=>{if(u===\"\\\\\"){n=true;return e}if(u===\"?\"){if(t){return t+u+(s?v.repeat(s.length):\"\")}if(o===0){return O+(s?v.repeat(s.length):\"\")}return v.repeat(r.length)}if(u===\".\"){return E.repeat(r.length)}if(u===\"*\"){if(t){return t+u+(s?w:\"\")}return w}return t?e:`\\\\${e}`}));if(n===true){if(r.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(e=>e.length%2===0?\"\\\\\\\\\":e?\"\\\\\":\"\"))}}if(s===e&&r.contains===true){N.output=e;return N}N.output=u.wrapOutput(s,N,t);return N}while(!eos()){B=D();if(B===\"\\0\"){continue}if(B===\"\\\\\"){const e=G();if(e===\"/\"&&r.bash!==true){continue}if(e===\".\"||e===\";\"){continue}if(!e){B+=\"\\\\\";push({type:\"text\",value:B});continue}const t=/^\\\\+/.exec(remaining());let n=0;if(t&&t[0].length>2){n=t[0].length;N.index+=n;if(n%2!==0){B+=\"\\\\\"}}if(r.unescape===true){B=D()||\"\"}else{B+=D()||\"\"}if(N.brackets===0){push({type:\"text\",value:B});continue}}if(N.brackets>0&&(B!==\"]\"||P.value===\"[\"||P.value===\"[^\")){if(r.posix!==false&&B===\":\"){const e=P.value.slice(1);if(e.includes(\"[\")){P.posix=true;if(e.includes(\":\")){const e=P.value.lastIndexOf(\"[\");const t=P.value.slice(0,e);const r=P.value.slice(e+2);const n=o[r];if(n){P.value=t+n;N.backtrack=true;D();if(!f.output&&A.indexOf(P)===1){f.output=d}continue}}}}if(B===\"[\"&&G()!==\":\"||B===\"-\"&&G()===\"]\"){B=`\\\\${B}`}if(B===\"]\"&&(P.value===\"[\"||P.value===\"[^\")){B=`\\\\${B}`}if(r.posix===true&&B===\"!\"&&P.value===\"[\"){B=\"^\"}P.value+=B;append({value:B});continue}if(N.quotes===1&&B!=='\"'){B=u.escapeRegex(B);P.value+=B;append({value:B});continue}if(B==='\"'){N.quotes=N.quotes===1?0:1;if(r.keepQuotes===true){push({type:\"text\",value:B})}continue}if(B===\"(\"){increment(\"parens\");push({type:\"paren\",value:B});continue}if(B===\")\"){if(N.parens===0&&r.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const e=k[k.length-1];if(e&&N.parens===e.parens+1){extglobClose(k.pop());continue}push({type:\"paren\",value:B,output:N.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(B===\"[\"){if(r.nobracket===true||!remaining().includes(\"]\")){if(r.nobracket!==true&&r.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}B=`\\\\${B}`}else{increment(\"brackets\")}push({type:\"bracket\",value:B});continue}if(B===\"]\"){if(r.nobracket===true||P&&P.type===\"bracket\"&&P.value.length===1){push({type:\"text\",value:B,output:`\\\\${B}`});continue}if(N.brackets===0){if(r.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:B,output:`\\\\${B}`});continue}decrement(\"brackets\");const e=P.value.slice(1);if(P.posix!==true&&e[0]===\"^\"&&!e.includes(\"/\")){B=`/${B}`}P.value+=B;append({value:B});if(r.literalBrackets===false||u.hasRegexChars(e)){continue}const t=u.escapeRegex(P.value);N.output=N.output.slice(0,-P.value.length);if(r.literalBrackets===true){N.output+=t;P.value=t;continue}P.value=`(${R}${t}|${P.value})`;N.output+=P.value;continue}if(B===\"{\"&&r.nobrace!==true){increment(\"braces\");const e={type:\"brace\",value:B,output:\"(\",outputIndex:N.output.length,tokensIndex:N.tokens.length};I.push(e);push(e);continue}if(B===\"}\"){const e=I[I.length-1];if(r.nobrace===true||!e){push({type:\"text\",value:B,output:B});continue}let t=\")\";if(e.dots===true){const e=A.slice();const n=[];for(let t=e.length-1;t>=0;t--){A.pop();if(e[t].type===\"brace\"){break}if(e[t].type!==\"dots\"){n.unshift(e[t].value)}}t=expandRange(n,r);N.backtrack=true}if(e.comma!==true&&e.dots!==true){const r=N.output.slice(0,e.outputIndex);const n=N.tokens.slice(e.tokensIndex);e.value=e.output=\"\\\\{\";B=t=\"\\\\}\";N.output=r;for(const e of n){N.output+=e.output||e.value}}push({type:\"brace\",value:B,output:t});decrement(\"braces\");I.pop();continue}if(B===\"|\"){if(k.length>0){k[k.length-1].conditions++}push({type:\"text\",value:B});continue}if(B===\",\"){let e=B;const t=I[I.length-1];if(t&&M[M.length-1]===\"braces\"){t.comma=true;e=\"|\"}push({type:\"comma\",value:B,output:e});continue}if(B===\"/\"){if(P.type===\"dot\"&&N.index===N.start+1){N.start=N.index+1;N.consumed=\"\";N.output=\"\";A.pop();P=f;continue}push({type:\"slash\",value:B,output:y});continue}if(B===\".\"){if(N.braces>0&&P.type===\"dot\"){if(P.value===\".\")P.output=E;const e=I[I.length-1];P.type=\"dots\";P.output+=B;P.value+=B;e.dots=true;continue}if(N.braces+N.parens===0&&P.type!==\"bos\"&&P.type!==\"slash\"){push({type:\"text\",value:B,output:E});continue}push({type:\"dot\",value:B,output:E});continue}if(B===\"?\"){const e=P&&P.value===\"(\";if(!e&&r.noextglob!==true&&G()===\"(\"&&G(2)!==\"?\"){extglobOpen(\"qmark\",B);continue}if(P&&P.type===\"paren\"){const e=G();let t=B;if(e===\"<\"&&!u.supportsLookbehinds()){throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\")}if(P.value===\"(\"&&!/[!=<:]/.test(e)||e===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){t=`\\\\${B}`}push({type:\"text\",value:B,output:t});continue}if(r.dot!==true&&(P.type===\"slash\"||P.type===\"bos\")){push({type:\"qmark\",value:B,output:$});continue}push({type:\"qmark\",value:B,output:v});continue}if(B===\"!\"){if(r.noextglob!==true&&G()===\"(\"){if(G(2)!==\"?\"||!/[!=<:]/.test(G(3))){extglobOpen(\"negate\",B);continue}}if(r.nonegate!==true&&N.index===0){negate();continue}}if(B===\"+\"){if(r.noextglob!==true&&G()===\"(\"&&G(2)!==\"?\"){extglobOpen(\"plus\",B);continue}if(P&&P.value===\"(\"||r.regex===false){push({type:\"plus\",value:B,output:C});continue}if(P&&(P.type===\"bracket\"||P.type===\"paren\"||P.type===\"brace\")||N.parens>0){push({type:\"plus\",value:B});continue}push({type:\"plus\",value:C});continue}if(B===\"@\"){if(r.noextglob!==true&&G()===\"(\"&&G(2)!==\"?\"){push({type:\"at\",extglob:true,value:B,output:\"\"});continue}push({type:\"text\",value:B});continue}if(B!==\"*\"){if(B===\"$\"||B===\"^\"){B=`\\\\${B}`}const e=i.exec(remaining());if(e){B+=e[0];N.index+=e[0].length}push({type:\"text\",value:B});continue}if(P&&(P.type===\"globstar\"||P.star===true)){P.type=\"star\";P.star=true;P.value+=B;P.output=w;N.backtrack=true;N.globstar=true;consume(B);continue}let t=remaining();if(r.noextglob!==true&&/^\\([^?]/.test(t)){extglobOpen(\"star\",B);continue}if(P.type===\"star\"){if(r.noglobstar===true){consume(B);continue}const n=P.prev;const u=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const o=u&&(u.type===\"star\"||u.type===\"globstar\");if(r.bash===true&&(!s||t[0]&&t[0]!==\"/\")){push({type:\"star\",value:B,output:\"\"});continue}const i=N.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const a=k.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!i&&!a){push({type:\"star\",value:B,output:\"\"});continue}while(t.slice(0,3)===\"/**\"){const r=e[N.index+4];if(r&&r!==\"/\"){break}t=t.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){P.type=\"globstar\";P.value+=B;P.output=globstar(r);N.output=P.output;N.globstar=true;consume(B);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!o&&eos()){N.output=N.output.slice(0,-(n.output+P.output).length);n.output=`(?:${n.output}`;P.type=\"globstar\";P.output=globstar(r)+(r.strictSlashes?\")\":\"|$)\");P.value+=B;N.globstar=true;N.output+=n.output+P.output;consume(B);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&t[0]===\"/\"){const e=t[1]!==void 0?\"|$\":\"\";N.output=N.output.slice(0,-(n.output+P.output).length);n.output=`(?:${n.output}`;P.type=\"globstar\";P.output=`${globstar(r)}${y}|${y}${e})`;P.value+=B;N.output+=n.output+P.output;N.globstar=true;consume(B+D());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&t[0]===\"/\"){P.type=\"globstar\";P.value+=B;P.output=`(?:^|${y}|${globstar(r)}${y})`;N.output=P.output;N.globstar=true;consume(B+D());push({type:\"slash\",value:\"/\",output:\"\"});continue}N.output=N.output.slice(0,-P.output.length);P.type=\"globstar\";P.output=globstar(r);P.value+=B;N.output+=P.output;N.globstar=true;consume(B);continue}const n={type:\"star\",value:B,output:w};if(r.bash===true){n.output=\".*?\";if(P.type===\"bos\"||P.type===\"slash\"){n.output=L+n.output}push(n);continue}if(P&&(P.type===\"bracket\"||P.type===\"paren\")&&r.regex===true){n.output=B;push(n);continue}if(N.index===N.start||P.type===\"slash\"||P.type===\"dot\"){if(P.type===\"dot\"){N.output+=S;P.output+=S}else if(r.dot===true){N.output+=H;P.output+=H}else{N.output+=L;P.output+=L}if(G()!==\"*\"){N.output+=d;P.output+=d}}push(n)}while(N.brackets>0){if(r.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));N.output=u.escapeLast(N.output,\"[\");decrement(\"brackets\")}while(N.parens>0){if(r.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));N.output=u.escapeLast(N.output,\"(\");decrement(\"parens\")}while(N.braces>0){if(r.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));N.output=u.escapeLast(N.output,\"{\");decrement(\"braces\")}if(r.strictSlashes!==true&&(P.type===\"star\"||P.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${y}?`})}if(N.backtrack===true){N.output=\"\";for(const e of N.tokens){N.output+=e.output!=null?e.output:e.value;if(e.suffix){N.output+=e.suffix}}}return N};parse.fastpaths=(e,t)=>{const r={...t};const o=typeof r.maxLength===\"number\"?Math.min(s,r.maxLength):s;const i=e.length;if(i>o){throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${o}`)}e=l[e]||e;const a=u.isWindows(t);const{DOT_LITERAL:c,SLASH_LITERAL:p,ONE_CHAR:f,DOTS_SLASH:A,NO_DOT:R,NO_DOTS:_,NO_DOTS_SLASH:h,STAR:g,START_ANCHOR:E}=n.globChars(a);const C=r.dot?_:R;const y=r.dot?h:R;const d=r.capture?\"\":\"?:\";const x={negated:false,prefix:\"\"};let b=r.bash===true?\".*?\":g;if(r.capture){b=`(${b})`}const globstar=e=>{if(e.noglobstar===true)return b;return`(${d}(?:(?!${E}${e.dot?A:c}).)*?)`};const create=e=>{switch(e){case\"*\":return`${C}${f}${b}`;case\".*\":return`${c}${f}${b}`;case\"*.*\":return`${C}${b}${c}${f}${b}`;case\"*/*\":return`${C}${b}${p}${f}${y}${b}`;case\"**\":return C+globstar(r);case\"**/*\":return`(?:${C}${globstar(r)}${p})?${y}${f}${b}`;case\"**/*.*\":return`(?:${C}${globstar(r)}${p})?${y}${b}${c}${f}${b}`;case\"**/.*\":return`(?:${C}${globstar(r)}${p})?${c}${f}${b}`;default:{const t=/^(.*?)\\.(\\w+)$/.exec(e);if(!t)return;const r=create(t[1]);if(!r)return;return r+c+t[2]}}};const S=u.removePrefix(e,x);let H=create(S);if(H&&r.strictSlashes!==true){H+=`${p}?`}return H};e.exports=parse},683:(e,t,r)=>{const n=r(17);const u=r(700);const s=r(754);const o=r(513);const i=r(356);const isObject=e=>e&&typeof e===\"object\"&&!Array.isArray(e);const picomatch=(e,t,r=false)=>{if(Array.isArray(e)){const n=e.map((e=>picomatch(e,t,r)));const arrayMatcher=e=>{for(const t of n){const r=t(e);if(r)return r}return false};return arrayMatcher}const n=isObject(e)&&e.tokens&&e.input;if(e===\"\"||typeof e!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const u=t||{};const s=o.isWindows(t);const i=n?picomatch.compileRe(e,t):picomatch.makeRe(e,t,false,true);const a=i.state;delete i.state;let isIgnored=()=>false;if(u.ignore){const e={...t,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(u.ignore,e,r)}const matcher=(r,n=false)=>{const{isMatch:o,match:l,output:c}=picomatch.test(r,i,t,{glob:e,posix:s});const p={glob:e,state:a,regex:i,posix:s,input:r,output:c,match:l,isMatch:o};if(typeof u.onResult===\"function\"){u.onResult(p)}if(o===false){p.isMatch=false;return n?p:false}if(isIgnored(r)){if(typeof u.onIgnore===\"function\"){u.onIgnore(p)}p.isMatch=false;return n?p:false}if(typeof u.onMatch===\"function\"){u.onMatch(p)}return n?p:true};if(r){matcher.state=a}return matcher};picomatch.test=(e,t,r,{glob:n,posix:u}={})=>{if(typeof e!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(e===\"\"){return{isMatch:false,output:\"\"}}const s=r||{};const i=s.format||(u?o.toPosixSlashes:null);let a=e===n;let l=a&&i?i(e):e;if(a===false){l=i?i(e):e;a=l===n}if(a===false||s.capture===true){if(s.matchBase===true||s.basename===true){a=picomatch.matchBase(e,t,r,u)}else{a=t.exec(l)}}return{isMatch:Boolean(a),match:a,output:l}};picomatch.matchBase=(e,t,r,u=o.isWindows(r))=>{const s=t instanceof RegExp?t:picomatch.makeRe(t,r);return s.test(n.basename(e))};picomatch.isMatch=(e,t,r)=>picomatch(t,r)(e);picomatch.parse=(e,t)=>{if(Array.isArray(e))return e.map((e=>picomatch.parse(e,t)));return s(e,{...t,fastpaths:false})};picomatch.scan=(e,t)=>u(e,t);picomatch.compileRe=(e,t,r=false,n=false)=>{if(r===true){return e.output}const u=t||{};const s=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let i=`${s}(?:${e.output})${o}`;if(e&&e.negated===true){i=`^(?!${i}).*$`}const a=picomatch.toRegex(i,t);if(n===true){a.state=e}return a};picomatch.makeRe=(e,t,r=false,n=false)=>{if(!e||typeof e!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}const u=t||{};let o={negated:false,fastpaths:true};let i=\"\";let a;if(e.startsWith(\"./\")){e=e.slice(2);i=o.prefix=\"./\"}if(u.fastpaths!==false&&(e[0]===\".\"||e[0]===\"*\")){a=s.fastpaths(e,t)}if(a===undefined){o=s(e,t);o.prefix=i+(o.prefix||\"\")}else{o.output=a}return picomatch.compileRe(o,t,r,n)};picomatch.toRegex=(e,t)=>{try{const r=t||{};return new RegExp(e,r.flags||(r.nocase?\"i\":\"\"))}catch(e){if(t&&t.debug===true)throw e;return/$^/}};picomatch.constants=i;e.exports=picomatch},700:(e,t,r)=>{const n=r(513);const{CHAR_ASTERISK:u,CHAR_AT:s,CHAR_BACKWARD_SLASH:o,CHAR_COMMA:i,CHAR_DOT:a,CHAR_EXCLAMATION_MARK:l,CHAR_FORWARD_SLASH:c,CHAR_LEFT_CURLY_BRACE:p,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:R,CHAR_QUESTION_MARK:_,CHAR_RIGHT_CURLY_BRACE:h,CHAR_RIGHT_PARENTHESES:g,CHAR_RIGHT_SQUARE_BRACKET:E}=r(356);const isPathSeparator=e=>e===c||e===o;const depth=e=>{if(e.isPrefix!==true){e.depth=e.isGlobstar?Infinity:1}};const scan=(e,t)=>{const r=t||{};const C=e.length-1;const y=r.parts===true||r.scanToEnd===true;const d=[];const x=[];const b=[];let S=e;let H=-1;let v=0;let $=0;let m=false;let T=false;let L=false;let O=false;let w=false;let N=false;let k=false;let I=false;let M=false;let P=0;let B;let G;let D={value:\"\",depth:0,isGlob:false};const eos=()=>H>=C;const peek=()=>S.charCodeAt(H+1);const advance=()=>{B=G;return S.charCodeAt(++H)};while(H<C){G=advance();let e;if(G===o){k=D.backslashes=true;G=advance();if(G===p){N=true}continue}if(N===true||G===p){P++;while(eos()!==true&&(G=advance())){if(G===o){k=D.backslashes=true;advance();continue}if(G===p){P++;continue}if(N!==true&&G===a&&(G=advance())===a){m=D.isBrace=true;L=D.isGlob=true;M=true;if(y===true){continue}break}if(N!==true&&G===i){m=D.isBrace=true;L=D.isGlob=true;M=true;if(y===true){continue}break}if(G===h){P--;if(P===0){N=false;m=D.isBrace=true;M=true;break}}}if(y===true){continue}break}if(G===c){d.push(H);x.push(D);D={value:\"\",depth:0,isGlob:false};if(M===true)continue;if(B===a&&H===v+1){v+=2;continue}$=H+1;continue}if(r.noext!==true){const e=G===R||G===s||G===u||G===_||G===l;if(e===true&&peek()===f){L=D.isGlob=true;O=D.isExtglob=true;M=true;if(y===true){while(eos()!==true&&(G=advance())){if(G===o){k=D.backslashes=true;G=advance();continue}if(G===g){L=D.isGlob=true;M=true;break}}continue}break}}if(G===u){if(B===u)w=D.isGlobstar=true;L=D.isGlob=true;M=true;if(y===true){continue}break}if(G===_){L=D.isGlob=true;M=true;if(y===true){continue}break}if(G===A){while(eos()!==true&&(e=advance())){if(e===o){k=D.backslashes=true;advance();continue}if(e===E){T=D.isBracket=true;L=D.isGlob=true;M=true;break}}if(y===true){continue}break}if(r.nonegate!==true&&G===l&&H===v){I=D.negated=true;v++;continue}if(r.noparen!==true&&G===f){L=D.isGlob=true;if(y===true){while(eos()!==true&&(G=advance())){if(G===f){k=D.backslashes=true;G=advance();continue}if(G===g){M=true;break}}continue}break}if(L===true){M=true;if(y===true){continue}break}}if(r.noext===true){O=false;L=false}let U=S;let K=\"\";let F=\"\";if(v>0){K=S.slice(0,v);S=S.slice(v);$-=v}if(U&&L===true&&$>0){U=S.slice(0,$);F=S.slice($)}else if(L===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(r.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&k===true){U=n.removeBackslashes(U)}}const Q={prefix:K,input:e,start:v,base:U,glob:F,isBrace:m,isBracket:T,isGlob:L,isExtglob:O,isGlobstar:w,negated:I};if(r.tokens===true){Q.maxDepth=0;if(!isPathSeparator(G)){x.push(D)}Q.tokens=x}if(r.parts===true||r.tokens===true){let t;for(let n=0;n<d.length;n++){const u=t?t+1:v;const s=d[n];const o=e.slice(u,s);if(r.tokens){if(n===0&&v!==0){x[n].isPrefix=true;x[n].value=K}else{x[n].value=o}depth(x[n]);Q.maxDepth+=x[n].depth}if(n!==0||o!==\"\"){b.push(o)}t=s}if(t&&t+1<e.length){const n=e.slice(t+1);b.push(n);if(r.tokens){x[x.length-1].value=n;depth(x[x.length-1]);Q.maxDepth+=x[x.length-1].depth}}Q.slashes=d;Q.parts=b}return Q};e.exports=scan},513:(e,t,r)=>{const n=r(17);const u=process.platform===\"win32\";const{REGEX_BACKSLASH:s,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:i,REGEX_SPECIAL_CHARS_GLOBAL:a}=r(356);t.isObject=e=>e!==null&&typeof e===\"object\"&&!Array.isArray(e);t.hasRegexChars=e=>i.test(e);t.isRegexChar=e=>e.length===1&&t.hasRegexChars(e);t.escapeRegex=e=>e.replace(a,\"\\\\$1\");t.toPosixSlashes=e=>e.replace(s,\"/\");t.removeBackslashes=e=>e.replace(o,(e=>e===\"\\\\\"?\"\":e));t.supportsLookbehinds=()=>{const e=process.version.slice(1).split(\".\").map(Number);if(e.length===3&&e[0]>=9||e[0]===8&&e[1]>=10){return true}return false};t.isWindows=e=>{if(e&&typeof e.windows===\"boolean\"){return e.windows}return u===true||n.sep===\"\\\\\"};t.escapeLast=(e,r,n)=>{const u=e.lastIndexOf(r,n);if(u===-1)return e;if(e[u-1]===\"\\\\\")return t.escapeLast(e,r,u-1);return`${e.slice(0,u)}\\\\${e.slice(u)}`};t.removePrefix=(e,t={})=>{let r=e;if(r.startsWith(\"./\")){r=r.slice(2);t.prefix=\"./\"}return r};t.wrapOutput=(e,t={},r={})=>{const n=r.contains?\"\":\"^\";const u=r.contains?\"\":\"$\";let s=`${n}(?:${e})${u}`;if(t.negated===true){s=`(?:^(?!${s}).*$)`}return s}},492:(e,t,r)=>{\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\nconst n=r(357);const toRegexRange=(e,t,r)=>{if(n(e)===false){throw new TypeError(\"toRegexRange: expected the first argument to be a number\")}if(t===void 0||e===t){return String(e)}if(n(t)===false){throw new TypeError(\"toRegexRange: expected the second argument to be a number.\")}let u={relaxZeros:true,...r};if(typeof u.strictZeros===\"boolean\"){u.relaxZeros=u.strictZeros===false}let s=String(u.relaxZeros);let o=String(u.shorthand);let i=String(u.capture);let a=String(u.wrap);let l=e+\":\"+t+\"=\"+s+o+i+a;if(toRegexRange.cache.hasOwnProperty(l)){return toRegexRange.cache[l].result}let c=Math.min(e,t);let p=Math.max(e,t);if(Math.abs(c-p)===1){let r=e+\"|\"+t;if(u.capture){return`(${r})`}if(u.wrap===false){return r}return`(?:${r})`}let f=hasPadding(e)||hasPadding(t);let A={min:e,max:t,a:c,b:p};let R=[];let _=[];if(f){A.isPadded=f;A.maxLen=String(A.max).length}if(c<0){let e=p<0?Math.abs(p):1;_=splitToPatterns(e,Math.abs(c),A,u);c=A.a=0}if(p>=0){R=splitToPatterns(c,p,A,u)}A.negatives=_;A.positives=R;A.result=collatePatterns(_,R,u);if(u.capture===true){A.result=`(${A.result})`}else if(u.wrap!==false&&R.length+_.length>1){A.result=`(?:${A.result})`}toRegexRange.cache[l]=A;return A.result};function collatePatterns(e,t,r){let n=filterPatterns(e,t,\"-\",false,r)||[];let u=filterPatterns(t,e,\"\",false,r)||[];let s=filterPatterns(e,t,\"-?\",true,r)||[];let o=n.concat(s).concat(u);return o.join(\"|\")}function splitToRanges(e,t){let r=1;let n=1;let u=countNines(e,r);let s=new Set([t]);while(e<=u&&u<=t){s.add(u);r+=1;u=countNines(e,r)}u=countZeros(t+1,n)-1;while(e<u&&u<=t){s.add(u);n+=1;u=countZeros(t+1,n)-1}s=[...s];s.sort(compare);return s}function rangeToPattern(e,t,r){if(e===t){return{pattern:e,count:[],digits:0}}let n=zip(e,t);let u=n.length;let s=\"\";let o=0;for(let e=0;e<u;e++){let[t,u]=n[e];if(t===u){s+=t}else if(t!==\"0\"||u!==\"9\"){s+=toCharacterClass(t,u,r)}else{o++}}if(o){s+=r.shorthand===true?\"\\\\d\":\"[0-9]\"}return{pattern:s,count:[o],digits:u}}function splitToPatterns(e,t,r,n){let u=splitToRanges(e,t);let s=[];let o=e;let i;for(let e=0;e<u.length;e++){let t=u[e];let a=rangeToPattern(String(o),String(t),n);let l=\"\";if(!r.isPadded&&i&&i.pattern===a.pattern){if(i.count.length>1){i.count.pop()}i.count.push(a.count[0]);i.string=i.pattern+toQuantifier(i.count);o=t+1;continue}if(r.isPadded){l=padZeros(t,r,n)}a.string=l+a.pattern+toQuantifier(a.count);s.push(a);o=t+1;i=a}return s}function filterPatterns(e,t,r,n,u){let s=[];for(let u of e){let{string:e}=u;if(!n&&!contains(t,\"string\",e)){s.push(r+e)}if(n&&contains(t,\"string\",e)){s.push(r+e)}}return s}function zip(e,t){let r=[];for(let n=0;n<e.length;n++)r.push([e[n],t[n]]);return r}function compare(e,t){return e>t?1:t>e?-1:0}function contains(e,t,r){return e.some((e=>e[t]===r))}function countNines(e,t){return Number(String(e).slice(0,-t)+\"9\".repeat(t))}function countZeros(e,t){return e-e%Math.pow(10,t)}function toQuantifier(e){let[t=0,r=\"\"]=e;if(r||t>1){return`{${t+(r?\",\"+r:\"\")}}`}return\"\"}function toCharacterClass(e,t,r){return`[${e}${t-e===1?\"\":\"-\"}${t}]`}function hasPadding(e){return/^-?(0+)\\d/.test(e)}function padZeros(e,t,r){if(!t.isPadded){return e}let n=Math.abs(t.maxLen-String(e).length);let u=r.relaxZeros!==false;switch(n){case 0:return\"\";case 1:return u?\"0?\":\"0\";case 2:return u?\"0{0,2}\":\"00\";default:{return u?`0{0,${n}}`:`0{${n}}`}}}toRegexRange.cache={};toRegexRange.clearCache=()=>toRegexRange.cache={};e.exports=toRegexRange},17:e=>{e.exports=__webpack_require__(/*! path */ \"(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\")},837:e=>{e.exports=__webpack_require__(/*! util */ \"(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\")}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var u=t[r]={exports:{}};var s=true;try{e[r](u,u.exports,__nccwpck_require__);s=false}finally{if(s)delete t[r]}return u.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(971);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWljcm9tYXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBLE1BQU0sYUFBYSxPQUFPLGNBQWMsZUFBZSxlQUFlLGNBQWMsZUFBZSxvQkFBb0IsSUFBSSxTQUFTLHFCQUFxQixnQkFBZ0IseUJBQXlCLHFCQUFxQixhQUFhLEtBQUssWUFBWSxLQUFLLGdDQUFnQyx5Q0FBeUMsa0JBQWtCLFVBQVUsb0JBQW9CLFVBQVUsd0JBQXdCLElBQUksd0JBQXdCLDhCQUE4QixlQUFlLHNCQUFzQixJQUFJLHdCQUF3QixvQkFBb0IsZUFBZSxxQkFBcUIsSUFBSSx3QkFBd0Isb0JBQW9CLGFBQWEscUJBQXFCLG9CQUFvQixxQkFBcUIsa0JBQWtCLFVBQVUscUJBQXFCLElBQUksdUJBQXVCLFVBQVUsK0RBQStELGlCQUFpQixlQUFlLGVBQWUsZUFBZSxxQkFBcUIsSUFBSSxnQkFBZ0IsSUFBSSwwQkFBMEIsK0NBQStDLHlCQUF5QixxQ0FBcUMsU0FBUyxvQkFBb0IsaUJBQWlCLHFCQUFxQixpQkFBaUIsb0JBQW9CLHVCQUF1QixxQkFBcUIsdUJBQXVCLHFCQUFxQiw4Q0FBOEMsWUFBWSxlQUFlLHdCQUF3Qix3QkFBd0IsY0FBYyw2QkFBNkIsRUFBRSxpQkFBaUIsa0NBQWtDLEVBQUUsTUFBTSxZQUFZLHNCQUFzQixjQUFjLFVBQVUsZ0JBQWdCLGtCQUFrQixTQUFTLFdBQVcsMmpCQUEyakIsdUxBQXVMLGlEQUFpRCx3SUFBd0ksY0FBYyxlQUFlLGVBQWUsZUFBZSxtQ0FBbUMsU0FBUyxlQUFlLGVBQWUsc0JBQXNCLGNBQWMsZ0NBQWdDLEVBQUUsR0FBRyxNQUFNLGdCQUFnQixxQkFBcUIsZ0JBQWdCLHVCQUF1QixLQUFLLGdCQUFnQixxQ0FBcUMsRUFBRSxHQUFHLEVBQUUsNkNBQTZDLHFCQUFxQixvQkFBb0IsSUFBSSw2Q0FBNkMsZ0JBQWdCLElBQUksV0FBVyxRQUFRLGNB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QVEsRUFBRSxnQkFBZ0IsRUFBRSxTQUFTLGlDQUFpQyxVQUFVLEVBQUUsRUFBRSxlQUFlLEVBQUUsRUFBRSxHQUFHLHVCQUF1QiwwQkFBMEIseUJBQXlCLGdCQUFnQixTQUFTLDBDQUEwQywyQkFBMkIsVUFBVSxnQkFBZ0IseUJBQXlCLG1CQUFtQixJQUFJLE9BQU8sU0FBUyxZQUFZLElBQUksR0FBRyxLQUFLLEVBQUUsR0FBRyxJQUFJLHNCQUFzQixrREFBa0QsdUJBQXVCLFFBQVEsVUFBVSxtQkFBTyxDQUFDLDRGQUFNLEVBQUUsU0FBUyxVQUFVLG1CQUFPLENBQUMsZ0ZBQU0sSUFBSSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWljcm9tYXRjaC9pbmRleC5qcz81NzY4Il0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXszMzM6KGUsdCxyKT0+e2NvbnN0IG49cigxMzcpO2NvbnN0IHU9cigxNzkpO2NvbnN0IHM9cigxMyk7Y29uc3Qgbz1yKDcxOSk7Y29uc3QgYnJhY2VzPShlLHQ9e30pPT57bGV0IHI9W107aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKGxldCBuIG9mIGUpe2xldCBlPWJyYWNlcy5jcmVhdGUobix0KTtpZihBcnJheS5pc0FycmF5KGUpKXtyLnB1c2goLi4uZSl9ZWxzZXtyLnB1c2goZSl9fX1lbHNle3I9W10uY29uY2F0KGJyYWNlcy5jcmVhdGUoZSx0KSl9aWYodCYmdC5leHBhbmQ9PT10cnVlJiZ0Lm5vZHVwZXM9PT10cnVlKXtyPVsuLi5uZXcgU2V0KHIpXX1yZXR1cm4gcn07YnJhY2VzLnBhcnNlPShlLHQ9e30pPT5vKGUsdCk7YnJhY2VzLnN0cmluZ2lmeT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIG4oYnJhY2VzLnBhcnNlKGUsdCksdCl9cmV0dXJuIG4oZSx0KX07YnJhY2VzLmNvbXBpbGU9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2U9YnJhY2VzLnBhcnNlKGUsdCl9cmV0dXJuIHUoZSx0KX07YnJhY2VzLmV4cGFuZD0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7ZT1icmFjZXMucGFyc2UoZSx0KX1sZXQgcj1zKGUsdCk7aWYodC5ub2VtcHR5PT09dHJ1ZSl7cj1yLmZpbHRlcihCb29sZWFuKX1pZih0Lm5vZHVwZXM9PT10cnVlKXtyPVsuLi5uZXcgU2V0KHIpXX1yZXR1cm4gcn07YnJhY2VzLmNyZWF0ZT0oZSx0PXt9KT0+e2lmKGU9PT1cIlwifHxlLmxlbmd0aDwzKXtyZXR1cm5bZV19cmV0dXJuIHQuZXhwYW5kIT09dHJ1ZT9icmFjZXMuY29tcGlsZShlLHQpOmJyYWNlcy5leHBhbmQoZSx0KX07ZS5leHBvcnRzPWJyYWNlc30sMTc5OihlLHQscik9Pntjb25zdCBuPXIoNzgzKTtjb25zdCB1PXIoNjE3KTtjb25zdCBjb21waWxlPShlLHQ9e30pPT57bGV0IHdhbGs9KGUscj17fSk9PntsZXQgcz11LmlzSW52YWxpZEJyYWNlKHIpO2xldCBvPWUuaW52YWxpZD09PXRydWUmJnQuZXNjYXBlSW52YWxpZD09PXRydWU7bGV0IGk9cz09PXRydWV8fG89PT10cnVlO2xldCBhPXQuZXNjYXBlSW52YWxpZD09PXRydWU/XCJcXFxcXCI6XCJcIjtsZXQgbD1cIlwiO2lmKGUuaXNPcGVuPT09dHJ1ZSl7cmV0dXJuIGErZS52YWx1ZX1pZihlLmlzQ2xvc2U9PT10cnVlKXtyZXR1cm4gYStlLnZhbHVlfWlmKGUudHlwZT09PVwib3BlblwiKXtyZXR1cm4gaT9hK2UudmFsdWU6XCIoXCJ9aWYoZS50eXBlPT09XCJjbG9zZVwiKXtyZXR1cm4gaT9hK2UudmFsdWU6XCIpXCJ9aWYoZS50eXBlPT09XCJjb21tYVwiKXtyZXR1cm4gZS5wcmV2LnR5cGU9PT1cImNvbW1hXCI/XCJcIjppP2UudmFsdWU6XCJ8XCJ9aWYoZS52YWx1ZSl7cmV0dXJuIGUudmFsdWV9aWYoZS5ub2RlcyYmZS5yYW5nZXM+MCl7bGV0IHI9dS5yZWR1Y2UoZS5ub2Rlcyk7bGV0IHM9biguLi5yLHsuLi50LHdyYXA6ZmFsc2UsdG9SZWdleDp0cnVlfSk7aWYocy5sZW5ndGghPT0wKXtyZXR1cm4gci5sZW5ndGg+MSYmcy5sZW5ndGg+MT9gKCR7c30pYDpzfX1pZihlLm5vZGVzKXtmb3IobGV0IHQgb2YgZS5ub2Rlcyl7bCs9d2Fsayh0LGUpfX1yZXR1cm4gbH07cmV0dXJuIHdhbGsoZSl9O2UuZXhwb3J0cz1jb21waWxlfSw0NTc6ZT0+e2UuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LENIQVJfMDpcIjBcIixDSEFSXzk6XCI5XCIsQ0hBUl9VUFBFUkNBU0VfQTpcIkFcIixDSEFSX0xPV0VSQ0FTRV9BOlwiYVwiLENIQVJfVVBQRVJDQVNFX1o6XCJaXCIsQ0hBUl9MT1dFUkNBU0VfWjpcInpcIixDSEFSX0xFRlRfUEFSRU5USEVTRVM6XCIoXCIsQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzpcIilcIixDSEFSX0FTVEVSSVNLOlwiKlwiLENIQVJfQU1QRVJTQU5EOlwiJlwiLENIQVJfQVQ6XCJAXCIsQ0hBUl9CQUNLU0xBU0g6XCJcXFxcXCIsQ0hBUl9CQUNLVElDSzpcImBcIixDSEFSX0NBUlJJQUdFX1JFVFVSTjpcIlxcclwiLENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6XCJeXCIsQ0hBUl9DT0xPTjpcIjpcIixDSEFSX0NPTU1BOlwiLFwiLENIQVJfRE9MTEFSOlwiJFwiLENIQVJfRE9UOlwiLlwiLENIQVJfRE9VQkxFX1FVT1RFOidcIicsQ0hBUl9FUVVBTDpcIj1cIixDSEFSX0VYQ0xBTUFUSU9OX01BUks6XCIhXCIsQ0hBUl9GT1JNX0ZFRUQ6XCJcXGZcIixDSEFSX0ZPUldBUkRfU0xBU0g6XCIvXCIsQ0hBUl9IQVNIOlwiI1wiLENIQVJfSFlQSEVOX01JTlVTOlwiLVwiLENIQVJfTEVGVF9BTkdMRV9CUkFDS0VUOlwiPFwiLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpcIntcIixDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6XCJbXCIsQ0hBUl9MSU5FX0ZFRUQ6XCJcXG5cIixDSEFSX05PX0JSRUFLX1NQQUNFOlwiwqBcIixDSEFSX1BFUkNFTlQ6XCIlXCIsQ0hBUl9QTFVTOlwiK1wiLENIQVJfUVVFU1RJT05fTUFSSzpcIj9cIixDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6XCI+XCIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpcIn1cIixDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOlwiXVwiLENIQVJfU0VNSUNPTE9OOlwiO1wiLENIQVJfU0lOR0xFX1FVT1RFOlwiJ1wiLENIQVJfU1BBQ0U6XCIgXCIsQ0hBUl9UQUI6XCJcXHRcIixDSEFSX1VOREVSU0NPUkU6XCJfXCIsQ0hBUl9WRVJUSUNBTF9MSU5FOlwifFwiLENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOlwiXFx1ZmVmZlwifX0sMTM6KGUsdCxyKT0+e2NvbnN0IG49cig3ODMpO2NvbnN0IHU9cigxMzcpO2NvbnN0IHM9cig2MTcpO2NvbnN0IGFwcGVuZD0oZT1cIlwiLHQ9XCJcIixyPWZhbHNlKT0+e2xldCBuPVtdO2U9W10uY29uY2F0KGUpO3Q9W10uY29uY2F0KHQpO2lmKCF0Lmxlbmd0aClyZXR1cm4gZTtpZighZS5sZW5ndGgpe3JldHVybiByP3MuZmxhdHRlbih0KS5tYXAoKGU9PmB7JHtlfX1gKSk6dH1mb3IobGV0IHUgb2YgZSl7aWYoQXJyYXkuaXNBcnJheSh1KSl7Zm9yKGxldCBlIG9mIHUpe24ucHVzaChhcHBlbmQoZSx0LHIpKX19ZWxzZXtmb3IobGV0IGUgb2YgdCl7aWYocj09PXRydWUmJnR5cGVvZiBlPT09XCJzdHJpbmdcIillPWB7JHtlfX1gO24ucHVzaChBcnJheS5pc0FycmF5KGUpP2FwcGVuZCh1LGUscik6dStlKX19fXJldHVybiBzLmZsYXR0ZW4obil9O2NvbnN0IGV4cGFuZD0oZSx0PXt9KT0+e2xldCByPXQucmFuZ2VMaW1pdD09PXZvaWQgMD8xZTM6dC5yYW5nZUxpbWl0O2xldCB3YWxrPShlLG89e30pPT57ZS5xdWV1ZT1bXTtsZXQgaT1vO2xldCBhPW8ucXVldWU7d2hpbGUoaS50eXBlIT09XCJicmFjZVwiJiZpLnR5cGUhPT1cInJvb3RcIiYmaS5wYXJlbnQpe2k9aS5wYXJlbnQ7YT1pLnF1ZXVlfWlmKGUuaW52YWxpZHx8ZS5kb2xsYXIpe2EucHVzaChhcHBlbmQoYS5wb3AoKSx1KGUsdCkpKTtyZXR1cm59aWYoZS50eXBlPT09XCJicmFjZVwiJiZlLmludmFsaWQhPT10cnVlJiZlLm5vZGVzLmxlbmd0aD09PTIpe2EucHVzaChhcHBlbmQoYS5wb3AoKSxbXCJ7fVwiXSkpO3JldHVybn1pZihlLm5vZGVzJiZlLnJhbmdlcz4wKXtsZXQgbz1zLnJlZHVjZShlLm5vZGVzKTtpZihzLmV4Y2VlZHNMaW1pdCguLi5vLHQuc3RlcCxyKSl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJleHBhbmRlZCBhcnJheSBsZW5ndGggZXhjZWVkcyByYW5nZSBsaW1pdC4gVXNlIG9wdGlvbnMucmFuZ2VMaW1pdCB0byBpbmNyZWFzZSBvciBkaXNhYmxlIHRoZSBsaW1pdC5cIil9bGV0IGk9biguLi5vLHQpO2lmKGkubGVuZ3RoPT09MCl7aT11KGUsdCl9YS5wdXNoKGFwcGVuZChhLnBvcCgpLGkpKTtlLm5vZGVzPVtdO3JldHVybn1sZXQgbD1zLmVuY2xvc2VCcmFjZShlKTtsZXQgYz1lLnF1ZXVlO2xldCBwPWU7d2hpbGUocC50eXBlIT09XCJicmFjZVwiJiZwLnR5cGUhPT1cInJvb3RcIiYmcC5wYXJlbnQpe3A9cC5wYXJlbnQ7Yz1wLnF1ZXVlfWZvcihsZXQgdD0wO3Q8ZS5ub2Rlcy5sZW5ndGg7dCsrKXtsZXQgcj1lLm5vZGVzW3RdO2lmKHIudHlwZT09PVwiY29tbWFcIiYmZS50eXBlPT09XCJicmFjZVwiKXtpZih0PT09MSljLnB1c2goXCJcIik7Yy5wdXNoKFwiXCIpO2NvbnRpbnVlfWlmKHIudHlwZT09PVwiY2xvc2VcIil7YS5wdXNoKGFwcGVuZChhLnBvcCgpLGMsbCkpO2NvbnRpbnVlfWlmKHIudmFsdWUmJnIudHlwZSE9PVwib3BlblwiKXtjLnB1c2goYXBwZW5kKGMucG9wKCksci52YWx1ZSkpO2NvbnRpbnVlfWlmKHIubm9kZXMpe3dhbGsocixlKX19cmV0dXJuIGN9O3JldHVybiBzLmZsYXR0ZW4od2FsayhlKSl9O2UuZXhwb3J0cz1leHBhbmR9LDcxOTooZSx0LHIpPT57Y29uc3Qgbj1yKDEzNyk7Y29uc3R7TUFYX0xFTkdUSDp1LENIQVJfQkFDS1NMQVNIOnMsQ0hBUl9CQUNLVElDSzpvLENIQVJfQ09NTUE6aSxDSEFSX0RPVDphLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpsLENIQVJfUklHSFRfUEFSRU5USEVTRVM6YyxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6cCxDSEFSX1JJR0hUX0NVUkxZX0JSQUNFOmYsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOkEsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpSLENIQVJfRE9VQkxFX1FVT1RFOl8sQ0hBUl9TSU5HTEVfUVVPVEU6aCxDSEFSX05PX0JSRUFLX1NQQUNFOmcsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6RX09cig0NTcpO2NvbnN0IHBhcnNlPShlLHQ9e30pPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIil9bGV0IHI9dHx8e307bGV0IEM9dHlwZW9mIHIubWF4TGVuZ3RoPT09XCJudW1iZXJcIj9NYXRoLm1pbih1LHIubWF4TGVuZ3RoKTp1O2lmKGUubGVuZ3RoPkMpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoICgke2UubGVuZ3RofSksIGV4Y2VlZHMgbWF4IGNoYXJhY3RlcnMgKCR7Q30pYCl9bGV0IHk9e3R5cGU6XCJyb290XCIsaW5wdXQ6ZSxub2RlczpbXX07bGV0IGQ9W3ldO2xldCB4PXk7bGV0IGI9eTtsZXQgUz0wO2xldCBIPWUubGVuZ3RoO2xldCB2PTA7bGV0ICQ9MDtsZXQgbTtsZXQgVD17fTtjb25zdCBhZHZhbmNlPSgpPT5lW3YrK107Y29uc3QgcHVzaD1lPT57aWYoZS50eXBlPT09XCJ0ZXh0XCImJmIudHlwZT09PVwiZG90XCIpe2IudHlwZT1cInRleHRcIn1pZihiJiZiLnR5cGU9PT1cInRleHRcIiYmZS50eXBlPT09XCJ0ZXh0XCIpe2IudmFsdWUrPWUudmFsdWU7cmV0dXJufXgubm9kZXMucHVzaChlKTtlLnBhcmVudD14O2UucHJldj1iO2I9ZTtyZXR1cm4gZX07cHVzaCh7dHlwZTpcImJvc1wifSk7d2hpbGUodjxIKXt4PWRbZC5sZW5ndGgtMV07bT1hZHZhbmNlKCk7aWYobT09PUV8fG09PT1nKXtjb250aW51ZX1pZihtPT09cyl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZToodC5rZWVwRXNjYXBpbmc/bTpcIlwiKSthZHZhbmNlKCl9KTtjb250aW51ZX1pZihtPT09Uil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpcIlxcXFxcIittfSk7Y29udGludWV9aWYobT09PUEpe1MrKztsZXQgZT10cnVlO2xldCB0O3doaWxlKHY8SCYmKHQ9YWR2YW5jZSgpKSl7bSs9dDtpZih0PT09QSl7UysrO2NvbnRpbnVlfWlmKHQ9PT1zKXttKz1hZHZhbmNlKCk7Y29udGludWV9aWYodD09PVIpe1MtLTtpZihTPT09MCl7YnJlYWt9fX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOm19KTtjb250aW51ZX1pZihtPT09bCl7eD1wdXNoKHt0eXBlOlwicGFyZW5cIixub2RlczpbXX0pO2QucHVzaCh4KTtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOm19KTtjb250aW51ZX1pZihtPT09Yyl7aWYoeC50eXBlIT09XCJwYXJlblwiKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOm19KTtjb250aW51ZX14PWQucG9wKCk7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7eD1kW2QubGVuZ3RoLTFdO2NvbnRpbnVlfWlmKG09PT1ffHxtPT09aHx8bT09PW8pe2xldCBlPW07bGV0IHI7aWYodC5rZWVwUXVvdGVzIT09dHJ1ZSl7bT1cIlwifXdoaWxlKHY8SCYmKHI9YWR2YW5jZSgpKSl7aWYocj09PXMpe20rPXIrYWR2YW5jZSgpO2NvbnRpbnVlfWlmKHI9PT1lKXtpZih0LmtlZXBRdW90ZXM9PT10cnVlKW0rPXI7YnJlYWt9bSs9cn1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOm19KTtjb250aW51ZX1pZihtPT09cCl7JCsrO2xldCBlPWIudmFsdWUmJmIudmFsdWUuc2xpY2UoLTEpPT09XCIkXCJ8fHguZG9sbGFyPT09dHJ1ZTtsZXQgdD17dHlwZTpcImJyYWNlXCIsb3Blbjp0cnVlLGNsb3NlOmZhbHNlLGRvbGxhcjplLGRlcHRoOiQsY29tbWFzOjAscmFuZ2VzOjAsbm9kZXM6W119O3g9cHVzaCh0KTtkLnB1c2goeCk7cHVzaCh7dHlwZTpcIm9wZW5cIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWYpe2lmKHgudHlwZSE9PVwiYnJhY2VcIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9bGV0IGU9XCJjbG9zZVwiO3g9ZC5wb3AoKTt4LmNsb3NlPXRydWU7cHVzaCh7dHlwZTplLHZhbHVlOm19KTskLS07eD1kW2QubGVuZ3RoLTFdO2NvbnRpbnVlfWlmKG09PT1pJiYkPjApe2lmKHgucmFuZ2VzPjApe3gucmFuZ2VzPTA7bGV0IGU9eC5ub2Rlcy5zaGlmdCgpO3gubm9kZXM9W2Use3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bih4KX1dfXB1c2goe3R5cGU6XCJjb21tYVwiLHZhbHVlOm19KTt4LmNvbW1hcysrO2NvbnRpbnVlfWlmKG09PT1hJiYkPjAmJnguY29tbWFzPT09MCl7bGV0IGU9eC5ub2RlcztpZigkPT09MHx8ZS5sZW5ndGg9PT0wKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOm19KTtjb250aW51ZX1pZihiLnR5cGU9PT1cImRvdFwiKXt4LnJhbmdlPVtdO2IudmFsdWUrPW07Yi50eXBlPVwicmFuZ2VcIjtpZih4Lm5vZGVzLmxlbmd0aCE9PTMmJngubm9kZXMubGVuZ3RoIT09NSl7eC5pbnZhbGlkPXRydWU7eC5yYW5nZXM9MDtiLnR5cGU9XCJ0ZXh0XCI7Y29udGludWV9eC5yYW5nZXMrKzt4LmFyZ3M9W107Y29udGludWV9aWYoYi50eXBlPT09XCJyYW5nZVwiKXtlLnBvcCgpO2xldCB0PWVbZS5sZW5ndGgtMV07dC52YWx1ZSs9Yi52YWx1ZSttO2I9dDt4LnJhbmdlcy0tO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJkb3RcIix2YWx1ZTptfSk7Y29udGludWV9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSl9ZG97eD1kLnBvcCgpO2lmKHgudHlwZSE9PVwicm9vdFwiKXt4Lm5vZGVzLmZvckVhY2goKGU9PntpZighZS5ub2Rlcyl7aWYoZS50eXBlPT09XCJvcGVuXCIpZS5pc09wZW49dHJ1ZTtpZihlLnR5cGU9PT1cImNsb3NlXCIpZS5pc0Nsb3NlPXRydWU7aWYoIWUubm9kZXMpZS50eXBlPVwidGV4dFwiO2UuaW52YWxpZD10cnVlfX0pKTtsZXQgZT1kW2QubGVuZ3RoLTFdO2xldCB0PWUubm9kZXMuaW5kZXhPZih4KTtlLm5vZGVzLnNwbGljZSh0LDEsLi4ueC5ub2Rlcyl9fXdoaWxlKGQubGVuZ3RoPjApO3B1c2goe3R5cGU6XCJlb3NcIn0pO3JldHVybiB5fTtlLmV4cG9ydHM9cGFyc2V9LDEzNzooZSx0LHIpPT57Y29uc3Qgbj1yKDYxNyk7ZS5leHBvcnRzPShlLHQ9e30pPT57bGV0IHN0cmluZ2lmeT0oZSxyPXt9KT0+e2xldCB1PXQuZXNjYXBlSW52YWxpZCYmbi5pc0ludmFsaWRCcmFjZShyKTtsZXQgcz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBvPVwiXCI7aWYoZS52YWx1ZSl7aWYoKHV8fHMpJiZuLmlzT3Blbk9yQ2xvc2UoZSkpe3JldHVyblwiXFxcXFwiK2UudmFsdWV9cmV0dXJuIGUudmFsdWV9aWYoZS52YWx1ZSl7cmV0dXJuIGUudmFsdWV9aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe28rPXN0cmluZ2lmeSh0KX19cmV0dXJuIG99O3JldHVybiBzdHJpbmdpZnkoZSl9fSw2MTc6KGUsdCk9Pnt0LmlzSW50ZWdlcj1lPT57aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihlKX1pZih0eXBlb2YgZT09PVwic3RyaW5nXCImJmUudHJpbSgpIT09XCJcIil7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoTnVtYmVyKGUpKX1yZXR1cm4gZmFsc2V9O3QuZmluZD0oZSx0KT0+ZS5ub2Rlcy5maW5kKChlPT5lLnR5cGU9PT10KSk7dC5leGNlZWRzTGltaXQ9KGUscixuPTEsdSk9PntpZih1PT09ZmFsc2UpcmV0dXJuIGZhbHNlO2lmKCF0LmlzSW50ZWdlcihlKXx8IXQuaXNJbnRlZ2VyKHIpKXJldHVybiBmYWxzZTtyZXR1cm4oTnVtYmVyKHIpLU51bWJlcihlKSkvTnVtYmVyKG4pPj11fTt0LmVzY2FwZU5vZGU9KGUsdD0wLHIpPT57bGV0IG49ZS5ub2Rlc1t0XTtpZighbilyZXR1cm47aWYociYmbi50eXBlPT09cnx8bi50eXBlPT09XCJvcGVuXCJ8fG4udHlwZT09PVwiY2xvc2VcIil7aWYobi5lc2NhcGVkIT09dHJ1ZSl7bi52YWx1ZT1cIlxcXFxcIituLnZhbHVlO24uZXNjYXBlZD10cnVlfX19O3QuZW5jbG9zZUJyYWNlPWU9PntpZihlLnR5cGUhPT1cImJyYWNlXCIpcmV0dXJuIGZhbHNlO2lmKGUuY29tbWFzPj4wK2UucmFuZ2VzPj4wPT09MCl7ZS5pbnZhbGlkPXRydWU7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfTt0LmlzSW52YWxpZEJyYWNlPWU9PntpZihlLnR5cGUhPT1cImJyYWNlXCIpcmV0dXJuIGZhbHNlO2lmKGUuaW52YWxpZD09PXRydWV8fGUuZG9sbGFyKXJldHVybiB0cnVlO2lmKGUuY29tbWFzPj4wK2UucmFuZ2VzPj4wPT09MCl7ZS5pbnZhbGlkPXRydWU7cmV0dXJuIHRydWV9aWYoZS5vcGVuIT09dHJ1ZXx8ZS5jbG9zZSE9PXRydWUpe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc09wZW5PckNsb3NlPWU9PntpZihlLnR5cGU9PT1cIm9wZW5cInx8ZS50eXBlPT09XCJjbG9zZVwiKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gZS5vcGVuPT09dHJ1ZXx8ZS5jbG9zZT09PXRydWV9O3QucmVkdWNlPWU9PmUucmVkdWNlKCgoZSx0KT0+e2lmKHQudHlwZT09PVwidGV4dFwiKWUucHVzaCh0LnZhbHVlKTtpZih0LnR5cGU9PT1cInJhbmdlXCIpdC50eXBlPVwidGV4dFwiO3JldHVybiBlfSksW10pO3QuZmxhdHRlbj0oLi4uZSk9Pntjb25zdCB0PVtdO2NvbnN0IGZsYXQ9ZT0+e2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtsZXQgbj1lW3JdO0FycmF5LmlzQXJyYXkobik/ZmxhdChuLHQpOm4hPT12b2lkIDAmJnQucHVzaChuKX1yZXR1cm4gdH07ZmxhdChlKTtyZXR1cm4gdH19LDc4MzooZSx0LHIpPT57XG4vKiFcbiAqIGZpbGwtcmFuZ2UgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2ZpbGwtcmFuZ2U+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jb25zdCBuPXIoODM3KTtjb25zdCB1PXIoNDkyKTtjb25zdCBpc09iamVjdD1lPT5lIT09bnVsbCYmdHlwZW9mIGU9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheShlKTtjb25zdCB0cmFuc2Zvcm09ZT0+dD0+ZT09PXRydWU/TnVtYmVyKHQpOlN0cmluZyh0KTtjb25zdCBpc1ZhbGlkVmFsdWU9ZT0+dHlwZW9mIGU9PT1cIm51bWJlclwifHx0eXBlb2YgZT09PVwic3RyaW5nXCImJmUhPT1cIlwiO2NvbnN0IGlzTnVtYmVyPWU9Pk51bWJlci5pc0ludGVnZXIoK2UpO2NvbnN0IHplcm9zPWU9PntsZXQgdD1gJHtlfWA7bGV0IHI9LTE7aWYodFswXT09PVwiLVwiKXQ9dC5zbGljZSgxKTtpZih0PT09XCIwXCIpcmV0dXJuIGZhbHNlO3doaWxlKHRbKytyXT09PVwiMFwiKTtyZXR1cm4gcj4wfTtjb25zdCBzdHJpbmdpZnk9KGUsdCxyKT0+e2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcInx8dHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gci5zdHJpbmdpZnk9PT10cnVlfTtjb25zdCBwYWQ9KGUsdCxyKT0+e2lmKHQ+MCl7bGV0IHI9ZVswXT09PVwiLVwiP1wiLVwiOlwiXCI7aWYocillPWUuc2xpY2UoMSk7ZT1yK2UucGFkU3RhcnQocj90LTE6dCxcIjBcIil9aWYocj09PWZhbHNlKXtyZXR1cm4gU3RyaW5nKGUpfXJldHVybiBlfTtjb25zdCB0b01heExlbj0oZSx0KT0+e2xldCByPWVbMF09PT1cIi1cIj9cIi1cIjpcIlwiO2lmKHIpe2U9ZS5zbGljZSgxKTt0LS19d2hpbGUoZS5sZW5ndGg8dCllPVwiMFwiK2U7cmV0dXJuIHI/XCItXCIrZTplfTtjb25zdCB0b1NlcXVlbmNlPShlLHQpPT57ZS5uZWdhdGl2ZXMuc29ydCgoKGUsdCk9PmU8dD8tMTplPnQ/MTowKSk7ZS5wb3NpdGl2ZXMuc29ydCgoKGUsdCk9PmU8dD8tMTplPnQ/MTowKSk7bGV0IHI9dC5jYXB0dXJlP1wiXCI6XCI/OlwiO2xldCBuPVwiXCI7bGV0IHU9XCJcIjtsZXQgcztpZihlLnBvc2l0aXZlcy5sZW5ndGgpe249ZS5wb3NpdGl2ZXMuam9pbihcInxcIil9aWYoZS5uZWdhdGl2ZXMubGVuZ3RoKXt1PWAtKCR7cn0ke2UubmVnYXRpdmVzLmpvaW4oXCJ8XCIpfSlgfWlmKG4mJnUpe3M9YCR7bn18JHt1fWB9ZWxzZXtzPW58fHV9aWYodC53cmFwKXtyZXR1cm5gKCR7cn0ke3N9KWB9cmV0dXJuIHN9O2NvbnN0IHRvUmFuZ2U9KGUsdCxyLG4pPT57aWYocil7cmV0dXJuIHUoZSx0LHt3cmFwOmZhbHNlLC4uLm59KX1sZXQgcz1TdHJpbmcuZnJvbUNoYXJDb2RlKGUpO2lmKGU9PT10KXJldHVybiBzO2xldCBvPVN0cmluZy5mcm9tQ2hhckNvZGUodCk7cmV0dXJuYFske3N9LSR7b31dYH07Y29uc3QgdG9SZWdleD0oZSx0LHIpPT57aWYoQXJyYXkuaXNBcnJheShlKSl7bGV0IHQ9ci53cmFwPT09dHJ1ZTtsZXQgbj1yLmNhcHR1cmU/XCJcIjpcIj86XCI7cmV0dXJuIHQ/YCgke259JHtlLmpvaW4oXCJ8XCIpfSlgOmUuam9pbihcInxcIil9cmV0dXJuIHUoZSx0LHIpfTtjb25zdCByYW5nZUVycm9yPSguLi5lKT0+bmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHJhbmdlIGFyZ3VtZW50czogXCIrbi5pbnNwZWN0KC4uLmUpKTtjb25zdCBpbnZhbGlkUmFuZ2U9KGUsdCxyKT0+e2lmKHIuc3RyaWN0UmFuZ2VzPT09dHJ1ZSl0aHJvdyByYW5nZUVycm9yKFtlLHRdKTtyZXR1cm5bXX07Y29uc3QgaW52YWxpZFN0ZXA9KGUsdCk9PntpZih0LnN0cmljdFJhbmdlcz09PXRydWUpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHN0ZXAgXCIke2V9XCIgdG8gYmUgYSBudW1iZXJgKX1yZXR1cm5bXX07Y29uc3QgZmlsbE51bWJlcnM9KGUsdCxyPTEsbj17fSk9PntsZXQgdT1OdW1iZXIoZSk7bGV0IHM9TnVtYmVyKHQpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHUpfHwhTnVtYmVyLmlzSW50ZWdlcihzKSl7aWYobi5zdHJpY3RSYW5nZXM9PT10cnVlKXRocm93IHJhbmdlRXJyb3IoW2UsdF0pO3JldHVybltdfWlmKHU9PT0wKXU9MDtpZihzPT09MClzPTA7bGV0IG89dT5zO2xldCBpPVN0cmluZyhlKTtsZXQgYT1TdHJpbmcodCk7bGV0IGw9U3RyaW5nKHIpO3I9TWF0aC5tYXgoTWF0aC5hYnMociksMSk7bGV0IGM9emVyb3MoaSl8fHplcm9zKGEpfHx6ZXJvcyhsKTtsZXQgcD1jP01hdGgubWF4KGkubGVuZ3RoLGEubGVuZ3RoLGwubGVuZ3RoKTowO2xldCBmPWM9PT1mYWxzZSYmc3RyaW5naWZ5KGUsdCxuKT09PWZhbHNlO2xldCBBPW4udHJhbnNmb3JtfHx0cmFuc2Zvcm0oZik7aWYobi50b1JlZ2V4JiZyPT09MSl7cmV0dXJuIHRvUmFuZ2UodG9NYXhMZW4oZSxwKSx0b01heExlbih0LHApLHRydWUsbil9bGV0IFI9e25lZ2F0aXZlczpbXSxwb3NpdGl2ZXM6W119O2xldCBwdXNoPWU9PlJbZTwwP1wibmVnYXRpdmVzXCI6XCJwb3NpdGl2ZXNcIl0ucHVzaChNYXRoLmFicyhlKSk7bGV0IF89W107bGV0IGg9MDt3aGlsZShvP3U+PXM6dTw9cyl7aWYobi50b1JlZ2V4PT09dHJ1ZSYmcj4xKXtwdXNoKHUpfWVsc2V7Xy5wdXNoKHBhZChBKHUsaCkscCxmKSl9dT1vP3Utcjp1K3I7aCsrfWlmKG4udG9SZWdleD09PXRydWUpe3JldHVybiByPjE/dG9TZXF1ZW5jZShSLG4pOnRvUmVnZXgoXyxudWxsLHt3cmFwOmZhbHNlLC4uLm59KX1yZXR1cm4gX307Y29uc3QgZmlsbExldHRlcnM9KGUsdCxyPTEsbj17fSk9PntpZighaXNOdW1iZXIoZSkmJmUubGVuZ3RoPjF8fCFpc051bWJlcih0KSYmdC5sZW5ndGg+MSl7cmV0dXJuIGludmFsaWRSYW5nZShlLHQsbil9bGV0IHU9bi50cmFuc2Zvcm18fChlPT5TdHJpbmcuZnJvbUNoYXJDb2RlKGUpKTtsZXQgcz1gJHtlfWAuY2hhckNvZGVBdCgwKTtsZXQgbz1gJHt0fWAuY2hhckNvZGVBdCgwKTtsZXQgaT1zPm87bGV0IGE9TWF0aC5taW4ocyxvKTtsZXQgbD1NYXRoLm1heChzLG8pO2lmKG4udG9SZWdleCYmcj09PTEpe3JldHVybiB0b1JhbmdlKGEsbCxmYWxzZSxuKX1sZXQgYz1bXTtsZXQgcD0wO3doaWxlKGk/cz49bzpzPD1vKXtjLnB1c2godShzLHApKTtzPWk/cy1yOnMrcjtwKyt9aWYobi50b1JlZ2V4PT09dHJ1ZSl7cmV0dXJuIHRvUmVnZXgoYyxudWxsLHt3cmFwOmZhbHNlLG9wdGlvbnM6bn0pfXJldHVybiBjfTtjb25zdCBmaWxsPShlLHQscixuPXt9KT0+e2lmKHQ9PW51bGwmJmlzVmFsaWRWYWx1ZShlKSl7cmV0dXJuW2VdfWlmKCFpc1ZhbGlkVmFsdWUoZSl8fCFpc1ZhbGlkVmFsdWUodCkpe3JldHVybiBpbnZhbGlkUmFuZ2UoZSx0LG4pfWlmKHR5cGVvZiByPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmlsbChlLHQsMSx7dHJhbnNmb3JtOnJ9KX1pZihpc09iamVjdChyKSl7cmV0dXJuIGZpbGwoZSx0LDAscil9bGV0IHU9ey4uLm59O2lmKHUuY2FwdHVyZT09PXRydWUpdS53cmFwPXRydWU7cj1yfHx1LnN0ZXB8fDE7aWYoIWlzTnVtYmVyKHIpKXtpZihyIT1udWxsJiYhaXNPYmplY3QocikpcmV0dXJuIGludmFsaWRTdGVwKHIsdSk7cmV0dXJuIGZpbGwoZSx0LDEscil9aWYoaXNOdW1iZXIoZSkmJmlzTnVtYmVyKHQpKXtyZXR1cm4gZmlsbE51bWJlcnMoZSx0LHIsdSl9cmV0dXJuIGZpbGxMZXR0ZXJzKGUsdCxNYXRoLm1heChNYXRoLmFicyhyKSwxKSx1KX07ZS5leHBvcnRzPWZpbGx9LDM1NzplPT57XG4vKiFcbiAqIGlzLW51bWJlciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtbnVtYmVyPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7cmV0dXJuIGUtZT09PTB9aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlLnRyaW0oKSE9PVwiXCIpe3JldHVybiBOdW1iZXIuaXNGaW5pdGU/TnVtYmVyLmlzRmluaXRlKCtlKTppc0Zpbml0ZSgrZSl9cmV0dXJuIGZhbHNlfX0sOTcxOihlLHQscik9Pntjb25zdCBuPXIoODM3KTtjb25zdCB1PXIoMzMzKTtjb25zdCBzPXIoMjUxKTtjb25zdCBvPXIoNTEzKTtjb25zdCBpc0VtcHR5U3RyaW5nPWU9PmU9PT1cIlwifHxlPT09XCIuL1wiO2NvbnN0IG1pY3JvbWF0Y2g9KGUsdCxyKT0+e3Q9W10uY29uY2F0KHQpO2U9W10uY29uY2F0KGUpO2xldCBuPW5ldyBTZXQ7bGV0IHU9bmV3IFNldDtsZXQgbz1uZXcgU2V0O2xldCBpPTA7bGV0IG9uUmVzdWx0PWU9PntvLmFkZChlLm91dHB1dCk7aWYociYmci5vblJlc3VsdCl7ci5vblJlc3VsdChlKX19O2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bysrKXtsZXQgYT1zKFN0cmluZyh0W29dKSx7Li4ucixvblJlc3VsdDpvblJlc3VsdH0sdHJ1ZSk7bGV0IGw9YS5zdGF0ZS5uZWdhdGVkfHxhLnN0YXRlLm5lZ2F0ZWRFeHRnbG9iO2lmKGwpaSsrO2ZvcihsZXQgdCBvZiBlKXtsZXQgZT1hKHQsdHJ1ZSk7bGV0IHI9bD8hZS5pc01hdGNoOmUuaXNNYXRjaDtpZighciljb250aW51ZTtpZihsKXtuLmFkZChlLm91dHB1dCl9ZWxzZXtuLmRlbGV0ZShlLm91dHB1dCk7dS5hZGQoZS5vdXRwdXQpfX19bGV0IGE9aT09PXQubGVuZ3RoP1suLi5vXTpbLi4udV07bGV0IGw9YS5maWx0ZXIoKGU9PiFuLmhhcyhlKSkpO2lmKHImJmwubGVuZ3RoPT09MCl7aWYoci5mYWlsZ2xvYj09PXRydWUpe3Rocm93IG5ldyBFcnJvcihgTm8gbWF0Y2hlcyBmb3VuZCBmb3IgXCIke3Quam9pbihcIiwgXCIpfVwiYCl9aWYoci5ub251bGw9PT10cnVlfHxyLm51bGxnbG9iPT09dHJ1ZSl7cmV0dXJuIHIudW5lc2NhcGU/dC5tYXAoKGU9PmUucmVwbGFjZSgvXFxcXC9nLFwiXCIpKSk6dH19cmV0dXJuIGx9O21pY3JvbWF0Y2gubWF0Y2g9bWljcm9tYXRjaDttaWNyb21hdGNoLm1hdGNoZXI9KGUsdCk9PnMoZSx0KTttaWNyb21hdGNoLmlzTWF0Y2g9KGUsdCxyKT0+cyh0LHIpKGUpO21pY3JvbWF0Y2guYW55PW1pY3JvbWF0Y2guaXNNYXRjaDttaWNyb21hdGNoLm5vdD0oZSx0LHI9e30pPT57dD1bXS5jb25jYXQodCkubWFwKFN0cmluZyk7bGV0IG49bmV3IFNldDtsZXQgdT1bXTtsZXQgb25SZXN1bHQ9ZT0+e2lmKHIub25SZXN1bHQpci5vblJlc3VsdChlKTt1LnB1c2goZS5vdXRwdXQpfTtsZXQgcz1taWNyb21hdGNoKGUsdCx7Li4ucixvblJlc3VsdDpvblJlc3VsdH0pO2ZvcihsZXQgZSBvZiB1KXtpZighcy5pbmNsdWRlcyhlKSl7bi5hZGQoZSl9fXJldHVyblsuLi5uXX07bWljcm9tYXRjaC5jb250YWlucz0oZSx0LHIpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhIHN0cmluZzogXCIke24uaW5zcGVjdChlKX1cImApfWlmKEFycmF5LmlzQXJyYXkodCkpe3JldHVybiB0LnNvbWUoKHQ9Pm1pY3JvbWF0Y2guY29udGFpbnMoZSx0LHIpKSl9aWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtpZihpc0VtcHR5U3RyaW5nKGUpfHxpc0VtcHR5U3RyaW5nKHQpKXtyZXR1cm4gZmFsc2V9aWYoZS5pbmNsdWRlcyh0KXx8ZS5zdGFydHNXaXRoKFwiLi9cIikmJmUuc2xpY2UoMikuaW5jbHVkZXModCkpe3JldHVybiB0cnVlfX1yZXR1cm4gbWljcm9tYXRjaC5pc01hdGNoKGUsdCx7Li4ucixjb250YWluczp0cnVlfSl9O21pY3JvbWF0Y2gubWF0Y2hLZXlzPShlLHQscik9PntpZighby5pc09iamVjdChlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3RcIil9bGV0IG49bWljcm9tYXRjaChPYmplY3Qua2V5cyhlKSx0LHIpO2xldCB1PXt9O2ZvcihsZXQgdCBvZiBuKXVbdF09ZVt0XTtyZXR1cm4gdX07bWljcm9tYXRjaC5zb21lPShlLHQscik9PntsZXQgbj1bXS5jb25jYXQoZSk7Zm9yKGxldCBlIG9mW10uY29uY2F0KHQpKXtsZXQgdD1zKFN0cmluZyhlKSxyKTtpZihuLnNvbWUoKGU9PnQoZSkpKSl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX07bWljcm9tYXRjaC5ldmVyeT0oZSx0LHIpPT57bGV0IG49W10uY29uY2F0KGUpO2ZvcihsZXQgZSBvZltdLmNvbmNhdCh0KSl7bGV0IHQ9cyhTdHJpbmcoZSkscik7aWYoIW4uZXZlcnkoKGU9PnQoZSkpKSl7cmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX07bWljcm9tYXRjaC5hbGw9KGUsdCxyKT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmc6IFwiJHtuLmluc3BlY3QoZSl9XCJgKX1yZXR1cm5bXS5jb25jYXQodCkuZXZlcnkoKHQ9PnModCxyKShlKSkpfTttaWNyb21hdGNoLmNhcHR1cmU9KGUsdCxyKT0+e2xldCBuPW8uaXNXaW5kb3dzKHIpO2xldCB1PXMubWFrZVJlKFN0cmluZyhlKSx7Li4ucixjYXB0dXJlOnRydWV9KTtsZXQgaT11LmV4ZWMobj9vLnRvUG9zaXhTbGFzaGVzKHQpOnQpO2lmKGkpe3JldHVybiBpLnNsaWNlKDEpLm1hcCgoZT0+ZT09PXZvaWQgMD9cIlwiOmUpKX19O21pY3JvbWF0Y2gubWFrZVJlPSguLi5lKT0+cy5tYWtlUmUoLi4uZSk7bWljcm9tYXRjaC5zY2FuPSguLi5lKT0+cy5zY2FuKC4uLmUpO21pY3JvbWF0Y2gucGFyc2U9KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IG4gb2ZbXS5jb25jYXQoZXx8W10pKXtmb3IobGV0IGUgb2YgdShTdHJpbmcobiksdCkpe3IucHVzaChzLnBhcnNlKGUsdCkpfX1yZXR1cm4gcn07bWljcm9tYXRjaC5icmFjZXM9KGUsdCk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpO2lmKHQmJnQubm9icmFjZT09PXRydWV8fCEvXFx7LipcXH0vLnRlc3QoZSkpe3JldHVybltlXX1yZXR1cm4gdShlLHQpfTttaWNyb21hdGNoLmJyYWNlRXhwYW5kPShlLHQpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtyZXR1cm4gbWljcm9tYXRjaC5icmFjZXMoZSx7Li4udCxleHBhbmQ6dHJ1ZX0pfTtlLmV4cG9ydHM9bWljcm9tYXRjaH0sMjUxOihlLHQscik9PntlLmV4cG9ydHM9cig2ODMpfSwzNTY6KGUsdCxyKT0+e2NvbnN0IG49cigxNyk7Y29uc3QgdT1cIlxcXFxcXFxcL1wiO2NvbnN0IHM9YFteJHt1fV1gO2NvbnN0IG89XCJcXFxcLlwiO2NvbnN0IGk9XCJcXFxcK1wiO2NvbnN0IGE9XCJcXFxcP1wiO2NvbnN0IGw9XCJcXFxcL1wiO2NvbnN0IGM9XCIoPz0uKVwiO2NvbnN0IHA9XCJbXi9dXCI7Y29uc3QgZj1gKD86JHtsfXwkKWA7Y29uc3QgQT1gKD86Xnwke2x9KWA7Y29uc3QgUj1gJHtvfXsxLDJ9JHtmfWA7Y29uc3QgXz1gKD8hJHtvfSlgO2NvbnN0IGg9YCg/ISR7QX0ke1J9KWA7Y29uc3QgZz1gKD8hJHtvfXswLDF9JHtmfSlgO2NvbnN0IEU9YCg/ISR7Un0pYDtjb25zdCBDPWBbXi4ke2x9XWA7Y29uc3QgeT1gJHtwfSo/YDtjb25zdCBkPXtET1RfTElURVJBTDpvLFBMVVNfTElURVJBTDppLFFNQVJLX0xJVEVSQUw6YSxTTEFTSF9MSVRFUkFMOmwsT05FX0NIQVI6YyxRTUFSSzpwLEVORF9BTkNIT1I6ZixET1RTX1NMQVNIOlIsTk9fRE9UOl8sTk9fRE9UUzpoLE5PX0RPVF9TTEFTSDpnLE5PX0RPVFNfU0xBU0g6RSxRTUFSS19OT19ET1Q6QyxTVEFSOnksU1RBUlRfQU5DSE9SOkF9O2NvbnN0IHg9ey4uLmQsU0xBU0hfTElURVJBTDpgWyR7dX1dYCxRTUFSSzpzLFNUQVI6YCR7c30qP2AsRE9UU19TTEFTSDpgJHtvfXsxLDJ9KD86WyR7dX1dfCQpYCxOT19ET1Q6YCg/ISR7b30pYCxOT19ET1RTOmAoPyEoPzpefFske3V9XSkke299ezEsMn0oPzpbJHt1fV18JCkpYCxOT19ET1RfU0xBU0g6YCg/ISR7b317MCwxfSg/Olske3V9XXwkKSlgLE5PX0RPVFNfU0xBU0g6YCg/ISR7b317MSwyfSg/Olske3V9XXwkKSlgLFFNQVJLX05PX0RPVDpgW14uJHt1fV1gLFNUQVJUX0FOQ0hPUjpgKD86XnxbJHt1fV0pYCxFTkRfQU5DSE9SOmAoPzpbJHt1fV18JClgfTtjb25zdCBiPXthbG51bTpcImEtekEtWjAtOVwiLGFscGhhOlwiYS16QS1aXCIsYXNjaWk6XCJcXFxceDAwLVxcXFx4N0ZcIixibGFuazpcIiBcXFxcdFwiLGNudHJsOlwiXFxcXHgwMC1cXFxceDFGXFxcXHg3RlwiLGRpZ2l0OlwiMC05XCIsZ3JhcGg6XCJcXFxceDIxLVxcXFx4N0VcIixsb3dlcjpcImEtelwiLHByaW50OlwiXFxcXHgyMC1cXFxceDdFIFwiLHB1bmN0OlwiXFxcXC0hXFxcIiMkJSYnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiLHNwYWNlOlwiIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGZcIix1cHBlcjpcIkEtWlwiLHdvcmQ6XCJBLVphLXowLTlfXCIseGRpZ2l0OlwiQS1GYS1mMC05XCJ9O2UuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LFBPU0lYX1JFR0VYX1NPVVJDRTpiLFJFR0VYX0JBQ0tTTEFTSDovXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6L15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6L1stKis/Ll4ke30ofClbXFxdXS8sUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOi8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6Lyg/OlxcWy4qP1teXFxcXF1cXF18XFxcXCg/PS4pKS9nLFJFUExBQ0VNRU5UUzp7XCIqKipcIjpcIipcIixcIioqLyoqXCI6XCIqKlwiLFwiKiovKiovKipcIjpcIioqXCJ9LENIQVJfMDo0OCxDSEFSXzk6NTcsQ0hBUl9VUFBFUkNBU0VfQTo2NSxDSEFSX0xPV0VSQ0FTRV9BOjk3LENIQVJfVVBQRVJDQVNFX1o6OTAsQ0hBUl9MT1dFUkNBU0VfWjoxMjIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOjQwLENIQVJfUklHSFRfUEFSRU5USEVTRVM6NDEsQ0hBUl9BU1RFUklTSzo0MixDSEFSX0FNUEVSU0FORDozOCxDSEFSX0FUOjY0LENIQVJfQkFDS1dBUkRfU0xBU0g6OTIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46MTMsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDo5NCxDSEFSX0NPTE9OOjU4LENIQVJfQ09NTUE6NDQsQ0hBUl9ET1Q6NDYsQ0hBUl9ET1VCTEVfUVVPVEU6MzQsQ0hBUl9FUVVBTDo2MSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6MzMsQ0hBUl9GT1JNX0ZFRUQ6MTIsQ0hBUl9GT1JXQVJEX1NMQVNIOjQ3LENIQVJfR1JBVkVfQUNDRU5UOjk2LENIQVJfSEFTSDozNSxDSEFSX0hZUEhFTl9NSU5VUzo0NSxDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDo2MCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6MTIzLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDo5MSxDSEFSX0xJTkVfRkVFRDoxMCxDSEFSX05PX0JSRUFLX1NQQUNFOjE2MCxDSEFSX1BFUkNFTlQ6MzcsQ0hBUl9QTFVTOjQzLENIQVJfUVVFU1RJT05fTUFSSzo2MyxDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6NjIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRToxMjUsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDo5MyxDSEFSX1NFTUlDT0xPTjo1OSxDSEFSX1NJTkdMRV9RVU9URTozOSxDSEFSX1NQQUNFOjMyLENIQVJfVEFCOjksQ0hBUl9VTkRFUlNDT1JFOjk1LENIQVJfVkVSVElDQUxfTElORToxMjQsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6NjUyNzksU0VQOm4uc2VwLGV4dGdsb2JDaGFycyhlKXtyZXR1cm57XCIhXCI6e3R5cGU6XCJuZWdhdGVcIixvcGVuOlwiKD86KD8hKD86XCIsY2xvc2U6YCkpJHtlLlNUQVJ9KWB9LFwiP1wiOnt0eXBlOlwicW1hcmtcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpP1wifSxcIitcIjp7dHlwZTpcInBsdXNcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpK1wifSxcIipcIjp7dHlwZTpcInN0YXJcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpKlwifSxcIkBcIjp7dHlwZTpcImF0XCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKVwifX19LGdsb2JDaGFycyhlKXtyZXR1cm4gZT09PXRydWU/eDpkfX19LDc1NDooZSx0LHIpPT57Y29uc3Qgbj1yKDM1Nik7Y29uc3QgdT1yKDUxMyk7Y29uc3R7TUFYX0xFTkdUSDpzLFBPU0lYX1JFR0VYX1NPVVJDRTpvLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOmksUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOmEsUkVQTEFDRU1FTlRTOmx9PW47Y29uc3QgZXhwYW5kUmFuZ2U9KGUsdCk9PntpZih0eXBlb2YgdC5leHBhbmRSYW5nZT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIHQuZXhwYW5kUmFuZ2UoLi4uZSx0KX1lLnNvcnQoKTtjb25zdCByPWBbJHtlLmpvaW4oXCItXCIpfV1gO3RyeXtuZXcgUmVnRXhwKHIpfWNhdGNoKHQpe3JldHVybiBlLm1hcCgoZT0+dS5lc2NhcGVSZWdleChlKSkpLmpvaW4oXCIuLlwiKX1yZXR1cm4gcn07Y29uc3Qgc3ludGF4RXJyb3I9KGUsdCk9PmBNaXNzaW5nICR7ZX06IFwiJHt0fVwiIC0gdXNlIFwiXFxcXFxcXFwke3R9XCIgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzYDtjb25zdCBwYXJzZT0oZSx0KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfWU9bFtlXXx8ZTtjb25zdCByPXsuLi50fTtjb25zdCBjPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyxyLm1heExlbmd0aCk6cztsZXQgcD1lLmxlbmd0aDtpZihwPmMpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke3B9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7Y31gKX1jb25zdCBmPXt0eXBlOlwiYm9zXCIsdmFsdWU6XCJcIixvdXRwdXQ6ci5wcmVwZW5kfHxcIlwifTtjb25zdCBBPVtmXTtjb25zdCBSPXIuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCBfPXUuaXNXaW5kb3dzKHQpO2NvbnN0IGg9bi5nbG9iQ2hhcnMoXyk7Y29uc3QgZz1uLmV4dGdsb2JDaGFycyhoKTtjb25zdHtET1RfTElURVJBTDpFLFBMVVNfTElURVJBTDpDLFNMQVNIX0xJVEVSQUw6eSxPTkVfQ0hBUjpkLERPVFNfU0xBU0g6eCxOT19ET1Q6YixOT19ET1RfU0xBU0g6UyxOT19ET1RTX1NMQVNIOkgsUU1BUks6dixRTUFSS19OT19ET1Q6JCxTVEFSOm0sU1RBUlRfQU5DSE9SOlR9PWg7Y29uc3QgZ2xvYnN0YXI9ZT0+YCgke1J9KD86KD8hJHtUfSR7ZS5kb3Q/eDpFfSkuKSo/KWA7Y29uc3QgTD1yLmRvdD9cIlwiOmI7Y29uc3QgTz1yLmRvdD92OiQ7bGV0IHc9ci5iYXNoPT09dHJ1ZT9nbG9ic3RhcihyKTptO2lmKHIuY2FwdHVyZSl7dz1gKCR7d30pYH1pZih0eXBlb2Ygci5ub2V4dD09PVwiYm9vbGVhblwiKXtyLm5vZXh0Z2xvYj1yLm5vZXh0fWNvbnN0IE49e2lucHV0OmUsaW5kZXg6LTEsc3RhcnQ6MCxkb3Q6ci5kb3Q9PT10cnVlLGNvbnN1bWVkOlwiXCIsb3V0cHV0OlwiXCIscHJlZml4OlwiXCIsYmFja3RyYWNrOmZhbHNlLG5lZ2F0ZWQ6ZmFsc2UsYnJhY2tldHM6MCxicmFjZXM6MCxwYXJlbnM6MCxxdW90ZXM6MCxnbG9ic3RhcjpmYWxzZSx0b2tlbnM6QX07ZT11LnJlbW92ZVByZWZpeChlLE4pO3A9ZS5sZW5ndGg7Y29uc3Qgaz1bXTtjb25zdCBJPVtdO2NvbnN0IE09W107bGV0IFA9ZjtsZXQgQjtjb25zdCBlb3M9KCk9Pk4uaW5kZXg9PT1wLTE7Y29uc3QgRz1OLnBlZWs9KHQ9MSk9PmVbTi5pbmRleCt0XTtjb25zdCBEPU4uYWR2YW5jZT0oKT0+ZVsrK04uaW5kZXhdO2NvbnN0IHJlbWFpbmluZz0oKT0+ZS5zbGljZShOLmluZGV4KzEpO2NvbnN0IGNvbnN1bWU9KGU9XCJcIix0PTApPT57Ti5jb25zdW1lZCs9ZTtOLmluZGV4Kz10fTtjb25zdCBhcHBlbmQ9ZT0+e04ub3V0cHV0Kz1lLm91dHB1dCE9bnVsbD9lLm91dHB1dDplLnZhbHVlO2NvbnN1bWUoZS52YWx1ZSl9O2NvbnN0IG5lZ2F0ZT0oKT0+e2xldCBlPTE7d2hpbGUoRygpPT09XCIhXCImJihHKDIpIT09XCIoXCJ8fEcoMyk9PT1cIj9cIikpe0QoKTtOLnN0YXJ0Kys7ZSsrfWlmKGUlMj09PTApe3JldHVybiBmYWxzZX1OLm5lZ2F0ZWQ9dHJ1ZTtOLnN0YXJ0Kys7cmV0dXJuIHRydWV9O2NvbnN0IGluY3JlbWVudD1lPT57TltlXSsrO00ucHVzaChlKX07Y29uc3QgZGVjcmVtZW50PWU9PntOW2VdLS07TS5wb3AoKX07Y29uc3QgcHVzaD1lPT57aWYoUC50eXBlPT09XCJnbG9ic3RhclwiKXtjb25zdCB0PU4uYnJhY2VzPjAmJihlLnR5cGU9PT1cImNvbW1hXCJ8fGUudHlwZT09PVwiYnJhY2VcIik7Y29uc3Qgcj1lLmV4dGdsb2I9PT10cnVlfHxrLmxlbmd0aCYmKGUudHlwZT09PVwicGlwZVwifHxlLnR5cGU9PT1cInBhcmVuXCIpO2lmKGUudHlwZSE9PVwic2xhc2hcIiYmZS50eXBlIT09XCJwYXJlblwiJiYhdCYmIXIpe04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLVAub3V0cHV0Lmxlbmd0aCk7UC50eXBlPVwic3RhclwiO1AudmFsdWU9XCIqXCI7UC5vdXRwdXQ9dztOLm91dHB1dCs9UC5vdXRwdXR9fWlmKGsubGVuZ3RoJiZlLnR5cGUhPT1cInBhcmVuXCImJiFnW2UudmFsdWVdKXtrW2subGVuZ3RoLTFdLmlubmVyKz1lLnZhbHVlfWlmKGUudmFsdWV8fGUub3V0cHV0KWFwcGVuZChlKTtpZihQJiZQLnR5cGU9PT1cInRleHRcIiYmZS50eXBlPT09XCJ0ZXh0XCIpe1AudmFsdWUrPWUudmFsdWU7UC5vdXRwdXQ9KFAub3V0cHV0fHxcIlwiKStlLnZhbHVlO3JldHVybn1lLnByZXY9UDtBLnB1c2goZSk7UD1lfTtjb25zdCBleHRnbG9iT3Blbj0oZSx0KT0+e2NvbnN0IG49ey4uLmdbdF0sY29uZGl0aW9uczoxLGlubmVyOlwiXCJ9O24ucHJldj1QO24ucGFyZW5zPU4ucGFyZW5zO24ub3V0cHV0PU4ub3V0cHV0O2NvbnN0IHU9KHIuY2FwdHVyZT9cIihcIjpcIlwiKStuLm9wZW47aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6ZSx2YWx1ZTp0LG91dHB1dDpOLm91dHB1dD9cIlwiOmR9KTtwdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6RCgpLG91dHB1dDp1fSk7ay5wdXNoKG4pfTtjb25zdCBleHRnbG9iQ2xvc2U9ZT0+e2xldCB0PWUuY2xvc2UrKHIuY2FwdHVyZT9cIilcIjpcIlwiKTtpZihlLnR5cGU9PT1cIm5lZ2F0ZVwiKXtsZXQgbj13O2lmKGUuaW5uZXImJmUuaW5uZXIubGVuZ3RoPjEmJmUuaW5uZXIuaW5jbHVkZXMoXCIvXCIpKXtuPWdsb2JzdGFyKHIpfWlmKG4hPT13fHxlb3MoKXx8L15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpe3Q9ZS5jbG9zZT1gKSQpKSR7bn1gfWlmKGUucHJldi50eXBlPT09XCJib3NcIil7Ti5uZWdhdGVkRXh0Z2xvYj10cnVlfX1wdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6QixvdXRwdXQ6dH0pO2RlY3JlbWVudChcInBhcmVuc1wiKX07aWYoci5mYXN0cGF0aHMhPT1mYWxzZSYmIS8oXlsqIV18Wy8oKVtcXF17fVwiXSkvLnRlc3QoZSkpe2xldCBuPWZhbHNlO2xldCBzPWUucmVwbGFjZShhLCgoZSx0LHIsdSxzLG8pPT57aWYodT09PVwiXFxcXFwiKXtuPXRydWU7cmV0dXJuIGV9aWYodT09PVwiP1wiKXtpZih0KXtyZXR1cm4gdCt1KyhzP3YucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1pZihvPT09MCl7cmV0dXJuIE8rKHM/di5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfXJldHVybiB2LnJlcGVhdChyLmxlbmd0aCl9aWYodT09PVwiLlwiKXtyZXR1cm4gRS5yZXBlYXQoci5sZW5ndGgpfWlmKHU9PT1cIipcIil7aWYodCl7cmV0dXJuIHQrdSsocz93OlwiXCIpfXJldHVybiB3fXJldHVybiB0P2U6YFxcXFwke2V9YH0pKTtpZihuPT09dHJ1ZSl7aWYoci51bmVzY2FwZT09PXRydWUpe3M9cy5yZXBsYWNlKC9cXFxcL2csXCJcIil9ZWxzZXtzPXMucmVwbGFjZSgvXFxcXCsvZywoZT0+ZS5sZW5ndGglMj09PTA/XCJcXFxcXFxcXFwiOmU/XCJcXFxcXCI6XCJcIikpfX1pZihzPT09ZSYmci5jb250YWlucz09PXRydWUpe04ub3V0cHV0PWU7cmV0dXJuIE59Ti5vdXRwdXQ9dS53cmFwT3V0cHV0KHMsTix0KTtyZXR1cm4gTn13aGlsZSghZW9zKCkpe0I9RCgpO2lmKEI9PT1cIlxcMFwiKXtjb250aW51ZX1pZihCPT09XCJcXFxcXCIpe2NvbnN0IGU9RygpO2lmKGU9PT1cIi9cIiYmci5iYXNoIT09dHJ1ZSl7Y29udGludWV9aWYoZT09PVwiLlwifHxlPT09XCI7XCIpe2NvbnRpbnVlfWlmKCFlKXtCKz1cIlxcXFxcIjtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX1jb25zdCB0PS9eXFxcXCsvLmV4ZWMocmVtYWluaW5nKCkpO2xldCBuPTA7aWYodCYmdFswXS5sZW5ndGg+Mil7bj10WzBdLmxlbmd0aDtOLmluZGV4Kz1uO2lmKG4lMiE9PTApe0IrPVwiXFxcXFwifX1pZihyLnVuZXNjYXBlPT09dHJ1ZSl7Qj1EKCl8fFwiXCJ9ZWxzZXtCKz1EKCl8fFwiXCJ9aWYoTi5icmFja2V0cz09PTApe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfX1pZihOLmJyYWNrZXRzPjAmJihCIT09XCJdXCJ8fFAudmFsdWU9PT1cIltcInx8UC52YWx1ZT09PVwiW15cIikpe2lmKHIucG9zaXghPT1mYWxzZSYmQj09PVwiOlwiKXtjb25zdCBlPVAudmFsdWUuc2xpY2UoMSk7aWYoZS5pbmNsdWRlcyhcIltcIikpe1AucG9zaXg9dHJ1ZTtpZihlLmluY2x1ZGVzKFwiOlwiKSl7Y29uc3QgZT1QLnZhbHVlLmxhc3RJbmRleE9mKFwiW1wiKTtjb25zdCB0PVAudmFsdWUuc2xpY2UoMCxlKTtjb25zdCByPVAudmFsdWUuc2xpY2UoZSsyKTtjb25zdCBuPW9bcl07aWYobil7UC52YWx1ZT10K247Ti5iYWNrdHJhY2s9dHJ1ZTtEKCk7aWYoIWYub3V0cHV0JiZBLmluZGV4T2YoUCk9PT0xKXtmLm91dHB1dD1kfWNvbnRpbnVlfX19fWlmKEI9PT1cIltcIiYmRygpIT09XCI6XCJ8fEI9PT1cIi1cIiYmRygpPT09XCJdXCIpe0I9YFxcXFwke0J9YH1pZihCPT09XCJdXCImJihQLnZhbHVlPT09XCJbXCJ8fFAudmFsdWU9PT1cIlteXCIpKXtCPWBcXFxcJHtCfWB9aWYoci5wb3NpeD09PXRydWUmJkI9PT1cIiFcIiYmUC52YWx1ZT09PVwiW1wiKXtCPVwiXlwifVAudmFsdWUrPUI7YXBwZW5kKHt2YWx1ZTpCfSk7Y29udGludWV9aWYoTi5xdW90ZXM9PT0xJiZCIT09J1wiJyl7Qj11LmVzY2FwZVJlZ2V4KEIpO1AudmFsdWUrPUI7YXBwZW5kKHt2YWx1ZTpCfSk7Y29udGludWV9aWYoQj09PSdcIicpe04ucXVvdGVzPU4ucXVvdGVzPT09MT8wOjE7aWYoci5rZWVwUXVvdGVzPT09dHJ1ZSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSl9Y29udGludWV9aWYoQj09PVwiKFwiKXtpbmNyZW1lbnQoXCJwYXJlbnNcIik7cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIilcIil7aWYoTi5wYXJlbnM9PT0wJiZyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl7dGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwib3BlbmluZ1wiLFwiKFwiKSl9Y29uc3QgZT1rW2subGVuZ3RoLTFdO2lmKGUmJk4ucGFyZW5zPT09ZS5wYXJlbnMrMSl7ZXh0Z2xvYkNsb3NlKGsucG9wKCkpO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkIsb3V0cHV0Ok4ucGFyZW5zP1wiKVwiOlwiXFxcXClcIn0pO2RlY3JlbWVudChcInBhcmVuc1wiKTtjb250aW51ZX1pZihCPT09XCJbXCIpe2lmKHIubm9icmFja2V0PT09dHJ1ZXx8IXJlbWFpbmluZygpLmluY2x1ZGVzKFwiXVwiKSl7aWYoci5ub2JyYWNrZXQhPT10cnVlJiZyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl7dGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSl9Qj1gXFxcXCR7Qn1gfWVsc2V7aW5jcmVtZW50KFwiYnJhY2tldHNcIil9cHVzaCh7dHlwZTpcImJyYWNrZXRcIix2YWx1ZTpCfSk7Y29udGludWV9aWYoQj09PVwiXVwiKXtpZihyLm5vYnJhY2tldD09PXRydWV8fFAmJlAudHlwZT09PVwiYnJhY2tldFwiJiZQLnZhbHVlLmxlbmd0aD09PTEpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6YFxcXFwke0J9YH0pO2NvbnRpbnVlfWlmKE4uYnJhY2tldHM9PT0wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl7dGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwib3BlbmluZ1wiLFwiW1wiKSl9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDpgXFxcXCR7Qn1gfSk7Y29udGludWV9ZGVjcmVtZW50KFwiYnJhY2tldHNcIik7Y29uc3QgZT1QLnZhbHVlLnNsaWNlKDEpO2lmKFAucG9zaXghPT10cnVlJiZlWzBdPT09XCJeXCImJiFlLmluY2x1ZGVzKFwiL1wiKSl7Qj1gLyR7Qn1gfVAudmFsdWUrPUI7YXBwZW5kKHt2YWx1ZTpCfSk7aWYoci5saXRlcmFsQnJhY2tldHM9PT1mYWxzZXx8dS5oYXNSZWdleENoYXJzKGUpKXtjb250aW51ZX1jb25zdCB0PXUuZXNjYXBlUmVnZXgoUC52YWx1ZSk7Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtUC52YWx1ZS5sZW5ndGgpO2lmKHIubGl0ZXJhbEJyYWNrZXRzPT09dHJ1ZSl7Ti5vdXRwdXQrPXQ7UC52YWx1ZT10O2NvbnRpbnVlfVAudmFsdWU9YCgke1J9JHt0fXwke1AudmFsdWV9KWA7Ti5vdXRwdXQrPVAudmFsdWU7Y29udGludWV9aWYoQj09PVwie1wiJiZyLm5vYnJhY2UhPT10cnVlKXtpbmNyZW1lbnQoXCJicmFjZXNcIik7Y29uc3QgZT17dHlwZTpcImJyYWNlXCIsdmFsdWU6QixvdXRwdXQ6XCIoXCIsb3V0cHV0SW5kZXg6Ti5vdXRwdXQubGVuZ3RoLHRva2Vuc0luZGV4Ok4udG9rZW5zLmxlbmd0aH07SS5wdXNoKGUpO3B1c2goZSk7Y29udGludWV9aWYoQj09PVwifVwiKXtjb25zdCBlPUlbSS5sZW5ndGgtMV07aWYoci5ub2JyYWNlPT09dHJ1ZXx8IWUpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6Qn0pO2NvbnRpbnVlfWxldCB0PVwiKVwiO2lmKGUuZG90cz09PXRydWUpe2NvbnN0IGU9QS5zbGljZSgpO2NvbnN0IG49W107Zm9yKGxldCB0PWUubGVuZ3RoLTE7dD49MDt0LS0pe0EucG9wKCk7aWYoZVt0XS50eXBlPT09XCJicmFjZVwiKXticmVha31pZihlW3RdLnR5cGUhPT1cImRvdHNcIil7bi51bnNoaWZ0KGVbdF0udmFsdWUpfX10PWV4cGFuZFJhbmdlKG4scik7Ti5iYWNrdHJhY2s9dHJ1ZX1pZihlLmNvbW1hIT09dHJ1ZSYmZS5kb3RzIT09dHJ1ZSl7Y29uc3Qgcj1OLm91dHB1dC5zbGljZSgwLGUub3V0cHV0SW5kZXgpO2NvbnN0IG49Ti50b2tlbnMuc2xpY2UoZS50b2tlbnNJbmRleCk7ZS52YWx1ZT1lLm91dHB1dD1cIlxcXFx7XCI7Qj10PVwiXFxcXH1cIjtOLm91dHB1dD1yO2Zvcihjb25zdCBlIG9mIG4pe04ub3V0cHV0Kz1lLm91dHB1dHx8ZS52YWx1ZX19cHVzaCh7dHlwZTpcImJyYWNlXCIsdmFsdWU6QixvdXRwdXQ6dH0pO2RlY3JlbWVudChcImJyYWNlc1wiKTtJLnBvcCgpO2NvbnRpbnVlfWlmKEI9PT1cInxcIil7aWYoay5sZW5ndGg+MCl7a1trLmxlbmd0aC0xXS5jb25kaXRpb25zKyt9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9aWYoQj09PVwiLFwiKXtsZXQgZT1CO2NvbnN0IHQ9SVtJLmxlbmd0aC0xXTtpZih0JiZNW00ubGVuZ3RoLTFdPT09XCJicmFjZXNcIil7dC5jb21tYT10cnVlO2U9XCJ8XCJ9cHVzaCh7dHlwZTpcImNvbW1hXCIsdmFsdWU6QixvdXRwdXQ6ZX0pO2NvbnRpbnVlfWlmKEI9PT1cIi9cIil7aWYoUC50eXBlPT09XCJkb3RcIiYmTi5pbmRleD09PU4uc3RhcnQrMSl7Ti5zdGFydD1OLmluZGV4KzE7Ti5jb25zdW1lZD1cIlwiO04ub3V0cHV0PVwiXCI7QS5wb3AoKTtQPWY7Y29udGludWV9cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6QixvdXRwdXQ6eX0pO2NvbnRpbnVlfWlmKEI9PT1cIi5cIil7aWYoTi5icmFjZXM+MCYmUC50eXBlPT09XCJkb3RcIil7aWYoUC52YWx1ZT09PVwiLlwiKVAub3V0cHV0PUU7Y29uc3QgZT1JW0kubGVuZ3RoLTFdO1AudHlwZT1cImRvdHNcIjtQLm91dHB1dCs9QjtQLnZhbHVlKz1CO2UuZG90cz10cnVlO2NvbnRpbnVlfWlmKE4uYnJhY2VzK04ucGFyZW5zPT09MCYmUC50eXBlIT09XCJib3NcIiYmUC50eXBlIT09XCJzbGFzaFwiKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OkV9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6QixvdXRwdXQ6RX0pO2NvbnRpbnVlfWlmKEI9PT1cIj9cIil7Y29uc3QgZT1QJiZQLnZhbHVlPT09XCIoXCI7aWYoIWUmJnIubm9leHRnbG9iIT09dHJ1ZSYmRygpPT09XCIoXCImJkcoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJxbWFya1wiLEIpO2NvbnRpbnVlfWlmKFAmJlAudHlwZT09PVwicGFyZW5cIil7Y29uc3QgZT1HKCk7bGV0IHQ9QjtpZihlPT09XCI8XCImJiF1LnN1cHBvcnRzTG9va2JlaGluZHMoKSl7dGhyb3cgbmV3IEVycm9yKFwiTm9kZS5qcyB2MTAgb3IgaGlnaGVyIGlzIHJlcXVpcmVkIGZvciByZWdleCBsb29rYmVoaW5kc1wiKX1pZihQLnZhbHVlPT09XCIoXCImJiEvWyE9PDpdLy50ZXN0KGUpfHxlPT09XCI8XCImJiEvPChbIT1dfFxcdys+KS8udGVzdChyZW1haW5pbmcoKSkpe3Q9YFxcXFwke0J9YH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OnR9KTtjb250aW51ZX1pZihyLmRvdCE9PXRydWUmJihQLnR5cGU9PT1cInNsYXNoXCJ8fFAudHlwZT09PVwiYm9zXCIpKXtwdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpCLG91dHB1dDokfSk7Y29udGludWV9cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6QixvdXRwdXQ6dn0pO2NvbnRpbnVlfWlmKEI9PT1cIiFcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIil7aWYoRygyKSE9PVwiP1wifHwhL1shPTw6XS8udGVzdChHKDMpKSl7ZXh0Z2xvYk9wZW4oXCJuZWdhdGVcIixCKTtjb250aW51ZX19aWYoci5ub25lZ2F0ZSE9PXRydWUmJk4uaW5kZXg9PT0wKXtuZWdhdGUoKTtjb250aW51ZX19aWYoQj09PVwiK1wiKXtpZihyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiJiZHKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicGx1c1wiLEIpO2NvbnRpbnVlfWlmKFAmJlAudmFsdWU9PT1cIihcInx8ci5yZWdleD09PWZhbHNlKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkIsb3V0cHV0OkN9KTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJicmFja2V0XCJ8fFAudHlwZT09PVwicGFyZW5cInx8UC50eXBlPT09XCJicmFjZVwiKXx8Ti5wYXJlbnM+MCl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpCfSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpDfSk7Y29udGludWV9aWYoQj09PVwiQFwiKXtpZihyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiJiZHKDIpIT09XCI/XCIpe3B1c2goe3R5cGU6XCJhdFwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpCLG91dHB1dDpcIlwifSk7Y29udGludWV9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9aWYoQiE9PVwiKlwiKXtpZihCPT09XCIkXCJ8fEI9PT1cIl5cIil7Qj1gXFxcXCR7Qn1gfWNvbnN0IGU9aS5leGVjKHJlbWFpbmluZygpKTtpZihlKXtCKz1lWzBdO04uaW5kZXgrPWVbMF0ubGVuZ3RofXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKFAmJihQLnR5cGU9PT1cImdsb2JzdGFyXCJ8fFAuc3Rhcj09PXRydWUpKXtQLnR5cGU9XCJzdGFyXCI7UC5zdGFyPXRydWU7UC52YWx1ZSs9QjtQLm91dHB1dD13O04uYmFja3RyYWNrPXRydWU7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQik7Y29udGludWV9bGV0IHQ9cmVtYWluaW5nKCk7aWYoci5ub2V4dGdsb2IhPT10cnVlJiYvXlxcKFteP10vLnRlc3QodCkpe2V4dGdsb2JPcGVuKFwic3RhclwiLEIpO2NvbnRpbnVlfWlmKFAudHlwZT09PVwic3RhclwiKXtpZihyLm5vZ2xvYnN0YXI9PT10cnVlKXtjb25zdW1lKEIpO2NvbnRpbnVlfWNvbnN0IG49UC5wcmV2O2NvbnN0IHU9bi5wcmV2O2NvbnN0IHM9bi50eXBlPT09XCJzbGFzaFwifHxuLnR5cGU9PT1cImJvc1wiO2NvbnN0IG89dSYmKHUudHlwZT09PVwic3RhclwifHx1LnR5cGU9PT1cImdsb2JzdGFyXCIpO2lmKHIuYmFzaD09PXRydWUmJighc3x8dFswXSYmdFswXSE9PVwiL1wiKSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpCLG91dHB1dDpcIlwifSk7Y29udGludWV9Y29uc3QgaT1OLmJyYWNlcz4wJiYobi50eXBlPT09XCJjb21tYVwifHxuLnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IGE9ay5sZW5ndGgmJihuLnR5cGU9PT1cInBpcGVcInx8bi50eXBlPT09XCJwYXJlblwiKTtpZighcyYmbi50eXBlIT09XCJwYXJlblwiJiYhaSYmIWEpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXdoaWxlKHQuc2xpY2UoMCwzKT09PVwiLyoqXCIpe2NvbnN0IHI9ZVtOLmluZGV4KzRdO2lmKHImJnIhPT1cIi9cIil7YnJlYWt9dD10LnNsaWNlKDMpO2NvbnN1bWUoXCIvKipcIiwzKX1pZihuLnR5cGU9PT1cImJvc1wiJiZlb3MoKSl7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLnZhbHVlKz1CO1Aub3V0cHV0PWdsb2JzdGFyKHIpO04ub3V0cHV0PVAub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiYhbyYmZW9zKCkpe04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtQLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO1AudHlwZT1cImdsb2JzdGFyXCI7UC5vdXRwdXQ9Z2xvYnN0YXIocikrKHIuc3RyaWN0U2xhc2hlcz9cIilcIjpcInwkKVwiKTtQLnZhbHVlKz1CO04uZ2xvYnN0YXI9dHJ1ZTtOLm91dHB1dCs9bi5vdXRwdXQrUC5vdXRwdXQ7Y29uc3VtZShCKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmdFswXT09PVwiL1wiKXtjb25zdCBlPXRbMV0hPT12b2lkIDA/XCJ8JFwiOlwiXCI7Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K1Aub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLm91dHB1dD1gJHtnbG9ic3RhcihyKX0ke3l9fCR7eX0ke2V9KWA7UC52YWx1ZSs9QjtOLm91dHB1dCs9bi5vdXRwdXQrUC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQitEKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9aWYobi50eXBlPT09XCJib3NcIiYmdFswXT09PVwiL1wiKXtQLnR5cGU9XCJnbG9ic3RhclwiO1AudmFsdWUrPUI7UC5vdXRwdXQ9YCg/Ol58JHt5fXwke2dsb2JzdGFyKHIpfSR7eX0pYDtOLm91dHB1dD1QLm91dHB1dDtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCK0QoKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1OLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC1QLm91dHB1dC5sZW5ndGgpO1AudHlwZT1cImdsb2JzdGFyXCI7UC5vdXRwdXQ9Z2xvYnN0YXIocik7UC52YWx1ZSs9QjtOLm91dHB1dCs9UC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQik7Y29udGludWV9Y29uc3Qgbj17dHlwZTpcInN0YXJcIix2YWx1ZTpCLG91dHB1dDp3fTtpZihyLmJhc2g9PT10cnVlKXtuLm91dHB1dD1cIi4qP1wiO2lmKFAudHlwZT09PVwiYm9zXCJ8fFAudHlwZT09PVwic2xhc2hcIil7bi5vdXRwdXQ9TCtuLm91dHB1dH1wdXNoKG4pO2NvbnRpbnVlfWlmKFAmJihQLnR5cGU9PT1cImJyYWNrZXRcInx8UC50eXBlPT09XCJwYXJlblwiKSYmci5yZWdleD09PXRydWUpe24ub3V0cHV0PUI7cHVzaChuKTtjb250aW51ZX1pZihOLmluZGV4PT09Ti5zdGFydHx8UC50eXBlPT09XCJzbGFzaFwifHxQLnR5cGU9PT1cImRvdFwiKXtpZihQLnR5cGU9PT1cImRvdFwiKXtOLm91dHB1dCs9UztQLm91dHB1dCs9U31lbHNlIGlmKHIuZG90PT09dHJ1ZSl7Ti5vdXRwdXQrPUg7UC5vdXRwdXQrPUh9ZWxzZXtOLm91dHB1dCs9TDtQLm91dHB1dCs9TH1pZihHKCkhPT1cIipcIil7Ti5vdXRwdXQrPWQ7UC5vdXRwdXQrPWR9fXB1c2gobil9d2hpbGUoTi5icmFja2V0cz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCJbXCIpO2RlY3JlbWVudChcImJyYWNrZXRzXCIpfXdoaWxlKE4ucGFyZW5zPjApe2lmKHIuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIilcIikpO04ub3V0cHV0PXUuZXNjYXBlTGFzdChOLm91dHB1dCxcIihcIik7ZGVjcmVtZW50KFwicGFyZW5zXCIpfXdoaWxlKE4uYnJhY2VzPjApe2lmKHIuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIn1cIikpO04ub3V0cHV0PXUuZXNjYXBlTGFzdChOLm91dHB1dCxcIntcIik7ZGVjcmVtZW50KFwiYnJhY2VzXCIpfWlmKHIuc3RyaWN0U2xhc2hlcyE9PXRydWUmJihQLnR5cGU9PT1cInN0YXJcInx8UC50eXBlPT09XCJicmFja2V0XCIpKXtwdXNoKHt0eXBlOlwibWF5YmVfc2xhc2hcIix2YWx1ZTpcIlwiLG91dHB1dDpgJHt5fT9gfSl9aWYoTi5iYWNrdHJhY2s9PT10cnVlKXtOLm91dHB1dD1cIlwiO2Zvcihjb25zdCBlIG9mIE4udG9rZW5zKXtOLm91dHB1dCs9ZS5vdXRwdXQhPW51bGw/ZS5vdXRwdXQ6ZS52YWx1ZTtpZihlLnN1ZmZpeCl7Ti5vdXRwdXQrPWUuc3VmZml4fX19cmV0dXJuIE59O3BhcnNlLmZhc3RwYXRocz0oZSx0KT0+e2NvbnN0IHI9ey4uLnR9O2NvbnN0IG89dHlwZW9mIHIubWF4TGVuZ3RoPT09XCJudW1iZXJcIj9NYXRoLm1pbihzLHIubWF4TGVuZ3RoKTpzO2NvbnN0IGk9ZS5sZW5ndGg7aWYoaT5vKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtpfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke299YCl9ZT1sW2VdfHxlO2NvbnN0IGE9dS5pc1dpbmRvd3ModCk7Y29uc3R7RE9UX0xJVEVSQUw6YyxTTEFTSF9MSVRFUkFMOnAsT05FX0NIQVI6ZixET1RTX1NMQVNIOkEsTk9fRE9UOlIsTk9fRE9UUzpfLE5PX0RPVFNfU0xBU0g6aCxTVEFSOmcsU1RBUlRfQU5DSE9SOkV9PW4uZ2xvYkNoYXJzKGEpO2NvbnN0IEM9ci5kb3Q/XzpSO2NvbnN0IHk9ci5kb3Q/aDpSO2NvbnN0IGQ9ci5jYXB0dXJlP1wiXCI6XCI/OlwiO2NvbnN0IHg9e25lZ2F0ZWQ6ZmFsc2UscHJlZml4OlwiXCJ9O2xldCBiPXIuYmFzaD09PXRydWU/XCIuKj9cIjpnO2lmKHIuY2FwdHVyZSl7Yj1gKCR7Yn0pYH1jb25zdCBnbG9ic3Rhcj1lPT57aWYoZS5ub2dsb2JzdGFyPT09dHJ1ZSlyZXR1cm4gYjtyZXR1cm5gKCR7ZH0oPzooPyEke0V9JHtlLmRvdD9BOmN9KS4pKj8pYH07Y29uc3QgY3JlYXRlPWU9Pntzd2l0Y2goZSl7Y2FzZVwiKlwiOnJldHVybmAke0N9JHtmfSR7Yn1gO2Nhc2VcIi4qXCI6cmV0dXJuYCR7Y30ke2Z9JHtifWA7Y2FzZVwiKi4qXCI6cmV0dXJuYCR7Q30ke2J9JHtjfSR7Zn0ke2J9YDtjYXNlXCIqLypcIjpyZXR1cm5gJHtDfSR7Yn0ke3B9JHtmfSR7eX0ke2J9YDtjYXNlXCIqKlwiOnJldHVybiBDK2dsb2JzdGFyKHIpO2Nhc2VcIioqLypcIjpyZXR1cm5gKD86JHtDfSR7Z2xvYnN0YXIocil9JHtwfSk/JHt5fSR7Zn0ke2J9YDtjYXNlXCIqKi8qLipcIjpyZXR1cm5gKD86JHtDfSR7Z2xvYnN0YXIocil9JHtwfSk/JHt5fSR7Yn0ke2N9JHtmfSR7Yn1gO2Nhc2VcIioqLy4qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7Y30ke2Z9JHtifWA7ZGVmYXVsdDp7Y29uc3QgdD0vXiguKj8pXFwuKFxcdyspJC8uZXhlYyhlKTtpZighdClyZXR1cm47Y29uc3Qgcj1jcmVhdGUodFsxXSk7aWYoIXIpcmV0dXJuO3JldHVybiByK2MrdFsyXX19fTtjb25zdCBTPXUucmVtb3ZlUHJlZml4KGUseCk7bGV0IEg9Y3JlYXRlKFMpO2lmKEgmJnIuc3RyaWN0U2xhc2hlcyE9PXRydWUpe0grPWAke3B9P2B9cmV0dXJuIEh9O2UuZXhwb3J0cz1wYXJzZX0sNjgzOihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9cig3MDApO2NvbnN0IHM9cig3NTQpO2NvbnN0IG89cig1MTMpO2NvbnN0IGk9cigzNTYpO2NvbnN0IGlzT2JqZWN0PWU9PmUmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7Y29uc3QgcGljb21hdGNoPShlLHQscj1mYWxzZSk9PntpZihBcnJheS5pc0FycmF5KGUpKXtjb25zdCBuPWUubWFwKChlPT5waWNvbWF0Y2goZSx0LHIpKSk7Y29uc3QgYXJyYXlNYXRjaGVyPWU9Pntmb3IoY29uc3QgdCBvZiBuKXtjb25zdCByPXQoZSk7aWYocilyZXR1cm4gcn1yZXR1cm4gZmFsc2V9O3JldHVybiBhcnJheU1hdGNoZXJ9Y29uc3Qgbj1pc09iamVjdChlKSYmZS50b2tlbnMmJmUuaW5wdXQ7aWYoZT09PVwiXCJ8fHR5cGVvZiBlIT09XCJzdHJpbmdcIiYmIW4pe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1jb25zdCB1PXR8fHt9O2NvbnN0IHM9by5pc1dpbmRvd3ModCk7Y29uc3QgaT1uP3BpY29tYXRjaC5jb21waWxlUmUoZSx0KTpwaWNvbWF0Y2gubWFrZVJlKGUsdCxmYWxzZSx0cnVlKTtjb25zdCBhPWkuc3RhdGU7ZGVsZXRlIGkuc3RhdGU7bGV0IGlzSWdub3JlZD0oKT0+ZmFsc2U7aWYodS5pZ25vcmUpe2NvbnN0IGU9ey4uLnQsaWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9O2lzSWdub3JlZD1waWNvbWF0Y2godS5pZ25vcmUsZSxyKX1jb25zdCBtYXRjaGVyPShyLG49ZmFsc2UpPT57Y29uc3R7aXNNYXRjaDpvLG1hdGNoOmwsb3V0cHV0OmN9PXBpY29tYXRjaC50ZXN0KHIsaSx0LHtnbG9iOmUscG9zaXg6c30pO2NvbnN0IHA9e2dsb2I6ZSxzdGF0ZTphLHJlZ2V4OmkscG9zaXg6cyxpbnB1dDpyLG91dHB1dDpjLG1hdGNoOmwsaXNNYXRjaDpvfTtpZih0eXBlb2YgdS5vblJlc3VsdD09PVwiZnVuY3Rpb25cIil7dS5vblJlc3VsdChwKX1pZihvPT09ZmFsc2Upe3AuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9wOmZhbHNlfWlmKGlzSWdub3JlZChyKSl7aWYodHlwZW9mIHUub25JZ25vcmU9PT1cImZ1bmN0aW9uXCIpe3Uub25JZ25vcmUocCl9cC5pc01hdGNoPWZhbHNlO3JldHVybiBuP3A6ZmFsc2V9aWYodHlwZW9mIHUub25NYXRjaD09PVwiZnVuY3Rpb25cIil7dS5vbk1hdGNoKHApfXJldHVybiBuP3A6dHJ1ZX07aWYocil7bWF0Y2hlci5zdGF0ZT1hfXJldHVybiBtYXRjaGVyfTtwaWNvbWF0Y2gudGVzdD0oZSx0LHIse2dsb2I6bixwb3NpeDp1fT17fSk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZ1wiKX1pZihlPT09XCJcIil7cmV0dXJue2lzTWF0Y2g6ZmFsc2Usb3V0cHV0OlwiXCJ9fWNvbnN0IHM9cnx8e307Y29uc3QgaT1zLmZvcm1hdHx8KHU/by50b1Bvc2l4U2xhc2hlczpudWxsKTtsZXQgYT1lPT09bjtsZXQgbD1hJiZpP2koZSk6ZTtpZihhPT09ZmFsc2Upe2w9aT9pKGUpOmU7YT1sPT09bn1pZihhPT09ZmFsc2V8fHMuY2FwdHVyZT09PXRydWUpe2lmKHMubWF0Y2hCYXNlPT09dHJ1ZXx8cy5iYXNlbmFtZT09PXRydWUpe2E9cGljb21hdGNoLm1hdGNoQmFzZShlLHQscix1KX1lbHNle2E9dC5leGVjKGwpfX1yZXR1cm57aXNNYXRjaDpCb29sZWFuKGEpLG1hdGNoOmEsb3V0cHV0Omx9fTtwaWNvbWF0Y2gubWF0Y2hCYXNlPShlLHQscix1PW8uaXNXaW5kb3dzKHIpKT0+e2NvbnN0IHM9dCBpbnN0YW5jZW9mIFJlZ0V4cD90OnBpY29tYXRjaC5tYWtlUmUodCxyKTtyZXR1cm4gcy50ZXN0KG4uYmFzZW5hbWUoZSkpfTtwaWNvbWF0Y2guaXNNYXRjaD0oZSx0LHIpPT5waWNvbWF0Y2godCxyKShlKTtwaWNvbWF0Y2gucGFyc2U9KGUsdCk9PntpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlLm1hcCgoZT0+cGljb21hdGNoLnBhcnNlKGUsdCkpKTtyZXR1cm4gcyhlLHsuLi50LGZhc3RwYXRoczpmYWxzZX0pfTtwaWNvbWF0Y2guc2Nhbj0oZSx0KT0+dShlLHQpO3BpY29tYXRjaC5jb21waWxlUmU9KGUsdCxyPWZhbHNlLG49ZmFsc2UpPT57aWYocj09PXRydWUpe3JldHVybiBlLm91dHB1dH1jb25zdCB1PXR8fHt9O2NvbnN0IHM9dS5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IG89dS5jb250YWlucz9cIlwiOlwiJFwiO2xldCBpPWAke3N9KD86JHtlLm91dHB1dH0pJHtvfWA7aWYoZSYmZS5uZWdhdGVkPT09dHJ1ZSl7aT1gXig/ISR7aX0pLiokYH1jb25zdCBhPXBpY29tYXRjaC50b1JlZ2V4KGksdCk7aWYobj09PXRydWUpe2Euc3RhdGU9ZX1yZXR1cm4gYX07cGljb21hdGNoLm1ha2VSZT0oZSx0LHI9ZmFsc2Usbj1mYWxzZSk9PntpZighZXx8dHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IHU9dHx8e307bGV0IG89e25lZ2F0ZWQ6ZmFsc2UsZmFzdHBhdGhzOnRydWV9O2xldCBpPVwiXCI7bGV0IGE7aWYoZS5zdGFydHNXaXRoKFwiLi9cIikpe2U9ZS5zbGljZSgyKTtpPW8ucHJlZml4PVwiLi9cIn1pZih1LmZhc3RwYXRocyE9PWZhbHNlJiYoZVswXT09PVwiLlwifHxlWzBdPT09XCIqXCIpKXthPXMuZmFzdHBhdGhzKGUsdCl9aWYoYT09PXVuZGVmaW5lZCl7bz1zKGUsdCk7by5wcmVmaXg9aSsoby5wcmVmaXh8fFwiXCIpfWVsc2V7by5vdXRwdXQ9YX1yZXR1cm4gcGljb21hdGNoLmNvbXBpbGVSZShvLHQscixuKX07cGljb21hdGNoLnRvUmVnZXg9KGUsdCk9Pnt0cnl7Y29uc3Qgcj10fHx7fTtyZXR1cm4gbmV3IFJlZ0V4cChlLHIuZmxhZ3N8fChyLm5vY2FzZT9cImlcIjpcIlwiKSl9Y2F0Y2goZSl7aWYodCYmdC5kZWJ1Zz09PXRydWUpdGhyb3cgZTtyZXR1cm4vJF4vfX07cGljb21hdGNoLmNvbnN0YW50cz1pO2UuZXhwb3J0cz1waWNvbWF0Y2h9LDcwMDooZSx0LHIpPT57Y29uc3Qgbj1yKDUxMyk7Y29uc3R7Q0hBUl9BU1RFUklTSzp1LENIQVJfQVQ6cyxDSEFSX0JBQ0tXQVJEX1NMQVNIOm8sQ0hBUl9DT01NQTppLENIQVJfRE9UOmEsQ0hBUl9FWENMQU1BVElPTl9NQVJLOmwsQ0hBUl9GT1JXQVJEX1NMQVNIOmMsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOnAsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOmYsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOkEsQ0hBUl9QTFVTOlIsQ0hBUl9RVUVTVElPTl9NQVJLOl8sQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpoLENIQVJfUklHSFRfUEFSRU5USEVTRVM6ZyxDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOkV9PXIoMzU2KTtjb25zdCBpc1BhdGhTZXBhcmF0b3I9ZT0+ZT09PWN8fGU9PT1vO2NvbnN0IGRlcHRoPWU9PntpZihlLmlzUHJlZml4IT09dHJ1ZSl7ZS5kZXB0aD1lLmlzR2xvYnN0YXI/SW5maW5pdHk6MX19O2NvbnN0IHNjYW49KGUsdCk9Pntjb25zdCByPXR8fHt9O2NvbnN0IEM9ZS5sZW5ndGgtMTtjb25zdCB5PXIucGFydHM9PT10cnVlfHxyLnNjYW5Ub0VuZD09PXRydWU7Y29uc3QgZD1bXTtjb25zdCB4PVtdO2NvbnN0IGI9W107bGV0IFM9ZTtsZXQgSD0tMTtsZXQgdj0wO2xldCAkPTA7bGV0IG09ZmFsc2U7bGV0IFQ9ZmFsc2U7bGV0IEw9ZmFsc2U7bGV0IE89ZmFsc2U7bGV0IHc9ZmFsc2U7bGV0IE49ZmFsc2U7bGV0IGs9ZmFsc2U7bGV0IEk9ZmFsc2U7bGV0IE09ZmFsc2U7bGV0IFA9MDtsZXQgQjtsZXQgRztsZXQgRD17dmFsdWU6XCJcIixkZXB0aDowLGlzR2xvYjpmYWxzZX07Y29uc3QgZW9zPSgpPT5IPj1DO2NvbnN0IHBlZWs9KCk9PlMuY2hhckNvZGVBdChIKzEpO2NvbnN0IGFkdmFuY2U9KCk9PntCPUc7cmV0dXJuIFMuY2hhckNvZGVBdCgrK0gpfTt3aGlsZShIPEMpe0c9YWR2YW5jZSgpO2xldCBlO2lmKEc9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTtHPWFkdmFuY2UoKTtpZihHPT09cCl7Tj10cnVlfWNvbnRpbnVlfWlmKE49PT10cnVlfHxHPT09cCl7UCsrO3doaWxlKGVvcygpIT09dHJ1ZSYmKEc9YWR2YW5jZSgpKSl7aWYoRz09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO2FkdmFuY2UoKTtjb250aW51ZX1pZihHPT09cCl7UCsrO2NvbnRpbnVlfWlmKE4hPT10cnVlJiZHPT09YSYmKEc9YWR2YW5jZSgpKT09PWEpe209RC5pc0JyYWNlPXRydWU7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoTiE9PXRydWUmJkc9PT1pKXttPUQuaXNCcmFjZT10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1oKXtQLS07aWYoUD09PTApe049ZmFsc2U7bT1ELmlzQnJhY2U9dHJ1ZTtNPXRydWU7YnJlYWt9fX1pZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PWMpe2QucHVzaChIKTt4LnB1c2goRCk7RD17dmFsdWU6XCJcIixkZXB0aDowLGlzR2xvYjpmYWxzZX07aWYoTT09PXRydWUpY29udGludWU7aWYoQj09PWEmJkg9PT12KzEpe3YrPTI7Y29udGludWV9JD1IKzE7Y29udGludWV9aWYoci5ub2V4dCE9PXRydWUpe2NvbnN0IGU9Rz09PVJ8fEc9PT1zfHxHPT09dXx8Rz09PV98fEc9PT1sO2lmKGU9PT10cnVlJiZwZWVrKCk9PT1mKXtMPUQuaXNHbG9iPXRydWU7Tz1ELmlzRXh0Z2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoRz1hZHZhbmNlKCkpKXtpZihHPT09byl7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7Y29udGludWV9aWYoRz09PWcpe0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7YnJlYWt9fWNvbnRpbnVlfWJyZWFrfX1pZihHPT09dSl7aWYoQj09PXUpdz1ELmlzR2xvYnN0YXI9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihHPT09Xyl7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PUEpe3doaWxlKGVvcygpIT09dHJ1ZSYmKGU9YWR2YW5jZSgpKSl7aWYoZT09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO2FkdmFuY2UoKTtjb250aW51ZX1pZihlPT09RSl7VD1ELmlzQnJhY2tldD10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7YnJlYWt9fWlmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihyLm5vbmVnYXRlIT09dHJ1ZSYmRz09PWwmJkg9PT12KXtJPUQubmVnYXRlZD10cnVlO3YrKztjb250aW51ZX1pZihyLm5vcGFyZW4hPT10cnVlJiZHPT09Zil7TD1ELmlzR2xvYj10cnVlO2lmKHk9PT10cnVlKXt3aGlsZShlb3MoKSE9PXRydWUmJihHPWFkdmFuY2UoKSkpe2lmKEc9PT1mKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTtHPWFkdmFuY2UoKTtjb250aW51ZX1pZihHPT09Zyl7TT10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha31pZihMPT09dHJ1ZSl7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha319aWYoci5ub2V4dD09PXRydWUpe089ZmFsc2U7TD1mYWxzZX1sZXQgVT1TO2xldCBLPVwiXCI7bGV0IEY9XCJcIjtpZih2PjApe0s9Uy5zbGljZSgwLHYpO1M9Uy5zbGljZSh2KTskLT12fWlmKFUmJkw9PT10cnVlJiYkPjApe1U9Uy5zbGljZSgwLCQpO0Y9Uy5zbGljZSgkKX1lbHNlIGlmKEw9PT10cnVlKXtVPVwiXCI7Rj1TfWVsc2V7VT1TfWlmKFUmJlUhPT1cIlwiJiZVIT09XCIvXCImJlUhPT1TKXtpZihpc1BhdGhTZXBhcmF0b3IoVS5jaGFyQ29kZUF0KFUubGVuZ3RoLTEpKSl7VT1VLnNsaWNlKDAsLTEpfX1pZihyLnVuZXNjYXBlPT09dHJ1ZSl7aWYoRilGPW4ucmVtb3ZlQmFja3NsYXNoZXMoRik7aWYoVSYmaz09PXRydWUpe1U9bi5yZW1vdmVCYWNrc2xhc2hlcyhVKX19Y29uc3QgUT17cHJlZml4OkssaW5wdXQ6ZSxzdGFydDp2LGJhc2U6VSxnbG9iOkYsaXNCcmFjZTptLGlzQnJhY2tldDpULGlzR2xvYjpMLGlzRXh0Z2xvYjpPLGlzR2xvYnN0YXI6dyxuZWdhdGVkOkl9O2lmKHIudG9rZW5zPT09dHJ1ZSl7US5tYXhEZXB0aD0wO2lmKCFpc1BhdGhTZXBhcmF0b3IoRykpe3gucHVzaChEKX1RLnRva2Vucz14fWlmKHIucGFydHM9PT10cnVlfHxyLnRva2Vucz09PXRydWUpe2xldCB0O2ZvcihsZXQgbj0wO248ZC5sZW5ndGg7bisrKXtjb25zdCB1PXQ/dCsxOnY7Y29uc3Qgcz1kW25dO2NvbnN0IG89ZS5zbGljZSh1LHMpO2lmKHIudG9rZW5zKXtpZihuPT09MCYmdiE9PTApe3hbbl0uaXNQcmVmaXg9dHJ1ZTt4W25dLnZhbHVlPUt9ZWxzZXt4W25dLnZhbHVlPW99ZGVwdGgoeFtuXSk7US5tYXhEZXB0aCs9eFtuXS5kZXB0aH1pZihuIT09MHx8byE9PVwiXCIpe2IucHVzaChvKX10PXN9aWYodCYmdCsxPGUubGVuZ3RoKXtjb25zdCBuPWUuc2xpY2UodCsxKTtiLnB1c2gobik7aWYoci50b2tlbnMpe3hbeC5sZW5ndGgtMV0udmFsdWU9bjtkZXB0aCh4W3gubGVuZ3RoLTFdKTtRLm1heERlcHRoKz14W3gubGVuZ3RoLTFdLmRlcHRofX1RLnNsYXNoZXM9ZDtRLnBhcnRzPWJ9cmV0dXJuIFF9O2UuZXhwb3J0cz1zY2FufSw1MTM6KGUsdCxyKT0+e2NvbnN0IG49cigxNyk7Y29uc3QgdT1wcm9jZXNzLnBsYXRmb3JtPT09XCJ3aW4zMlwiO2NvbnN0e1JFR0VYX0JBQ0tTTEFTSDpzLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6byxSRUdFWF9TUEVDSUFMX0NIQVJTOmksUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUw6YX09cigzNTYpO3QuaXNPYmplY3Q9ZT0+ZSE9PW51bGwmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7dC5oYXNSZWdleENoYXJzPWU9PmkudGVzdChlKTt0LmlzUmVnZXhDaGFyPWU9PmUubGVuZ3RoPT09MSYmdC5oYXNSZWdleENoYXJzKGUpO3QuZXNjYXBlUmVnZXg9ZT0+ZS5yZXBsYWNlKGEsXCJcXFxcJDFcIik7dC50b1Bvc2l4U2xhc2hlcz1lPT5lLnJlcGxhY2UocyxcIi9cIik7dC5yZW1vdmVCYWNrc2xhc2hlcz1lPT5lLnJlcGxhY2UobywoZT0+ZT09PVwiXFxcXFwiP1wiXCI6ZSkpO3Quc3VwcG9ydHNMb29rYmVoaW5kcz0oKT0+e2NvbnN0IGU9cHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpLnNwbGl0KFwiLlwiKS5tYXAoTnVtYmVyKTtpZihlLmxlbmd0aD09PTMmJmVbMF0+PTl8fGVbMF09PT04JiZlWzFdPj0xMCl7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfTt0LmlzV2luZG93cz1lPT57aWYoZSYmdHlwZW9mIGUud2luZG93cz09PVwiYm9vbGVhblwiKXtyZXR1cm4gZS53aW5kb3dzfXJldHVybiB1PT09dHJ1ZXx8bi5zZXA9PT1cIlxcXFxcIn07dC5lc2NhcGVMYXN0PShlLHIsbik9Pntjb25zdCB1PWUubGFzdEluZGV4T2YocixuKTtpZih1PT09LTEpcmV0dXJuIGU7aWYoZVt1LTFdPT09XCJcXFxcXCIpcmV0dXJuIHQuZXNjYXBlTGFzdChlLHIsdS0xKTtyZXR1cm5gJHtlLnNsaWNlKDAsdSl9XFxcXCR7ZS5zbGljZSh1KX1gfTt0LnJlbW92ZVByZWZpeD0oZSx0PXt9KT0+e2xldCByPWU7aWYoci5zdGFydHNXaXRoKFwiLi9cIikpe3I9ci5zbGljZSgyKTt0LnByZWZpeD1cIi4vXCJ9cmV0dXJuIHJ9O3Qud3JhcE91dHB1dD0oZSx0PXt9LHI9e30pPT57Y29uc3Qgbj1yLmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3QgdT1yLmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IHM9YCR7bn0oPzoke2V9KSR7dX1gO2lmKHQubmVnYXRlZD09PXRydWUpe3M9YCg/Ol4oPyEke3N9KS4qJClgfXJldHVybiBzfX0sNDkyOihlLHQscik9Pntcbi8qIVxuICogdG8tcmVnZXgtcmFuZ2UgPGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb21hdGNoL3RvLXJlZ2V4LXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3Qgbj1yKDM1Nyk7Y29uc3QgdG9SZWdleFJhbmdlPShlLHQscik9PntpZihuKGUpPT09ZmFsc2Upe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJ0b1JlZ2V4UmFuZ2U6IGV4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhIG51bWJlclwiKX1pZih0PT09dm9pZCAwfHxlPT09dCl7cmV0dXJuIFN0cmluZyhlKX1pZihuKHQpPT09ZmFsc2Upe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJ0b1JlZ2V4UmFuZ2U6IGV4cGVjdGVkIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBudW1iZXIuXCIpfWxldCB1PXtyZWxheFplcm9zOnRydWUsLi4ucn07aWYodHlwZW9mIHUuc3RyaWN0WmVyb3M9PT1cImJvb2xlYW5cIil7dS5yZWxheFplcm9zPXUuc3RyaWN0WmVyb3M9PT1mYWxzZX1sZXQgcz1TdHJpbmcodS5yZWxheFplcm9zKTtsZXQgbz1TdHJpbmcodS5zaG9ydGhhbmQpO2xldCBpPVN0cmluZyh1LmNhcHR1cmUpO2xldCBhPVN0cmluZyh1LndyYXApO2xldCBsPWUrXCI6XCIrdCtcIj1cIitzK28raSthO2lmKHRvUmVnZXhSYW5nZS5jYWNoZS5oYXNPd25Qcm9wZXJ0eShsKSl7cmV0dXJuIHRvUmVnZXhSYW5nZS5jYWNoZVtsXS5yZXN1bHR9bGV0IGM9TWF0aC5taW4oZSx0KTtsZXQgcD1NYXRoLm1heChlLHQpO2lmKE1hdGguYWJzKGMtcCk9PT0xKXtsZXQgcj1lK1wifFwiK3Q7aWYodS5jYXB0dXJlKXtyZXR1cm5gKCR7cn0pYH1pZih1LndyYXA9PT1mYWxzZSl7cmV0dXJuIHJ9cmV0dXJuYCg/OiR7cn0pYH1sZXQgZj1oYXNQYWRkaW5nKGUpfHxoYXNQYWRkaW5nKHQpO2xldCBBPXttaW46ZSxtYXg6dCxhOmMsYjpwfTtsZXQgUj1bXTtsZXQgXz1bXTtpZihmKXtBLmlzUGFkZGVkPWY7QS5tYXhMZW49U3RyaW5nKEEubWF4KS5sZW5ndGh9aWYoYzwwKXtsZXQgZT1wPDA/TWF0aC5hYnMocCk6MTtfPXNwbGl0VG9QYXR0ZXJucyhlLE1hdGguYWJzKGMpLEEsdSk7Yz1BLmE9MH1pZihwPj0wKXtSPXNwbGl0VG9QYXR0ZXJucyhjLHAsQSx1KX1BLm5lZ2F0aXZlcz1fO0EucG9zaXRpdmVzPVI7QS5yZXN1bHQ9Y29sbGF0ZVBhdHRlcm5zKF8sUix1KTtpZih1LmNhcHR1cmU9PT10cnVlKXtBLnJlc3VsdD1gKCR7QS5yZXN1bHR9KWB9ZWxzZSBpZih1LndyYXAhPT1mYWxzZSYmUi5sZW5ndGgrXy5sZW5ndGg+MSl7QS5yZXN1bHQ9YCg/OiR7QS5yZXN1bHR9KWB9dG9SZWdleFJhbmdlLmNhY2hlW2xdPUE7cmV0dXJuIEEucmVzdWx0fTtmdW5jdGlvbiBjb2xsYXRlUGF0dGVybnMoZSx0LHIpe2xldCBuPWZpbHRlclBhdHRlcm5zKGUsdCxcIi1cIixmYWxzZSxyKXx8W107bGV0IHU9ZmlsdGVyUGF0dGVybnModCxlLFwiXCIsZmFsc2Uscil8fFtdO2xldCBzPWZpbHRlclBhdHRlcm5zKGUsdCxcIi0/XCIsdHJ1ZSxyKXx8W107bGV0IG89bi5jb25jYXQocykuY29uY2F0KHUpO3JldHVybiBvLmpvaW4oXCJ8XCIpfWZ1bmN0aW9uIHNwbGl0VG9SYW5nZXMoZSx0KXtsZXQgcj0xO2xldCBuPTE7bGV0IHU9Y291bnROaW5lcyhlLHIpO2xldCBzPW5ldyBTZXQoW3RdKTt3aGlsZShlPD11JiZ1PD10KXtzLmFkZCh1KTtyKz0xO3U9Y291bnROaW5lcyhlLHIpfXU9Y291bnRaZXJvcyh0KzEsbiktMTt3aGlsZShlPHUmJnU8PXQpe3MuYWRkKHUpO24rPTE7dT1jb3VudFplcm9zKHQrMSxuKS0xfXM9Wy4uLnNdO3Muc29ydChjb21wYXJlKTtyZXR1cm4gc31mdW5jdGlvbiByYW5nZVRvUGF0dGVybihlLHQscil7aWYoZT09PXQpe3JldHVybntwYXR0ZXJuOmUsY291bnQ6W10sZGlnaXRzOjB9fWxldCBuPXppcChlLHQpO2xldCB1PW4ubGVuZ3RoO2xldCBzPVwiXCI7bGV0IG89MDtmb3IobGV0IGU9MDtlPHU7ZSsrKXtsZXRbdCx1XT1uW2VdO2lmKHQ9PT11KXtzKz10fWVsc2UgaWYodCE9PVwiMFwifHx1IT09XCI5XCIpe3MrPXRvQ2hhcmFjdGVyQ2xhc3ModCx1LHIpfWVsc2V7bysrfX1pZihvKXtzKz1yLnNob3J0aGFuZD09PXRydWU/XCJcXFxcZFwiOlwiWzAtOV1cIn1yZXR1cm57cGF0dGVybjpzLGNvdW50OltvXSxkaWdpdHM6dX19ZnVuY3Rpb24gc3BsaXRUb1BhdHRlcm5zKGUsdCxyLG4pe2xldCB1PXNwbGl0VG9SYW5nZXMoZSx0KTtsZXQgcz1bXTtsZXQgbz1lO2xldCBpO2ZvcihsZXQgZT0wO2U8dS5sZW5ndGg7ZSsrKXtsZXQgdD11W2VdO2xldCBhPXJhbmdlVG9QYXR0ZXJuKFN0cmluZyhvKSxTdHJpbmcodCksbik7bGV0IGw9XCJcIjtpZighci5pc1BhZGRlZCYmaSYmaS5wYXR0ZXJuPT09YS5wYXR0ZXJuKXtpZihpLmNvdW50Lmxlbmd0aD4xKXtpLmNvdW50LnBvcCgpfWkuY291bnQucHVzaChhLmNvdW50WzBdKTtpLnN0cmluZz1pLnBhdHRlcm4rdG9RdWFudGlmaWVyKGkuY291bnQpO289dCsxO2NvbnRpbnVlfWlmKHIuaXNQYWRkZWQpe2w9cGFkWmVyb3ModCxyLG4pfWEuc3RyaW5nPWwrYS5wYXR0ZXJuK3RvUXVhbnRpZmllcihhLmNvdW50KTtzLnB1c2goYSk7bz10KzE7aT1hfXJldHVybiBzfWZ1bmN0aW9uIGZpbHRlclBhdHRlcm5zKGUsdCxyLG4sdSl7bGV0IHM9W107Zm9yKGxldCB1IG9mIGUpe2xldHtzdHJpbmc6ZX09dTtpZighbiYmIWNvbnRhaW5zKHQsXCJzdHJpbmdcIixlKSl7cy5wdXNoKHIrZSl9aWYobiYmY29udGFpbnModCxcInN0cmluZ1wiLGUpKXtzLnB1c2gocitlKX19cmV0dXJuIHN9ZnVuY3Rpb24gemlwKGUsdCl7bGV0IHI9W107Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspci5wdXNoKFtlW25dLHRbbl1dKTtyZXR1cm4gcn1mdW5jdGlvbiBjb21wYXJlKGUsdCl7cmV0dXJuIGU+dD8xOnQ+ZT8tMTowfWZ1bmN0aW9uIGNvbnRhaW5zKGUsdCxyKXtyZXR1cm4gZS5zb21lKChlPT5lW3RdPT09cikpfWZ1bmN0aW9uIGNvdW50TmluZXMoZSx0KXtyZXR1cm4gTnVtYmVyKFN0cmluZyhlKS5zbGljZSgwLC10KStcIjlcIi5yZXBlYXQodCkpfWZ1bmN0aW9uIGNvdW50WmVyb3MoZSx0KXtyZXR1cm4gZS1lJU1hdGgucG93KDEwLHQpfWZ1bmN0aW9uIHRvUXVhbnRpZmllcihlKXtsZXRbdD0wLHI9XCJcIl09ZTtpZihyfHx0PjEpe3JldHVybmB7JHt0KyhyP1wiLFwiK3I6XCJcIil9fWB9cmV0dXJuXCJcIn1mdW5jdGlvbiB0b0NoYXJhY3RlckNsYXNzKGUsdCxyKXtyZXR1cm5gWyR7ZX0ke3QtZT09PTE/XCJcIjpcIi1cIn0ke3R9XWB9ZnVuY3Rpb24gaGFzUGFkZGluZyhlKXtyZXR1cm4vXi0/KDArKVxcZC8udGVzdChlKX1mdW5jdGlvbiBwYWRaZXJvcyhlLHQscil7aWYoIXQuaXNQYWRkZWQpe3JldHVybiBlfWxldCBuPU1hdGguYWJzKHQubWF4TGVuLVN0cmluZyhlKS5sZW5ndGgpO2xldCB1PXIucmVsYXhaZXJvcyE9PWZhbHNlO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuXCJcIjtjYXNlIDE6cmV0dXJuIHU/XCIwP1wiOlwiMFwiO2Nhc2UgMjpyZXR1cm4gdT9cIjB7MCwyfVwiOlwiMDBcIjtkZWZhdWx0OntyZXR1cm4gdT9gMHswLCR7bn19YDpgMHske259fWB9fX10b1JlZ2V4UmFuZ2UuY2FjaGU9e307dG9SZWdleFJhbmdlLmNsZWFyQ2FjaGU9KCk9PnRvUmVnZXhSYW5nZS5jYWNoZT17fTtlLmV4cG9ydHM9dG9SZWdleFJhbmdlfSwxNzplPT57ZS5leHBvcnRzPXJlcXVpcmUoXCJwYXRoXCIpfSw4Mzc6ZT0+e2UuZXhwb3J0cz1yZXF1aXJlKFwidXRpbFwiKX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciB1PXRbcl09e2V4cG9ydHM6e319O3ZhciBzPXRydWU7dHJ5e2Vbcl0odSx1LmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7cz1mYWxzZX1maW5hbGx5e2lmKHMpZGVsZXRlIHRbcl19cmV0dXJuIHUuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXyg5NzEpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={686:(e,r,t)=>{var n=t(808);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},808:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(686);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz82N2Y5Il0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs2ODY6KGUscix0KT0+e3ZhciBuPXQoODA4KTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDgwODplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNjg2KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={114:function(e){function assertPath(e){if(typeof e!==\"string\"){throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(e))}}function normalizeStringPosix(e,r){var t=\"\";var i=0;var n=-1;var a=0;var f;for(var l=0;l<=e.length;++l){if(l<e.length)f=e.charCodeAt(l);else if(f===47)break;else f=47;if(f===47){if(n===l-1||a===1){}else if(n!==l-1&&a===2){if(t.length<2||i!==2||t.charCodeAt(t.length-1)!==46||t.charCodeAt(t.length-2)!==46){if(t.length>2){var s=t.lastIndexOf(\"/\");if(s!==t.length-1){if(s===-1){t=\"\";i=0}else{t=t.slice(0,s);i=t.length-1-t.lastIndexOf(\"/\")}n=l;a=0;continue}}else if(t.length===2||t.length===1){t=\"\";i=0;n=l;a=0;continue}}if(r){if(t.length>0)t+=\"/..\";else t=\"..\";i=2}}else{if(t.length>0)t+=\"/\"+e.slice(n+1,l);else t=e.slice(n+1,l);i=l-n-1}n=l;a=0}else if(f===46&&a!==-1){++a}else{a=-1}}return t}function _format(e,r){var t=r.dir||r.root;var i=r.base||(r.name||\"\")+(r.ext||\"\");if(!t){return i}if(t===r.root){return t+i}return t+e+i}var r={resolve:function resolve(){var e=\"\";var r=false;var t;for(var i=arguments.length-1;i>=-1&&!r;i--){var n;if(i>=0)n=arguments[i];else{if(t===undefined)t=\"\";n=t}assertPath(n);if(n.length===0){continue}e=n+\"/\"+e;r=n.charCodeAt(0)===47}e=normalizeStringPosix(e,!r);if(r){if(e.length>0)return\"/\"+e;else return\"/\"}else if(e.length>0){return e}else{return\".\"}},normalize:function normalize(e){assertPath(e);if(e.length===0)return\".\";var r=e.charCodeAt(0)===47;var t=e.charCodeAt(e.length-1)===47;e=normalizeStringPosix(e,!r);if(e.length===0&&!r)e=\".\";if(e.length>0&&t)e+=\"/\";if(r)return\"/\"+e;return e},isAbsolute:function isAbsolute(e){assertPath(e);return e.length>0&&e.charCodeAt(0)===47},join:function join(){if(arguments.length===0)return\".\";var e;for(var t=0;t<arguments.length;++t){var i=arguments[t];assertPath(i);if(i.length>0){if(e===undefined)e=i;else e+=\"/\"+i}}if(e===undefined)return\".\";return r.normalize(e)},relative:function relative(e,t){assertPath(e);assertPath(t);if(e===t)return\"\";e=r.resolve(e);t=r.resolve(t);if(e===t)return\"\";var i=1;for(;i<e.length;++i){if(e.charCodeAt(i)!==47)break}var n=e.length;var a=n-i;var f=1;for(;f<t.length;++f){if(t.charCodeAt(f)!==47)break}var l=t.length;var s=l-f;var o=a<s?a:s;var u=-1;var h=0;for(;h<=o;++h){if(h===o){if(s>o){if(t.charCodeAt(f+h)===47){return t.slice(f+h+1)}else if(h===0){return t.slice(f+h)}}else if(a>o){if(e.charCodeAt(i+h)===47){u=h}else if(h===0){u=0}}break}var c=e.charCodeAt(i+h);var v=t.charCodeAt(f+h);if(c!==v)break;else if(c===47)u=h}var g=\"\";for(h=i+u+1;h<=n;++h){if(h===n||e.charCodeAt(h)===47){if(g.length===0)g+=\"..\";else g+=\"/..\"}}if(g.length>0)return g+t.slice(f+u);else{f+=u;if(t.charCodeAt(f)===47)++f;return t.slice(f)}},_makeLong:function _makeLong(e){return e},dirname:function dirname(e){assertPath(e);if(e.length===0)return\".\";var r=e.charCodeAt(0);var t=r===47;var i=-1;var n=true;for(var a=e.length-1;a>=1;--a){r=e.charCodeAt(a);if(r===47){if(!n){i=a;break}}else{n=false}}if(i===-1)return t?\"/\":\".\";if(t&&i===1)return\"//\";return e.slice(0,i)},basename:function basename(e,r){if(r!==undefined&&typeof r!==\"string\")throw new TypeError('\"ext\" argument must be a string');assertPath(e);var t=0;var i=-1;var n=true;var a;if(r!==undefined&&r.length>0&&r.length<=e.length){if(r.length===e.length&&r===e)return\"\";var f=r.length-1;var l=-1;for(a=e.length-1;a>=0;--a){var s=e.charCodeAt(a);if(s===47){if(!n){t=a+1;break}}else{if(l===-1){n=false;l=a+1}if(f>=0){if(s===r.charCodeAt(f)){if(--f===-1){i=a}}else{f=-1;i=l}}}}if(t===i)i=l;else if(i===-1)i=e.length;return e.slice(t,i)}else{for(a=e.length-1;a>=0;--a){if(e.charCodeAt(a)===47){if(!n){t=a+1;break}}else if(i===-1){n=false;i=a+1}}if(i===-1)return\"\";return e.slice(t,i)}},extname:function extname(e){assertPath(e);var r=-1;var t=0;var i=-1;var n=true;var a=0;for(var f=e.length-1;f>=0;--f){var l=e.charCodeAt(f);if(l===47){if(!n){t=f+1;break}continue}if(i===-1){n=false;i=f+1}if(l===46){if(r===-1)r=f;else if(a!==1)a=1}else if(r!==-1){a=-1}}if(r===-1||i===-1||a===0||a===1&&r===i-1&&r===t+1){return\"\"}return e.slice(r,i)},format:function format(e){if(e===null||typeof e!==\"object\"){throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof e)}return _format(\"/\",e)},parse:function parse(e){assertPath(e);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(e.length===0)return r;var t=e.charCodeAt(0);var i=t===47;var n;if(i){r.root=\"/\";n=1}else{n=0}var a=-1;var f=0;var l=-1;var s=true;var o=e.length-1;var u=0;for(;o>=n;--o){t=e.charCodeAt(o);if(t===47){if(!s){f=o+1;break}continue}if(l===-1){s=false;l=o+1}if(t===46){if(a===-1)a=o;else if(u!==1)u=1}else if(a!==-1){u=-1}}if(a===-1||l===-1||u===0||u===1&&a===l-1&&a===f+1){if(l!==-1){if(f===0&&i)r.base=r.name=e.slice(1,l);else r.base=r.name=e.slice(f,l)}}else{if(f===0&&i){r.name=e.slice(1,a);r.base=e.slice(1,l)}else{r.name=e.slice(f,a);r.base=e.slice(f,l)}r.ext=e.slice(a,l)}if(f>0)r.dir=e.slice(0,f-1);else if(i)r.dir=\"/\";return r},sep:\"/\",delimiter:\":\",win32:null,posix:null};r.posix=r;e.exports=r}};var r={};function __nccwpck_require__(t){var i=r[t];if(i!==undefined){return i.exports}var n=r[t]={exports:{}};var a=true;try{e[t](n,n.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(114);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLGFBQWEsT0FBTyxnQkFBZ0IsdUJBQXVCLHdCQUF3QiwyRUFBMkUsbUNBQW1DLFNBQVMsUUFBUSxTQUFTLFFBQVEsTUFBTSxZQUFZLFlBQVksS0FBSyxnQ0FBZ0MscUJBQXFCLFVBQVUsV0FBVyxvQkFBb0Isd0JBQXdCLG9GQUFvRixlQUFlLHlCQUF5QixtQkFBbUIsV0FBVyxLQUFLLElBQUksS0FBSyxlQUFlLGdDQUFnQyxJQUFJLElBQUksVUFBVSxvQ0FBb0MsS0FBSyxJQUFJLElBQUksSUFBSSxVQUFVLE1BQU0sdUJBQXVCLFlBQVksS0FBSyxLQUFLLG9DQUFvQyxzQkFBc0IsUUFBUSxJQUFJLElBQUksd0JBQXdCLElBQUksS0FBSyxNQUFNLFNBQVMsc0JBQXNCLG9CQUFvQix1Q0FBdUMsT0FBTyxTQUFTLGVBQWUsV0FBVyxhQUFhLE9BQU8sMkJBQTJCLFNBQVMsWUFBWSxNQUFNLDZCQUE2QixVQUFVLEtBQUssTUFBTSx1QkFBdUIsS0FBSyxzQkFBc0IsSUFBSSxjQUFjLGlCQUFpQixTQUFTLFVBQVUsdUJBQXVCLDZCQUE2QixNQUFNLDBCQUEwQixlQUFlLG9CQUFvQixTQUFTLEtBQUssV0FBVyxpQ0FBaUMsY0FBYywwQkFBMEIsMkJBQTJCLG9DQUFvQyw2QkFBNkIsMEJBQTBCLHdCQUF3QixpQkFBaUIsU0FBUyxtQ0FBbUMsY0FBYyx3Q0FBd0Msc0JBQXNCLGtDQUFrQyxNQUFNLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLGNBQWMsZUFBZSxxQkFBcUIsZUFBZSwyQkFBMkIsc0JBQXNCLGlDQUFpQyxjQUFjLGNBQWMsa0JBQWtCLGVBQWUsZUFBZSxrQkFBa0IsUUFBUSxLQUFLLFdBQVcsS0FBSyw4QkFBOEIsZUFBZSxVQUFVLFFBQVEsS0FBSyxXQUFXLEtBQUssOEJBQThCLGVBQWUsVUFBVSxjQUFjLFNBQVMsUUFBUSxLQUFLLEtBQUssS0FBSyxVQUFVLFFBQVEsMkJBQTJCLHNCQUFzQixlQUFlLHFCQUFxQixhQUFhLDJCQUEyQixJQUFJLGVBQWUsS0FBSyxNQUFNLHdCQUF3Qix3QkFBd0IsZUFBZSxtQkFBbUIsU0FBUyxZQUFZLEtBQUssS0FBSyxnQ0FBZ0Msd0JBQXdCLGVBQWUsb0NBQW9DLEtBQUssS0FBSyw0QkFBNEIsbUJBQW1CLGlDQUFpQyxTQUFTLDZCQUE2QixjQUFjLDBCQUEwQixzQkFBc0IsYUFBYSxTQUFTLFdBQVcscUJBQXFCLEtBQUssS0FBSyxrQkFBa0IsV0FBVyxPQUFPLElBQUksT0FBTyxLQUFLLFNBQVMsMkJBQTJCLHVCQUF1QixvQkFBb0IsaUNBQWlDLDZGQUE2RixjQUFjLFFBQVEsU0FBUyxXQUFXLE1BQU0sa0RBQWtELHVDQUF1QyxpQkFBaUIsU0FBUyxpQkFBaUIsS0FBSyxLQUFLLHNCQUFzQixXQUFXLE9BQU8sTUFBTSxPQUFPLEtBQUssV0FBVyxRQUFRLE1BQU0sU0FBUyx3QkFBd0IsYUFBYSxLQUFLLEtBQUssS0FBSyxPQUFPLGFBQWEsMEJBQTBCLG9CQUFvQixLQUFLLGlCQUFpQixLQUFLLEtBQUsseUJBQXlCLE9BQU8sTUFBTSxPQUFPLGdCQUFnQixRQUFRLE9BQU8sbUJBQW1CLHFCQUFxQiw2QkFBNkIsY0FBYyxTQUFTLFFBQVEsU0FBUyxXQUFXLFFBQVEscUJBQXFCLEtBQUssS0FBSyxzQkFBc0IsV0FBVyxPQUFPLE1BQU0sTUFBTSxTQUFTLFdBQVcsUUFBUSxNQUFNLFdBQVcsY0FBYyxrQkFBa0IsZ0JBQWdCLE1BQU0sbURBQW1ELFNBQVMsb0JBQW9CLDJCQUEyQixrQ0FBa0MsaUdBQWlHLHNCQUFzQix5QkFBeUIsY0FBYyxPQUFPLHVDQUF1Qyx5QkFBeUIsc0JBQXNCLGFBQWEsTUFBTSxNQUFNLFdBQVcsSUFBSSxLQUFLLElBQUksU0FBUyxRQUFRLFNBQVMsV0FBVyxpQkFBaUIsUUFBUSxLQUFLLEtBQUssS0FBSyxrQkFBa0IsV0FBVyxPQUFPLE1BQU0sTUFBTSxTQUFTLFdBQVcsUUFBUSxNQUFNLFdBQVcsY0FBYyxrQkFBa0IsZ0JBQWdCLE1BQU0sbURBQW1ELFdBQVcsdUNBQXVDLGlDQUFpQyxLQUFLLGFBQWEsb0JBQW9CLG9CQUFvQixLQUFLLG9CQUFvQixvQkFBb0IsbUJBQW1CLDRCQUE0QixvQkFBb0IsU0FBUyw4Q0FBOEMsVUFBVSxjQUFjLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanM/MjY3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT17MTE0OmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGFzc2VydFBhdGgoZSl7aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlKSl9fWZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUscil7dmFyIHQ9XCJcIjt2YXIgaT0wO3ZhciBuPS0xO3ZhciBhPTA7dmFyIGY7Zm9yKHZhciBsPTA7bDw9ZS5sZW5ndGg7KytsKXtpZihsPGUubGVuZ3RoKWY9ZS5jaGFyQ29kZUF0KGwpO2Vsc2UgaWYoZj09PTQ3KWJyZWFrO2Vsc2UgZj00NztpZihmPT09NDcpe2lmKG49PT1sLTF8fGE9PT0xKXt9ZWxzZSBpZihuIT09bC0xJiZhPT09Mil7aWYodC5sZW5ndGg8Mnx8aSE9PTJ8fHQuY2hhckNvZGVBdCh0Lmxlbmd0aC0xKSE9PTQ2fHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMikhPT00Nil7aWYodC5sZW5ndGg+Mil7dmFyIHM9dC5sYXN0SW5kZXhPZihcIi9cIik7aWYocyE9PXQubGVuZ3RoLTEpe2lmKHM9PT0tMSl7dD1cIlwiO2k9MH1lbHNle3Q9dC5zbGljZSgwLHMpO2k9dC5sZW5ndGgtMS10Lmxhc3RJbmRleE9mKFwiL1wiKX1uPWw7YT0wO2NvbnRpbnVlfX1lbHNlIGlmKHQubGVuZ3RoPT09Mnx8dC5sZW5ndGg9PT0xKXt0PVwiXCI7aT0wO249bDthPTA7Y29udGludWV9fWlmKHIpe2lmKHQubGVuZ3RoPjApdCs9XCIvLi5cIjtlbHNlIHQ9XCIuLlwiO2k9Mn19ZWxzZXtpZih0Lmxlbmd0aD4wKXQrPVwiL1wiK2Uuc2xpY2UobisxLGwpO2Vsc2UgdD1lLnNsaWNlKG4rMSxsKTtpPWwtbi0xfW49bDthPTB9ZWxzZSBpZihmPT09NDYmJmEhPT0tMSl7KythfWVsc2V7YT0tMX19cmV0dXJuIHR9ZnVuY3Rpb24gX2Zvcm1hdChlLHIpe3ZhciB0PXIuZGlyfHxyLnJvb3Q7dmFyIGk9ci5iYXNlfHwoci5uYW1lfHxcIlwiKSsoci5leHR8fFwiXCIpO2lmKCF0KXtyZXR1cm4gaX1pZih0PT09ci5yb290KXtyZXR1cm4gdCtpfXJldHVybiB0K2UraX12YXIgcj17cmVzb2x2ZTpmdW5jdGlvbiByZXNvbHZlKCl7dmFyIGU9XCJcIjt2YXIgcj1mYWxzZTt2YXIgdDtmb3IodmFyIGk9YXJndW1lbnRzLmxlbmd0aC0xO2k+PS0xJiYhcjtpLS0pe3ZhciBuO2lmKGk+PTApbj1hcmd1bWVudHNbaV07ZWxzZXtpZih0PT09dW5kZWZpbmVkKXQ9XCJcIjtuPXR9YXNzZXJ0UGF0aChuKTtpZihuLmxlbmd0aD09PTApe2NvbnRpbnVlfWU9bitcIi9cIitlO3I9bi5jaGFyQ29kZUF0KDApPT09NDd9ZT1ub3JtYWxpemVTdHJpbmdQb3NpeChlLCFyKTtpZihyKXtpZihlLmxlbmd0aD4wKXJldHVyblwiL1wiK2U7ZWxzZSByZXR1cm5cIi9cIn1lbHNlIGlmKGUubGVuZ3RoPjApe3JldHVybiBlfWVsc2V7cmV0dXJuXCIuXCJ9fSxub3JtYWxpemU6ZnVuY3Rpb24gbm9ybWFsaXplKGUpe2Fzc2VydFBhdGgoZSk7aWYoZS5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciByPWUuY2hhckNvZGVBdCgwKT09PTQ3O3ZhciB0PWUuY2hhckNvZGVBdChlLmxlbmd0aC0xKT09PTQ3O2U9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYoZS5sZW5ndGg9PT0wJiYhcillPVwiLlwiO2lmKGUubGVuZ3RoPjAmJnQpZSs9XCIvXCI7aWYocilyZXR1cm5cIi9cIitlO3JldHVybiBlfSxpc0Fic29sdXRlOmZ1bmN0aW9uIGlzQWJzb2x1dGUoZSl7YXNzZXJ0UGF0aChlKTtyZXR1cm4gZS5sZW5ndGg+MCYmZS5jaGFyQ29kZUF0KDApPT09NDd9LGpvaW46ZnVuY3Rpb24gam9pbigpe2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciBlO2Zvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDsrK3Qpe3ZhciBpPWFyZ3VtZW50c1t0XTthc3NlcnRQYXRoKGkpO2lmKGkubGVuZ3RoPjApe2lmKGU9PT11bmRlZmluZWQpZT1pO2Vsc2UgZSs9XCIvXCIraX19aWYoZT09PXVuZGVmaW5lZClyZXR1cm5cIi5cIjtyZXR1cm4gci5ub3JtYWxpemUoZSl9LHJlbGF0aXZlOmZ1bmN0aW9uIHJlbGF0aXZlKGUsdCl7YXNzZXJ0UGF0aChlKTthc3NlcnRQYXRoKHQpO2lmKGU9PT10KXJldHVyblwiXCI7ZT1yLnJlc29sdmUoZSk7dD1yLnJlc29sdmUodCk7aWYoZT09PXQpcmV0dXJuXCJcIjt2YXIgaT0xO2Zvcig7aTxlLmxlbmd0aDsrK2kpe2lmKGUuY2hhckNvZGVBdChpKSE9PTQ3KWJyZWFrfXZhciBuPWUubGVuZ3RoO3ZhciBhPW4taTt2YXIgZj0xO2Zvcig7Zjx0Lmxlbmd0aDsrK2Ype2lmKHQuY2hhckNvZGVBdChmKSE9PTQ3KWJyZWFrfXZhciBsPXQubGVuZ3RoO3ZhciBzPWwtZjt2YXIgbz1hPHM/YTpzO3ZhciB1PS0xO3ZhciBoPTA7Zm9yKDtoPD1vOysraCl7aWYoaD09PW8pe2lmKHM+byl7aWYodC5jaGFyQ29kZUF0KGYraCk9PT00Nyl7cmV0dXJuIHQuc2xpY2UoZitoKzEpfWVsc2UgaWYoaD09PTApe3JldHVybiB0LnNsaWNlKGYraCl9fWVsc2UgaWYoYT5vKXtpZihlLmNoYXJDb2RlQXQoaStoKT09PTQ3KXt1PWh9ZWxzZSBpZihoPT09MCl7dT0wfX1icmVha312YXIgYz1lLmNoYXJDb2RlQXQoaStoKTt2YXIgdj10LmNoYXJDb2RlQXQoZitoKTtpZihjIT09dilicmVhaztlbHNlIGlmKGM9PT00Nyl1PWh9dmFyIGc9XCJcIjtmb3IoaD1pK3UrMTtoPD1uOysraCl7aWYoaD09PW58fGUuY2hhckNvZGVBdChoKT09PTQ3KXtpZihnLmxlbmd0aD09PTApZys9XCIuLlwiO2Vsc2UgZys9XCIvLi5cIn19aWYoZy5sZW5ndGg+MClyZXR1cm4gZyt0LnNsaWNlKGYrdSk7ZWxzZXtmKz11O2lmKHQuY2hhckNvZGVBdChmKT09PTQ3KSsrZjtyZXR1cm4gdC5zbGljZShmKX19LF9tYWtlTG9uZzpmdW5jdGlvbiBfbWFrZUxvbmcoZSl7cmV0dXJuIGV9LGRpcm5hbWU6ZnVuY3Rpb24gZGlybmFtZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk7dmFyIHQ9cj09PTQ3O3ZhciBpPS0xO3ZhciBuPXRydWU7Zm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MTstLWEpe3I9ZS5jaGFyQ29kZUF0KGEpO2lmKHI9PT00Nyl7aWYoIW4pe2k9YTticmVha319ZWxzZXtuPWZhbHNlfX1pZihpPT09LTEpcmV0dXJuIHQ/XCIvXCI6XCIuXCI7aWYodCYmaT09PTEpcmV0dXJuXCIvL1wiO3JldHVybiBlLnNsaWNlKDAsaSl9LGJhc2VuYW1lOmZ1bmN0aW9uIGJhc2VuYW1lKGUscil7aWYociE9PXVuZGVmaW5lZCYmdHlwZW9mIHIhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO2Fzc2VydFBhdGgoZSk7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhO2lmKHIhPT11bmRlZmluZWQmJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD1lLmxlbmd0aCl7aWYoci5sZW5ndGg9PT1lLmxlbmd0aCYmcj09PWUpcmV0dXJuXCJcIjt2YXIgZj1yLmxlbmd0aC0xO3ZhciBsPS0xO2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe3ZhciBzPWUuY2hhckNvZGVBdChhKTtpZihzPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZXtpZihsPT09LTEpe249ZmFsc2U7bD1hKzF9aWYoZj49MCl7aWYocz09PXIuY2hhckNvZGVBdChmKSl7aWYoLS1mPT09LTEpe2k9YX19ZWxzZXtmPS0xO2k9bH19fX1pZih0PT09aSlpPWw7ZWxzZSBpZihpPT09LTEpaT1lLmxlbmd0aDtyZXR1cm4gZS5zbGljZSh0LGkpfWVsc2V7Zm9yKGE9ZS5sZW5ndGgtMTthPj0wOy0tYSl7aWYoZS5jaGFyQ29kZUF0KGEpPT09NDcpe2lmKCFuKXt0PWErMTticmVha319ZWxzZSBpZihpPT09LTEpe249ZmFsc2U7aT1hKzF9fWlmKGk9PT0tMSlyZXR1cm5cIlwiO3JldHVybiBlLnNsaWNlKHQsaSl9fSxleHRuYW1lOmZ1bmN0aW9uIGV4dG5hbWUoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj0tMTt2YXIgdD0wO3ZhciBpPS0xO3ZhciBuPXRydWU7dmFyIGE9MDtmb3IodmFyIGY9ZS5sZW5ndGgtMTtmPj0wOy0tZil7dmFyIGw9ZS5jaGFyQ29kZUF0KGYpO2lmKGw9PT00Nyl7aWYoIW4pe3Q9ZisxO2JyZWFrfWNvbnRpbnVlfWlmKGk9PT0tMSl7bj1mYWxzZTtpPWYrMX1pZihsPT09NDYpe2lmKHI9PT0tMSlyPWY7ZWxzZSBpZihhIT09MSlhPTF9ZWxzZSBpZihyIT09LTEpe2E9LTF9fWlmKHI9PT0tMXx8aT09PS0xfHxhPT09MHx8YT09PTEmJnI9PT1pLTEmJnI9PT10KzEpe3JldHVyblwiXCJ9cmV0dXJuIGUuc2xpY2UocixpKX0sZm9ybWF0OmZ1bmN0aW9uIGZvcm1hdChlKXtpZihlPT09bnVsbHx8dHlwZW9mIGUhPT1cIm9iamVjdFwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiBlKX1yZXR1cm4gX2Zvcm1hdChcIi9cIixlKX0scGFyc2U6ZnVuY3Rpb24gcGFyc2UoZSl7YXNzZXJ0UGF0aChlKTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKGUubGVuZ3RoPT09MClyZXR1cm4gcjt2YXIgdD1lLmNoYXJDb2RlQXQoMCk7dmFyIGk9dD09PTQ3O3ZhciBuO2lmKGkpe3Iucm9vdD1cIi9cIjtuPTF9ZWxzZXtuPTB9dmFyIGE9LTE7dmFyIGY9MDt2YXIgbD0tMTt2YXIgcz10cnVlO3ZhciBvPWUubGVuZ3RoLTE7dmFyIHU9MDtmb3IoO28+PW47LS1vKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PT09NDcpe2lmKCFzKXtmPW8rMTticmVha31jb250aW51ZX1pZihsPT09LTEpe3M9ZmFsc2U7bD1vKzF9aWYodD09PTQ2KXtpZihhPT09LTEpYT1vO2Vsc2UgaWYodSE9PTEpdT0xfWVsc2UgaWYoYSE9PS0xKXt1PS0xfX1pZihhPT09LTF8fGw9PT0tMXx8dT09PTB8fHU9PT0xJiZhPT09bC0xJiZhPT09ZisxKXtpZihsIT09LTEpe2lmKGY9PT0wJiZpKXIuYmFzZT1yLm5hbWU9ZS5zbGljZSgxLGwpO2Vsc2Ugci5iYXNlPXIubmFtZT1lLnNsaWNlKGYsbCl9fWVsc2V7aWYoZj09PTAmJmkpe3IubmFtZT1lLnNsaWNlKDEsYSk7ci5iYXNlPWUuc2xpY2UoMSxsKX1lbHNle3IubmFtZT1lLnNsaWNlKGYsYSk7ci5iYXNlPWUuc2xpY2UoZixsKX1yLmV4dD1lLnNsaWNlKGEsbCl9aWYoZj4wKXIuZGlyPWUuc2xpY2UoMCxmLTEpO2Vsc2UgaWYoaSlyLmRpcj1cIi9cIjtyZXR1cm4gcn0sc2VwOlwiL1wiLGRlbGltaXRlcjpcIjpcIix3aW4zMjpudWxsLHBvc2l4Om51bGx9O3IucG9zaXg9cjtlLmV4cG9ydHM9cn19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIGk9clt0XTtpZihpIT09dW5kZWZpbmVkKXtyZXR1cm4gaS5leHBvcnRzfXZhciBuPXJbdF09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2VbdF0obixuLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHJbdF19cmV0dXJuIG4uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXygxMTQpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/compiled/util/util.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/../node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../node_modules/process/browser.js\");\n(function(){var r={992:function(r){r.exports=function(r,t,o){if(r.filter)return r.filter(t,o);if(void 0===r||null===r)throw new TypeError;if(\"function\"!=typeof t)throw new TypeError;var n=[];for(var i=0;i<r.length;i++){if(!e.call(r,i))continue;var a=r[i];if(t.call(o,a,i,r))n.push(a)}return n};var e=Object.prototype.hasOwnProperty},256:function(r,e,t){\"use strict\";var o=t(925);var n=t(139);var i=n(o(\"String.prototype.indexOf\"));r.exports=function callBoundIntrinsic(r,e){var t=o(r,!!e);if(typeof t===\"function\"&&i(r,\".prototype.\")>-1){return n(t)}return t}},139:function(r,e,t){\"use strict\";var o=t(174);var n=t(925);var i=n(\"%Function.prototype.apply%\");var a=n(\"%Function.prototype.call%\");var y=n(\"%Reflect.apply%\",true)||o.call(a,i);var f=n(\"%Object.getOwnPropertyDescriptor%\",true);var p=n(\"%Object.defineProperty%\",true);var u=n(\"%Math.max%\");if(p){try{p({},\"a\",{value:1})}catch(r){p=null}}r.exports=function callBind(r){var e=y(o,a,arguments);if(f&&p){var t=f(e,\"length\");if(t.configurable){p(e,\"length\",{value:1+u(0,r.length-(arguments.length-1))})}}return e};var s=function applyBind(){return y(o,i,arguments)};if(p){p(r.exports,\"apply\",{value:s})}else{r.exports.apply=s}},144:function(r){var e=Object.prototype.hasOwnProperty;var t=Object.prototype.toString;r.exports=function forEach(r,o,n){if(t.call(o)!==\"[object Function]\"){throw new TypeError(\"iterator must be a function\")}var i=r.length;if(i===+i){for(var a=0;a<i;a++){o.call(n,r[a],a,r)}}else{for(var y in r){if(e.call(r,y)){o.call(n,r[y],y,r)}}}}},426:function(r){\"use strict\";var e=\"Function.prototype.bind called on incompatible \";var t=Array.prototype.slice;var o=Object.prototype.toString;var n=\"[object Function]\";r.exports=function bind(r){var i=this;if(typeof i!==\"function\"||o.call(i)!==n){throw new TypeError(e+i)}var a=t.call(arguments,1);var y;var binder=function(){if(this instanceof y){var e=i.apply(this,a.concat(t.call(arguments)));if(Object(e)===e){return e}return this}else{return i.apply(r,a.concat(t.call(arguments)))}};var f=Math.max(0,i.length-a.length);var p=[];for(var u=0;u<f;u++){p.push(\"$\"+u)}y=Function(\"binder\",\"return function (\"+p.join(\",\")+\"){ return binder.apply(this,arguments); }\")(binder);if(i.prototype){var s=function Empty(){};s.prototype=i.prototype;y.prototype=new s;s.prototype=null}return y}},174:function(r,e,t){\"use strict\";var o=t(426);r.exports=Function.prototype.bind||o},500:function(r,e,t){\"use strict\";var o;var n=SyntaxError;var i=Function;var a=TypeError;var getEvalledConstructor=function(r){try{return i('\"use strict\"; return ('+r+\").constructor;\")()}catch(r){}};var y=Object.getOwnPropertyDescriptor;if(y){try{y({},\"\")}catch(r){y=null}}var throwTypeError=function(){throw new a};var f=y?function(){try{arguments.callee;return throwTypeError}catch(r){try{return y(arguments,\"callee\").get}catch(r){return throwTypeError}}}():throwTypeError;var p=t(115)();var u=Object.getPrototypeOf||function(r){return r.__proto__};var s={};var c=typeof Uint8Array===\"undefined\"?o:u(Uint8Array);var l={\"%AggregateError%\":typeof AggregateError===\"undefined\"?o:AggregateError,\"%Array%\":Array,\"%ArrayBuffer%\":typeof ArrayBuffer===\"undefined\"?o:ArrayBuffer,\"%ArrayIteratorPrototype%\":p?u([][Symbol.iterator]()):o,\"%AsyncFromSyncIteratorPrototype%\":o,\"%AsyncFunction%\":s,\"%AsyncGenerator%\":s,\"%AsyncGeneratorFunction%\":s,\"%AsyncIteratorPrototype%\":s,\"%Atomics%\":typeof Atomics===\"undefined\"?o:Atomics,\"%BigInt%\":typeof BigInt===\"undefined\"?o:BigInt,\"%Boolean%\":Boolean,\"%DataView%\":typeof DataView===\"undefined\"?o:DataView,\"%Date%\":Date,\"%decodeURI%\":decodeURI,\"%decodeURIComponent%\":decodeURIComponent,\"%encodeURI%\":encodeURI,\"%encodeURIComponent%\":encodeURIComponent,\"%Error%\":Error,\"%eval%\":eval,\"%EvalError%\":EvalError,\"%Float32Array%\":typeof Float32Array===\"undefined\"?o:Float32Array,\"%Float64Array%\":typeof Float64Array===\"undefined\"?o:Float64Array,\"%FinalizationRegistry%\":typeof FinalizationRegistry===\"undefined\"?o:FinalizationRegistry,\"%Function%\":i,\"%GeneratorFunction%\":s,\"%Int8Array%\":typeof Int8Array===\"undefined\"?o:Int8Array,\"%Int16Array%\":typeof Int16Array===\"undefined\"?o:Int16Array,\"%Int32Array%\":typeof Int32Array===\"undefined\"?o:Int32Array,\"%isFinite%\":isFinite,\"%isNaN%\":isNaN,\"%IteratorPrototype%\":p?u(u([][Symbol.iterator]())):o,\"%JSON%\":typeof JSON===\"object\"?JSON:o,\"%Map%\":typeof Map===\"undefined\"?o:Map,\"%MapIteratorPrototype%\":typeof Map===\"undefined\"||!p?o:u((new Map)[Symbol.iterator]()),\"%Math%\":Math,\"%Number%\":Number,\"%Object%\":Object,\"%parseFloat%\":parseFloat,\"%parseInt%\":parseInt,\"%Promise%\":typeof Promise===\"undefined\"?o:Promise,\"%Proxy%\":typeof Proxy===\"undefined\"?o:Proxy,\"%RangeError%\":RangeError,\"%ReferenceError%\":ReferenceError,\"%Reflect%\":typeof Reflect===\"undefined\"?o:Reflect,\"%RegExp%\":RegExp,\"%Set%\":typeof Set===\"undefined\"?o:Set,\"%SetIteratorPrototype%\":typeof Set===\"undefined\"||!p?o:u((new Set)[Symbol.iterator]()),\"%SharedArrayBuffer%\":typeof SharedArrayBuffer===\"undefined\"?o:SharedArrayBuffer,\"%String%\":String,\"%StringIteratorPrototype%\":p?u(\"\"[Symbol.iterator]()):o,\"%Symbol%\":p?Symbol:o,\"%SyntaxError%\":n,\"%ThrowTypeError%\":f,\"%TypedArray%\":c,\"%TypeError%\":a,\"%Uint8Array%\":typeof Uint8Array===\"undefined\"?o:Uint8Array,\"%Uint8ClampedArray%\":typeof Uint8ClampedArray===\"undefined\"?o:Uint8ClampedArray,\"%Uint16Array%\":typeof Uint16Array===\"undefined\"?o:Uint16Array,\"%Uint32Array%\":typeof Uint32Array===\"undefined\"?o:Uint32Array,\"%URIError%\":URIError,\"%WeakMap%\":typeof WeakMap===\"undefined\"?o:WeakMap,\"%WeakRef%\":typeof WeakRef===\"undefined\"?o:WeakRef,\"%WeakSet%\":typeof WeakSet===\"undefined\"?o:WeakSet};var d=function doEval(r){var e;if(r===\"%AsyncFunction%\"){e=getEvalledConstructor(\"async function () {}\")}else if(r===\"%GeneratorFunction%\"){e=getEvalledConstructor(\"function* () {}\")}else if(r===\"%AsyncGeneratorFunction%\"){e=getEvalledConstructor(\"async function* () {}\")}else if(r===\"%AsyncGenerator%\"){var t=doEval(\"%AsyncGeneratorFunction%\");if(t){e=t.prototype}}else if(r===\"%AsyncIteratorPrototype%\"){var o=doEval(\"%AsyncGenerator%\");if(o){e=u(o.prototype)}}l[r]=e;return e};var g={\"%ArrayBufferPrototype%\":[\"ArrayBuffer\",\"prototype\"],\"%ArrayPrototype%\":[\"Array\",\"prototype\"],\"%ArrayProto_entries%\":[\"Array\",\"prototype\",\"entries\"],\"%ArrayProto_forEach%\":[\"Array\",\"prototype\",\"forEach\"],\"%ArrayProto_keys%\":[\"Array\",\"prototype\",\"keys\"],\"%ArrayProto_values%\":[\"Array\",\"prototype\",\"values\"],\"%AsyncFunctionPrototype%\":[\"AsyncFunction\",\"prototype\"],\"%AsyncGenerator%\":[\"AsyncGeneratorFunction\",\"prototype\"],\"%AsyncGeneratorPrototype%\":[\"AsyncGeneratorFunction\",\"prototype\",\"prototype\"],\"%BooleanPrototype%\":[\"Boolean\",\"prototype\"],\"%DataViewPrototype%\":[\"DataView\",\"prototype\"],\"%DatePrototype%\":[\"Date\",\"prototype\"],\"%ErrorPrototype%\":[\"Error\",\"prototype\"],\"%EvalErrorPrototype%\":[\"EvalError\",\"prototype\"],\"%Float32ArrayPrototype%\":[\"Float32Array\",\"prototype\"],\"%Float64ArrayPrototype%\":[\"Float64Array\",\"prototype\"],\"%FunctionPrototype%\":[\"Function\",\"prototype\"],\"%Generator%\":[\"GeneratorFunction\",\"prototype\"],\"%GeneratorPrototype%\":[\"GeneratorFunction\",\"prototype\",\"prototype\"],\"%Int8ArrayPrototype%\":[\"Int8Array\",\"prototype\"],\"%Int16ArrayPrototype%\":[\"Int16Array\",\"prototype\"],\"%Int32ArrayPrototype%\":[\"Int32Array\",\"prototype\"],\"%JSONParse%\":[\"JSON\",\"parse\"],\"%JSONStringify%\":[\"JSON\",\"stringify\"],\"%MapPrototype%\":[\"Map\",\"prototype\"],\"%NumberPrototype%\":[\"Number\",\"prototype\"],\"%ObjectPrototype%\":[\"Object\",\"prototype\"],\"%ObjProto_toString%\":[\"Object\",\"prototype\",\"toString\"],\"%ObjProto_valueOf%\":[\"Object\",\"prototype\",\"valueOf\"],\"%PromisePrototype%\":[\"Promise\",\"prototype\"],\"%PromiseProto_then%\":[\"Promise\",\"prototype\",\"then\"],\"%Promise_all%\":[\"Promise\",\"all\"],\"%Promise_reject%\":[\"Promise\",\"reject\"],\"%Promise_resolve%\":[\"Promise\",\"resolve\"],\"%RangeErrorPrototype%\":[\"RangeError\",\"prototype\"],\"%ReferenceErrorPrototype%\":[\"ReferenceError\",\"prototype\"],\"%RegExpPrototype%\":[\"RegExp\",\"prototype\"],\"%SetPrototype%\":[\"Set\",\"prototype\"],\"%SharedArrayBufferPrototype%\":[\"SharedArrayBuffer\",\"prototype\"],\"%StringPrototype%\":[\"String\",\"prototype\"],\"%SymbolPrototype%\":[\"Symbol\",\"prototype\"],\"%SyntaxErrorPrototype%\":[\"SyntaxError\",\"prototype\"],\"%TypedArrayPrototype%\":[\"TypedArray\",\"prototype\"],\"%TypeErrorPrototype%\":[\"TypeError\",\"prototype\"],\"%Uint8ArrayPrototype%\":[\"Uint8Array\",\"prototype\"],\"%Uint8ClampedArrayPrototype%\":[\"Uint8ClampedArray\",\"prototype\"],\"%Uint16ArrayPrototype%\":[\"Uint16Array\",\"prototype\"],\"%Uint32ArrayPrototype%\":[\"Uint32Array\",\"prototype\"],\"%URIErrorPrototype%\":[\"URIError\",\"prototype\"],\"%WeakMapPrototype%\":[\"WeakMap\",\"prototype\"],\"%WeakSetPrototype%\":[\"WeakSet\",\"prototype\"]};var v=t(174);var b=t(101);var A=v.call(Function.call,Array.prototype.concat);var m=v.call(Function.apply,Array.prototype.splice);var S=v.call(Function.call,String.prototype.replace);var h=v.call(Function.call,String.prototype.slice);var P=v.call(Function.call,RegExp.prototype.exec);var O=/[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;var w=/\\\\(\\\\)?/g;var j=function stringToPath(r){var e=h(r,0,1);var t=h(r,-1);if(e===\"%\"&&t!==\"%\"){throw new n(\"invalid intrinsic syntax, expected closing `%`\")}else if(t===\"%\"&&e!==\"%\"){throw new n(\"invalid intrinsic syntax, expected opening `%`\")}var o=[];S(r,O,(function(r,e,t,n){o[o.length]=t?S(n,w,\"$1\"):e||r}));return o};var E=function getBaseIntrinsic(r,e){var t=r;var o;if(b(g,t)){o=g[t];t=\"%\"+o[0]+\"%\"}if(b(l,t)){var i=l[t];if(i===s){i=d(t)}if(typeof i===\"undefined\"&&!e){throw new a(\"intrinsic \"+r+\" exists, but is not available. Please file an issue!\")}return{alias:o,name:t,value:i}}throw new n(\"intrinsic \"+r+\" does not exist!\")};r.exports=function GetIntrinsic(r,e){if(typeof r!==\"string\"||r.length===0){throw new a(\"intrinsic name must be a non-empty string\")}if(arguments.length>1&&typeof e!==\"boolean\"){throw new a('\"allowMissing\" argument must be a boolean')}if(P(/^%?[^%]*%?$/g,r)===null){throw new n(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\")}var t=j(r);var i=t.length>0?t[0]:\"\";var f=E(\"%\"+i+\"%\",e);var p=f.name;var u=f.value;var s=false;var c=f.alias;if(c){i=c[0];m(t,A([0,1],c))}for(var d=1,g=true;d<t.length;d+=1){var v=t[d];var S=h(v,0,1);var O=h(v,-1);if((S==='\"'||S===\"'\"||S===\"`\"||(O==='\"'||O===\"'\"||O===\"`\"))&&S!==O){throw new n(\"property names with quotes must have matching quotes\")}if(v===\"constructor\"||!g){s=true}i+=\".\"+v;p=\"%\"+i+\"%\";if(b(l,p)){u=l[p]}else if(u!=null){if(!(v in u)){if(!e){throw new a(\"base intrinsic for \"+r+\" exists, but the property is not available.\")}return void o}if(y&&d+1>=t.length){var w=y(u,v);g=!!w;if(g&&\"get\"in w&&!(\"originalValue\"in w.get)){u=w.get}else{u=u[v]}}else{g=b(u,v);u=u[v]}if(g&&!s){l[p]=u}}}return u}},925:function(r,e,t){\"use strict\";var o;var n=SyntaxError;var i=Function;var a=TypeError;var getEvalledConstructor=function(r){try{return i('\"use strict\"; return ('+r+\").constructor;\")()}catch(r){}};var y=Object.getOwnPropertyDescriptor;if(y){try{y({},\"\")}catch(r){y=null}}var throwTypeError=function(){throw new a};var f=y?function(){try{arguments.callee;return throwTypeError}catch(r){try{return y(arguments,\"callee\").get}catch(r){return throwTypeError}}}():throwTypeError;var p=t(115)();var u=t(504)();var s=Object.getPrototypeOf||(u?function(r){return r.__proto__}:null);var c={};var l=typeof Uint8Array===\"undefined\"||!s?o:s(Uint8Array);var d={\"%AggregateError%\":typeof AggregateError===\"undefined\"?o:AggregateError,\"%Array%\":Array,\"%ArrayBuffer%\":typeof ArrayBuffer===\"undefined\"?o:ArrayBuffer,\"%ArrayIteratorPrototype%\":p&&s?s([][Symbol.iterator]()):o,\"%AsyncFromSyncIteratorPrototype%\":o,\"%AsyncFunction%\":c,\"%AsyncGenerator%\":c,\"%AsyncGeneratorFunction%\":c,\"%AsyncIteratorPrototype%\":c,\"%Atomics%\":typeof Atomics===\"undefined\"?o:Atomics,\"%BigInt%\":typeof BigInt===\"undefined\"?o:BigInt,\"%BigInt64Array%\":typeof BigInt64Array===\"undefined\"?o:BigInt64Array,\"%BigUint64Array%\":typeof BigUint64Array===\"undefined\"?o:BigUint64Array,\"%Boolean%\":Boolean,\"%DataView%\":typeof DataView===\"undefined\"?o:DataView,\"%Date%\":Date,\"%decodeURI%\":decodeURI,\"%decodeURIComponent%\":decodeURIComponent,\"%encodeURI%\":encodeURI,\"%encodeURIComponent%\":encodeURIComponent,\"%Error%\":Error,\"%eval%\":eval,\"%EvalError%\":EvalError,\"%Float32Array%\":typeof Float32Array===\"undefined\"?o:Float32Array,\"%Float64Array%\":typeof Float64Array===\"undefined\"?o:Float64Array,\"%FinalizationRegistry%\":typeof FinalizationRegistry===\"undefined\"?o:FinalizationRegistry,\"%Function%\":i,\"%GeneratorFunction%\":c,\"%Int8Array%\":typeof Int8Array===\"undefined\"?o:Int8Array,\"%Int16Array%\":typeof Int16Array===\"undefined\"?o:Int16Array,\"%Int32Array%\":typeof Int32Array===\"undefined\"?o:Int32Array,\"%isFinite%\":isFinite,\"%isNaN%\":isNaN,\"%IteratorPrototype%\":p&&s?s(s([][Symbol.iterator]())):o,\"%JSON%\":typeof JSON===\"object\"?JSON:o,\"%Map%\":typeof Map===\"undefined\"?o:Map,\"%MapIteratorPrototype%\":typeof Map===\"undefined\"||!p||!s?o:s((new Map)[Symbol.iterator]()),\"%Math%\":Math,\"%Number%\":Number,\"%Object%\":Object,\"%parseFloat%\":parseFloat,\"%parseInt%\":parseInt,\"%Promise%\":typeof Promise===\"undefined\"?o:Promise,\"%Proxy%\":typeof Proxy===\"undefined\"?o:Proxy,\"%RangeError%\":RangeError,\"%ReferenceError%\":ReferenceError,\"%Reflect%\":typeof Reflect===\"undefined\"?o:Reflect,\"%RegExp%\":RegExp,\"%Set%\":typeof Set===\"undefined\"?o:Set,\"%SetIteratorPrototype%\":typeof Set===\"undefined\"||!p||!s?o:s((new Set)[Symbol.iterator]()),\"%SharedArrayBuffer%\":typeof SharedArrayBuffer===\"undefined\"?o:SharedArrayBuffer,\"%String%\":String,\"%StringIteratorPrototype%\":p&&s?s(\"\"[Symbol.iterator]()):o,\"%Symbol%\":p?Symbol:o,\"%SyntaxError%\":n,\"%ThrowTypeError%\":f,\"%TypedArray%\":l,\"%TypeError%\":a,\"%Uint8Array%\":typeof Uint8Array===\"undefined\"?o:Uint8Array,\"%Uint8ClampedArray%\":typeof Uint8ClampedArray===\"undefined\"?o:Uint8ClampedArray,\"%Uint16Array%\":typeof Uint16Array===\"undefined\"?o:Uint16Array,\"%Uint32Array%\":typeof Uint32Array===\"undefined\"?o:Uint32Array,\"%URIError%\":URIError,\"%WeakMap%\":typeof WeakMap===\"undefined\"?o:WeakMap,\"%WeakRef%\":typeof WeakRef===\"undefined\"?o:WeakRef,\"%WeakSet%\":typeof WeakSet===\"undefined\"?o:WeakSet};if(s){try{null.error}catch(r){var g=s(s(r));d[\"%Error.prototype%\"]=g}}var v=function doEval(r){var e;if(r===\"%AsyncFunction%\"){e=getEvalledConstructor(\"async function () {}\")}else if(r===\"%GeneratorFunction%\"){e=getEvalledConstructor(\"function* () {}\")}else if(r===\"%AsyncGeneratorFunction%\"){e=getEvalledConstructor(\"async function* () {}\")}else if(r===\"%AsyncGenerator%\"){var t=doEval(\"%AsyncGeneratorFunction%\");if(t){e=t.prototype}}else if(r===\"%AsyncIteratorPrototype%\"){var o=doEval(\"%AsyncGenerator%\");if(o&&s){e=s(o.prototype)}}d[r]=e;return e};var b={\"%ArrayBufferPrototype%\":[\"ArrayBuffer\",\"prototype\"],\"%ArrayPrototype%\":[\"Array\",\"prototype\"],\"%ArrayProto_entries%\":[\"Array\",\"prototype\",\"entries\"],\"%ArrayProto_forEach%\":[\"Array\",\"prototype\",\"forEach\"],\"%ArrayProto_keys%\":[\"Array\",\"prototype\",\"keys\"],\"%ArrayProto_values%\":[\"Array\",\"prototype\",\"values\"],\"%AsyncFunctionPrototype%\":[\"AsyncFunction\",\"prototype\"],\"%AsyncGenerator%\":[\"AsyncGeneratorFunction\",\"prototype\"],\"%AsyncGeneratorPrototype%\":[\"AsyncGeneratorFunction\",\"prototype\",\"prototype\"],\"%BooleanPrototype%\":[\"Boolean\",\"prototype\"],\"%DataViewPrototype%\":[\"DataView\",\"prototype\"],\"%DatePrototype%\":[\"Date\",\"prototype\"],\"%ErrorPrototype%\":[\"Error\",\"prototype\"],\"%EvalErrorPrototype%\":[\"EvalError\",\"prototype\"],\"%Float32ArrayPrototype%\":[\"Float32Array\",\"prototype\"],\"%Float64ArrayPrototype%\":[\"Float64Array\",\"prototype\"],\"%FunctionPrototype%\":[\"Function\",\"prototype\"],\"%Generator%\":[\"GeneratorFunction\",\"prototype\"],\"%GeneratorPrototype%\":[\"GeneratorFunction\",\"prototype\",\"prototype\"],\"%Int8ArrayPrototype%\":[\"Int8Array\",\"prototype\"],\"%Int16ArrayPrototype%\":[\"Int16Array\",\"prototype\"],\"%Int32ArrayPrototype%\":[\"Int32Array\",\"prototype\"],\"%JSONParse%\":[\"JSON\",\"parse\"],\"%JSONStringify%\":[\"JSON\",\"stringify\"],\"%MapPrototype%\":[\"Map\",\"prototype\"],\"%NumberPrototype%\":[\"Number\",\"prototype\"],\"%ObjectPrototype%\":[\"Object\",\"prototype\"],\"%ObjProto_toString%\":[\"Object\",\"prototype\",\"toString\"],\"%ObjProto_valueOf%\":[\"Object\",\"prototype\",\"valueOf\"],\"%PromisePrototype%\":[\"Promise\",\"prototype\"],\"%PromiseProto_then%\":[\"Promise\",\"prototype\",\"then\"],\"%Promise_all%\":[\"Promise\",\"all\"],\"%Promise_reject%\":[\"Promise\",\"reject\"],\"%Promise_resolve%\":[\"Promise\",\"resolve\"],\"%RangeErrorPrototype%\":[\"RangeError\",\"prototype\"],\"%ReferenceErrorPrototype%\":[\"ReferenceError\",\"prototype\"],\"%RegExpPrototype%\":[\"RegExp\",\"prototype\"],\"%SetPrototype%\":[\"Set\",\"prototype\"],\"%SharedArrayBufferPrototype%\":[\"SharedArrayBuffer\",\"prototype\"],\"%StringPrototype%\":[\"String\",\"prototype\"],\"%SymbolPrototype%\":[\"Symbol\",\"prototype\"],\"%SyntaxErrorPrototype%\":[\"SyntaxError\",\"prototype\"],\"%TypedArrayPrototype%\":[\"TypedArray\",\"prototype\"],\"%TypeErrorPrototype%\":[\"TypeError\",\"prototype\"],\"%Uint8ArrayPrototype%\":[\"Uint8Array\",\"prototype\"],\"%Uint8ClampedArrayPrototype%\":[\"Uint8ClampedArray\",\"prototype\"],\"%Uint16ArrayPrototype%\":[\"Uint16Array\",\"prototype\"],\"%Uint32ArrayPrototype%\":[\"Uint32Array\",\"prototype\"],\"%URIErrorPrototype%\":[\"URIError\",\"prototype\"],\"%WeakMapPrototype%\":[\"WeakMap\",\"prototype\"],\"%WeakSetPrototype%\":[\"WeakSet\",\"prototype\"]};var A=t(174);var m=t(101);var S=A.call(Function.call,Array.prototype.concat);var h=A.call(Function.apply,Array.prototype.splice);var P=A.call(Function.call,String.prototype.replace);var O=A.call(Function.call,String.prototype.slice);var w=A.call(Function.call,RegExp.prototype.exec);var j=/[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;var E=/\\\\(\\\\)?/g;var I=function stringToPath(r){var e=O(r,0,1);var t=O(r,-1);if(e===\"%\"&&t!==\"%\"){throw new n(\"invalid intrinsic syntax, expected closing `%`\")}else if(t===\"%\"&&e!==\"%\"){throw new n(\"invalid intrinsic syntax, expected opening `%`\")}var o=[];P(r,j,(function(r,e,t,n){o[o.length]=t?P(n,E,\"$1\"):e||r}));return o};var B=function getBaseIntrinsic(r,e){var t=r;var o;if(m(b,t)){o=b[t];t=\"%\"+o[0]+\"%\"}if(m(d,t)){var i=d[t];if(i===c){i=v(t)}if(typeof i===\"undefined\"&&!e){throw new a(\"intrinsic \"+r+\" exists, but is not available. Please file an issue!\")}return{alias:o,name:t,value:i}}throw new n(\"intrinsic \"+r+\" does not exist!\")};r.exports=function GetIntrinsic(r,e){if(typeof r!==\"string\"||r.length===0){throw new a(\"intrinsic name must be a non-empty string\")}if(arguments.length>1&&typeof e!==\"boolean\"){throw new a('\"allowMissing\" argument must be a boolean')}if(w(/^%?[^%]*%?$/,r)===null){throw new n(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\")}var t=I(r);var i=t.length>0?t[0]:\"\";var f=B(\"%\"+i+\"%\",e);var p=f.name;var u=f.value;var s=false;var c=f.alias;if(c){i=c[0];h(t,S([0,1],c))}for(var l=1,g=true;l<t.length;l+=1){var v=t[l];var b=O(v,0,1);var A=O(v,-1);if((b==='\"'||b===\"'\"||b===\"`\"||(A==='\"'||A===\"'\"||A===\"`\"))&&b!==A){throw new n(\"property names with quotes must have matching quotes\")}if(v===\"constructor\"||!g){s=true}i+=\".\"+v;p=\"%\"+i+\"%\";if(m(d,p)){u=d[p]}else if(u!=null){if(!(v in u)){if(!e){throw new a(\"base intrinsic for \"+r+\" exists, but the property is not available.\")}return void o}if(y&&l+1>=t.length){var P=y(u,v);g=!!P;if(g&&\"get\"in P&&!(\"originalValue\"in P.get)){u=P.get}else{u=u[v]}}else{g=m(u,v);u=u[v]}if(g&&!s){d[p]=u}}}return u}},504:function(r){\"use strict\";var e={foo:{}};var t=Object;r.exports=function hasProto(){return{__proto__:e}.foo===e.foo&&!({__proto__:null}instanceof t)}},942:function(r,e,t){\"use strict\";var o=typeof Symbol!==\"undefined\"&&Symbol;var n=t(773);r.exports=function hasNativeSymbols(){if(typeof o!==\"function\"){return false}if(typeof Symbol!==\"function\"){return false}if(typeof o(\"foo\")!==\"symbol\"){return false}if(typeof Symbol(\"bar\")!==\"symbol\"){return false}return n()}},773:function(r){\"use strict\";r.exports=function hasSymbols(){if(typeof Symbol!==\"function\"||typeof Object.getOwnPropertySymbols!==\"function\"){return false}if(typeof Symbol.iterator===\"symbol\"){return true}var r={};var e=Symbol(\"test\");var t=Object(e);if(typeof e===\"string\"){return false}if(Object.prototype.toString.call(e)!==\"[object Symbol]\"){return false}if(Object.prototype.toString.call(t)!==\"[object Symbol]\"){return false}var o=42;r[e]=o;for(e in r){return false}if(typeof Object.keys===\"function\"&&Object.keys(r).length!==0){return false}if(typeof Object.getOwnPropertyNames===\"function\"&&Object.getOwnPropertyNames(r).length!==0){return false}var n=Object.getOwnPropertySymbols(r);if(n.length!==1||n[0]!==e){return false}if(!Object.prototype.propertyIsEnumerable.call(r,e)){return false}if(typeof Object.getOwnPropertyDescriptor===\"function\"){var i=Object.getOwnPropertyDescriptor(r,e);if(i.value!==o||i.enumerable!==true){return false}}return true}},115:function(r,e,t){\"use strict\";var o=typeof Symbol!==\"undefined\"&&Symbol;var n=t(832);r.exports=function hasNativeSymbols(){if(typeof o!==\"function\"){return false}if(typeof Symbol!==\"function\"){return false}if(typeof o(\"foo\")!==\"symbol\"){return false}if(typeof Symbol(\"bar\")!==\"symbol\"){return false}return n()}},832:function(r){\"use strict\";r.exports=function hasSymbols(){if(typeof Symbol!==\"function\"||typeof Object.getOwnPropertySymbols!==\"function\"){return false}if(typeof Symbol.iterator===\"symbol\"){return true}var r={};var e=Symbol(\"test\");var t=Object(e);if(typeof e===\"string\"){return false}if(Object.prototype.toString.call(e)!==\"[object Symbol]\"){return false}if(Object.prototype.toString.call(t)!==\"[object Symbol]\"){return false}var o=42;r[e]=o;for(e in r){return false}if(typeof Object.keys===\"function\"&&Object.keys(r).length!==0){return false}if(typeof Object.getOwnPropertyNames===\"function\"&&Object.getOwnPropertyNames(r).length!==0){return false}var n=Object.getOwnPropertySymbols(r);if(n.length!==1||n[0]!==e){return false}if(!Object.prototype.propertyIsEnumerable.call(r,e)){return false}if(typeof Object.getOwnPropertyDescriptor===\"function\"){var i=Object.getOwnPropertyDescriptor(r,e);if(i.value!==o||i.enumerable!==true){return false}}return true}},101:function(r,e,t){\"use strict\";var o=t(174);r.exports=o.call(Function.call,Object.prototype.hasOwnProperty)},782:function(r){if(typeof Object.create===\"function\"){r.exports=function inherits(r,e){if(e){r.super_=e;r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:false,writable:true,configurable:true}})}}}else{r.exports=function inherits(r,e){if(e){r.super_=e;var TempCtor=function(){};TempCtor.prototype=e.prototype;r.prototype=new TempCtor;r.prototype.constructor=r}}}},157:function(r){\"use strict\";var e=typeof Symbol===\"function\"&&typeof Symbol.toStringTag===\"symbol\";var t=Object.prototype.toString;var o=function isArguments(r){if(e&&r&&typeof r===\"object\"&&Symbol.toStringTag in r){return false}return t.call(r)===\"[object Arguments]\"};var n=function isArguments(r){if(o(r)){return true}return r!==null&&typeof r===\"object\"&&typeof r.length===\"number\"&&r.length>=0&&t.call(r)!==\"[object Array]\"&&t.call(r.callee)===\"[object Function]\"};var i=function(){return o(arguments)}();o.isLegacyArguments=n;r.exports=i?o:n},391:function(r){\"use strict\";var e=Object.prototype.toString;var t=Function.prototype.toString;var o=/^\\s*(?:function)?\\*/;var n=typeof Symbol===\"function\"&&typeof Symbol.toStringTag===\"symbol\";var i=Object.getPrototypeOf;var getGeneratorFunc=function(){if(!n){return false}try{return Function(\"return function*() {}\")()}catch(r){}};var a=getGeneratorFunc();var y=a?i(a):{};r.exports=function isGeneratorFunction(r){if(typeof r!==\"function\"){return false}if(o.test(t.call(r))){return true}if(!n){var a=e.call(r);return a===\"[object GeneratorFunction]\"}return i(r)===y}},994:function(r,e,t){\"use strict\";var o=t(144);var n=t(349);var i=t(256);var a=i(\"Object.prototype.toString\");var y=t(942)();var f=y&&typeof Symbol.toStringTag===\"symbol\";var p=n();var u=i(\"Array.prototype.indexOf\",true)||function indexOf(r,e){for(var t=0;t<r.length;t+=1){if(r[t]===e){return t}}return-1};var s=i(\"String.prototype.slice\");var c={};var l=t(24);var d=Object.getPrototypeOf;if(f&&l&&d){o(p,(function(r){var e=new __webpack_require__.g[r];if(!(Symbol.toStringTag in e)){throw new EvalError(\"this engine has support for Symbol.toStringTag, but \"+r+\" does not have the property! Please report this.\")}var t=d(e);var o=l(t,Symbol.toStringTag);if(!o){var n=d(t);o=l(n,Symbol.toStringTag)}c[r]=o.get}))}var g=function tryAllTypedArrays(r){var e=false;o(c,(function(t,o){if(!e){try{e=t.call(r)===o}catch(r){}}}));return e};r.exports=function isTypedArray(r){if(!r||typeof r!==\"object\"){return false}if(!f){var e=s(a(r),8,-1);return u(p,e)>-1}if(!l){return false}return g(r)}},369:function(r){r.exports=function isBuffer(r){return r instanceof Buffer}},584:function(r,e,t){\"use strict\";var o=t(157);var n=t(391);var i=t(490);var a=t(994);function uncurryThis(r){return r.call.bind(r)}var y=typeof BigInt!==\"undefined\";var f=typeof Symbol!==\"undefined\";var p=uncurryThis(Object.prototype.toString);var u=uncurryThis(Number.prototype.valueOf);var s=uncurryThis(String.prototype.valueOf);var c=uncurryThis(Boolean.prototype.valueOf);if(y){var l=uncurryThis(BigInt.prototype.valueOf)}if(f){var d=uncurryThis(Symbol.prototype.valueOf)}function checkBoxedPrimitive(r,e){if(typeof r!==\"object\"){return false}try{e(r);return true}catch(r){return false}}e.isArgumentsObject=o;e.isGeneratorFunction=n;e.isTypedArray=a;function isPromise(r){return typeof Promise!==\"undefined\"&&r instanceof Promise||r!==null&&typeof r===\"object\"&&typeof r.then===\"function\"&&typeof r.catch===\"function\"}e.isPromise=isPromise;function isArrayBufferView(r){if(typeof ArrayBuffer!==\"undefined\"&&ArrayBuffer.isView){return ArrayBuffer.isView(r)}return a(r)||isDataView(r)}e.isArrayBufferView=isArrayBufferView;function isUint8Array(r){return i(r)===\"Uint8Array\"}e.isUint8Array=isUint8Array;function isUint8ClampedArray(r){return i(r)===\"Uint8ClampedArray\"}e.isUint8ClampedArray=isUint8ClampedArray;function isUint16Array(r){return i(r)===\"Uint16Array\"}e.isUint16Array=isUint16Array;function isUint32Array(r){return i(r)===\"Uint32Array\"}e.isUint32Array=isUint32Array;function isInt8Array(r){return i(r)===\"Int8Array\"}e.isInt8Array=isInt8Array;function isInt16Array(r){return i(r)===\"Int16Array\"}e.isInt16Array=isInt16Array;function isInt32Array(r){return i(r)===\"Int32Array\"}e.isInt32Array=isInt32Array;function isFloat32Array(r){return i(r)===\"Float32Array\"}e.isFloat32Array=isFloat32Array;function isFloat64Array(r){return i(r)===\"Float64Array\"}e.isFloat64Array=isFloat64Array;function isBigInt64Array(r){return i(r)===\"BigInt64Array\"}e.isBigInt64Array=isBigInt64Array;function isBigUint64Array(r){return i(r)===\"BigUint64Array\"}e.isBigUint64Array=isBigUint64Array;function isMapToString(r){return p(r)===\"[object Map]\"}isMapToString.working=typeof Map!==\"undefined\"&&isMapToString(new Map);function isMap(r){if(typeof Map===\"undefined\"){return false}return isMapToString.working?isMapToString(r):r instanceof Map}e.isMap=isMap;function isSetToString(r){return p(r)===\"[object Set]\"}isSetToString.working=typeof Set!==\"undefined\"&&isSetToString(new Set);function isSet(r){if(typeof Set===\"undefined\"){return false}return isSetToString.working?isSetToString(r):r instanceof Set}e.isSet=isSet;function isWeakMapToString(r){return p(r)===\"[object WeakMap]\"}isWeakMapToString.working=typeof WeakMap!==\"undefined\"&&isWeakMapToString(new WeakMap);function isWeakMap(r){if(typeof WeakMap===\"undefined\"){return false}return isWeakMapToString.working?isWeakMapToString(r):r instanceof WeakMap}e.isWeakMap=isWeakMap;function isWeakSetToString(r){return p(r)===\"[object WeakSet]\"}isWeakSetToString.working=typeof WeakSet!==\"undefined\"&&isWeakSetToString(new WeakSet);function isWeakSet(r){return isWeakSetToString(r)}e.isWeakSet=isWeakSet;function isArrayBufferToString(r){return p(r)===\"[object ArrayBuffer]\"}isArrayBufferToString.working=typeof ArrayBuffer!==\"undefined\"&&isArrayBufferToString(new ArrayBuffer);function isArrayBuffer(r){if(typeof ArrayBuffer===\"undefined\"){return false}return isArrayBufferToString.working?isArrayBufferToString(r):r instanceof ArrayBuffer}e.isArrayBuffer=isArrayBuffer;function isDataViewToString(r){return p(r)===\"[object DataView]\"}isDataViewToString.working=typeof ArrayBuffer!==\"undefined\"&&typeof DataView!==\"undefined\"&&isDataViewToString(new DataView(new ArrayBuffer(1),0,1));function isDataView(r){if(typeof DataView===\"undefined\"){return false}return isDataViewToString.working?isDataViewToString(r):r instanceof DataView}e.isDataView=isDataView;var g=typeof SharedArrayBuffer!==\"undefined\"?SharedArrayBuffer:undefined;function isSharedArrayBufferToString(r){return p(r)===\"[object SharedArrayBuffer]\"}function isSharedArrayBuffer(r){if(typeof g===\"undefined\"){return false}if(typeof isSharedArrayBufferToString.working===\"undefined\"){isSharedArrayBufferToString.working=isSharedArrayBufferToString(new g)}return isSharedArrayBufferToString.working?isSharedArrayBufferToString(r):r instanceof g}e.isSharedArrayBuffer=isSharedArrayBuffer;function isAsyncFunction(r){return p(r)===\"[object AsyncFunction]\"}e.isAsyncFunction=isAsyncFunction;function isMapIterator(r){return p(r)===\"[object Map Iterator]\"}e.isMapIterator=isMapIterator;function isSetIterator(r){return p(r)===\"[object Set Iterator]\"}e.isSetIterator=isSetIterator;function isGeneratorObject(r){return p(r)===\"[object Generator]\"}e.isGeneratorObject=isGeneratorObject;function isWebAssemblyCompiledModule(r){return p(r)===\"[object WebAssembly.Module]\"}e.isWebAssemblyCompiledModule=isWebAssemblyCompiledModule;function isNumberObject(r){return checkBoxedPrimitive(r,u)}e.isNumberObject=isNumberObject;function isStringObject(r){return checkBoxedPrimitive(r,s)}e.isStringObject=isStringObject;function isBooleanObject(r){return checkBoxedPrimitive(r,c)}e.isBooleanObject=isBooleanObject;function isBigIntObject(r){return y&&checkBoxedPrimitive(r,l)}e.isBigIntObject=isBigIntObject;function isSymbolObject(r){return f&&checkBoxedPrimitive(r,d)}e.isSymbolObject=isSymbolObject;function isBoxedPrimitive(r){return isNumberObject(r)||isStringObject(r)||isBooleanObject(r)||isBigIntObject(r)||isSymbolObject(r)}e.isBoxedPrimitive=isBoxedPrimitive;function isAnyArrayBuffer(r){return typeof Uint8Array!==\"undefined\"&&(isArrayBuffer(r)||isSharedArrayBuffer(r))}e.isAnyArrayBuffer=isAnyArrayBuffer;[\"isProxy\",\"isExternal\",\"isModuleNamespaceObject\"].forEach((function(r){Object.defineProperty(e,r,{enumerable:false,value:function(){throw new Error(r+\" is not supported in userland\")}})}))},177:function(r,e,t){var o=Object.getOwnPropertyDescriptors||function getOwnPropertyDescriptors(r){var e=Object.keys(r);var t={};for(var o=0;o<e.length;o++){t[e[o]]=Object.getOwnPropertyDescriptor(r,e[o])}return t};var n=/%[sdj%]/g;e.format=function(r){if(!isString(r)){var e=[];for(var t=0;t<arguments.length;t++){e.push(inspect(arguments[t]))}return e.join(\" \")}var t=1;var o=arguments;var i=o.length;var a=String(r).replace(n,(function(r){if(r===\"%%\")return\"%\";if(t>=i)return r;switch(r){case\"%s\":return String(o[t++]);case\"%d\":return Number(o[t++]);case\"%j\":try{return JSON.stringify(o[t++])}catch(r){return\"[Circular]\"}default:return r}}));for(var y=o[t];t<i;y=o[++t]){if(isNull(y)||!isObject(y)){a+=\" \"+y}else{a+=\" \"+inspect(y)}}return a};e.deprecate=function(r,t){if(typeof process!==\"undefined\"&&process.noDeprecation===true){return r}if(typeof process===\"undefined\"){return function(){return e.deprecate(r,t).apply(this,arguments)}}var o=false;function deprecated(){if(!o){if(process.throwDeprecation){throw new Error(t)}else if(process.traceDeprecation){console.trace(t)}else{console.error(t)}o=true}return r.apply(this,arguments)}return deprecated};var i={};var a=/^$/;if(process.env.NODE_DEBUG){var y=process.env.NODE_DEBUG;y=y.replace(/[|\\\\{}()[\\]^$+?.]/g,\"\\\\$&\").replace(/\\*/g,\".*\").replace(/,/g,\"$|^\").toUpperCase();a=new RegExp(\"^\"+y+\"$\",\"i\")}e.debuglog=function(r){r=r.toUpperCase();if(!i[r]){if(a.test(r)){var t=process.pid;i[r]=function(){var o=e.format.apply(e,arguments);console.error(\"%s %d: %s\",r,t,o)}}else{i[r]=function(){}}}return i[r]};function inspect(r,t){var o={seen:[],stylize:stylizeNoColor};if(arguments.length>=3)o.depth=arguments[2];if(arguments.length>=4)o.colors=arguments[3];if(isBoolean(t)){o.showHidden=t}else if(t){e._extend(o,t)}if(isUndefined(o.showHidden))o.showHidden=false;if(isUndefined(o.depth))o.depth=2;if(isUndefined(o.colors))o.colors=false;if(isUndefined(o.customInspect))o.customInspect=true;if(o.colors)o.stylize=stylizeWithColor;return formatValue(o,r,o.depth)}e.inspect=inspect;inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]};inspect.styles={special:\"cyan\",number:\"yellow\",boolean:\"yellow\",undefined:\"grey\",null:\"bold\",string:\"green\",date:\"magenta\",regexp:\"red\"};function stylizeWithColor(r,e){var t=inspect.styles[e];if(t){return\"\u001b[\"+inspect.colors[t][0]+\"m\"+r+\"\u001b[\"+inspect.colors[t][1]+\"m\"}else{return r}}function stylizeNoColor(r,e){return r}function arrayToHash(r){var e={};r.forEach((function(r,t){e[r]=true}));return e}function formatValue(r,t,o){if(r.customInspect&&t&&isFunction(t.inspect)&&t.inspect!==e.inspect&&!(t.constructor&&t.constructor.prototype===t)){var n=t.inspect(o,r);if(!isString(n)){n=formatValue(r,n,o)}return n}var i=formatPrimitive(r,t);if(i){return i}var a=Object.keys(t);var y=arrayToHash(a);if(r.showHidden){a=Object.getOwnPropertyNames(t)}if(isError(t)&&(a.indexOf(\"message\")>=0||a.indexOf(\"description\")>=0)){return formatError(t)}if(a.length===0){if(isFunction(t)){var f=t.name?\": \"+t.name:\"\";return r.stylize(\"[Function\"+f+\"]\",\"special\")}if(isRegExp(t)){return r.stylize(RegExp.prototype.toString.call(t),\"regexp\")}if(isDate(t)){return r.stylize(Date.prototype.toString.call(t),\"date\")}if(isError(t)){return formatError(t)}}var p=\"\",u=false,s=[\"{\",\"}\"];if(isArray(t)){u=true;s=[\"[\",\"]\"]}if(isFunction(t)){var c=t.name?\": \"+t.name:\"\";p=\" [Function\"+c+\"]\"}if(isRegExp(t)){p=\" \"+RegExp.prototype.toString.call(t)}if(isDate(t)){p=\" \"+Date.prototype.toUTCString.call(t)}if(isError(t)){p=\" \"+formatError(t)}if(a.length===0&&(!u||t.length==0)){return s[0]+p+s[1]}if(o<0){if(isRegExp(t)){return r.stylize(RegExp.prototype.toString.call(t),\"regexp\")}else{return r.stylize(\"[Object]\",\"special\")}}r.seen.push(t);var l;if(u){l=formatArray(r,t,o,y,a)}else{l=a.map((function(e){return formatProperty(r,t,o,y,e,u)}))}r.seen.pop();return reduceToSingleString(l,p,s)}function formatPrimitive(r,e){if(isUndefined(e))return r.stylize(\"undefined\",\"undefined\");if(isString(e)){var t=\"'\"+JSON.stringify(e).replace(/^\"|\"$/g,\"\").replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"')+\"'\";return r.stylize(t,\"string\")}if(isNumber(e))return r.stylize(\"\"+e,\"number\");if(isBoolean(e))return r.stylize(\"\"+e,\"boolean\");if(isNull(e))return r.stylize(\"null\",\"null\")}function formatError(r){return\"[\"+Error.prototype.toString.call(r)+\"]\"}function formatArray(r,e,t,o,n){var i=[];for(var a=0,y=e.length;a<y;++a){if(hasOwnProperty(e,String(a))){i.push(formatProperty(r,e,t,o,String(a),true))}else{i.push(\"\")}}n.forEach((function(n){if(!n.match(/^\\d+$/)){i.push(formatProperty(r,e,t,o,n,true))}}));return i}function formatProperty(r,e,t,o,n,i){var a,y,f;f=Object.getOwnPropertyDescriptor(e,n)||{value:e[n]};if(f.get){if(f.set){y=r.stylize(\"[Getter/Setter]\",\"special\")}else{y=r.stylize(\"[Getter]\",\"special\")}}else{if(f.set){y=r.stylize(\"[Setter]\",\"special\")}}if(!hasOwnProperty(o,n)){a=\"[\"+n+\"]\"}if(!y){if(r.seen.indexOf(f.value)<0){if(isNull(t)){y=formatValue(r,f.value,null)}else{y=formatValue(r,f.value,t-1)}if(y.indexOf(\"\\n\")>-1){if(i){y=y.split(\"\\n\").map((function(r){return\"  \"+r})).join(\"\\n\").substr(2)}else{y=\"\\n\"+y.split(\"\\n\").map((function(r){return\"   \"+r})).join(\"\\n\")}}}else{y=r.stylize(\"[Circular]\",\"special\")}}if(isUndefined(a)){if(i&&n.match(/^\\d+$/)){return y}a=JSON.stringify(\"\"+n);if(a.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)){a=a.substr(1,a.length-2);a=r.stylize(a,\"name\")}else{a=a.replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"').replace(/(^\"|\"$)/g,\"'\");a=r.stylize(a,\"string\")}}return a+\": \"+y}function reduceToSingleString(r,e,t){var o=0;var n=r.reduce((function(r,e){o++;if(e.indexOf(\"\\n\")>=0)o++;return r+e.replace(/\\u001b\\[\\d\\d?m/g,\"\").length+1}),0);if(n>60){return t[0]+(e===\"\"?\"\":e+\"\\n \")+\" \"+r.join(\",\\n  \")+\" \"+t[1]}return t[0]+e+\" \"+r.join(\", \")+\" \"+t[1]}e.types=t(584);function isArray(r){return Array.isArray(r)}e.isArray=isArray;function isBoolean(r){return typeof r===\"boolean\"}e.isBoolean=isBoolean;function isNull(r){return r===null}e.isNull=isNull;function isNullOrUndefined(r){return r==null}e.isNullOrUndefined=isNullOrUndefined;function isNumber(r){return typeof r===\"number\"}e.isNumber=isNumber;function isString(r){return typeof r===\"string\"}e.isString=isString;function isSymbol(r){return typeof r===\"symbol\"}e.isSymbol=isSymbol;function isUndefined(r){return r===void 0}e.isUndefined=isUndefined;function isRegExp(r){return isObject(r)&&objectToString(r)===\"[object RegExp]\"}e.isRegExp=isRegExp;e.types.isRegExp=isRegExp;function isObject(r){return typeof r===\"object\"&&r!==null}e.isObject=isObject;function isDate(r){return isObject(r)&&objectToString(r)===\"[object Date]\"}e.isDate=isDate;e.types.isDate=isDate;function isError(r){return isObject(r)&&(objectToString(r)===\"[object Error]\"||r instanceof Error)}e.isError=isError;e.types.isNativeError=isError;function isFunction(r){return typeof r===\"function\"}e.isFunction=isFunction;function isPrimitive(r){return r===null||typeof r===\"boolean\"||typeof r===\"number\"||typeof r===\"string\"||typeof r===\"symbol\"||typeof r===\"undefined\"}e.isPrimitive=isPrimitive;e.isBuffer=t(369);function objectToString(r){return Object.prototype.toString.call(r)}function pad(r){return r<10?\"0\"+r.toString(10):r.toString(10)}var f=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"];function timestamp(){var r=new Date;var e=[pad(r.getHours()),pad(r.getMinutes()),pad(r.getSeconds())].join(\":\");return[r.getDate(),f[r.getMonth()],e].join(\" \")}e.log=function(){console.log(\"%s - %s\",timestamp(),e.format.apply(e,arguments))};e.inherits=t(782);e._extend=function(r,e){if(!e||!isObject(e))return r;var t=Object.keys(e);var o=t.length;while(o--){r[t[o]]=e[t[o]]}return r};function hasOwnProperty(r,e){return Object.prototype.hasOwnProperty.call(r,e)}var p=typeof Symbol!==\"undefined\"?Symbol(\"util.promisify.custom\"):undefined;e.promisify=function promisify(r){if(typeof r!==\"function\")throw new TypeError('The \"original\" argument must be of type Function');if(p&&r[p]){var e=r[p];if(typeof e!==\"function\"){throw new TypeError('The \"util.promisify.custom\" argument must be of type Function')}Object.defineProperty(e,p,{value:e,enumerable:false,writable:false,configurable:true});return e}function e(){var e,t;var o=new Promise((function(r,o){e=r;t=o}));var n=[];for(var i=0;i<arguments.length;i++){n.push(arguments[i])}n.push((function(r,o){if(r){t(r)}else{e(o)}}));try{r.apply(this,n)}catch(r){t(r)}return o}Object.setPrototypeOf(e,Object.getPrototypeOf(r));if(p)Object.defineProperty(e,p,{value:e,enumerable:false,writable:false,configurable:true});return Object.defineProperties(e,o(r))};e.promisify.custom=p;function callbackifyOnRejected(r,e){if(!r){var t=new Error(\"Promise was rejected with a falsy value\");t.reason=r;r=t}return e(r)}function callbackify(r){if(typeof r!==\"function\"){throw new TypeError('The \"original\" argument must be of type Function')}function callbackified(){var e=[];for(var t=0;t<arguments.length;t++){e.push(arguments[t])}var o=e.pop();if(typeof o!==\"function\"){throw new TypeError(\"The last argument must be of type Function\")}var n=this;var cb=function(){return o.apply(n,arguments)};r.apply(this,e).then((function(r){process.nextTick(cb.bind(null,null,r))}),(function(r){process.nextTick(callbackifyOnRejected.bind(null,r,cb))}))}Object.setPrototypeOf(callbackified,Object.getPrototypeOf(r));Object.defineProperties(callbackified,o(r));return callbackified}e.callbackify=callbackify},490:function(r,e,t){\"use strict\";var o=t(144);var n=t(349);var i=t(256);var a=i(\"Object.prototype.toString\");var y=t(942)();var f=y&&typeof Symbol.toStringTag===\"symbol\";var p=n();var u=i(\"String.prototype.slice\");var s={};var c=t(24);var l=Object.getPrototypeOf;if(f&&c&&l){o(p,(function(r){if(typeof __webpack_require__.g[r]===\"function\"){var e=new __webpack_require__.g[r];if(!(Symbol.toStringTag in e)){throw new EvalError(\"this engine has support for Symbol.toStringTag, but \"+r+\" does not have the property! Please report this.\")}var t=l(e);var o=c(t,Symbol.toStringTag);if(!o){var n=l(t);o=c(n,Symbol.toStringTag)}s[r]=o.get}}))}var d=function tryAllTypedArrays(r){var e=false;o(s,(function(t,o){if(!e){try{var n=t.call(r);if(n===o){e=n}}catch(r){}}}));return e};var g=t(994);r.exports=function whichTypedArray(r){if(!g(r)){return false}if(!f){return u(a(r),8,-1)}return d(r)}},349:function(r,e,t){\"use strict\";var o=t(992);r.exports=function availableTypedArrays(){return o([\"BigInt64Array\",\"BigUint64Array\",\"Float32Array\",\"Float64Array\",\"Int16Array\",\"Int32Array\",\"Int8Array\",\"Uint16Array\",\"Uint32Array\",\"Uint8Array\",\"Uint8ClampedArray\"],(function(r){return typeof __webpack_require__.g[r]===\"function\"}))}},24:function(r,e,t){\"use strict\";var o=t(500);var n=o(\"%Object.getOwnPropertyDescriptor%\",true);if(n){try{n([],\"length\")}catch(r){n=null}}r.exports=n}};var e={};function __nccwpck_require__(t){var o=e[t];if(o!==undefined){return o.exports}var n=e[t]={exports:{}};var i=true;try{r[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete e[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(177);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvdXRpbC91dGlsLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBLFlBQVksT0FBTyxnQkFBZ0IsMEJBQTBCLGlDQUFpQyw0Q0FBNEMsNENBQTRDLFNBQVMsWUFBWSxXQUFXLEtBQUsseUJBQXlCLFdBQVcsNkJBQTZCLFVBQVUsc0NBQXNDLHFCQUFxQixhQUFhLGFBQWEsYUFBYSx1Q0FBdUMsMkNBQTJDLGVBQWUsaURBQWlELFlBQVksVUFBVSxxQkFBcUIsYUFBYSxhQUFhLGFBQWEsc0NBQXNDLHFDQUFxQyw2Q0FBNkMsa0RBQWtELHdDQUF3QyxzQkFBc0IsTUFBTSxJQUFJLElBQUksTUFBTSxRQUFRLEVBQUUsU0FBUyxRQUFRLCtCQUErQix1QkFBdUIsU0FBUyxvQkFBb0IsbUJBQW1CLGNBQWMsMkNBQTJDLEdBQUcsVUFBVSwyQkFBMkIseUJBQXlCLE1BQU0scUJBQXFCLFFBQVEsRUFBRSxLQUFLLG1CQUFtQixpQkFBaUIsc0NBQXNDLGdDQUFnQyxrQ0FBa0Msb0NBQW9DLG1EQUFtRCxlQUFlLFdBQVcsWUFBWSxJQUFJLEtBQUssb0JBQW9CLEtBQUssZ0JBQWdCLGdCQUFnQix1QkFBdUIsaUJBQWlCLGFBQWEsd0RBQXdELDRCQUE0QixnQ0FBZ0MsMEJBQTBCLDJCQUEyQixXQUFXLHlDQUF5Qyx5QkFBeUIsMEJBQTBCLE1BQU0sc0JBQXNCLHNCQUFzQixnREFBZ0Qsa0JBQWtCLFNBQVMsWUFBWSxLQUFLLGdEQUFnRCxvQ0FBb0MsU0FBUyxZQUFZLElBQUksS0FBSyxjQUFjLHdEQUF3RCxzQ0FBc0MsV0FBVyxnQkFBZ0IseUJBQXlCLHdCQUF3QixrQkFBa0IsaUJBQWlCLFVBQVUscUJBQXFCLGFBQWEsYUFBYSxxQ0FBcUMscUJBQXFCLGFBQWEsTUFBTSxrQkFBa0IsZUFBZSxnQkFBZ0Isc0NBQXNDLElBQUksd0JBQXdCLDJCQUEyQixLQUFLLFlBQVksc0NBQXNDLE1BQU0sSUFB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X0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcz8zOTU0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciByPXs5OTI6ZnVuY3Rpb24ocil7ci5leHBvcnRzPWZ1bmN0aW9uKHIsdCxvKXtpZihyLmZpbHRlcilyZXR1cm4gci5maWx0ZXIodCxvKTtpZih2b2lkIDA9PT1yfHxudWxsPT09cil0aHJvdyBuZXcgVHlwZUVycm9yO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgbj1bXTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl7aWYoIWUuY2FsbChyLGkpKWNvbnRpbnVlO3ZhciBhPXJbaV07aWYodC5jYWxsKG8sYSxpLHIpKW4ucHVzaChhKX1yZXR1cm4gbn07dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eX0sMjU2OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbz10KDkyNSk7dmFyIG49dCgxMzkpO3ZhciBpPW4obyhcIlN0cmluZy5wcm90b3R5cGUuaW5kZXhPZlwiKSk7ci5leHBvcnRzPWZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhyLGUpe3ZhciB0PW8ociwhIWUpO2lmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiJiZpKHIsXCIucHJvdG90eXBlLlwiKT4tMSl7cmV0dXJuIG4odCl9cmV0dXJuIHR9fSwxMzk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTc0KTt2YXIgbj10KDkyNSk7dmFyIGk9bihcIiVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklXCIpO3ZhciBhPW4oXCIlRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlXCIpO3ZhciB5PW4oXCIlUmVmbGVjdC5hcHBseSVcIix0cnVlKXx8by5jYWxsKGEsaSk7dmFyIGY9bihcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLHRydWUpO3ZhciBwPW4oXCIlT2JqZWN0LmRlZmluZVByb3BlcnR5JVwiLHRydWUpO3ZhciB1PW4oXCIlTWF0aC5tYXglXCIpO2lmKHApe3RyeXtwKHt9LFwiYVwiLHt2YWx1ZToxfSl9Y2F0Y2gocil7cD1udWxsfX1yLmV4cG9ydHM9ZnVuY3Rpb24gY2FsbEJpbmQocil7dmFyIGU9eShvLGEsYXJndW1lbnRzKTtpZihmJiZwKXt2YXIgdD1mKGUsXCJsZW5ndGhcIik7aWYodC5jb25maWd1cmFibGUpe3AoZSxcImxlbmd0aFwiLHt2YWx1ZToxK3UoMCxyLmxlbmd0aC0oYXJndW1lbnRzLmxlbmd0aC0xKSl9KX19cmV0dXJuIGV9O3ZhciBzPWZ1bmN0aW9uIGFwcGx5QmluZCgpe3JldHVybiB5KG8saSxhcmd1bWVudHMpfTtpZihwKXtwKHIuZXhwb3J0cyxcImFwcGx5XCIse3ZhbHVlOnN9KX1lbHNle3IuZXhwb3J0cy5hcHBseT1zfX0sMTQ0OmZ1bmN0aW9uKHIpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztyLmV4cG9ydHM9ZnVuY3Rpb24gZm9yRWFjaChyLG8sbil7aWYodC5jYWxsKG8pIT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpfXZhciBpPXIubGVuZ3RoO2lmKGk9PT0raSl7Zm9yKHZhciBhPTA7YTxpO2ErKyl7by5jYWxsKG4sclthXSxhLHIpfX1lbHNle2Zvcih2YXIgeSBpbiByKXtpZihlLmNhbGwocix5KSl7by5jYWxsKG4sclt5XSx5LHIpfX19fX0sNDI2OmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPVwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcIjt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2U7dmFyIG89T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgbj1cIltvYmplY3QgRnVuY3Rpb25dXCI7ci5leHBvcnRzPWZ1bmN0aW9uIGJpbmQocil7dmFyIGk9dGhpcztpZih0eXBlb2YgaSE9PVwiZnVuY3Rpb25cInx8by5jYWxsKGkpIT09bil7dGhyb3cgbmV3IFR5cGVFcnJvcihlK2kpfXZhciBhPXQuY2FsbChhcmd1bWVudHMsMSk7dmFyIHk7dmFyIGJpbmRlcj1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiB5KXt2YXIgZT1pLmFwcGx5KHRoaXMsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKTtpZihPYmplY3QoZSk9PT1lKXtyZXR1cm4gZX1yZXR1cm4gdGhpc31lbHNle3JldHVybiBpLmFwcGx5KHIsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKX19O3ZhciBmPU1hdGgubWF4KDAsaS5sZW5ndGgtYS5sZW5ndGgpO3ZhciBwPVtdO2Zvcih2YXIgdT0wO3U8Zjt1Kyspe3AucHVzaChcIiRcIit1KX15PUZ1bmN0aW9uKFwiYmluZGVyXCIsXCJyZXR1cm4gZnVuY3Rpb24gKFwiK3Auam9pbihcIixcIikrXCIpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfVwiKShiaW5kZXIpO2lmKGkucHJvdG90eXBlKXt2YXIgcz1mdW5jdGlvbiBFbXB0eSgpe307cy5wcm90b3R5cGU9aS5wcm90b3R5cGU7eS5wcm90b3R5cGU9bmV3IHM7cy5wcm90b3R5cGU9bnVsbH1yZXR1cm4geX19LDE3NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCg0MjYpO3IuZXhwb3J0cz1GdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8b30sNTAwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbzt2YXIgbj1TeW50YXhFcnJvcjt2YXIgaT1GdW5jdGlvbjt2YXIgYT1UeXBlRXJyb3I7dmFyIGdldEV2YWxsZWRDb25zdHJ1Y3Rvcj1mdW5jdGlvbihyKXt0cnl7cmV0dXJuIGkoJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcrcitcIikuY29uc3RydWN0b3I7XCIpKCl9Y2F0Y2gocil7fX07dmFyIHk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtpZih5KXt0cnl7eSh7fSxcIlwiKX1jYXRjaChyKXt5PW51bGx9fXZhciB0aHJvd1R5cGVFcnJvcj1mdW5jdGlvbigpe3Rocm93IG5ldyBhfTt2YXIgZj15P2Z1bmN0aW9uKCl7dHJ5e2FyZ3VtZW50cy5jYWxsZWU7cmV0dXJuIHRocm93VHlwZUVycm9yfWNhdGNoKHIpe3RyeXtyZXR1cm4geShhcmd1bWVudHMsXCJjYWxsZWVcIikuZ2V0fWNhdGNoKHIpe3JldHVybiB0aHJvd1R5cGVFcnJvcn19fSgpOnRocm93VHlwZUVycm9yO3ZhciBwPXQoMTE1KSgpO3ZhciB1PU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocil7cmV0dXJuIHIuX19wcm90b19ffTt2YXIgcz17fTt2YXIgYz10eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzp1KFVpbnQ4QXJyYXkpO3ZhciBsPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP286QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6byxcIiVBc3luY0Z1bmN0aW9uJVwiOnMsXCIlQXN5bmNHZW5lcmF0b3IlXCI6cyxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOnMsXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpzLFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP286QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQsXCIlQm9vbGVhbiVcIjpCb29sZWFuLFwiJURhdGFWaWV3JVwiOnR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCI/bzpEYXRhVmlldyxcIiVEYXRlJVwiOkRhdGUsXCIlZGVjb2RlVVJJJVwiOmRlY29kZVVSSSxcIiVkZWNvZGVVUklDb21wb25lbnQlXCI6ZGVjb2RlVVJJQ29tcG9uZW50LFwiJWVuY29kZVVSSSVcIjplbmNvZGVVUkksXCIlZW5jb2RlVVJJQ29tcG9uZW50JVwiOmVuY29kZVVSSUNvbXBvbmVudCxcIiVFcnJvciVcIjpFcnJvcixcIiVldmFsJVwiOmV2YWwsXCIlRXZhbEVycm9yJVwiOkV2YWxFcnJvcixcIiVGbG9hdDMyQXJyYXklXCI6dHlwZW9mIEZsb2F0MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bzpGbG9hdDMyQXJyYXksXCIlRmxvYXQ2NEFycmF5JVwiOnR5cGVvZiBGbG9hdDY0QXJyYXk9PT1cInVuZGVmaW5lZFwiP286RmxvYXQ2NEFycmF5LFwiJUZpbmFsaXphdGlvblJlZ2lzdHJ5JVwiOnR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeT09PVwidW5kZWZpbmVkXCI/bzpGaW5hbGl6YXRpb25SZWdpc3RyeSxcIiVGdW5jdGlvbiVcIjppLFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiOnMsXCIlSW50OEFycmF5JVwiOnR5cGVvZiBJbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50OEFycmF5LFwiJUludDE2QXJyYXklXCI6dHlwZW9mIEludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50MTZBcnJheSxcIiVJbnQzMkFycmF5JVwiOnR5cGVvZiBJbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOkludDMyQXJyYXksXCIlaXNGaW5pdGUlXCI6aXNGaW5pdGUsXCIlaXNOYU4lXCI6aXNOYU4sXCIlSXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KHUoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSk6byxcIiVKU09OJVwiOnR5cGVvZiBKU09OPT09XCJvYmplY3RcIj9KU09OOm8sXCIlTWFwJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwiP286TWFwLFwiJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwifHwhcD9vOnUoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bzpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bzpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bzpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP286U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcD9vOnUoKG5ldyBTZXQpW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlU2hhcmVkQXJyYXlCdWZmZXIlXCI6dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOlNoYXJlZEFycmF5QnVmZmVyLFwiJVN0cmluZyVcIjpTdHJpbmcsXCIlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KFwiXCJbU3ltYm9sLml0ZXJhdG9yXSgpKTpvLFwiJVN5bWJvbCVcIjpwP1N5bWJvbDpvLFwiJVN5bnRheEVycm9yJVwiOm4sXCIlVGhyb3dUeXBlRXJyb3IlXCI6ZixcIiVUeXBlZEFycmF5JVwiOmMsXCIlVHlwZUVycm9yJVwiOmEsXCIlVWludDhBcnJheSVcIjp0eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50OEFycmF5LFwiJVVpbnQ4Q2xhbXBlZEFycmF5JVwiOnR5cGVvZiBVaW50OENsYW1wZWRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50OENsYW1wZWRBcnJheSxcIiVVaW50MTZBcnJheSVcIjp0eXBlb2YgVWludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDE2QXJyYXksXCIlVWludDMyQXJyYXklXCI6dHlwZW9mIFVpbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOlVpbnQzMkFycmF5LFwiJVVSSUVycm9yJVwiOlVSSUVycm9yLFwiJVdlYWtNYXAlXCI6dHlwZW9mIFdlYWtNYXA9PT1cInVuZGVmaW5lZFwiP286V2Vha01hcCxcIiVXZWFrUmVmJVwiOnR5cGVvZiBXZWFrUmVmPT09XCJ1bmRlZmluZWRcIj9vOldlYWtSZWYsXCIlV2Vha1NldCVcIjp0eXBlb2YgV2Vha1NldD09PVwidW5kZWZpbmVkXCI/bzpXZWFrU2V0fTt2YXIgZD1mdW5jdGlvbiBkb0V2YWwocil7dmFyIGU7aWYocj09PVwiJUFzeW5jRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24gKCkge31cIil9ZWxzZSBpZihyPT09XCIlR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yJVwiKXt2YXIgdD1kb0V2YWwoXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIik7aWYodCl7ZT10LnByb3RvdHlwZX19ZWxzZSBpZihyPT09XCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIil7dmFyIG89ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yJVwiKTtpZihvKXtlPXUoby5wcm90b3R5cGUpfX1sW3JdPWU7cmV0dXJuIGV9O3ZhciBnPXtcIiVBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG90eXBlJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b19lbnRyaWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImVudHJpZXNcIl0sXCIlQXJyYXlQcm90b19mb3JFYWNoJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImZvckVhY2hcIl0sXCIlQXJyYXlQcm90b19rZXlzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImtleXNcIl0sXCIlQXJyYXlQcm90b192YWx1ZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwidmFsdWVzXCJdLFwiJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiQXN5bmNGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVCb29sZWFuUHJvdG90eXBlJVwiOltcIkJvb2xlYW5cIixcInByb3RvdHlwZVwiXSxcIiVEYXRhVmlld1Byb3RvdHlwZSVcIjpbXCJEYXRhVmlld1wiLFwicHJvdG90eXBlXCJdLFwiJURhdGVQcm90b3R5cGUlXCI6W1wiRGF0ZVwiLFwicHJvdG90eXBlXCJdLFwiJUVycm9yUHJvdG90eXBlJVwiOltcIkVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRXZhbEVycm9yUHJvdG90eXBlJVwiOltcIkV2YWxFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0MzJBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDY0QXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQ2NEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3IlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUludDhBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIkludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIkludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVKU09OUGFyc2UlXCI6W1wiSlNPTlwiLFwicGFyc2VcIl0sXCIlSlNPTlN0cmluZ2lmeSVcIjpbXCJKU09OXCIsXCJzdHJpbmdpZnlcIl0sXCIlTWFwUHJvdG90eXBlJVwiOltcIk1hcFwiLFwicHJvdG90eXBlXCJdLFwiJU51bWJlclByb3RvdHlwZSVcIjpbXCJOdW1iZXJcIixcInByb3RvdHlwZVwiXSxcIiVPYmplY3RQcm90b3R5cGUlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqUHJvdG9fdG9TdHJpbmclXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInRvU3RyaW5nXCJdLFwiJU9ialByb3RvX3ZhbHVlT2YlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInZhbHVlT2ZcIl0sXCIlUHJvbWlzZVByb3RvdHlwZSVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIl0sXCIlUHJvbWlzZVByb3RvX3RoZW4lXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCIsXCJ0aGVuXCJdLFwiJVByb21pc2VfYWxsJVwiOltcIlByb21pc2VcIixcImFsbFwiXSxcIiVQcm9taXNlX3JlamVjdCVcIjpbXCJQcm9taXNlXCIsXCJyZWplY3RcIl0sXCIlUHJvbWlzZV9yZXNvbHZlJVwiOltcIlByb21pc2VcIixcInJlc29sdmVcIl0sXCIlUmFuZ2VFcnJvclByb3RvdHlwZSVcIjpbXCJSYW5nZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmVmZXJlbmNlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWdFeHBQcm90b3R5cGUlXCI6W1wiUmVnRXhwXCIsXCJwcm90b3R5cGVcIl0sXCIlU2V0UHJvdG90eXBlJVwiOltcIlNldFwiLFwicHJvdG90eXBlXCJdLFwiJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIlNoYXJlZEFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlU3RyaW5nUHJvdG90eXBlJVwiOltcIlN0cmluZ1wiLFwicHJvdG90eXBlXCJdLFwiJVN5bWJvbFByb3RvdHlwZSVcIjpbXCJTeW1ib2xcIixcInByb3RvdHlwZVwiXSxcIiVTeW50YXhFcnJvclByb3RvdHlwZSVcIjpbXCJTeW50YXhFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVHlwZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVFcnJvclByb3RvdHlwZSVcIjpbXCJUeXBlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OENsYW1wZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVUklFcnJvclByb3RvdHlwZSVcIjpbXCJVUklFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtNYXBQcm90b3R5cGUlXCI6W1wiV2Vha01hcFwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtTZXRQcm90b3R5cGUlXCI6W1wiV2Vha1NldFwiLFwicHJvdG90eXBlXCJdfTt2YXIgdj10KDE3NCk7dmFyIGI9dCgxMDEpO3ZhciBBPXYuY2FsbChGdW5jdGlvbi5jYWxsLEFycmF5LnByb3RvdHlwZS5jb25jYXQpO3ZhciBtPXYuY2FsbChGdW5jdGlvbi5hcHBseSxBcnJheS5wcm90b3R5cGUuc3BsaWNlKTt2YXIgUz12LmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO3ZhciBoPXYuY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO3ZhciBQPXYuY2FsbChGdW5jdGlvbi5jYWxsLFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7dmFyIE89L1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7dmFyIHc9L1xcXFwoXFxcXCk/L2c7dmFyIGo9ZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHIpe3ZhciBlPWgociwwLDEpO3ZhciB0PWgociwtMSk7aWYoZT09PVwiJVwiJiZ0IT09XCIlXCIpe3Rocm93IG5ldyBuKFwiaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYFwiKX1lbHNlIGlmKHQ9PT1cIiVcIiYmZSE9PVwiJVwiKXt0aHJvdyBuZXcgbihcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWBcIil9dmFyIG89W107UyhyLE8sKGZ1bmN0aW9uKHIsZSx0LG4pe29bby5sZW5ndGhdPXQ/UyhuLHcsXCIkMVwiKTplfHxyfSkpO3JldHVybiBvfTt2YXIgRT1mdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKHIsZSl7dmFyIHQ9cjt2YXIgbztpZihiKGcsdCkpe289Z1t0XTt0PVwiJVwiK29bMF0rXCIlXCJ9aWYoYihsLHQpKXt2YXIgaT1sW3RdO2lmKGk9PT1zKXtpPWQodCl9aWYodHlwZW9mIGk9PT1cInVuZGVmaW5lZFwiJiYhZSl7dGhyb3cgbmV3IGEoXCJpbnRyaW5zaWMgXCIrcitcIiBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSFcIil9cmV0dXJue2FsaWFzOm8sbmFtZTp0LHZhbHVlOml9fXRocm93IG5ldyBuKFwiaW50cmluc2ljIFwiK3IrXCIgZG9lcyBub3QgZXhpc3QhXCIpfTtyLmV4cG9ydHM9ZnVuY3Rpb24gR2V0SW50cmluc2ljKHIsZSl7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyLmxlbmd0aD09PTApe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9aWYoYXJndW1lbnRzLmxlbmd0aD4xJiZ0eXBlb2YgZSE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgYSgnXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpfWlmKFAoL14lP1teJV0qJT8kL2cscik9PT1udWxsKXt0aHJvdyBuZXcgbihcImAlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWVcIil9dmFyIHQ9aihyKTt2YXIgaT10Lmxlbmd0aD4wP3RbMF06XCJcIjt2YXIgZj1FKFwiJVwiK2krXCIlXCIsZSk7dmFyIHA9Zi5uYW1lO3ZhciB1PWYudmFsdWU7dmFyIHM9ZmFsc2U7dmFyIGM9Zi5hbGlhcztpZihjKXtpPWNbMF07bSh0LEEoWzAsMV0sYykpfWZvcih2YXIgZD0xLGc9dHJ1ZTtkPHQubGVuZ3RoO2QrPTEpe3ZhciB2PXRbZF07dmFyIFM9aCh2LDAsMSk7dmFyIE89aCh2LC0xKTtpZigoUz09PSdcIid8fFM9PT1cIidcInx8Uz09PVwiYFwifHwoTz09PSdcIid8fE89PT1cIidcInx8Tz09PVwiYFwiKSkmJlMhPT1PKXt0aHJvdyBuZXcgbihcInByb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXNcIil9aWYodj09PVwiY29uc3RydWN0b3JcInx8IWcpe3M9dHJ1ZX1pKz1cIi5cIit2O3A9XCIlXCIraStcIiVcIjtpZihiKGwscCkpe3U9bFtwXX1lbHNlIGlmKHUhPW51bGwpe2lmKCEodiBpbiB1KSl7aWYoIWUpe3Rocm93IG5ldyBhKFwiYmFzZSBpbnRyaW5zaWMgZm9yIFwiK3IrXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpfXJldHVybiB2b2lkIG99aWYoeSYmZCsxPj10Lmxlbmd0aCl7dmFyIHc9eSh1LHYpO2c9ISF3O2lmKGcmJlwiZ2V0XCJpbiB3JiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gdy5nZXQpKXt1PXcuZ2V0fWVsc2V7dT11W3ZdfX1lbHNle2c9Yih1LHYpO3U9dVt2XX1pZihnJiYhcyl7bFtwXT11fX19cmV0dXJuIHV9fSw5MjU6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvO3ZhciBuPVN5bnRheEVycm9yO3ZhciBpPUZ1bmN0aW9uO3ZhciBhPVR5cGVFcnJvcjt2YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yPWZ1bmN0aW9uKHIpe3RyeXtyZXR1cm4gaSgnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJytyK1wiKS5jb25zdHJ1Y3RvcjtcIikoKX1jYXRjaChyKXt9fTt2YXIgeT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2lmKHkpe3RyeXt5KHt9LFwiXCIpfWNhdGNoKHIpe3k9bnVsbH19dmFyIHRocm93VHlwZUVycm9yPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IGF9O3ZhciBmPXk/ZnVuY3Rpb24oKXt0cnl7YXJndW1lbnRzLmNhbGxlZTtyZXR1cm4gdGhyb3dUeXBlRXJyb3J9Y2F0Y2gocil7dHJ5e3JldHVybiB5KGFyZ3VtZW50cyxcImNhbGxlZVwiKS5nZXR9Y2F0Y2gocil7cmV0dXJuIHRocm93VHlwZUVycm9yfX19KCk6dGhyb3dUeXBlRXJyb3I7dmFyIHA9dCgxMTUpKCk7dmFyIHU9dCg1MDQpKCk7dmFyIHM9T2JqZWN0LmdldFByb3RvdHlwZU9mfHwodT9mdW5jdGlvbihyKXtyZXR1cm4gci5fX3Byb3RvX199Om51bGwpO3ZhciBjPXt9O3ZhciBsPXR5cGVvZiBVaW50OEFycmF5PT09XCJ1bmRlZmluZWRcInx8IXM/bzpzKFVpbnQ4QXJyYXkpO3ZhciBkPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP286QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cCYmcz9zKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6byxcIiVBc3luY0Z1bmN0aW9uJVwiOmMsXCIlQXN5bmNHZW5lcmF0b3IlXCI6YyxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOmMsXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpjLFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP286QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQsXCIlQmlnSW50NjRBcnJheSVcIjp0eXBlb2YgQmlnSW50NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQ2NEFycmF5LFwiJUJpZ1VpbnQ2NEFycmF5JVwiOnR5cGVvZiBCaWdVaW50NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpCaWdVaW50NjRBcnJheSxcIiVCb29sZWFuJVwiOkJvb2xlYW4sXCIlRGF0YVZpZXclXCI6dHlwZW9mIERhdGFWaWV3PT09XCJ1bmRlZmluZWRcIj9vOkRhdGFWaWV3LFwiJURhdGUlXCI6RGF0ZSxcIiVkZWNvZGVVUkklXCI6ZGVjb2RlVVJJLFwiJWRlY29kZVVSSUNvbXBvbmVudCVcIjpkZWNvZGVVUklDb21wb25lbnQsXCIlZW5jb2RlVVJJJVwiOmVuY29kZVVSSSxcIiVlbmNvZGVVUklDb21wb25lbnQlXCI6ZW5jb2RlVVJJQ29tcG9uZW50LFwiJUVycm9yJVwiOkVycm9yLFwiJWV2YWwlXCI6ZXZhbCxcIiVFdmFsRXJyb3IlXCI6RXZhbEVycm9yLFwiJUZsb2F0MzJBcnJheSVcIjp0eXBlb2YgRmxvYXQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOkZsb2F0MzJBcnJheSxcIiVGbG9hdDY0QXJyYXklXCI6dHlwZW9mIEZsb2F0NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpGbG9hdDY0QXJyYXksXCIlRmluYWxpemF0aW9uUmVnaXN0cnklXCI6dHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5PT09XCJ1bmRlZmluZWRcIj9vOkZpbmFsaXphdGlvblJlZ2lzdHJ5LFwiJUZ1bmN0aW9uJVwiOmksXCIlR2VuZXJhdG9yRnVuY3Rpb24lXCI6YyxcIiVJbnQ4QXJyYXklXCI6dHlwZW9mIEludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzpJbnQ4QXJyYXksXCIlSW50MTZBcnJheSVcIjp0eXBlb2YgSW50MTZBcnJheT09PVwidW5kZWZpbmVkXCI/bzpJbnQxNkFycmF5LFwiJUludDMyQXJyYXklXCI6dHlwZW9mIEludDMyQXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50MzJBcnJheSxcIiVpc0Zpbml0ZSVcIjppc0Zpbml0ZSxcIiVpc05hTiVcIjppc05hTixcIiVJdGVyYXRvclByb3RvdHlwZSVcIjpwJiZzP3MocyhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKTpvLFwiJUpTT04lXCI6dHlwZW9mIEpTT049PT1cIm9iamVjdFwiP0pTT046byxcIiVNYXAlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCI/bzpNYXAsXCIlTWFwSXRlcmF0b3JQcm90b3R5cGUlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCJ8fCFwfHwhcz9vOnMoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bzpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bzpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bzpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP286U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcHx8IXM/bzpzKChuZXcgU2V0KVtTeW1ib2wuaXRlcmF0b3JdKCkpLFwiJVNoYXJlZEFycmF5QnVmZmVyJVwiOnR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCI/bzpTaGFyZWRBcnJheUJ1ZmZlcixcIiVTdHJpbmclXCI6U3RyaW5nLFwiJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVwiOnAmJnM/cyhcIlwiW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVTeW1ib2wlXCI6cD9TeW1ib2w6byxcIiVTeW50YXhFcnJvciVcIjpuLFwiJVRocm93VHlwZUVycm9yJVwiOmYsXCIlVHlwZWRBcnJheSVcIjpsLFwiJVR5cGVFcnJvciVcIjphLFwiJVVpbnQ4QXJyYXklXCI6dHlwZW9mIFVpbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDhBcnJheSxcIiVVaW50OENsYW1wZWRBcnJheSVcIjp0eXBlb2YgVWludDhDbGFtcGVkQXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDhDbGFtcGVkQXJyYXksXCIlVWludDE2QXJyYXklXCI6dHlwZW9mIFVpbnQxNkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOlVpbnQxNkFycmF5LFwiJVVpbnQzMkFycmF5JVwiOnR5cGVvZiBVaW50MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50MzJBcnJheSxcIiVVUklFcnJvciVcIjpVUklFcnJvcixcIiVXZWFrTWFwJVwiOnR5cGVvZiBXZWFrTWFwPT09XCJ1bmRlZmluZWRcIj9vOldlYWtNYXAsXCIlV2Vha1JlZiVcIjp0eXBlb2YgV2Vha1JlZj09PVwidW5kZWZpbmVkXCI/bzpXZWFrUmVmLFwiJVdlYWtTZXQlXCI6dHlwZW9mIFdlYWtTZXQ9PT1cInVuZGVmaW5lZFwiP286V2Vha1NldH07aWYocyl7dHJ5e251bGwuZXJyb3J9Y2F0Y2gocil7dmFyIGc9cyhzKHIpKTtkW1wiJUVycm9yLnByb3RvdHlwZSVcIl09Z319dmFyIHY9ZnVuY3Rpb24gZG9FdmFsKHIpe3ZhciBlO2lmKHI9PT1cIiVBc3luY0Z1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImFzeW5jIGZ1bmN0aW9uICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImZ1bmN0aW9uKiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImFzeW5jIGZ1bmN0aW9uKiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVBc3luY0dlbmVyYXRvciVcIil7dmFyIHQ9ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpO2lmKHQpe2U9dC5wcm90b3R5cGV9fWVsc2UgaWYocj09PVwiJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlXCIpe3ZhciBvPWRvRXZhbChcIiVBc3luY0dlbmVyYXRvciVcIik7aWYobyYmcyl7ZT1zKG8ucHJvdG90eXBlKX19ZFtyXT1lO3JldHVybiBlfTt2YXIgYj17XCIlQXJyYXlCdWZmZXJQcm90b3R5cGUlXCI6W1wiQXJyYXlCdWZmZXJcIixcInByb3RvdHlwZVwiXSxcIiVBcnJheVByb3RvdHlwZSVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG9fZW50cmllcyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJlbnRyaWVzXCJdLFwiJUFycmF5UHJvdG9fZm9yRWFjaCVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJmb3JFYWNoXCJdLFwiJUFycmF5UHJvdG9fa2V5cyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJrZXlzXCJdLFwiJUFycmF5UHJvdG9fdmFsdWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcInZhbHVlc1wiXSxcIiVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJVwiOltcIkFzeW5jRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvciVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCIsXCJwcm90b3R5cGVcIl0sXCIlQm9vbGVhblByb3RvdHlwZSVcIjpbXCJCb29sZWFuXCIsXCJwcm90b3R5cGVcIl0sXCIlRGF0YVZpZXdQcm90b3R5cGUlXCI6W1wiRGF0YVZpZXdcIixcInByb3RvdHlwZVwiXSxcIiVEYXRlUHJvdG90eXBlJVwiOltcIkRhdGVcIixcInByb3RvdHlwZVwiXSxcIiVFcnJvclByb3RvdHlwZSVcIjpbXCJFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUV2YWxFcnJvclByb3RvdHlwZSVcIjpbXCJFdmFsRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRmxvYXQ2NEFycmF5UHJvdG90eXBlJVwiOltcIkZsb2F0NjRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUZ1bmN0aW9uUHJvdG90eXBlJVwiOltcIkZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlR2VuZXJhdG9yJVwiOltcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlR2VuZXJhdG9yUHJvdG90eXBlJVwiOltcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVJbnQ4QXJyYXlQcm90b3R5cGUlXCI6W1wiSW50OEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSW50MTZBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSW50MzJBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSlNPTlBhcnNlJVwiOltcIkpTT05cIixcInBhcnNlXCJdLFwiJUpTT05TdHJpbmdpZnklXCI6W1wiSlNPTlwiLFwic3RyaW5naWZ5XCJdLFwiJU1hcFByb3RvdHlwZSVcIjpbXCJNYXBcIixcInByb3RvdHlwZVwiXSxcIiVOdW1iZXJQcm90b3R5cGUlXCI6W1wiTnVtYmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqZWN0UHJvdG90eXBlJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCJdLFwiJU9ialByb3RvX3RvU3RyaW5nJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCIsXCJ0b1N0cmluZ1wiXSxcIiVPYmpQcm90b192YWx1ZU9mJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCIsXCJ2YWx1ZU9mXCJdLFwiJVByb21pc2VQcm90b3R5cGUlXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCJdLFwiJVByb21pc2VQcm90b190aGVuJVwiOltcIlByb21pc2VcIixcInByb3RvdHlwZVwiLFwidGhlblwiXSxcIiVQcm9taXNlX2FsbCVcIjpbXCJQcm9taXNlXCIsXCJhbGxcIl0sXCIlUHJvbWlzZV9yZWplY3QlXCI6W1wiUHJvbWlzZVwiLFwicmVqZWN0XCJdLFwiJVByb21pc2VfcmVzb2x2ZSVcIjpbXCJQcm9taXNlXCIsXCJyZXNvbHZlXCJdLFwiJVJhbmdlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmFuZ2VFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJVwiOltcIlJlZmVyZW5jZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVnRXhwUHJvdG90eXBlJVwiOltcIlJlZ0V4cFwiLFwicHJvdG90eXBlXCJdLFwiJVNldFByb3RvdHlwZSVcIjpbXCJTZXRcIixcInByb3RvdHlwZVwiXSxcIiVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJTaGFyZWRBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJVN0cmluZ1Byb3RvdHlwZSVcIjpbXCJTdHJpbmdcIixcInByb3RvdHlwZVwiXSxcIiVTeW1ib2xQcm90b3R5cGUlXCI6W1wiU3ltYm9sXCIsXCJwcm90b3R5cGVcIl0sXCIlU3ludGF4RXJyb3JQcm90b3R5cGUlXCI6W1wiU3ludGF4RXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVUeXBlZEFycmF5UHJvdG90eXBlJVwiOltcIlR5cGVkQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVUeXBlRXJyb3JQcm90b3R5cGUlXCI6W1wiVHlwZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDhBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDhDbGFtcGVkQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50MTZBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50MTZBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVVJJRXJyb3JQcm90b3R5cGUlXCI6W1wiVVJJRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVXZWFrTWFwUHJvdG90eXBlJVwiOltcIldlYWtNYXBcIixcInByb3RvdHlwZVwiXSxcIiVXZWFrU2V0UHJvdG90eXBlJVwiOltcIldlYWtTZXRcIixcInByb3RvdHlwZVwiXX07dmFyIEE9dCgxNzQpO3ZhciBtPXQoMTAxKTt2YXIgUz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxBcnJheS5wcm90b3R5cGUuY29uY2F0KTt2YXIgaD1BLmNhbGwoRnVuY3Rpb24uYXBwbHksQXJyYXkucHJvdG90eXBlLnNwbGljZSk7dmFyIFA9QS5jYWxsKEZ1bmN0aW9uLmNhbGwsU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTt2YXIgTz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnNsaWNlKTt2YXIgdz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxSZWdFeHAucHJvdG90eXBlLmV4ZWMpO3ZhciBqPS9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO3ZhciBFPS9cXFxcKFxcXFwpPy9nO3ZhciBJPWZ1bmN0aW9uIHN0cmluZ1RvUGF0aChyKXt2YXIgZT1PKHIsMCwxKTt2YXIgdD1PKHIsLTEpO2lmKGU9PT1cIiVcIiYmdCE9PVwiJVwiKXt0aHJvdyBuZXcgbihcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWBcIil9ZWxzZSBpZih0PT09XCIlXCImJmUhPT1cIiVcIil7dGhyb3cgbmV3IG4oXCJpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgXCIpfXZhciBvPVtdO1AocixqLChmdW5jdGlvbihyLGUsdCxuKXtvW28ubGVuZ3RoXT10P1AobixFLFwiJDFcIik6ZXx8cn0pKTtyZXR1cm4gb307dmFyIEI9ZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhyLGUpe3ZhciB0PXI7dmFyIG87aWYobShiLHQpKXtvPWJbdF07dD1cIiVcIitvWzBdK1wiJVwifWlmKG0oZCx0KSl7dmFyIGk9ZFt0XTtpZihpPT09Yyl7aT12KHQpfWlmKHR5cGVvZiBpPT09XCJ1bmRlZmluZWRcIiYmIWUpe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIFwiK3IrXCIgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhXCIpfXJldHVybnthbGlhczpvLG5hbWU6dCx2YWx1ZTppfX10aHJvdyBuZXcgbihcImludHJpbnNpYyBcIityK1wiIGRvZXMgbm90IGV4aXN0IVwiKX07ci5leHBvcnRzPWZ1bmN0aW9uIEdldEludHJpbnNpYyhyLGUpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8ci5sZW5ndGg9PT0wKXt0aHJvdyBuZXcgYShcImludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWlmKGFyZ3VtZW50cy5sZW5ndGg+MSYmdHlwZW9mIGUhPT1cImJvb2xlYW5cIil7dGhyb3cgbmV3IGEoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKX1pZih3KC9eJT9bXiVdKiU/JC8scik9PT1udWxsKXt0aHJvdyBuZXcgbihcImAlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWVcIil9dmFyIHQ9SShyKTt2YXIgaT10Lmxlbmd0aD4wP3RbMF06XCJcIjt2YXIgZj1CKFwiJVwiK2krXCIlXCIsZSk7dmFyIHA9Zi5uYW1lO3ZhciB1PWYudmFsdWU7dmFyIHM9ZmFsc2U7dmFyIGM9Zi5hbGlhcztpZihjKXtpPWNbMF07aCh0LFMoWzAsMV0sYykpfWZvcih2YXIgbD0xLGc9dHJ1ZTtsPHQubGVuZ3RoO2wrPTEpe3ZhciB2PXRbbF07dmFyIGI9Tyh2LDAsMSk7dmFyIEE9Tyh2LC0xKTtpZigoYj09PSdcIid8fGI9PT1cIidcInx8Yj09PVwiYFwifHwoQT09PSdcIid8fEE9PT1cIidcInx8QT09PVwiYFwiKSkmJmIhPT1BKXt0aHJvdyBuZXcgbihcInByb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXNcIil9aWYodj09PVwiY29uc3RydWN0b3JcInx8IWcpe3M9dHJ1ZX1pKz1cIi5cIit2O3A9XCIlXCIraStcIiVcIjtpZihtKGQscCkpe3U9ZFtwXX1lbHNlIGlmKHUhPW51bGwpe2lmKCEodiBpbiB1KSl7aWYoIWUpe3Rocm93IG5ldyBhKFwiYmFzZSBpbnRyaW5zaWMgZm9yIFwiK3IrXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpfXJldHVybiB2b2lkIG99aWYoeSYmbCsxPj10Lmxlbmd0aCl7dmFyIFA9eSh1LHYpO2c9ISFQO2lmKGcmJlwiZ2V0XCJpbiBQJiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gUC5nZXQpKXt1PVAuZ2V0fWVsc2V7dT11W3ZdfX1lbHNle2c9bSh1LHYpO3U9dVt2XX1pZihnJiYhcyl7ZFtwXT11fX19cmV0dXJuIHV9fSw1MDQ6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e2Zvbzp7fX07dmFyIHQ9T2JqZWN0O3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNQcm90bygpe3JldHVybntfX3Byb3RvX186ZX0uZm9vPT09ZS5mb28mJiEoe19fcHJvdG9fXzpudWxsfWluc3RhbmNlb2YgdCl9fSw5NDI6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG49dCg3NzMpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG8hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG8oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbigpfX0sNzczOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbz00MjtyW2VdPW87Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYobi5sZW5ndGghPT0xfHxuWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW98fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMTU6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG49dCg4MzIpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG8hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG8oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbigpfX0sODMyOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbz00MjtyW2VdPW87Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYobi5sZW5ndGghPT0xfHxuWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW98fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMDE6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTc0KTtyLmV4cG9ydHM9by5jYWxsKEZ1bmN0aW9uLmNhbGwsT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSl9LDc4MjpmdW5jdGlvbihyKXtpZih0eXBlb2YgT2JqZWN0LmNyZWF0ZT09PVwiZnVuY3Rpb25cIil7ci5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKHIsZSl7aWYoZSl7ci5zdXBlcl89ZTtyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6cixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9fSl9fX1lbHNle3IuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhyLGUpe2lmKGUpe3Iuc3VwZXJfPWU7dmFyIFRlbXBDdG9yPWZ1bmN0aW9uKCl7fTtUZW1wQ3Rvci5wcm90b3R5cGU9ZS5wcm90b3R5cGU7ci5wcm90b3R5cGU9bmV3IFRlbXBDdG9yO3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPXJ9fX19LDE1NzpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBvPWZ1bmN0aW9uIGlzQXJndW1lbnRzKHIpe2lmKGUmJnImJnR5cGVvZiByPT09XCJvYmplY3RcIiYmU3ltYm9sLnRvU3RyaW5nVGFnIGluIHIpe3JldHVybiBmYWxzZX1yZXR1cm4gdC5jYWxsKHIpPT09XCJbb2JqZWN0IEFyZ3VtZW50c11cIn07dmFyIG49ZnVuY3Rpb24gaXNBcmd1bWVudHMocil7aWYobyhyKSl7cmV0dXJuIHRydWV9cmV0dXJuIHIhPT1udWxsJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJnR5cGVvZiByLmxlbmd0aD09PVwibnVtYmVyXCImJnIubGVuZ3RoPj0wJiZ0LmNhbGwocikhPT1cIltvYmplY3QgQXJyYXldXCImJnQuY2FsbChyLmNhbGxlZSk9PT1cIltvYmplY3QgRnVuY3Rpb25dXCJ9O3ZhciBpPWZ1bmN0aW9uKCl7cmV0dXJuIG8oYXJndW1lbnRzKX0oKTtvLmlzTGVnYWN5QXJndW1lbnRzPW47ci5leHBvcnRzPWk/bzpufSwzOTE6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgdD1GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7dmFyIG89L15cXHMqKD86ZnVuY3Rpb24pP1xcKi87dmFyIG49dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIGk9T2JqZWN0LmdldFByb3RvdHlwZU9mO3ZhciBnZXRHZW5lcmF0b3JGdW5jPWZ1bmN0aW9uKCl7aWYoIW4pe3JldHVybiBmYWxzZX10cnl7cmV0dXJuIEZ1bmN0aW9uKFwicmV0dXJuIGZ1bmN0aW9uKigpIHt9XCIpKCl9Y2F0Y2gocil7fX07dmFyIGE9Z2V0R2VuZXJhdG9yRnVuYygpO3ZhciB5PWE/aShhKTp7fTtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKG8udGVzdCh0LmNhbGwocikpKXtyZXR1cm4gdHJ1ZX1pZighbil7dmFyIGE9ZS5jYWxsKHIpO3JldHVybiBhPT09XCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwifXJldHVybiBpKHIpPT09eX19LDk5NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCgxNDQpO3ZhciBuPXQoMzQ5KTt2YXIgaT10KDI1Nik7dmFyIGE9aShcIk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcIik7dmFyIHk9dCg5NDIpKCk7dmFyIGY9eSYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIHA9bigpO3ZhciB1PWkoXCJBcnJheS5wcm90b3R5cGUuaW5kZXhPZlwiLHRydWUpfHxmdW5jdGlvbiBpbmRleE9mKHIsZSl7Zm9yKHZhciB0PTA7dDxyLmxlbmd0aDt0Kz0xKXtpZihyW3RdPT09ZSl7cmV0dXJuIHR9fXJldHVybi0xfTt2YXIgcz1pKFwiU3RyaW5nLnByb3RvdHlwZS5zbGljZVwiKTt2YXIgYz17fTt2YXIgbD10KDI0KTt2YXIgZD1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7aWYoZiYmbCYmZCl7byhwLChmdW5jdGlvbihyKXt2YXIgZT1uZXcgZ2xvYmFsW3JdO2lmKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGUpKXt0aHJvdyBuZXcgRXZhbEVycm9yKFwidGhpcyBlbmdpbmUgaGFzIHN1cHBvcnQgZm9yIFN5bWJvbC50b1N0cmluZ1RhZywgYnV0IFwiK3IrXCIgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy5cIil9dmFyIHQ9ZChlKTt2YXIgbz1sKHQsU3ltYm9sLnRvU3RyaW5nVGFnKTtpZighbyl7dmFyIG49ZCh0KTtvPWwobixTeW1ib2wudG9TdHJpbmdUYWcpfWNbcl09by5nZXR9KSl9dmFyIGc9ZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXMocil7dmFyIGU9ZmFsc2U7byhjLChmdW5jdGlvbih0LG8pe2lmKCFlKXt0cnl7ZT10LmNhbGwocik9PT1vfWNhdGNoKHIpe319fSkpO3JldHVybiBlfTtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNUeXBlZEFycmF5KHIpe2lmKCFyfHx0eXBlb2YgciE9PVwib2JqZWN0XCIpe3JldHVybiBmYWxzZX1pZighZil7dmFyIGU9cyhhKHIpLDgsLTEpO3JldHVybiB1KHAsZSk+LTF9aWYoIWwpe3JldHVybiBmYWxzZX1yZXR1cm4gZyhyKX19LDM2OTpmdW5jdGlvbihyKXtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNCdWZmZXIocil7cmV0dXJuIHIgaW5zdGFuY2VvZiBCdWZmZXJ9fSw1ODQ6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTU3KTt2YXIgbj10KDM5MSk7dmFyIGk9dCg0OTApO3ZhciBhPXQoOTk0KTtmdW5jdGlvbiB1bmN1cnJ5VGhpcyhyKXtyZXR1cm4gci5jYWxsLmJpbmQocil9dmFyIHk9dHlwZW9mIEJpZ0ludCE9PVwidW5kZWZpbmVkXCI7dmFyIGY9dHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCI7dmFyIHA9dW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7dmFyIHU9dW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTt2YXIgcz11bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO3ZhciBjPXVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO2lmKHkpe3ZhciBsPXVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZil9aWYoZil7dmFyIGQ9dW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKX1mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHIsZSl7aWYodHlwZW9mIHIhPT1cIm9iamVjdFwiKXtyZXR1cm4gZmFsc2V9dHJ5e2Uocik7cmV0dXJuIHRydWV9Y2F0Y2gocil7cmV0dXJuIGZhbHNlfX1lLmlzQXJndW1lbnRzT2JqZWN0PW87ZS5pc0dlbmVyYXRvckZ1bmN0aW9uPW47ZS5pc1R5cGVkQXJyYXk9YTtmdW5jdGlvbiBpc1Byb21pc2Uocil7cmV0dXJuIHR5cGVvZiBQcm9taXNlIT09XCJ1bmRlZmluZWRcIiYmciBpbnN0YW5jZW9mIFByb21pc2V8fHIhPT1udWxsJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJnR5cGVvZiByLnRoZW49PT1cImZ1bmN0aW9uXCImJnR5cGVvZiByLmNhdGNoPT09XCJmdW5jdGlvblwifWUuaXNQcm9taXNlPWlzUHJvbWlzZTtmdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyhyKXtpZih0eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZBcnJheUJ1ZmZlci5pc1ZpZXcpe3JldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcocil9cmV0dXJuIGEocil8fGlzRGF0YVZpZXcocil9ZS5pc0FycmF5QnVmZmVyVmlldz1pc0FycmF5QnVmZmVyVmlldztmdW5jdGlvbiBpc1VpbnQ4QXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQ4QXJyYXlcIn1lLmlzVWludDhBcnJheT1pc1VpbnQ4QXJyYXk7ZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDhDbGFtcGVkQXJyYXlcIn1lLmlzVWludDhDbGFtcGVkQXJyYXk9aXNVaW50OENsYW1wZWRBcnJheTtmdW5jdGlvbiBpc1VpbnQxNkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50MTZBcnJheVwifWUuaXNVaW50MTZBcnJheT1pc1VpbnQxNkFycmF5O2Z1bmN0aW9uIGlzVWludDMyQXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQzMkFycmF5XCJ9ZS5pc1VpbnQzMkFycmF5PWlzVWludDMyQXJyYXk7ZnVuY3Rpb24gaXNJbnQ4QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkludDhBcnJheVwifWUuaXNJbnQ4QXJyYXk9aXNJbnQ4QXJyYXk7ZnVuY3Rpb24gaXNJbnQxNkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJJbnQxNkFycmF5XCJ9ZS5pc0ludDE2QXJyYXk9aXNJbnQxNkFycmF5O2Z1bmN0aW9uIGlzSW50MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiSW50MzJBcnJheVwifWUuaXNJbnQzMkFycmF5PWlzSW50MzJBcnJheTtmdW5jdGlvbiBpc0Zsb2F0MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiRmxvYXQzMkFycmF5XCJ9ZS5pc0Zsb2F0MzJBcnJheT1pc0Zsb2F0MzJBcnJheTtmdW5jdGlvbiBpc0Zsb2F0NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiRmxvYXQ2NEFycmF5XCJ9ZS5pc0Zsb2F0NjRBcnJheT1pc0Zsb2F0NjRBcnJheTtmdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkJpZ0ludDY0QXJyYXlcIn1lLmlzQmlnSW50NjRBcnJheT1pc0JpZ0ludDY0QXJyYXk7ZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiQmlnVWludDY0QXJyYXlcIn1lLmlzQmlnVWludDY0QXJyYXk9aXNCaWdVaW50NjRBcnJheTtmdW5jdGlvbiBpc01hcFRvU3RyaW5nKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IE1hcF1cIn1pc01hcFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIE1hcCE9PVwidW5kZWZpbmVkXCImJmlzTWFwVG9TdHJpbmcobmV3IE1hcCk7ZnVuY3Rpb24gaXNNYXAocil7aWYodHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nP2lzTWFwVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIE1hcH1lLmlzTWFwPWlzTWFwO2Z1bmN0aW9uIGlzU2V0VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgU2V0XVwifWlzU2V0VG9TdHJpbmcud29ya2luZz10eXBlb2YgU2V0IT09XCJ1bmRlZmluZWRcIiYmaXNTZXRUb1N0cmluZyhuZXcgU2V0KTtmdW5jdGlvbiBpc1NldChyKXtpZih0eXBlb2YgU2V0PT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmc/aXNTZXRUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgU2V0fWUuaXNTZXQ9aXNTZXQ7ZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2Vha01hcF1cIn1pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nPXR5cGVvZiBXZWFrTWFwIT09XCJ1bmRlZmluZWRcIiYmaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXApO2Z1bmN0aW9uIGlzV2Vha01hcChyKXtpZih0eXBlb2YgV2Vha01hcD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZz9pc1dlYWtNYXBUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgV2Vha01hcH1lLmlzV2Vha01hcD1pc1dlYWtNYXA7ZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2Vha1NldF1cIn1pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nPXR5cGVvZiBXZWFrU2V0IT09XCJ1bmRlZmluZWRcIiYmaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQpO2Z1bmN0aW9uIGlzV2Vha1NldChyKXtyZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcocil9ZS5pc1dlYWtTZXQ9aXNXZWFrU2V0O2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIn1pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz10eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKTtmdW5jdGlvbiBpc0FycmF5QnVmZmVyKHIpe2lmKHR5cGVvZiBBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc/aXNBcnJheUJ1ZmZlclRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcn1lLmlzQXJyYXlCdWZmZXI9aXNBcnJheUJ1ZmZlcjtmdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgRGF0YVZpZXddXCJ9aXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmc9dHlwZW9mIEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIERhdGFWaWV3IT09XCJ1bmRlZmluZWRcIiYmaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksMCwxKSk7ZnVuY3Rpb24gaXNEYXRhVmlldyhyKXtpZih0eXBlb2YgRGF0YVZpZXc9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nP2lzRGF0YVZpZXdUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgRGF0YVZpZXd9ZS5pc0RhdGFWaWV3PWlzRGF0YVZpZXc7dmFyIGc9dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIj9TaGFyZWRBcnJheUJ1ZmZlcjp1bmRlZmluZWQ7ZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXVwifWZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIocil7aWYodHlwZW9mIGc9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nPT09XCJ1bmRlZmluZWRcIil7aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc9aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBnKX1yZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc/aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBnfWUuaXNTaGFyZWRBcnJheUJ1ZmZlcj1pc1NoYXJlZEFycmF5QnVmZmVyO2Z1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbihyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwifWUuaXNBc3luY0Z1bmN0aW9uPWlzQXN5bmNGdW5jdGlvbjtmdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IE1hcCBJdGVyYXRvcl1cIn1lLmlzTWFwSXRlcmF0b3I9aXNNYXBJdGVyYXRvcjtmdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IFNldCBJdGVyYXRvcl1cIn1lLmlzU2V0SXRlcmF0b3I9aXNTZXRJdGVyYXRvcjtmdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdChyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBHZW5lcmF0b3JdXCJ9ZS5pc0dlbmVyYXRvck9iamVjdD1pc0dlbmVyYXRvck9iamVjdDtmdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXVwifWUuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlPWlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtmdW5jdGlvbiBpc051bWJlck9iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLHUpfWUuaXNOdW1iZXJPYmplY3Q9aXNOdW1iZXJPYmplY3Q7ZnVuY3Rpb24gaXNTdHJpbmdPYmplY3Qocil7cmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUocixzKX1lLmlzU3RyaW5nT2JqZWN0PWlzU3RyaW5nT2JqZWN0O2Z1bmN0aW9uIGlzQm9vbGVhbk9iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLGMpfWUuaXNCb29sZWFuT2JqZWN0PWlzQm9vbGVhbk9iamVjdDtmdW5jdGlvbiBpc0JpZ0ludE9iamVjdChyKXtyZXR1cm4geSYmY2hlY2tCb3hlZFByaW1pdGl2ZShyLGwpfWUuaXNCaWdJbnRPYmplY3Q9aXNCaWdJbnRPYmplY3Q7ZnVuY3Rpb24gaXNTeW1ib2xPYmplY3Qocil7cmV0dXJuIGYmJmNoZWNrQm94ZWRQcmltaXRpdmUocixkKX1lLmlzU3ltYm9sT2JqZWN0PWlzU3ltYm9sT2JqZWN0O2Z1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUocil7cmV0dXJuIGlzTnVtYmVyT2JqZWN0KHIpfHxpc1N0cmluZ09iamVjdChyKXx8aXNCb29sZWFuT2JqZWN0KHIpfHxpc0JpZ0ludE9iamVjdChyKXx8aXNTeW1ib2xPYmplY3Qocil9ZS5pc0JveGVkUHJpbWl0aXZlPWlzQm94ZWRQcmltaXRpdmU7ZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcihyKXtyZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkhPT1cInVuZGVmaW5lZFwiJiYoaXNBcnJheUJ1ZmZlcihyKXx8aXNTaGFyZWRBcnJheUJ1ZmZlcihyKSl9ZS5pc0FueUFycmF5QnVmZmVyPWlzQW55QXJyYXlCdWZmZXI7W1wiaXNQcm94eVwiLFwiaXNFeHRlcm5hbFwiLFwiaXNNb2R1bGVOYW1lc3BhY2VPYmplY3RcIl0uZm9yRWFjaCgoZnVuY3Rpb24ocil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTpmYWxzZSx2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihyK1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmRcIil9fSl9KSl9LDE3NzpmdW5jdGlvbihyLGUsdCl7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnN8fGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocil7dmFyIGU9T2JqZWN0LmtleXMocik7dmFyIHQ9e307Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDtvKyspe3RbZVtvXV09T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGVbb10pfXJldHVybiB0fTt2YXIgbj0vJVtzZGolXS9nO2UuZm9ybWF0PWZ1bmN0aW9uKHIpe2lmKCFpc1N0cmluZyhyKSl7dmFyIGU9W107Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7ZS5wdXNoKGluc3BlY3QoYXJndW1lbnRzW3RdKSl9cmV0dXJuIGUuam9pbihcIiBcIil9dmFyIHQ9MTt2YXIgbz1hcmd1bWVudHM7dmFyIGk9by5sZW5ndGg7dmFyIGE9U3RyaW5nKHIpLnJlcGxhY2UobiwoZnVuY3Rpb24ocil7aWYocj09PVwiJSVcIilyZXR1cm5cIiVcIjtpZih0Pj1pKXJldHVybiByO3N3aXRjaChyKXtjYXNlXCIlc1wiOnJldHVybiBTdHJpbmcob1t0KytdKTtjYXNlXCIlZFwiOnJldHVybiBOdW1iZXIob1t0KytdKTtjYXNlXCIlalwiOnRyeXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkob1t0KytdKX1jYXRjaChyKXtyZXR1cm5cIltDaXJjdWxhcl1cIn1kZWZhdWx0OnJldHVybiByfX0pKTtmb3IodmFyIHk9b1t0XTt0PGk7eT1vWysrdF0pe2lmKGlzTnVsbCh5KXx8IWlzT2JqZWN0KHkpKXthKz1cIiBcIit5fWVsc2V7YSs9XCIgXCIraW5zcGVjdCh5KX19cmV0dXJuIGF9O2UuZGVwcmVjYXRlPWZ1bmN0aW9uKHIsdCl7aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLm5vRGVwcmVjYXRpb249PT10cnVlKXtyZXR1cm4gcn1pZih0eXBlb2YgcHJvY2Vzcz09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmRlcHJlY2F0ZShyLHQpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIG89ZmFsc2U7ZnVuY3Rpb24gZGVwcmVjYXRlZCgpe2lmKCFvKXtpZihwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pe3Rocm93IG5ldyBFcnJvcih0KX1lbHNlIGlmKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbil7Y29uc29sZS50cmFjZSh0KX1lbHNle2NvbnNvbGUuZXJyb3IodCl9bz10cnVlfXJldHVybiByLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gZGVwcmVjYXRlZH07dmFyIGk9e307dmFyIGE9L14kLztpZihwcm9jZXNzLmVudi5OT0RFX0RFQlVHKXt2YXIgeT1wcm9jZXNzLmVudi5OT0RFX0RFQlVHO3k9eS5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLFwiXFxcXCQmXCIpLnJlcGxhY2UoL1xcKi9nLFwiLipcIikucmVwbGFjZSgvLC9nLFwiJHxeXCIpLnRvVXBwZXJDYXNlKCk7YT1uZXcgUmVnRXhwKFwiXlwiK3krXCIkXCIsXCJpXCIpfWUuZGVidWdsb2c9ZnVuY3Rpb24ocil7cj1yLnRvVXBwZXJDYXNlKCk7aWYoIWlbcl0pe2lmKGEudGVzdChyKSl7dmFyIHQ9cHJvY2Vzcy5waWQ7aVtyXT1mdW5jdGlvbigpe3ZhciBvPWUuZm9ybWF0LmFwcGx5KGUsYXJndW1lbnRzKTtjb25zb2xlLmVycm9yKFwiJXMgJWQ6ICVzXCIscix0LG8pfX1lbHNle2lbcl09ZnVuY3Rpb24oKXt9fX1yZXR1cm4gaVtyXX07ZnVuY3Rpb24gaW5zcGVjdChyLHQpe3ZhciBvPXtzZWVuOltdLHN0eWxpemU6c3R5bGl6ZU5vQ29sb3J9O2lmKGFyZ3VtZW50cy5sZW5ndGg+PTMpby5kZXB0aD1hcmd1bWVudHNbMl07aWYoYXJndW1lbnRzLmxlbmd0aD49NClvLmNvbG9ycz1hcmd1bWVudHNbM107aWYoaXNCb29sZWFuKHQpKXtvLnNob3dIaWRkZW49dH1lbHNlIGlmKHQpe2UuX2V4dGVuZChvLHQpfWlmKGlzVW5kZWZpbmVkKG8uc2hvd0hpZGRlbikpby5zaG93SGlkZGVuPWZhbHNlO2lmKGlzVW5kZWZpbmVkKG8uZGVwdGgpKW8uZGVwdGg9MjtpZihpc1VuZGVmaW5lZChvLmNvbG9ycykpby5jb2xvcnM9ZmFsc2U7aWYoaXNVbmRlZmluZWQoby5jdXN0b21JbnNwZWN0KSlvLmN1c3RvbUluc3BlY3Q9dHJ1ZTtpZihvLmNvbG9ycylvLnN0eWxpemU9c3R5bGl6ZVdpdGhDb2xvcjtyZXR1cm4gZm9ybWF0VmFsdWUobyxyLG8uZGVwdGgpfWUuaW5zcGVjdD1pbnNwZWN0O2luc3BlY3QuY29sb3JzPXtib2xkOlsxLDIyXSxpdGFsaWM6WzMsMjNdLHVuZGVybGluZTpbNCwyNF0saW52ZXJzZTpbNywyN10sd2hpdGU6WzM3LDM5XSxncmV5Ols5MCwzOV0sYmxhY2s6WzMwLDM5XSxibHVlOlszNCwzOV0sY3lhbjpbMzYsMzldLGdyZWVuOlszMiwzOV0sbWFnZW50YTpbMzUsMzldLHJlZDpbMzEsMzldLHllbGxvdzpbMzMsMzldfTtpbnNwZWN0LnN0eWxlcz17c3BlY2lhbDpcImN5YW5cIixudW1iZXI6XCJ5ZWxsb3dcIixib29sZWFuOlwieWVsbG93XCIsdW5kZWZpbmVkOlwiZ3JleVwiLG51bGw6XCJib2xkXCIsc3RyaW5nOlwiZ3JlZW5cIixkYXRlOlwibWFnZW50YVwiLHJlZ2V4cDpcInJlZFwifTtmdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHIsZSl7dmFyIHQ9aW5zcGVjdC5zdHlsZXNbZV07aWYodCl7cmV0dXJuXCJcdTAwMWJbXCIraW5zcGVjdC5jb2xvcnNbdF1bMF0rXCJtXCIrcitcIlx1MDAxYltcIitpbnNwZWN0LmNvbG9yc1t0XVsxXStcIm1cIn1lbHNle3JldHVybiByfX1mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihyLGUpe3JldHVybiByfWZ1bmN0aW9uIGFycmF5VG9IYXNoKHIpe3ZhciBlPXt9O3IuZm9yRWFjaCgoZnVuY3Rpb24ocix0KXtlW3JdPXRydWV9KSk7cmV0dXJuIGV9ZnVuY3Rpb24gZm9ybWF0VmFsdWUocix0LG8pe2lmKHIuY3VzdG9tSW5zcGVjdCYmdCYmaXNGdW5jdGlvbih0Lmluc3BlY3QpJiZ0Lmluc3BlY3QhPT1lLmluc3BlY3QmJiEodC5jb25zdHJ1Y3RvciYmdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU9PT10KSl7dmFyIG49dC5pbnNwZWN0KG8scik7aWYoIWlzU3RyaW5nKG4pKXtuPWZvcm1hdFZhbHVlKHIsbixvKX1yZXR1cm4gbn12YXIgaT1mb3JtYXRQcmltaXRpdmUocix0KTtpZihpKXtyZXR1cm4gaX12YXIgYT1PYmplY3Qua2V5cyh0KTt2YXIgeT1hcnJheVRvSGFzaChhKTtpZihyLnNob3dIaWRkZW4pe2E9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCl9aWYoaXNFcnJvcih0KSYmKGEuaW5kZXhPZihcIm1lc3NhZ2VcIik+PTB8fGEuaW5kZXhPZihcImRlc2NyaXB0aW9uXCIpPj0wKSl7cmV0dXJuIGZvcm1hdEVycm9yKHQpfWlmKGEubGVuZ3RoPT09MCl7aWYoaXNGdW5jdGlvbih0KSl7dmFyIGY9dC5uYW1lP1wiOiBcIit0Lm5hbWU6XCJcIjtyZXR1cm4gci5zdHlsaXplKFwiW0Z1bmN0aW9uXCIrZitcIl1cIixcInNwZWNpYWxcIil9aWYoaXNSZWdFeHAodCkpe3JldHVybiByLnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwicmVnZXhwXCIpfWlmKGlzRGF0ZSh0KSl7cmV0dXJuIHIuc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwiZGF0ZVwiKX1pZihpc0Vycm9yKHQpKXtyZXR1cm4gZm9ybWF0RXJyb3IodCl9fXZhciBwPVwiXCIsdT1mYWxzZSxzPVtcIntcIixcIn1cIl07aWYoaXNBcnJheSh0KSl7dT10cnVlO3M9W1wiW1wiLFwiXVwiXX1pZihpc0Z1bmN0aW9uKHQpKXt2YXIgYz10Lm5hbWU/XCI6IFwiK3QubmFtZTpcIlwiO3A9XCIgW0Z1bmN0aW9uXCIrYytcIl1cIn1pZihpc1JlZ0V4cCh0KSl7cD1cIiBcIitSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9aWYoaXNEYXRlKHQpKXtwPVwiIFwiK0RhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodCl9aWYoaXNFcnJvcih0KSl7cD1cIiBcIitmb3JtYXRFcnJvcih0KX1pZihhLmxlbmd0aD09PTAmJighdXx8dC5sZW5ndGg9PTApKXtyZXR1cm4gc1swXStwK3NbMV19aWYobzwwKXtpZihpc1JlZ0V4cCh0KSl7cmV0dXJuIHIuc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJyZWdleHBcIil9ZWxzZXtyZXR1cm4gci5zdHlsaXplKFwiW09iamVjdF1cIixcInNwZWNpYWxcIil9fXIuc2Vlbi5wdXNoKHQpO3ZhciBsO2lmKHUpe2w9Zm9ybWF0QXJyYXkocix0LG8seSxhKX1lbHNle2w9YS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBmb3JtYXRQcm9wZXJ0eShyLHQsbyx5LGUsdSl9KSl9ci5zZWVuLnBvcCgpO3JldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhsLHAscyl9ZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKHIsZSl7aWYoaXNVbmRlZmluZWQoZSkpcmV0dXJuIHIuc3R5bGl6ZShcInVuZGVmaW5lZFwiLFwidW5kZWZpbmVkXCIpO2lmKGlzU3RyaW5nKGUpKXt2YXIgdD1cIidcIitKU09OLnN0cmluZ2lmeShlKS5yZXBsYWNlKC9eXCJ8XCIkL2csXCJcIikucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykrXCInXCI7cmV0dXJuIHIuc3R5bGl6ZSh0LFwic3RyaW5nXCIpfWlmKGlzTnVtYmVyKGUpKXJldHVybiByLnN0eWxpemUoXCJcIitlLFwibnVtYmVyXCIpO2lmKGlzQm9vbGVhbihlKSlyZXR1cm4gci5zdHlsaXplKFwiXCIrZSxcImJvb2xlYW5cIik7aWYoaXNOdWxsKGUpKXJldHVybiByLnN0eWxpemUoXCJudWxsXCIsXCJudWxsXCIpfWZ1bmN0aW9uIGZvcm1hdEVycm9yKHIpe3JldHVyblwiW1wiK0Vycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpK1wiXVwifWZ1bmN0aW9uIGZvcm1hdEFycmF5KHIsZSx0LG8sbil7dmFyIGk9W107Zm9yKHZhciBhPTAseT1lLmxlbmd0aDthPHk7KythKXtpZihoYXNPd25Qcm9wZXJ0eShlLFN0cmluZyhhKSkpe2kucHVzaChmb3JtYXRQcm9wZXJ0eShyLGUsdCxvLFN0cmluZyhhKSx0cnVlKSl9ZWxzZXtpLnB1c2goXCJcIil9fW4uZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW4ubWF0Y2goL15cXGQrJC8pKXtpLnB1c2goZm9ybWF0UHJvcGVydHkocixlLHQsbyxuLHRydWUpKX19KSk7cmV0dXJuIGl9ZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkocixlLHQsbyxuLGkpe3ZhciBhLHksZjtmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKXx8e3ZhbHVlOmVbbl19O2lmKGYuZ2V0KXtpZihmLnNldCl7eT1yLnN0eWxpemUoXCJbR2V0dGVyL1NldHRlcl1cIixcInNwZWNpYWxcIil9ZWxzZXt5PXIuc3R5bGl6ZShcIltHZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1lbHNle2lmKGYuc2V0KXt5PXIuc3R5bGl6ZShcIltTZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1pZighaGFzT3duUHJvcGVydHkobyxuKSl7YT1cIltcIituK1wiXVwifWlmKCF5KXtpZihyLnNlZW4uaW5kZXhPZihmLnZhbHVlKTwwKXtpZihpc051bGwodCkpe3k9Zm9ybWF0VmFsdWUocixmLnZhbHVlLG51bGwpfWVsc2V7eT1mb3JtYXRWYWx1ZShyLGYudmFsdWUsdC0xKX1pZih5LmluZGV4T2YoXCJcXG5cIik+LTEpe2lmKGkpe3k9eS5zcGxpdChcIlxcblwiKS5tYXAoKGZ1bmN0aW9uKHIpe3JldHVyblwiICBcIityfSkpLmpvaW4oXCJcXG5cIikuc3Vic3RyKDIpfWVsc2V7eT1cIlxcblwiK3kuc3BsaXQoXCJcXG5cIikubWFwKChmdW5jdGlvbihyKXtyZXR1cm5cIiAgIFwiK3J9KSkuam9pbihcIlxcblwiKX19fWVsc2V7eT1yLnN0eWxpemUoXCJbQ2lyY3VsYXJdXCIsXCJzcGVjaWFsXCIpfX1pZihpc1VuZGVmaW5lZChhKSl7aWYoaSYmbi5tYXRjaCgvXlxcZCskLykpe3JldHVybiB5fWE9SlNPTi5zdHJpbmdpZnkoXCJcIituKTtpZihhLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSl7YT1hLnN1YnN0cigxLGEubGVuZ3RoLTIpO2E9ci5zdHlsaXplKGEsXCJuYW1lXCIpfWVsc2V7YT1hLnJlcGxhY2UoLycvZyxcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCdcIicpLnJlcGxhY2UoLyheXCJ8XCIkKS9nLFwiJ1wiKTthPXIuc3R5bGl6ZShhLFwic3RyaW5nXCIpfX1yZXR1cm4gYStcIjogXCIreX1mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhyLGUsdCl7dmFyIG89MDt2YXIgbj1yLnJlZHVjZSgoZnVuY3Rpb24ocixlKXtvKys7aWYoZS5pbmRleE9mKFwiXFxuXCIpPj0wKW8rKztyZXR1cm4gcitlLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLFwiXCIpLmxlbmd0aCsxfSksMCk7aWYobj42MCl7cmV0dXJuIHRbMF0rKGU9PT1cIlwiP1wiXCI6ZStcIlxcbiBcIikrXCIgXCIrci5qb2luKFwiLFxcbiAgXCIpK1wiIFwiK3RbMV19cmV0dXJuIHRbMF0rZStcIiBcIityLmpvaW4oXCIsIFwiKStcIiBcIit0WzFdfWUudHlwZXM9dCg1ODQpO2Z1bmN0aW9uIGlzQXJyYXkocil7cmV0dXJuIEFycmF5LmlzQXJyYXkocil9ZS5pc0FycmF5PWlzQXJyYXk7ZnVuY3Rpb24gaXNCb29sZWFuKHIpe3JldHVybiB0eXBlb2Ygcj09PVwiYm9vbGVhblwifWUuaXNCb29sZWFuPWlzQm9vbGVhbjtmdW5jdGlvbiBpc051bGwocil7cmV0dXJuIHI9PT1udWxsfWUuaXNOdWxsPWlzTnVsbDtmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChyKXtyZXR1cm4gcj09bnVsbH1lLmlzTnVsbE9yVW5kZWZpbmVkPWlzTnVsbE9yVW5kZWZpbmVkO2Z1bmN0aW9uIGlzTnVtYmVyKHIpe3JldHVybiB0eXBlb2Ygcj09PVwibnVtYmVyXCJ9ZS5pc051bWJlcj1pc051bWJlcjtmdW5jdGlvbiBpc1N0cmluZyhyKXtyZXR1cm4gdHlwZW9mIHI9PT1cInN0cmluZ1wifWUuaXNTdHJpbmc9aXNTdHJpbmc7ZnVuY3Rpb24gaXNTeW1ib2wocil7cmV0dXJuIHR5cGVvZiByPT09XCJzeW1ib2xcIn1lLmlzU3ltYm9sPWlzU3ltYm9sO2Z1bmN0aW9uIGlzVW5kZWZpbmVkKHIpe3JldHVybiByPT09dm9pZCAwfWUuaXNVbmRlZmluZWQ9aXNVbmRlZmluZWQ7ZnVuY3Rpb24gaXNSZWdFeHAocil7cmV0dXJuIGlzT2JqZWN0KHIpJiZvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBSZWdFeHBdXCJ9ZS5pc1JlZ0V4cD1pc1JlZ0V4cDtlLnR5cGVzLmlzUmVnRXhwPWlzUmVnRXhwO2Z1bmN0aW9uIGlzT2JqZWN0KHIpe3JldHVybiB0eXBlb2Ygcj09PVwib2JqZWN0XCImJnIhPT1udWxsfWUuaXNPYmplY3Q9aXNPYmplY3Q7ZnVuY3Rpb24gaXNEYXRlKHIpe3JldHVybiBpc09iamVjdChyKSYmb2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgRGF0ZV1cIn1lLmlzRGF0ZT1pc0RhdGU7ZS50eXBlcy5pc0RhdGU9aXNEYXRlO2Z1bmN0aW9uIGlzRXJyb3Iocil7cmV0dXJuIGlzT2JqZWN0KHIpJiYob2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgRXJyb3JdXCJ8fHIgaW5zdGFuY2VvZiBFcnJvcil9ZS5pc0Vycm9yPWlzRXJyb3I7ZS50eXBlcy5pc05hdGl2ZUVycm9yPWlzRXJyb3I7ZnVuY3Rpb24gaXNGdW5jdGlvbihyKXtyZXR1cm4gdHlwZW9mIHI9PT1cImZ1bmN0aW9uXCJ9ZS5pc0Z1bmN0aW9uPWlzRnVuY3Rpb247ZnVuY3Rpb24gaXNQcmltaXRpdmUocil7cmV0dXJuIHI9PT1udWxsfHx0eXBlb2Ygcj09PVwiYm9vbGVhblwifHx0eXBlb2Ygcj09PVwibnVtYmVyXCJ8fHR5cGVvZiByPT09XCJzdHJpbmdcInx8dHlwZW9mIHI9PT1cInN5bWJvbFwifHx0eXBlb2Ygcj09PVwidW5kZWZpbmVkXCJ9ZS5pc1ByaW1pdGl2ZT1pc1ByaW1pdGl2ZTtlLmlzQnVmZmVyPXQoMzY5KTtmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhyKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpfWZ1bmN0aW9uIHBhZChyKXtyZXR1cm4gcjwxMD9cIjBcIityLnRvU3RyaW5nKDEwKTpyLnRvU3RyaW5nKDEwKX12YXIgZj1bXCJKYW5cIixcIkZlYlwiLFwiTWFyXCIsXCJBcHJcIixcIk1heVwiLFwiSnVuXCIsXCJKdWxcIixcIkF1Z1wiLFwiU2VwXCIsXCJPY3RcIixcIk5vdlwiLFwiRGVjXCJdO2Z1bmN0aW9uIHRpbWVzdGFtcCgpe3ZhciByPW5ldyBEYXRlO3ZhciBlPVtwYWQoci5nZXRIb3VycygpKSxwYWQoci5nZXRNaW51dGVzKCkpLHBhZChyLmdldFNlY29uZHMoKSldLmpvaW4oXCI6XCIpO3JldHVybltyLmdldERhdGUoKSxmW3IuZ2V0TW9udGgoKV0sZV0uam9pbihcIiBcIil9ZS5sb2c9ZnVuY3Rpb24oKXtjb25zb2xlLmxvZyhcIiVzIC0gJXNcIix0aW1lc3RhbXAoKSxlLmZvcm1hdC5hcHBseShlLGFyZ3VtZW50cykpfTtlLmluaGVyaXRzPXQoNzgyKTtlLl9leHRlbmQ9ZnVuY3Rpb24ocixlKXtpZighZXx8IWlzT2JqZWN0KGUpKXJldHVybiByO3ZhciB0PU9iamVjdC5rZXlzKGUpO3ZhciBvPXQubGVuZ3RoO3doaWxlKG8tLSl7clt0W29dXT1lW3Rbb11dfXJldHVybiByfTtmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShyLGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixlKX12YXIgcD10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIj9TeW1ib2woXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIik6dW5kZWZpbmVkO2UucHJvbWlzaWZ5PWZ1bmN0aW9uIHByb21pc2lmeShyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO2lmKHAmJnJbcF0pe3ZhciBlPXJbcF07aWYodHlwZW9mIGUhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHAse3ZhbHVlOmUsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTpmYWxzZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBlfWZ1bmN0aW9uIGUoKXt2YXIgZSx0O3ZhciBvPW5ldyBQcm9taXNlKChmdW5jdGlvbihyLG8pe2U9cjt0PW99KSk7dmFyIG49W107Zm9yKHZhciBpPTA7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl7bi5wdXNoKGFyZ3VtZW50c1tpXSl9bi5wdXNoKChmdW5jdGlvbihyLG8pe2lmKHIpe3Qocil9ZWxzZXtlKG8pfX0pKTt0cnl7ci5hcHBseSh0aGlzLG4pfWNhdGNoKHIpe3Qocil9cmV0dXJuIG99T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsT2JqZWN0LmdldFByb3RvdHlwZU9mKHIpKTtpZihwKU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHAse3ZhbHVlOmUsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTpmYWxzZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLG8ocikpfTtlLnByb21pc2lmeS5jdXN0b209cDtmdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocixlKXtpZighcil7dmFyIHQ9bmV3IEVycm9yKFwiUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlXCIpO3QucmVhc29uPXI7cj10fXJldHVybiBlKHIpfWZ1bmN0aW9uIGNhbGxiYWNraWZ5KHIpe2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpfWZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKXt2YXIgZT1bXTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtlLnB1c2goYXJndW1lbnRzW3RdKX12YXIgbz1lLnBvcCgpO2lmKHR5cGVvZiBvIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uXCIpfXZhciBuPXRoaXM7dmFyIGNiPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXBwbHkobixhcmd1bWVudHMpfTtyLmFwcGx5KHRoaXMsZSkudGhlbigoZnVuY3Rpb24ocil7cHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsbnVsbCxyKSl9KSwoZnVuY3Rpb24ocil7cHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLHIsY2IpKX0pKX1PYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCxPYmplY3QuZ2V0UHJvdG90eXBlT2YocikpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsbyhyKSk7cmV0dXJuIGNhbGxiYWNraWZpZWR9ZS5jYWxsYmFja2lmeT1jYWxsYmFja2lmeX0sNDkwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbz10KDE0NCk7dmFyIG49dCgzNDkpO3ZhciBpPXQoMjU2KTt2YXIgYT1pKFwiT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1wiKTt2YXIgeT10KDk0MikoKTt2YXIgZj15JiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgcD1uKCk7dmFyIHU9aShcIlN0cmluZy5wcm90b3R5cGUuc2xpY2VcIik7dmFyIHM9e307dmFyIGM9dCgyNCk7dmFyIGw9T2JqZWN0LmdldFByb3RvdHlwZU9mO2lmKGYmJmMmJmwpe28ocCwoZnVuY3Rpb24ocil7aWYodHlwZW9mIGdsb2JhbFtyXT09PVwiZnVuY3Rpb25cIil7dmFyIGU9bmV3IGdsb2JhbFtyXTtpZighKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBlKSl7dGhyb3cgbmV3IEV2YWxFcnJvcihcInRoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCBcIityK1wiIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuXCIpfXZhciB0PWwoZSk7dmFyIG89Yyh0LFN5bWJvbC50b1N0cmluZ1RhZyk7aWYoIW8pe3ZhciBuPWwodCk7bz1jKG4sU3ltYm9sLnRvU3RyaW5nVGFnKX1zW3JdPW8uZ2V0fX0pKX12YXIgZD1mdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyhyKXt2YXIgZT1mYWxzZTtvKHMsKGZ1bmN0aW9uKHQsbyl7aWYoIWUpe3RyeXt2YXIgbj10LmNhbGwocik7aWYobj09PW8pe2U9bn19Y2F0Y2gocil7fX19KSk7cmV0dXJuIGV9O3ZhciBnPXQoOTk0KTtyLmV4cG9ydHM9ZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHIpe2lmKCFnKHIpKXtyZXR1cm4gZmFsc2V9aWYoIWYpe3JldHVybiB1KGEociksOCwtMSl9cmV0dXJuIGQocil9fSwzNDk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoOTkyKTtyLmV4cG9ydHM9ZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKXtyZXR1cm4gbyhbXCJCaWdJbnQ2NEFycmF5XCIsXCJCaWdVaW50NjRBcnJheVwiLFwiRmxvYXQzMkFycmF5XCIsXCJGbG9hdDY0QXJyYXlcIixcIkludDE2QXJyYXlcIixcIkludDMyQXJyYXlcIixcIkludDhBcnJheVwiLFwiVWludDE2QXJyYXlcIixcIlVpbnQzMkFycmF5XCIsXCJVaW50OEFycmF5XCIsXCJVaW50OENsYW1wZWRBcnJheVwiXSwoZnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiBnbG9iYWxbcl09PT1cImZ1bmN0aW9uXCJ9KSl9fSwyNDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCg1MDApO3ZhciBuPW8oXCIlT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciVcIix0cnVlKTtpZihuKXt0cnl7bihbXSxcImxlbmd0aFwiKX1jYXRjaChyKXtuPW51bGx9fXIuZXhwb3J0cz1ufX07dmFyIGU9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgbz1lW3RdO2lmKG8hPT11bmRlZmluZWQpe3JldHVybiBvLmV4cG9ydHN9dmFyIG49ZVt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7clt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgZVt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDE3Nyk7bW9kdWxlLmV4cG9ydHM9dH0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/base64-js/index.js":
/*!******************************************!*\
  !*** ../node_modules/base64-js/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcz80OGNiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/buffer/index.js":
/*!***************************************!*\
  !*** ../node_modules/buffer/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/../node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/../node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyx5RUFBVztBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzPzUzNjciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG5jb25zdCBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICBsZXQgeSA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIGxldCBpbmRleFNpemUgPSAxXG4gIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpXG4gIGlmIChkaXIpIHtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgY29uc3QgcmVzID0gW11cblxuICBsZXQgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgbGV0IGNvZGVQb2ludCA9IG51bGxcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbmNvbnN0IE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICBsZXQgb3V0ID0gJydcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICBsZXQgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIGxldCBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjRcblxuICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdFxuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgaSA9IGJ5dGVMZW5ndGhcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gK1xuICAgIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggK1xuICAgIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICtcbiAgICAobGFzdCA8PCAyNCkgLy8gT3ZlcmZsb3dcblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQoZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0QkUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDddID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA2XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNV0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDRdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyAzXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMl0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDFdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXRdID0gaGlcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSAwXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIGxldCBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fVxuZnVuY3Rpb24gRSAoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7XG4gIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gXG4gICAgICAvLyBBY2Nlc3MgdGhlIHN0YWNrIHRvIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZVxuICAgICAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgICAgIHRoaXMuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIC8vIFJlc2V0IHRoZSBuYW1lIHRvIHRoZSBhY3R1YWwgbmFtZS5cbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgfVxuICB9XG59XG5cbkUoJ0VSUl9CVUZGRVJfT1VUX09GX0JPVU5EUycsXG4gIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgXG4gICAgfVxuXG4gICAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJ1xuICB9LCBSYW5nZUVycm9yKVxuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpXG5FKCdFUlJfT1VUX09GX1JBTkdFJyxcbiAgZnVuY3Rpb24gKHN0ciwgcmFuZ2UsIGlucHV0KSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYFxuICAgIGxldCByZWNlaXZlZCA9IGlucHV0XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9XG4gICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gICAgcmV0dXJuIG1zZ1xuICB9LCBSYW5nZUVycm9yKVxuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cblxuLy8gQ0hFQ0sgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMgKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGlmIChidWZbb2Zmc2V0XSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGggKyAxKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnXG4gICAgbGV0IHJhbmdlXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAzKSB7XG4gICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDh9JHtufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWBcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCd2YWx1ZScsIHJhbmdlLCB2YWx1ZSlcbiAgfVxuICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpXG4gIH1cblxuICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSlcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5jb25zdCBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgbGV0IGNvZGVQb2ludFxuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgbGV0IGMsIGhpLCBsb1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG5jb25zdCBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTZcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/ieee754/index.js":
/*!****************************************!*\
  !*** ../node_modules/ieee754/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxTQUFTLFVBQVU7O0FBRW5CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzP2Y3MjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/mqtt/dist/mqtt.esm.js":
/*!*********************************************!*\
  !*** ../node_modules/mqtt/dist/mqtt.esm.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nvar ds=Object.defineProperty;var $g=Object.getOwnPropertyDescriptor;var Hg=Object.getOwnPropertyNames;var Vg=Object.prototype.hasOwnProperty;var be=(t,e)=>()=>(t&&(e=t(t=0)),e);var M=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Qt=(t,e)=>{for(var r in e)ds(t,r,{get:e[r],enumerable:!0})},zg=(t,e,r,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of Hg(e))!Vg.call(t,n)&&n!==r&&ds(t,n,{get:()=>e[n],enumerable:!(i=$g(e,n))||i.enumerable});return t};var Z=t=>zg(ds({},\"__esModule\",{value:!0}),t);var B,_=be(()=>{B={deviceMemory:8,hardwareConcurrency:8,language:\"en-US\"}});var P={};Qt(P,{_debugEnd:()=>yu,_debugProcess:()=>gu,_events:()=>ku,_eventsCount:()=>xu,_exiting:()=>Yl,_fatalExceptions:()=>cu,_getActiveHandles:()=>eu,_getActiveRequests:()=>Zl,_kill:()=>ru,_linkedBinding:()=>Gl,_maxListeners:()=>Ou,_preload_modules:()=>Cu,_rawDebug:()=>zl,_startProfilerIdleNotifier:()=>bu,_stopProfilerIdleNotifier:()=>wu,_tickCallback:()=>pu,abort:()=>Eu,addListener:()=>Mu,allowedNodeEnvironmentFlags:()=>lu,arch:()=>xl,argv:()=>Ul,argv0:()=>Ru,assert:()=>uu,binding:()=>Fl,chdir:()=>Hl,config:()=>Jl,cpuUsage:()=>Fi,cwd:()=>$l,debugPort:()=>Tu,default:()=>$u,dlopen:()=>Xl,domain:()=>Ql,emit:()=>Du,emitWarning:()=>jl,env:()=>Ll,execArgv:()=>Nl,execPath:()=>Iu,exit:()=>ou,features:()=>fu,hasUncaughtExceptionCaptureCallback:()=>du,hrtime:()=>ji,kill:()=>su,listeners:()=>Wu,memoryUsage:()=>nu,moduleLoadList:()=>Kl,nextTick:()=>Pl,off:()=>Uu,on:()=>bt,once:()=>Lu,openStdin:()=>au,pid:()=>Su,platform:()=>Ml,ppid:()=>Au,prependListener:()=>ju,prependOnceListener:()=>Fu,reallyExit:()=>tu,release:()=>Vl,removeAllListeners:()=>qu,removeListener:()=>Nu,resourceUsage:()=>iu,setSourceMapsEnabled:()=>Bu,setUncaughtExceptionCaptureCallback:()=>hu,stderr:()=>mu,stdin:()=>vu,stdout:()=>_u,title:()=>kl,umask:()=>Wl,uptime:()=>Pu,version:()=>ql,versions:()=>Dl});function ys(t){throw new Error(\"Node.js process \"+t+\" is not supported by JSPM core outside of Node.js\")}function Kg(){!kr||!Yt||(kr=!1,Yt.length?yt=Yt.concat(yt):Di=-1,yt.length&&Bl())}function Bl(){if(!kr){var t=setTimeout(Kg,0);kr=!0;for(var e=yt.length;e;){for(Yt=yt,yt=[];++Di<e;)Yt&&Yt[Di].run();Di=-1,e=yt.length}Yt=null,kr=!1,clearTimeout(t)}}function Pl(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];yt.push(new Ol(t,e)),yt.length===1&&!kr&&setTimeout(Bl,0)}function Ol(t,e){this.fun=t,this.array=e}function me(){}function Gl(t){ys(\"_linkedBinding\")}function Xl(t){ys(\"dlopen\")}function Zl(){return[]}function eu(){return[]}function uu(t,e){if(!t)throw new Error(e||\"assertion error\")}function du(){return!1}function Pu(){return Mt.now()/1e3}function ji(t){var e=Math.floor((Date.now()-Mt.now())*.001),r=Mt.now()*.001,i=Math.floor(r)+e,n=Math.floor(r%1*1e9);return t&&(i=i-t[0],n=n-t[1],n<0&&(i--,n+=gs)),[i,n]}function bt(){return $u}function Wu(t){return[]}var yt,kr,Yt,Di,kl,xl,Ml,Ll,Ul,Nl,ql,Dl,jl,Fl,Wl,$l,Hl,Vl,zl,Kl,Ql,Yl,Jl,tu,ru,Fi,iu,nu,su,ou,au,lu,fu,cu,hu,pu,gu,yu,bu,wu,_u,mu,vu,Eu,Su,Au,Iu,Tu,Ru,Cu,Bu,Mt,ps,gs,Ou,ku,xu,Mu,Lu,Uu,Nu,qu,Du,ju,Fu,$u,Hu=be(()=>{v();m();_();yt=[],kr=!1,Di=-1;Ol.prototype.run=function(){this.fun.apply(null,this.array)};kl=\"browser\",xl=\"x64\",Ml=\"browser\",Ll={PATH:\"/usr/bin\",LANG:B.language+\".UTF-8\",PWD:\"/\",HOME:\"/home\",TMP:\"/tmp\"},Ul=[\"/usr/bin/node\"],Nl=[],ql=\"v16.8.0\",Dl={},jl=function(t,e){console.warn((e?e+\": \":\"\")+t)},Fl=function(t){ys(\"binding\")},Wl=function(t){return 0},$l=function(){return\"/\"},Hl=function(t){},Vl={name:\"node\",sourceUrl:\"\",headersUrl:\"\",libUrl:\"\"};zl=me,Kl=[];Ql={},Yl=!1,Jl={};tu=me,ru=me,Fi=function(){return{}},iu=Fi,nu=Fi,su=me,ou=me,au=me,lu={};fu={inspector:!1,debug:!1,uv:!1,ipv6:!1,tls_alpn:!1,tls_sni:!1,tls_ocsp:!1,tls:!1,cached_builtins:!0},cu=me,hu=me;pu=me,gu=me,yu=me,bu=me,wu=me,_u=void 0,mu=void 0,vu=void 0,Eu=me,Su=2,Au=1,Iu=\"/bin/usr/node\",Tu=9229,Ru=\"node\",Cu=[],Bu=me,Mt={now:typeof performance<\"u\"?performance.now.bind(performance):void 0,timing:typeof performance<\"u\"?performance.timing:void 0};Mt.now===void 0&&(ps=Date.now(),Mt.timing&&Mt.timing.navigationStart&&(ps=Mt.timing.navigationStart),Mt.now=()=>Date.now()-ps);gs=1e9;ji.bigint=function(t){var e=ji(t);return typeof BigInt>\"u\"?e[0]*gs+e[1]:BigInt(e[0]*gs)+BigInt(e[1])};Ou=10,ku={},xu=0;Mu=bt,Lu=bt,Uu=bt,Nu=bt,qu=bt,Du=me,ju=bt,Fu=bt;$u={version:ql,versions:Dl,arch:xl,platform:Ml,release:Vl,_rawDebug:zl,moduleLoadList:Kl,binding:Fl,_linkedBinding:Gl,_events:ku,_eventsCount:xu,_maxListeners:Ou,on:bt,addListener:Mu,once:Lu,off:Uu,removeListener:Nu,removeAllListeners:qu,emit:Du,prependListener:ju,prependOnceListener:Fu,listeners:Wu,domain:Ql,_exiting:Yl,config:Jl,dlopen:Xl,uptime:Pu,_getActiveRequests:Zl,_getActiveHandles:eu,reallyExit:tu,_kill:ru,cpuUsage:Fi,resourceUsage:iu,memoryUsage:nu,kill:su,exit:ou,openStdin:au,allowedNodeEnvironmentFlags:lu,assert:uu,features:fu,_fatalExceptions:cu,setUncaughtExceptionCaptureCallback:hu,hasUncaughtExceptionCaptureCallback:du,emitWarning:jl,nextTick:Pl,_tickCallback:pu,_debugProcess:gu,_debugEnd:yu,_startProfilerIdleNotifier:bu,_stopProfilerIdleNotifier:wu,stdout:_u,stdin:vu,stderr:mu,abort:Eu,umask:Wl,chdir:Hl,cwd:$l,env:Ll,title:kl,argv:Ul,execArgv:Nl,pid:Su,ppid:Au,execPath:Iu,debugPort:Tu,hrtime:ji,argv0:Ru,_preload_modules:Cu,setSourceMapsEnabled:Bu}});var m=be(()=>{Hu()});var ve={};Qt(ve,{Buffer:()=>k,INSPECT_MAX_BYTES:()=>Jg,default:()=>Lt,kMaxLength:()=>Xg});function Gg(){if(Vu)return li;Vu=!0,li.byteLength=a,li.toByteArray=c,li.fromByteArray=g;for(var t=[],e=[],r=typeof Uint8Array<\"u\"?Uint8Array:Array,i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",n=0,o=i.length;n<o;++n)t[n]=i[n],e[i.charCodeAt(n)]=n;e[\"-\".charCodeAt(0)]=62,e[\"_\".charCodeAt(0)]=63;function s(y){var w=y.length;if(w%4>0)throw new Error(\"Invalid string. Length must be a multiple of 4\");var E=y.indexOf(\"=\");E===-1&&(E=w);var S=E===w?0:4-E%4;return[E,S]}function a(y){var w=s(y),E=w[0],S=w[1];return(E+S)*3/4-S}function u(y,w,E){return(w+E)*3/4-E}function c(y){var w,E=s(y),S=E[0],I=E[1],C=new r(u(y,S,I)),R=0,U=I>0?S-4:S,N;for(N=0;N<U;N+=4)w=e[y.charCodeAt(N)]<<18|e[y.charCodeAt(N+1)]<<12|e[y.charCodeAt(N+2)]<<6|e[y.charCodeAt(N+3)],C[R++]=w>>16&255,C[R++]=w>>8&255,C[R++]=w&255;return I===2&&(w=e[y.charCodeAt(N)]<<2|e[y.charCodeAt(N+1)]>>4,C[R++]=w&255),I===1&&(w=e[y.charCodeAt(N)]<<10|e[y.charCodeAt(N+1)]<<4|e[y.charCodeAt(N+2)]>>2,C[R++]=w>>8&255,C[R++]=w&255),C}function h(y){return t[y>>18&63]+t[y>>12&63]+t[y>>6&63]+t[y&63]}function d(y,w,E){for(var S,I=[],C=w;C<E;C+=3)S=(y[C]<<16&16711680)+(y[C+1]<<8&65280)+(y[C+2]&255),I.push(h(S));return I.join(\"\")}function g(y){for(var w,E=y.length,S=E%3,I=[],C=16383,R=0,U=E-S;R<U;R+=C)I.push(d(y,R,R+C>U?U:R+C));return S===1?(w=y[E-1],I.push(t[w>>2]+t[w<<4&63]+\"==\")):S===2&&(w=(y[E-2]<<8)+y[E-1],I.push(t[w>>10]+t[w>>4&63]+t[w<<2&63]+\"=\")),I.join(\"\")}return li}function Qg(){if(zu)return Wi;zu=!0;return Wi.read=function(t,e,r,i,n){var o,s,a=n*8-i-1,u=(1<<a)-1,c=u>>1,h=-7,d=r?n-1:0,g=r?-1:1,y=t[e+d];for(d+=g,o=y&(1<<-h)-1,y>>=-h,h+=a;h>0;o=o*256+t[e+d],d+=g,h-=8);for(s=o&(1<<-h)-1,o>>=-h,h+=i;h>0;s=s*256+t[e+d],d+=g,h-=8);if(o===0)o=1-c;else{if(o===u)return s?NaN:(y?-1:1)*(1/0);s=s+Math.pow(2,i),o=o-c}return(y?-1:1)*s*Math.pow(2,o-i)},Wi.write=function(t,e,r,i,n,o){var s,a,u,c=o*8-n-1,h=(1<<c)-1,d=h>>1,g=n===23?Math.pow(2,-24)-Math.pow(2,-77):0,y=i?0:o-1,w=i?1:-1,E=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=h):(s=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-s))<1&&(s--,u*=2),s+d>=1?e+=g/u:e+=g*Math.pow(2,1-d),e*u>=2&&(s++,u/=2),s+d>=h?(a=0,s=h):s+d>=1?(a=(e*u-1)*Math.pow(2,n),s=s+d):(a=e*Math.pow(2,d-1)*Math.pow(2,n),s=0));n>=8;t[r+y]=a&255,y+=w,a/=256,n-=8);for(s=s<<n|a,c+=n;c>0;t[r+y]=s&255,y+=w,s/=256,c-=8);t[r+y-w]|=E*128},Wi}function Yg(){if(Ku)return Jt;Ku=!0;let t=Gg(),e=Qg(),r=typeof Symbol==\"function\"&&typeof Symbol.for==\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;Jt.Buffer=s,Jt.SlowBuffer=I,Jt.INSPECT_MAX_BYTES=50;let i=2147483647;Jt.kMaxLength=i,s.TYPED_ARRAY_SUPPORT=n(),!s.TYPED_ARRAY_SUPPORT&&typeof console<\"u\"&&typeof console.error==\"function\"&&console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");function n(){try{let p=new Uint8Array(1),l={foo:function(){return 42}};return Object.setPrototypeOf(l,Uint8Array.prototype),Object.setPrototypeOf(p,l),p.foo()===42}catch{return!1}}Object.defineProperty(s.prototype,\"parent\",{enumerable:!0,get:function(){if(s.isBuffer(this))return this.buffer}}),Object.defineProperty(s.prototype,\"offset\",{enumerable:!0,get:function(){if(s.isBuffer(this))return this.byteOffset}});function o(p){if(p>i)throw new RangeError('The value \"'+p+'\" is invalid for option \"size\"');let l=new Uint8Array(p);return Object.setPrototypeOf(l,s.prototype),l}function s(p,l,f){if(typeof p==\"number\"){if(typeof l==\"string\")throw new TypeError('The \"string\" argument must be of type string. Received type number');return h(p)}return a(p,l,f)}s.poolSize=8192;function a(p,l,f){if(typeof p==\"string\")return d(p,l);if(ArrayBuffer.isView(p))return y(p);if(p==null)throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof p);if(Ye(p,ArrayBuffer)||p&&Ye(p.buffer,ArrayBuffer)||typeof SharedArrayBuffer<\"u\"&&(Ye(p,SharedArrayBuffer)||p&&Ye(p.buffer,SharedArrayBuffer)))return w(p,l,f);if(typeof p==\"number\")throw new TypeError('The \"value\" argument must not be of type number. Received type number');let b=p.valueOf&&p.valueOf();if(b!=null&&b!==p)return s.from(b,l,f);let A=E(p);if(A)return A;if(typeof Symbol<\"u\"&&Symbol.toPrimitive!=null&&typeof p[Symbol.toPrimitive]==\"function\")return s.from(p[Symbol.toPrimitive](\"string\"),l,f);throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof p)}s.from=function(p,l,f){return a(p,l,f)},Object.setPrototypeOf(s.prototype,Uint8Array.prototype),Object.setPrototypeOf(s,Uint8Array);function u(p){if(typeof p!=\"number\")throw new TypeError('\"size\" argument must be of type number');if(p<0)throw new RangeError('The value \"'+p+'\" is invalid for option \"size\"')}function c(p,l,f){return u(p),p<=0?o(p):l!==void 0?typeof f==\"string\"?o(p).fill(l,f):o(p).fill(l):o(p)}s.alloc=function(p,l,f){return c(p,l,f)};function h(p){return u(p),o(p<0?0:S(p)|0)}s.allocUnsafe=function(p){return h(p)},s.allocUnsafeSlow=function(p){return h(p)};function d(p,l){if((typeof l!=\"string\"||l===\"\")&&(l=\"utf8\"),!s.isEncoding(l))throw new TypeError(\"Unknown encoding: \"+l);let f=C(p,l)|0,b=o(f),A=b.write(p,l);return A!==f&&(b=b.slice(0,A)),b}function g(p){let l=p.length<0?0:S(p.length)|0,f=o(l);for(let b=0;b<l;b+=1)f[b]=p[b]&255;return f}function y(p){if(Ye(p,Uint8Array)){let l=new Uint8Array(p);return w(l.buffer,l.byteOffset,l.byteLength)}return g(p)}function w(p,l,f){if(l<0||p.byteLength<l)throw new RangeError('\"offset\" is outside of buffer bounds');if(p.byteLength<l+(f||0))throw new RangeError('\"length\" is outside of buffer bounds');let b;return l===void 0&&f===void 0?b=new Uint8Array(p):f===void 0?b=new Uint8Array(p,l):b=new Uint8Array(p,l,f),Object.setPrototypeOf(b,s.prototype),b}function E(p){if(s.isBuffer(p)){let l=S(p.length)|0,f=o(l);return f.length===0||p.copy(f,0,0,l),f}if(p.length!==void 0)return typeof p.length!=\"number\"||hs(p.length)?o(0):g(p);if(p.type===\"Buffer\"&&Array.isArray(p.data))return g(p.data)}function S(p){if(p>=i)throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+i.toString(16)+\" bytes\");return p|0}function I(p){return+p!=p&&(p=0),s.alloc(+p)}s.isBuffer=function(l){return l!=null&&l._isBuffer===!0&&l!==s.prototype},s.compare=function(l,f){if(Ye(l,Uint8Array)&&(l=s.from(l,l.offset,l.byteLength)),Ye(f,Uint8Array)&&(f=s.from(f,f.offset,f.byteLength)),!s.isBuffer(l)||!s.isBuffer(f))throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');if(l===f)return 0;let b=l.length,A=f.length;for(let T=0,O=Math.min(b,A);T<O;++T)if(l[T]!==f[T]){b=l[T],A=f[T];break}return b<A?-1:A<b?1:0},s.isEncoding=function(l){switch(String(l).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}},s.concat=function(l,f){if(!Array.isArray(l))throw new TypeError('\"list\" argument must be an Array of Buffers');if(l.length===0)return s.alloc(0);let b;if(f===void 0)for(f=0,b=0;b<l.length;++b)f+=l[b].length;let A=s.allocUnsafe(f),T=0;for(b=0;b<l.length;++b){let O=l[b];if(Ye(O,Uint8Array))T+O.length>A.length?(s.isBuffer(O)||(O=s.from(O)),O.copy(A,T)):Uint8Array.prototype.set.call(A,O,T);else if(s.isBuffer(O))O.copy(A,T);else throw new TypeError('\"list\" argument must be an Array of Buffers');T+=O.length}return A};function C(p,l){if(s.isBuffer(p))return p.length;if(ArrayBuffer.isView(p)||Ye(p,ArrayBuffer))return p.byteLength;if(typeof p!=\"string\")throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof p);let f=p.length,b=arguments.length>2&&arguments[2]===!0;if(!b&&f===0)return 0;let A=!1;for(;;)switch(l){case\"ascii\":case\"latin1\":case\"binary\":return f;case\"utf8\":case\"utf-8\":return cs(p).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return f*2;case\"hex\":return f>>>1;case\"base64\":return Cl(p).length;default:if(A)return b?-1:cs(p).length;l=(\"\"+l).toLowerCase(),A=!0}}s.byteLength=C;function R(p,l,f){let b=!1;if((l===void 0||l<0)&&(l=0),l>this.length||((f===void 0||f>this.length)&&(f=this.length),f<=0)||(f>>>=0,l>>>=0,f<=l))return\"\";for(p||(p=\"utf8\");;)switch(p){case\"hex\":return Mg(this,l,f);case\"utf8\":case\"utf-8\":return Rr(this,l,f);case\"ascii\":return us(this,l,f);case\"latin1\":case\"binary\":return xg(this,l,f);case\"base64\":return pe(this,l,f);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return Lg(this,l,f);default:if(b)throw new TypeError(\"Unknown encoding: \"+p);p=(p+\"\").toLowerCase(),b=!0}}s.prototype._isBuffer=!0;function U(p,l,f){let b=p[l];p[l]=p[f],p[f]=b}s.prototype.swap16=function(){let l=this.length;if(l%2!==0)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(let f=0;f<l;f+=2)U(this,f,f+1);return this},s.prototype.swap32=function(){let l=this.length;if(l%4!==0)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(let f=0;f<l;f+=4)U(this,f,f+3),U(this,f+1,f+2);return this},s.prototype.swap64=function(){let l=this.length;if(l%8!==0)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(let f=0;f<l;f+=8)U(this,f,f+7),U(this,f+1,f+6),U(this,f+2,f+5),U(this,f+3,f+4);return this},s.prototype.toString=function(){let l=this.length;return l===0?\"\":arguments.length===0?Rr(this,0,l):R.apply(this,arguments)},s.prototype.toLocaleString=s.prototype.toString,s.prototype.equals=function(l){if(!s.isBuffer(l))throw new TypeError(\"Argument must be a Buffer\");return this===l?!0:s.compare(this,l)===0},s.prototype.inspect=function(){let l=\"\",f=Jt.INSPECT_MAX_BYTES;return l=this.toString(\"hex\",0,f).replace(/(.{2})/g,\"$1 \").trim(),this.length>f&&(l+=\" ... \"),\"<Buffer \"+l+\">\"},r&&(s.prototype[r]=s.prototype.inspect),s.prototype.compare=function(l,f,b,A,T){if(Ye(l,Uint8Array)&&(l=s.from(l,l.offset,l.byteLength)),!s.isBuffer(l))throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type '+typeof l);if(f===void 0&&(f=0),b===void 0&&(b=l?l.length:0),A===void 0&&(A=0),T===void 0&&(T=this.length),f<0||b>l.length||A<0||T>this.length)throw new RangeError(\"out of range index\");if(A>=T&&f>=b)return 0;if(A>=T)return-1;if(f>=b)return 1;if(f>>>=0,b>>>=0,A>>>=0,T>>>=0,this===l)return 0;let O=T-A,$=b-f,se=Math.min(O,$),te=this.slice(A,T),oe=l.slice(f,b);for(let J=0;J<se;++J)if(te[J]!==oe[J]){O=te[J],$=oe[J];break}return O<$?-1:$<O?1:0};function N(p,l,f,b,A){if(p.length===0)return-1;if(typeof f==\"string\"?(b=f,f=0):f>2147483647?f=2147483647:f<-2147483648&&(f=-2147483648),f=+f,hs(f)&&(f=A?0:p.length-1),f<0&&(f=p.length+f),f>=p.length){if(A)return-1;f=p.length-1}else if(f<0)if(A)f=0;else return-1;if(typeof l==\"string\"&&(l=s.from(l,b)),s.isBuffer(l))return l.length===0?-1:W(p,l,f,b,A);if(typeof l==\"number\")return l=l&255,typeof Uint8Array.prototype.indexOf==\"function\"?A?Uint8Array.prototype.indexOf.call(p,l,f):Uint8Array.prototype.lastIndexOf.call(p,l,f):W(p,[l],f,b,A);throw new TypeError(\"val must be string, number or Buffer\")}function W(p,l,f,b,A){let T=1,O=p.length,$=l.length;if(b!==void 0&&(b=String(b).toLowerCase(),b===\"ucs2\"||b===\"ucs-2\"||b===\"utf16le\"||b===\"utf-16le\")){if(p.length<2||l.length<2)return-1;T=2,O/=2,$/=2,f/=2}function se(oe,J){return T===1?oe[J]:oe.readUInt16BE(J*T)}let te;if(A){let oe=-1;for(te=f;te<O;te++)if(se(p,te)===se(l,oe===-1?0:te-oe)){if(oe===-1&&(oe=te),te-oe+1===$)return oe*T}else oe!==-1&&(te-=te-oe),oe=-1}else for(f+$>O&&(f=O-$),te=f;te>=0;te--){let oe=!0;for(let J=0;J<$;J++)if(se(p,te+J)!==se(l,J)){oe=!1;break}if(oe)return te}return-1}s.prototype.includes=function(l,f,b){return this.indexOf(l,f,b)!==-1},s.prototype.indexOf=function(l,f,b){return N(this,l,f,b,!0)},s.prototype.lastIndexOf=function(l,f,b){return N(this,l,f,b,!1)};function K(p,l,f,b){f=Number(f)||0;let A=p.length-f;b?(b=Number(b),b>A&&(b=A)):b=A;let T=l.length;b>T/2&&(b=T/2);let O;for(O=0;O<b;++O){let $=parseInt(l.substr(O*2,2),16);if(hs($))return O;p[f+O]=$}return O}function z(p,l,f,b){return qi(cs(l,p.length-f),p,f,b)}function Q(p,l,f,b){return qi(Dg(l),p,f,b)}function de(p,l,f,b){return qi(Cl(l),p,f,b)}function Gt(p,l,f,b){return qi(jg(l,p.length-f),p,f,b)}s.prototype.write=function(l,f,b,A){if(f===void 0)A=\"utf8\",b=this.length,f=0;else if(b===void 0&&typeof f==\"string\")A=f,b=this.length,f=0;else if(isFinite(f))f=f>>>0,isFinite(b)?(b=b>>>0,A===void 0&&(A=\"utf8\")):(A=b,b=void 0);else throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");let T=this.length-f;if((b===void 0||b>T)&&(b=T),l.length>0&&(b<0||f<0)||f>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");A||(A=\"utf8\");let O=!1;for(;;)switch(A){case\"hex\":return K(this,l,f,b);case\"utf8\":case\"utf-8\":return z(this,l,f,b);case\"ascii\":case\"latin1\":case\"binary\":return Q(this,l,f,b);case\"base64\":return de(this,l,f,b);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return Gt(this,l,f,b);default:if(O)throw new TypeError(\"Unknown encoding: \"+A);A=(\"\"+A).toLowerCase(),O=!0}},s.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function pe(p,l,f){return l===0&&f===p.length?t.fromByteArray(p):t.fromByteArray(p.slice(l,f))}function Rr(p,l,f){f=Math.min(p.length,f);let b=[],A=l;for(;A<f;){let T=p[A],O=null,$=T>239?4:T>223?3:T>191?2:1;if(A+$<=f){let se,te,oe,J;switch($){case 1:T<128&&(O=T);break;case 2:se=p[A+1],(se&192)===128&&(J=(T&31)<<6|se&63,J>127&&(O=J));break;case 3:se=p[A+1],te=p[A+2],(se&192)===128&&(te&192)===128&&(J=(T&15)<<12|(se&63)<<6|te&63,J>2047&&(J<55296||J>57343)&&(O=J));break;case 4:se=p[A+1],te=p[A+2],oe=p[A+3],(se&192)===128&&(te&192)===128&&(oe&192)===128&&(J=(T&15)<<18|(se&63)<<12|(te&63)<<6|oe&63,J>65535&&J<1114112&&(O=J))}}O===null?(O=65533,$=1):O>65535&&(O-=65536,b.push(O>>>10&1023|55296),O=56320|O&1023),b.push(O),A+=$}return Br(b)}let Cr=4096;function Br(p){let l=p.length;if(l<=Cr)return String.fromCharCode.apply(String,p);let f=\"\",b=0;for(;b<l;)f+=String.fromCharCode.apply(String,p.slice(b,b+=Cr));return f}function us(p,l,f){let b=\"\";f=Math.min(p.length,f);for(let A=l;A<f;++A)b+=String.fromCharCode(p[A]&127);return b}function xg(p,l,f){let b=\"\";f=Math.min(p.length,f);for(let A=l;A<f;++A)b+=String.fromCharCode(p[A]);return b}function Mg(p,l,f){let b=p.length;(!l||l<0)&&(l=0),(!f||f<0||f>b)&&(f=b);let A=\"\";for(let T=l;T<f;++T)A+=Fg[p[T]];return A}function Lg(p,l,f){let b=p.slice(l,f),A=\"\";for(let T=0;T<b.length-1;T+=2)A+=String.fromCharCode(b[T]+b[T+1]*256);return A}s.prototype.slice=function(l,f){let b=this.length;l=~~l,f=f===void 0?b:~~f,l<0?(l+=b,l<0&&(l=0)):l>b&&(l=b),f<0?(f+=b,f<0&&(f=0)):f>b&&(f=b),f<l&&(f=l);let A=this.subarray(l,f);return Object.setPrototypeOf(A,s.prototype),A};function ge(p,l,f){if(p%1!==0||p<0)throw new RangeError(\"offset is not uint\");if(p+l>f)throw new RangeError(\"Trying to access beyond buffer length\")}s.prototype.readUintLE=s.prototype.readUIntLE=function(l,f,b){l=l>>>0,f=f>>>0,b||ge(l,f,this.length);let A=this[l],T=1,O=0;for(;++O<f&&(T*=256);)A+=this[l+O]*T;return A},s.prototype.readUintBE=s.prototype.readUIntBE=function(l,f,b){l=l>>>0,f=f>>>0,b||ge(l,f,this.length);let A=this[l+--f],T=1;for(;f>0&&(T*=256);)A+=this[l+--f]*T;return A},s.prototype.readUint8=s.prototype.readUInt8=function(l,f){return l=l>>>0,f||ge(l,1,this.length),this[l]},s.prototype.readUint16LE=s.prototype.readUInt16LE=function(l,f){return l=l>>>0,f||ge(l,2,this.length),this[l]|this[l+1]<<8},s.prototype.readUint16BE=s.prototype.readUInt16BE=function(l,f){return l=l>>>0,f||ge(l,2,this.length),this[l]<<8|this[l+1]},s.prototype.readUint32LE=s.prototype.readUInt32LE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),(this[l]|this[l+1]<<8|this[l+2]<<16)+this[l+3]*16777216},s.prototype.readUint32BE=s.prototype.readUInt32BE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),this[l]*16777216+(this[l+1]<<16|this[l+2]<<8|this[l+3])},s.prototype.readBigUInt64LE=xt(function(l){l=l>>>0,Or(l,\"offset\");let f=this[l],b=this[l+7];(f===void 0||b===void 0)&&ai(l,this.length-8);let A=f+this[++l]*2**8+this[++l]*2**16+this[++l]*2**24,T=this[++l]+this[++l]*2**8+this[++l]*2**16+b*2**24;return BigInt(A)+(BigInt(T)<<BigInt(32))}),s.prototype.readBigUInt64BE=xt(function(l){l=l>>>0,Or(l,\"offset\");let f=this[l],b=this[l+7];(f===void 0||b===void 0)&&ai(l,this.length-8);let A=f*2**24+this[++l]*2**16+this[++l]*2**8+this[++l],T=this[++l]*2**24+this[++l]*2**16+this[++l]*2**8+b;return(BigInt(A)<<BigInt(32))+BigInt(T)}),s.prototype.readIntLE=function(l,f,b){l=l>>>0,f=f>>>0,b||ge(l,f,this.length);let A=this[l],T=1,O=0;for(;++O<f&&(T*=256);)A+=this[l+O]*T;return T*=128,A>=T&&(A-=Math.pow(2,8*f)),A},s.prototype.readIntBE=function(l,f,b){l=l>>>0,f=f>>>0,b||ge(l,f,this.length);let A=f,T=1,O=this[l+--A];for(;A>0&&(T*=256);)O+=this[l+--A]*T;return T*=128,O>=T&&(O-=Math.pow(2,8*f)),O},s.prototype.readInt8=function(l,f){return l=l>>>0,f||ge(l,1,this.length),this[l]&128?(255-this[l]+1)*-1:this[l]},s.prototype.readInt16LE=function(l,f){l=l>>>0,f||ge(l,2,this.length);let b=this[l]|this[l+1]<<8;return b&32768?b|4294901760:b},s.prototype.readInt16BE=function(l,f){l=l>>>0,f||ge(l,2,this.length);let b=this[l+1]|this[l]<<8;return b&32768?b|4294901760:b},s.prototype.readInt32LE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),this[l]|this[l+1]<<8|this[l+2]<<16|this[l+3]<<24},s.prototype.readInt32BE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),this[l]<<24|this[l+1]<<16|this[l+2]<<8|this[l+3]},s.prototype.readBigInt64LE=xt(function(l){l=l>>>0,Or(l,\"offset\");let f=this[l],b=this[l+7];(f===void 0||b===void 0)&&ai(l,this.length-8);let A=this[l+4]+this[l+5]*2**8+this[l+6]*2**16+(b<<24);return(BigInt(A)<<BigInt(32))+BigInt(f+this[++l]*2**8+this[++l]*2**16+this[++l]*2**24)}),s.prototype.readBigInt64BE=xt(function(l){l=l>>>0,Or(l,\"offset\");let f=this[l],b=this[l+7];(f===void 0||b===void 0)&&ai(l,this.length-8);let A=(f<<24)+this[++l]*2**16+this[++l]*2**8+this[++l];return(BigInt(A)<<BigInt(32))+BigInt(this[++l]*2**24+this[++l]*2**16+this[++l]*2**8+b)}),s.prototype.readFloatLE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),e.read(this,l,!0,23,4)},s.prototype.readFloatBE=function(l,f){return l=l>>>0,f||ge(l,4,this.length),e.read(this,l,!1,23,4)},s.prototype.readDoubleLE=function(l,f){return l=l>>>0,f||ge(l,8,this.length),e.read(this,l,!0,52,8)},s.prototype.readDoubleBE=function(l,f){return l=l>>>0,f||ge(l,8,this.length),e.read(this,l,!1,52,8)};function Ce(p,l,f,b,A,T){if(!s.isBuffer(p))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(l>A||l<T)throw new RangeError('\"value\" argument is out of bounds');if(f+b>p.length)throw new RangeError(\"Index out of range\")}s.prototype.writeUintLE=s.prototype.writeUIntLE=function(l,f,b,A){if(l=+l,f=f>>>0,b=b>>>0,!A){let $=Math.pow(2,8*b)-1;Ce(this,l,f,b,$,0)}let T=1,O=0;for(this[f]=l&255;++O<b&&(T*=256);)this[f+O]=l/T&255;return f+b},s.prototype.writeUintBE=s.prototype.writeUIntBE=function(l,f,b,A){if(l=+l,f=f>>>0,b=b>>>0,!A){let $=Math.pow(2,8*b)-1;Ce(this,l,f,b,$,0)}let T=b-1,O=1;for(this[f+T]=l&255;--T>=0&&(O*=256);)this[f+T]=l/O&255;return f+b},s.prototype.writeUint8=s.prototype.writeUInt8=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,1,255,0),this[f]=l&255,f+1},s.prototype.writeUint16LE=s.prototype.writeUInt16LE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,2,65535,0),this[f]=l&255,this[f+1]=l>>>8,f+2},s.prototype.writeUint16BE=s.prototype.writeUInt16BE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,2,65535,0),this[f]=l>>>8,this[f+1]=l&255,f+2},s.prototype.writeUint32LE=s.prototype.writeUInt32LE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,4,4294967295,0),this[f+3]=l>>>24,this[f+2]=l>>>16,this[f+1]=l>>>8,this[f]=l&255,f+4},s.prototype.writeUint32BE=s.prototype.writeUInt32BE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,4,4294967295,0),this[f]=l>>>24,this[f+1]=l>>>16,this[f+2]=l>>>8,this[f+3]=l&255,f+4};function vl(p,l,f,b,A){Rl(l,b,A,p,f,7);let T=Number(l&BigInt(4294967295));p[f++]=T,T=T>>8,p[f++]=T,T=T>>8,p[f++]=T,T=T>>8,p[f++]=T;let O=Number(l>>BigInt(32)&BigInt(4294967295));return p[f++]=O,O=O>>8,p[f++]=O,O=O>>8,p[f++]=O,O=O>>8,p[f++]=O,f}function El(p,l,f,b,A){Rl(l,b,A,p,f,7);let T=Number(l&BigInt(4294967295));p[f+7]=T,T=T>>8,p[f+6]=T,T=T>>8,p[f+5]=T,T=T>>8,p[f+4]=T;let O=Number(l>>BigInt(32)&BigInt(4294967295));return p[f+3]=O,O=O>>8,p[f+2]=O,O=O>>8,p[f+1]=O,O=O>>8,p[f]=O,f+8}s.prototype.writeBigUInt64LE=xt(function(l,f=0){return vl(this,l,f,BigInt(0),BigInt(\"0xffffffffffffffff\"))}),s.prototype.writeBigUInt64BE=xt(function(l,f=0){return El(this,l,f,BigInt(0),BigInt(\"0xffffffffffffffff\"))}),s.prototype.writeIntLE=function(l,f,b,A){if(l=+l,f=f>>>0,!A){let se=Math.pow(2,8*b-1);Ce(this,l,f,b,se-1,-se)}let T=0,O=1,$=0;for(this[f]=l&255;++T<b&&(O*=256);)l<0&&$===0&&this[f+T-1]!==0&&($=1),this[f+T]=(l/O>>0)-$&255;return f+b},s.prototype.writeIntBE=function(l,f,b,A){if(l=+l,f=f>>>0,!A){let se=Math.pow(2,8*b-1);Ce(this,l,f,b,se-1,-se)}let T=b-1,O=1,$=0;for(this[f+T]=l&255;--T>=0&&(O*=256);)l<0&&$===0&&this[f+T+1]!==0&&($=1),this[f+T]=(l/O>>0)-$&255;return f+b},s.prototype.writeInt8=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,1,127,-128),l<0&&(l=255+l+1),this[f]=l&255,f+1},s.prototype.writeInt16LE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,2,32767,-32768),this[f]=l&255,this[f+1]=l>>>8,f+2},s.prototype.writeInt16BE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,2,32767,-32768),this[f]=l>>>8,this[f+1]=l&255,f+2},s.prototype.writeInt32LE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,4,2147483647,-2147483648),this[f]=l&255,this[f+1]=l>>>8,this[f+2]=l>>>16,this[f+3]=l>>>24,f+4},s.prototype.writeInt32BE=function(l,f,b){return l=+l,f=f>>>0,b||Ce(this,l,f,4,2147483647,-2147483648),l<0&&(l=4294967295+l+1),this[f]=l>>>24,this[f+1]=l>>>16,this[f+2]=l>>>8,this[f+3]=l&255,f+4},s.prototype.writeBigInt64LE=xt(function(l,f=0){return vl(this,l,f,-BigInt(\"0x8000000000000000\"),BigInt(\"0x7fffffffffffffff\"))}),s.prototype.writeBigInt64BE=xt(function(l,f=0){return El(this,l,f,-BigInt(\"0x8000000000000000\"),BigInt(\"0x7fffffffffffffff\"))});function Sl(p,l,f,b,A,T){if(f+b>p.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"Index out of range\")}function Al(p,l,f,b,A){return l=+l,f=f>>>0,A||Sl(p,l,f,4),e.write(p,l,f,b,23,4),f+4}s.prototype.writeFloatLE=function(l,f,b){return Al(this,l,f,!0,b)},s.prototype.writeFloatBE=function(l,f,b){return Al(this,l,f,!1,b)};function Il(p,l,f,b,A){return l=+l,f=f>>>0,A||Sl(p,l,f,8),e.write(p,l,f,b,52,8),f+8}s.prototype.writeDoubleLE=function(l,f,b){return Il(this,l,f,!0,b)},s.prototype.writeDoubleBE=function(l,f,b){return Il(this,l,f,!1,b)},s.prototype.copy=function(l,f,b,A){if(!s.isBuffer(l))throw new TypeError(\"argument should be a Buffer\");if(b||(b=0),!A&&A!==0&&(A=this.length),f>=l.length&&(f=l.length),f||(f=0),A>0&&A<b&&(A=b),A===b||l.length===0||this.length===0)return 0;if(f<0)throw new RangeError(\"targetStart out of bounds\");if(b<0||b>=this.length)throw new RangeError(\"Index out of range\");if(A<0)throw new RangeError(\"sourceEnd out of bounds\");A>this.length&&(A=this.length),l.length-f<A-b&&(A=l.length-f+b);let T=A-b;return this===l&&typeof Uint8Array.prototype.copyWithin==\"function\"?this.copyWithin(f,b,A):Uint8Array.prototype.set.call(l,this.subarray(b,A),f),T},s.prototype.fill=function(l,f,b,A){if(typeof l==\"string\"){if(typeof f==\"string\"?(A=f,f=0,b=this.length):typeof b==\"string\"&&(A=b,b=this.length),A!==void 0&&typeof A!=\"string\")throw new TypeError(\"encoding must be a string\");if(typeof A==\"string\"&&!s.isEncoding(A))throw new TypeError(\"Unknown encoding: \"+A);if(l.length===1){let O=l.charCodeAt(0);(A===\"utf8\"&&O<128||A===\"latin1\")&&(l=O)}}else typeof l==\"number\"?l=l&255:typeof l==\"boolean\"&&(l=Number(l));if(f<0||this.length<f||this.length<b)throw new RangeError(\"Out of range index\");if(b<=f)return this;f=f>>>0,b=b===void 0?this.length:b>>>0,l||(l=0);let T;if(typeof l==\"number\")for(T=f;T<b;++T)this[T]=l;else{let O=s.isBuffer(l)?l:s.from(l,A),$=O.length;if($===0)throw new TypeError('The value \"'+l+'\" is invalid for argument \"value\"');for(T=0;T<b-f;++T)this[T+f]=O[T%$]}return this};let Pr={};function fs(p,l,f){Pr[p]=class extends f{constructor(){super(),Object.defineProperty(this,\"message\",{value:l.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${p}]`,this.stack,delete this.name}get code(){return p}set code(A){Object.defineProperty(this,\"code\",{configurable:!0,enumerable:!0,value:A,writable:!0})}toString(){return`${this.name} [${p}]: ${this.message}`}}}fs(\"ERR_BUFFER_OUT_OF_BOUNDS\",function(p){return p?`${p} is outside of buffer bounds`:\"Attempt to access memory outside buffer bounds\"},RangeError),fs(\"ERR_INVALID_ARG_TYPE\",function(p,l){return`The \"${p}\" argument must be of type number. Received type ${typeof l}`},TypeError),fs(\"ERR_OUT_OF_RANGE\",function(p,l,f){let b=`The value of \"${p}\" is out of range.`,A=f;return Number.isInteger(f)&&Math.abs(f)>2**32?A=Tl(String(f)):typeof f==\"bigint\"&&(A=String(f),(f>BigInt(2)**BigInt(32)||f<-(BigInt(2)**BigInt(32)))&&(A=Tl(A)),A+=\"n\"),b+=` It must be ${l}. Received ${A}`,b},RangeError);function Tl(p){let l=\"\",f=p.length,b=p[0]===\"-\"?1:0;for(;f>=b+4;f-=3)l=`_${p.slice(f-3,f)}${l}`;return`${p.slice(0,f)}${l}`}function Ug(p,l,f){Or(l,\"offset\"),(p[l]===void 0||p[l+f]===void 0)&&ai(l,p.length-(f+1))}function Rl(p,l,f,b,A,T){if(p>f||p<l){let O=typeof l==\"bigint\"?\"n\":\"\",$;throw T>3?l===0||l===BigInt(0)?$=`>= 0${O} and < 2${O} ** ${(T+1)*8}${O}`:$=`>= -(2${O} ** ${(T+1)*8-1}${O}) and < 2 ** ${(T+1)*8-1}${O}`:$=`>= ${l}${O} and <= ${f}${O}`,new Pr.ERR_OUT_OF_RANGE(\"value\",$,p)}Ug(b,A,T)}function Or(p,l){if(typeof p!=\"number\")throw new Pr.ERR_INVALID_ARG_TYPE(l,\"number\",p)}function ai(p,l,f){throw Math.floor(p)!==p?(Or(p,f),new Pr.ERR_OUT_OF_RANGE(f||\"offset\",\"an integer\",p)):l<0?new Pr.ERR_BUFFER_OUT_OF_BOUNDS:new Pr.ERR_OUT_OF_RANGE(f||\"offset\",`>= ${f?1:0} and <= ${l}`,p)}let Ng=/[^+/0-9A-Za-z-_]/g;function qg(p){if(p=p.split(\"=\")[0],p=p.trim().replace(Ng,\"\"),p.length<2)return\"\";for(;p.length%4!==0;)p=p+\"=\";return p}function cs(p,l){l=l||1/0;let f,b=p.length,A=null,T=[];for(let O=0;O<b;++O){if(f=p.charCodeAt(O),f>55295&&f<57344){if(!A){if(f>56319){(l-=3)>-1&&T.push(239,191,189);continue}else if(O+1===b){(l-=3)>-1&&T.push(239,191,189);continue}A=f;continue}if(f<56320){(l-=3)>-1&&T.push(239,191,189),A=f;continue}f=(A-55296<<10|f-56320)+65536}else A&&(l-=3)>-1&&T.push(239,191,189);if(A=null,f<128){if((l-=1)<0)break;T.push(f)}else if(f<2048){if((l-=2)<0)break;T.push(f>>6|192,f&63|128)}else if(f<65536){if((l-=3)<0)break;T.push(f>>12|224,f>>6&63|128,f&63|128)}else if(f<1114112){if((l-=4)<0)break;T.push(f>>18|240,f>>12&63|128,f>>6&63|128,f&63|128)}else throw new Error(\"Invalid code point\")}return T}function Dg(p){let l=[];for(let f=0;f<p.length;++f)l.push(p.charCodeAt(f)&255);return l}function jg(p,l){let f,b,A,T=[];for(let O=0;O<p.length&&!((l-=2)<0);++O)f=p.charCodeAt(O),b=f>>8,A=f%256,T.push(A),T.push(b);return T}function Cl(p){return t.toByteArray(qg(p))}function qi(p,l,f,b){let A;for(A=0;A<b&&!(A+f>=l.length||A>=p.length);++A)l[A+f]=p[A];return A}function Ye(p,l){return p instanceof l||p!=null&&p.constructor!=null&&p.constructor.name!=null&&p.constructor.name===l.name}function hs(p){return p!==p}let Fg=function(){let p=\"0123456789abcdef\",l=new Array(256);for(let f=0;f<16;++f){let b=f*16;for(let A=0;A<16;++A)l[b+A]=p[f]+p[A]}return l}();function xt(p){return typeof BigInt>\"u\"?Wg:p}function Wg(){throw new Error(\"BigInt not supported\")}return Jt}var li,Vu,Wi,zu,Jt,Ku,Lt,k,Jg,Xg,we=be(()=>{v();m();_();li={},Vu=!1;Wi={},zu=!1;Jt={},Ku=!1;Lt=Yg();Lt.Buffer;Lt.SlowBuffer;Lt.INSPECT_MAX_BYTES;Lt.kMaxLength;k=Lt.Buffer,Jg=Lt.INSPECT_MAX_BYTES,Xg=Lt.kMaxLength});var v=be(()=>{we()});var Gu=M(ws=>{\"use strict\";v();m();_();Object.defineProperty(ws,\"__esModule\",{value:!0});var bs=class{constructor(e){this.aliasToTopic={},this.max=e}put(e,r){return r===0||r>this.max?!1:(this.aliasToTopic[r]=e,this.length=Object.keys(this.aliasToTopic).length,!0)}getTopicByAlias(e){return this.aliasToTopic[e]}clear(){this.aliasToTopic={}}};ws.default=bs});var ce=M((RA,Qu)=>{\"use strict\";v();m();_();Qu.exports={ArrayIsArray(t){return Array.isArray(t)},ArrayPrototypeIncludes(t,e){return t.includes(e)},ArrayPrototypeIndexOf(t,e){return t.indexOf(e)},ArrayPrototypeJoin(t,e){return t.join(e)},ArrayPrototypeMap(t,e){return t.map(e)},ArrayPrototypePop(t,e){return t.pop(e)},ArrayPrototypePush(t,e){return t.push(e)},ArrayPrototypeSlice(t,e,r){return t.slice(e,r)},Error,FunctionPrototypeCall(t,e,...r){return t.call(e,...r)},FunctionPrototypeSymbolHasInstance(t,e){return Function.prototype[Symbol.hasInstance].call(t,e)},MathFloor:Math.floor,Number,NumberIsInteger:Number.isInteger,NumberIsNaN:Number.isNaN,NumberMAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER,NumberMIN_SAFE_INTEGER:Number.MIN_SAFE_INTEGER,NumberParseInt:Number.parseInt,ObjectDefineProperties(t,e){return Object.defineProperties(t,e)},ObjectDefineProperty(t,e,r){return Object.defineProperty(t,e,r)},ObjectGetOwnPropertyDescriptor(t,e){return Object.getOwnPropertyDescriptor(t,e)},ObjectKeys(t){return Object.keys(t)},ObjectSetPrototypeOf(t,e){return Object.setPrototypeOf(t,e)},Promise,PromisePrototypeCatch(t,e){return t.catch(e)},PromisePrototypeThen(t,e,r){return t.then(e,r)},PromiseReject(t){return Promise.reject(t)},ReflectApply:Reflect.apply,RegExpPrototypeTest(t,e){return t.test(e)},SafeSet:Set,String,StringPrototypeSlice(t,e,r){return t.slice(e,r)},StringPrototypeToLowerCase(t){return t.toLowerCase()},StringPrototypeToUpperCase(t){return t.toUpperCase()},StringPrototypeTrim(t){return t.trim()},Symbol,SymbolFor:Symbol.for,SymbolAsyncIterator:Symbol.asyncIterator,SymbolHasInstance:Symbol.hasInstance,SymbolIterator:Symbol.iterator,TypedArrayPrototypeSet(t,e,r){return t.set(e,r)},Uint8Array}});var Je=M((NA,ms)=>{\"use strict\";v();m();_();var Zg=(we(),Z(ve)),ey=Object.getPrototypeOf(async function(){}).constructor,Yu=globalThis.Blob||Zg.Blob,ty=typeof Yu<\"u\"?function(e){return e instanceof Yu}:function(e){return!1},_s=class extends Error{constructor(e){if(!Array.isArray(e))throw new TypeError(`Expected input to be an Array, got ${typeof e}`);let r=\"\";for(let i=0;i<e.length;i++)r+=`    ${e[i].stack}\n`;super(r),this.name=\"AggregateError\",this.errors=e}};ms.exports={AggregateError:_s,kEmptyObject:Object.freeze({}),once(t){let e=!1;return function(...r){e||(e=!0,t.apply(this,r))}},createDeferredPromise:function(){let t,e;return{promise:new Promise((i,n)=>{t=i,e=n}),resolve:t,reject:e}},promisify(t){return new Promise((e,r)=>{t((i,...n)=>i?r(i):e(...n))})},debuglog(){return function(){}},format(t,...e){return t.replace(/%([sdifj])/g,function(...[r,i]){let n=e.shift();return i===\"f\"?n.toFixed(6):i===\"j\"?JSON.stringify(n):i===\"s\"&&typeof n==\"object\"?`${n.constructor!==Object?n.constructor.name:\"\"} {}`.trim():n.toString()})},inspect(t){switch(typeof t){case\"string\":if(t.includes(\"'\"))if(t.includes('\"')){if(!t.includes(\"`\")&&!t.includes(\"${\"))return`\\`${t}\\``}else return`\"${t}\"`;return`'${t}'`;case\"number\":return isNaN(t)?\"NaN\":Object.is(t,-0)?String(t):t;case\"bigint\":return`${String(t)}n`;case\"boolean\":case\"undefined\":return String(t);case\"object\":return\"{}\"}},types:{isAsyncFunction(t){return t instanceof ey},isArrayBufferView(t){return ArrayBuffer.isView(t)}},isBlob:ty};ms.exports.promisify.custom=Symbol.for(\"nodejs.util.promisify.custom\")});var Hi=M((KA,$i)=>{\"use strict\";v();m();_();var{AbortController:Ju,AbortSignal:ry}=typeof self<\"u\"?self:typeof window<\"u\"?window:void 0;$i.exports=Ju;$i.exports.AbortSignal=ry;$i.exports.default=Ju});var Se=M((iI,ef)=>{\"use strict\";v();m();_();var{format:iy,inspect:Vi,AggregateError:ny}=Je(),sy=globalThis.AggregateError||ny,oy=Symbol(\"kIsNodeError\"),ay=[\"string\",\"function\",\"number\",\"object\",\"Function\",\"Object\",\"boolean\",\"bigint\",\"symbol\"],ly=/^([A-Z][a-z0-9]*)+$/,uy=\"__node_internal_\",zi={};function Xt(t,e){if(!t)throw new zi.ERR_INTERNAL_ASSERTION(e)}function Xu(t){let e=\"\",r=t.length,i=t[0]===\"-\"?1:0;for(;r>=i+4;r-=3)e=`_${t.slice(r-3,r)}${e}`;return`${t.slice(0,r)}${e}`}function fy(t,e,r){if(typeof e==\"function\")return Xt(e.length<=r.length,`Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e.length}).`),e(...r);let i=(e.match(/%[dfijoOs]/g)||[]).length;return Xt(i===r.length,`Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${i}).`),r.length===0?e:iy(e,...r)}function _e(t,e,r){r||(r=Error);class i extends r{constructor(...o){super(fy(t,e,o))}toString(){return`${this.name} [${t}]: ${this.message}`}}Object.defineProperties(i.prototype,{name:{value:r.name,writable:!0,enumerable:!1,configurable:!0},toString:{value(){return`${this.name} [${t}]: ${this.message}`},writable:!0,enumerable:!1,configurable:!0}}),i.prototype.code=t,i.prototype[oy]=!0,zi[t]=i}function Zu(t){let e=uy+t.name;return Object.defineProperty(t,\"name\",{value:e}),t}function cy(t,e){if(t&&e&&t!==e){if(Array.isArray(e.errors))return e.errors.push(t),e;let r=new sy([e,t],e.message);return r.code=e.code,r}return t||e}var vs=class extends Error{constructor(e=\"The operation was aborted\",r=void 0){if(r!==void 0&&typeof r!=\"object\")throw new zi.ERR_INVALID_ARG_TYPE(\"options\",\"Object\",r);super(e,r),this.code=\"ABORT_ERR\",this.name=\"AbortError\"}};_e(\"ERR_ASSERTION\",\"%s\",Error);_e(\"ERR_INVALID_ARG_TYPE\",(t,e,r)=>{Xt(typeof t==\"string\",\"'name' must be a string\"),Array.isArray(e)||(e=[e]);let i=\"The \";t.endsWith(\" argument\")?i+=`${t} `:i+=`\"${t}\" ${t.includes(\".\")?\"property\":\"argument\"} `,i+=\"must be \";let n=[],o=[],s=[];for(let u of e)Xt(typeof u==\"string\",\"All expected entries have to be of type string\"),ay.includes(u)?n.push(u.toLowerCase()):ly.test(u)?o.push(u):(Xt(u!==\"object\",'The value \"object\" should be written as \"Object\"'),s.push(u));if(o.length>0){let u=n.indexOf(\"object\");u!==-1&&(n.splice(n,u,1),o.push(\"Object\"))}if(n.length>0){switch(n.length){case 1:i+=`of type ${n[0]}`;break;case 2:i+=`one of type ${n[0]} or ${n[1]}`;break;default:{let u=n.pop();i+=`one of type ${n.join(\", \")}, or ${u}`}}(o.length>0||s.length>0)&&(i+=\" or \")}if(o.length>0){switch(o.length){case 1:i+=`an instance of ${o[0]}`;break;case 2:i+=`an instance of ${o[0]} or ${o[1]}`;break;default:{let u=o.pop();i+=`an instance of ${o.join(\", \")}, or ${u}`}}s.length>0&&(i+=\" or \")}switch(s.length){case 0:break;case 1:s[0].toLowerCase()!==s[0]&&(i+=\"an \"),i+=`${s[0]}`;break;case 2:i+=`one of ${s[0]} or ${s[1]}`;break;default:{let u=s.pop();i+=`one of ${s.join(\", \")}, or ${u}`}}if(r==null)i+=`. Received ${r}`;else if(typeof r==\"function\"&&r.name)i+=`. Received function ${r.name}`;else if(typeof r==\"object\"){var a;if((a=r.constructor)!==null&&a!==void 0&&a.name)i+=`. Received an instance of ${r.constructor.name}`;else{let u=Vi(r,{depth:-1});i+=`. Received ${u}`}}else{let u=Vi(r,{colors:!1});u.length>25&&(u=`${u.slice(0,25)}...`),i+=`. Received type ${typeof r} (${u})`}return i},TypeError);_e(\"ERR_INVALID_ARG_VALUE\",(t,e,r=\"is invalid\")=>{let i=Vi(e);return i.length>128&&(i=i.slice(0,128)+\"...\"),`The ${t.includes(\".\")?\"property\":\"argument\"} '${t}' ${r}. Received ${i}`},TypeError);_e(\"ERR_INVALID_RETURN_VALUE\",(t,e,r)=>{var i;let n=r!=null&&(i=r.constructor)!==null&&i!==void 0&&i.name?`instance of ${r.constructor.name}`:`type ${typeof r}`;return`Expected ${t} to be returned from the \"${e}\" function but got ${n}.`},TypeError);_e(\"ERR_MISSING_ARGS\",(...t)=>{Xt(t.length>0,\"At least one arg needs to be specified\");let e,r=t.length;switch(t=(Array.isArray(t)?t:[t]).map(i=>`\"${i}\"`).join(\" or \"),r){case 1:e+=`The ${t[0]} argument`;break;case 2:e+=`The ${t[0]} and ${t[1]} arguments`;break;default:{let i=t.pop();e+=`The ${t.join(\", \")}, and ${i} arguments`}break}return`${e} must be specified`},TypeError);_e(\"ERR_OUT_OF_RANGE\",(t,e,r)=>{Xt(e,'Missing \"range\" argument');let i;return Number.isInteger(r)&&Math.abs(r)>2**32?i=Xu(String(r)):typeof r==\"bigint\"?(i=String(r),(r>2n**32n||r<-(2n**32n))&&(i=Xu(i)),i+=\"n\"):i=Vi(r),`The value of \"${t}\" is out of range. It must be ${e}. Received ${i}`},RangeError);_e(\"ERR_MULTIPLE_CALLBACK\",\"Callback called multiple times\",Error);_e(\"ERR_METHOD_NOT_IMPLEMENTED\",\"The %s method is not implemented\",Error);_e(\"ERR_STREAM_ALREADY_FINISHED\",\"Cannot call %s after a stream was finished\",Error);_e(\"ERR_STREAM_CANNOT_PIPE\",\"Cannot pipe, not readable\",Error);_e(\"ERR_STREAM_DESTROYED\",\"Cannot call %s after a stream was destroyed\",Error);_e(\"ERR_STREAM_NULL_VALUES\",\"May not write null values to stream\",TypeError);_e(\"ERR_STREAM_PREMATURE_CLOSE\",\"Premature close\",Error);_e(\"ERR_STREAM_PUSH_AFTER_EOF\",\"stream.push() after EOF\",Error);_e(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\",\"stream.unshift() after end event\",Error);_e(\"ERR_STREAM_WRITE_AFTER_END\",\"write after end\",Error);_e(\"ERR_UNKNOWN_ENCODING\",\"Unknown encoding: %s\",TypeError);ef.exports={AbortError:vs,aggregateTwoErrors:Zu(cy),hideStackFrames:Zu,codes:zi}});var ui=M((dI,ff)=>{\"use strict\";v();m();_();var{ArrayIsArray:Ss,ArrayPrototypeIncludes:sf,ArrayPrototypeJoin:of,ArrayPrototypeMap:hy,NumberIsInteger:As,NumberIsNaN:dy,NumberMAX_SAFE_INTEGER:py,NumberMIN_SAFE_INTEGER:gy,NumberParseInt:yy,ObjectPrototypeHasOwnProperty:by,RegExpPrototypeExec:af,String:wy,StringPrototypeToUpperCase:_y,StringPrototypeTrim:my}=ce(),{hideStackFrames:Ue,codes:{ERR_SOCKET_BAD_PORT:vy,ERR_INVALID_ARG_TYPE:Ae,ERR_INVALID_ARG_VALUE:xr,ERR_OUT_OF_RANGE:Zt,ERR_UNKNOWN_SIGNAL:tf}}=Se(),{normalizeEncoding:Ey}=Je(),{isAsyncFunction:Sy,isArrayBufferView:Ay}=Je().types,rf={};function Iy(t){return t===(t|0)}function Ty(t){return t===t>>>0}var Ry=/^[0-7]+$/,Cy=\"must be a 32-bit unsigned integer or an octal string\";function By(t,e,r){if(typeof t>\"u\"&&(t=r),typeof t==\"string\"){if(af(Ry,t)===null)throw new xr(e,t,Cy);t=yy(t,8)}return lf(t,e),t}var Py=Ue((t,e,r=gy,i=py)=>{if(typeof t!=\"number\")throw new Ae(e,\"number\",t);if(!As(t))throw new Zt(e,\"an integer\",t);if(t<r||t>i)throw new Zt(e,`>= ${r} && <= ${i}`,t)}),Oy=Ue((t,e,r=-2147483648,i=2147483647)=>{if(typeof t!=\"number\")throw new Ae(e,\"number\",t);if(!As(t))throw new Zt(e,\"an integer\",t);if(t<r||t>i)throw new Zt(e,`>= ${r} && <= ${i}`,t)}),lf=Ue((t,e,r=!1)=>{if(typeof t!=\"number\")throw new Ae(e,\"number\",t);if(!As(t))throw new Zt(e,\"an integer\",t);let i=r?1:0,n=4294967295;if(t<i||t>n)throw new Zt(e,`>= ${i} && <= ${n}`,t)});function Is(t,e){if(typeof t!=\"string\")throw new Ae(e,\"string\",t)}function ky(t,e,r=void 0,i){if(typeof t!=\"number\")throw new Ae(e,\"number\",t);if(r!=null&&t<r||i!=null&&t>i||(r!=null||i!=null)&&dy(t))throw new Zt(e,`${r!=null?`>= ${r}`:\"\"}${r!=null&&i!=null?\" && \":\"\"}${i!=null?`<= ${i}`:\"\"}`,t)}var xy=Ue((t,e,r)=>{if(!sf(r,t)){let n=\"must be one of: \"+of(hy(r,o=>typeof o==\"string\"?`'${o}'`:wy(o)),\", \");throw new xr(e,t,n)}});function uf(t,e){if(typeof t!=\"boolean\")throw new Ae(e,\"boolean\",t)}function Es(t,e,r){return t==null||!by(t,e)?r:t[e]}var My=Ue((t,e,r=null)=>{let i=Es(r,\"allowArray\",!1),n=Es(r,\"allowFunction\",!1);if(!Es(r,\"nullable\",!1)&&t===null||!i&&Ss(t)||typeof t!=\"object\"&&(!n||typeof t!=\"function\"))throw new Ae(e,\"Object\",t)}),Ly=Ue((t,e)=>{if(t!=null&&typeof t!=\"object\"&&typeof t!=\"function\")throw new Ae(e,\"a dictionary\",t)}),Ts=Ue((t,e,r=0)=>{if(!Ss(t))throw new Ae(e,\"Array\",t);if(t.length<r){let i=`must be longer than ${r}`;throw new xr(e,t,i)}});function Uy(t,e){Ts(t,e);for(let r=0;r<t.length;r++)Is(t[r],`${e}[${r}]`)}function Ny(t,e){Ts(t,e);for(let r=0;r<t.length;r++)uf(t[r],`${e}[${r}]`)}function qy(t,e=\"signal\"){if(Is(t,e),rf[t]===void 0)throw rf[_y(t)]!==void 0?new tf(t+\" (signals must use all capital letters)\"):new tf(t)}var Dy=Ue((t,e=\"buffer\")=>{if(!Ay(t))throw new Ae(e,[\"Buffer\",\"TypedArray\",\"DataView\"],t)});function jy(t,e){let r=Ey(e),i=t.length;if(r===\"hex\"&&i%2!==0)throw new xr(\"encoding\",e,`is invalid for data of length ${i}`)}function Fy(t,e=\"Port\",r=!0){if(typeof t!=\"number\"&&typeof t!=\"string\"||typeof t==\"string\"&&my(t).length===0||+t!==+t>>>0||t>65535||t===0&&!r)throw new vy(e,t,r);return t|0}var Wy=Ue((t,e)=>{if(t!==void 0&&(t===null||typeof t!=\"object\"||!(\"aborted\"in t)))throw new Ae(e,\"AbortSignal\",t)}),$y=Ue((t,e)=>{if(typeof t!=\"function\")throw new Ae(e,\"Function\",t)}),Hy=Ue((t,e)=>{if(typeof t!=\"function\"||Sy(t))throw new Ae(e,\"Function\",t)}),Vy=Ue((t,e)=>{if(t!==void 0)throw new Ae(e,\"undefined\",t)});function zy(t,e,r){if(!sf(r,t))throw new Ae(e,`('${of(r,\"|\")}')`,t)}var Ky=/^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/;function nf(t,e){if(typeof t>\"u\"||!af(Ky,t))throw new xr(e,t,'must be an array or string of format \"</styles.css>; rel=preload; as=style\"')}function Gy(t){if(typeof t==\"string\")return nf(t,\"hints\"),t;if(Ss(t)){let e=t.length,r=\"\";if(e===0)return r;for(let i=0;i<e;i++){let n=t[i];nf(n,\"hints\"),r+=n,i!==e-1&&(r+=\", \")}return r}throw new xr(\"hints\",t,'must be an array or string of format \"</styles.css>; rel=preload; as=style\"')}ff.exports={isInt32:Iy,isUint32:Ty,parseFileMode:By,validateArray:Ts,validateStringArray:Uy,validateBooleanArray:Ny,validateBoolean:uf,validateBuffer:Dy,validateDictionary:Ly,validateEncoding:jy,validateFunction:$y,validateInt32:Oy,validateInteger:Py,validateNumber:ky,validateObject:My,validateOneOf:xy,validatePlainFunction:Hy,validatePort:Fy,validateSignalName:qy,validateString:Is,validateUint32:lf,validateUndefined:Vy,validateUnion:zy,validateAbortSignal:Wy,validateLinkHeaderValue:Gy}});var Ut=M((SI,pf)=>{v();m();_();var ae=pf.exports={},Xe,Ze;function Rs(){throw new Error(\"setTimeout has not been defined\")}function Cs(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{typeof setTimeout==\"function\"?Xe=setTimeout:Xe=Rs}catch{Xe=Rs}try{typeof clearTimeout==\"function\"?Ze=clearTimeout:Ze=Cs}catch{Ze=Cs}})();function cf(t){if(Xe===setTimeout)return setTimeout(t,0);if((Xe===Rs||!Xe)&&setTimeout)return Xe=setTimeout,setTimeout(t,0);try{return Xe(t,0)}catch{try{return Xe.call(null,t,0)}catch{return Xe.call(this,t,0)}}}function Qy(t){if(Ze===clearTimeout)return clearTimeout(t);if((Ze===Cs||!Ze)&&clearTimeout)return Ze=clearTimeout,clearTimeout(t);try{return Ze(t)}catch{try{return Ze.call(null,t)}catch{return Ze.call(this,t)}}}var wt=[],Mr=!1,er,Ki=-1;function Yy(){!Mr||!er||(Mr=!1,er.length?wt=er.concat(wt):Ki=-1,wt.length&&hf())}function hf(){if(!Mr){var t=cf(Yy);Mr=!0;for(var e=wt.length;e;){for(er=wt,wt=[];++Ki<e;)er&&er[Ki].run();Ki=-1,e=wt.length}er=null,Mr=!1,Qy(t)}}ae.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];wt.push(new df(t,e)),wt.length===1&&!Mr&&cf(hf)};function df(t,e){this.fun=t,this.array=e}df.prototype.run=function(){this.fun.apply(null,this.array)};ae.title=\"browser\";ae.browser=!0;ae.env={};ae.argv=[];ae.version=\"\";ae.versions={};function _t(){}ae.on=_t;ae.addListener=_t;ae.once=_t;ae.off=_t;ae.removeListener=_t;ae.removeAllListeners=_t;ae.emit=_t;ae.prependListener=_t;ae.prependOnceListener=_t;ae.listeners=function(t){return[]};ae.binding=function(t){throw new Error(\"process.binding is not supported\")};ae.cwd=function(){return\"/\"};ae.chdir=function(t){throw new Error(\"process.chdir is not supported\")};ae.umask=function(){return 0}});var tt=M((xI,Pf)=>{\"use strict\";v();m();_();var{Symbol:Gi,SymbolAsyncIterator:gf,SymbolIterator:yf,SymbolFor:bf}=ce(),wf=Gi(\"kDestroyed\"),_f=Gi(\"kIsErrored\"),Bs=Gi(\"kIsReadable\"),mf=Gi(\"kIsDisturbed\"),Jy=bf(\"nodejs.webstream.isClosedPromise\"),Xy=bf(\"nodejs.webstream.controllerErrorFunction\");function Qi(t,e=!1){var r;return!!(t&&typeof t.pipe==\"function\"&&typeof t.on==\"function\"&&(!e||typeof t.pause==\"function\"&&typeof t.resume==\"function\")&&(!t._writableState||((r=t._readableState)===null||r===void 0?void 0:r.readable)!==!1)&&(!t._writableState||t._readableState))}function Yi(t){var e;return!!(t&&typeof t.write==\"function\"&&typeof t.on==\"function\"&&(!t._readableState||((e=t._writableState)===null||e===void 0?void 0:e.writable)!==!1))}function Zy(t){return!!(t&&typeof t.pipe==\"function\"&&t._readableState&&typeof t.on==\"function\"&&typeof t.write==\"function\")}function et(t){return t&&(t._readableState||t._writableState||typeof t.write==\"function\"&&typeof t.on==\"function\"||typeof t.pipe==\"function\"&&typeof t.on==\"function\")}function vf(t){return!!(t&&!et(t)&&typeof t.pipeThrough==\"function\"&&typeof t.getReader==\"function\"&&typeof t.cancel==\"function\")}function Ef(t){return!!(t&&!et(t)&&typeof t.getWriter==\"function\"&&typeof t.abort==\"function\")}function Sf(t){return!!(t&&!et(t)&&typeof t.readable==\"object\"&&typeof t.writable==\"object\")}function eb(t){return vf(t)||Ef(t)||Sf(t)}function tb(t,e){return t==null?!1:e===!0?typeof t[gf]==\"function\":e===!1?typeof t[yf]==\"function\":typeof t[gf]==\"function\"||typeof t[yf]==\"function\"}function Ji(t){if(!et(t))return null;let e=t._writableState,r=t._readableState,i=e||r;return!!(t.destroyed||t[wf]||i!=null&&i.destroyed)}function Af(t){if(!Yi(t))return null;if(t.writableEnded===!0)return!0;let e=t._writableState;return e!=null&&e.errored?!1:typeof e?.ended!=\"boolean\"?null:e.ended}function rb(t,e){if(!Yi(t))return null;if(t.writableFinished===!0)return!0;let r=t._writableState;return r!=null&&r.errored?!1:typeof r?.finished!=\"boolean\"?null:!!(r.finished||e===!1&&r.ended===!0&&r.length===0)}function ib(t){if(!Qi(t))return null;if(t.readableEnded===!0)return!0;let e=t._readableState;return!e||e.errored?!1:typeof e?.ended!=\"boolean\"?null:e.ended}function If(t,e){if(!Qi(t))return null;let r=t._readableState;return r!=null&&r.errored?!1:typeof r?.endEmitted!=\"boolean\"?null:!!(r.endEmitted||e===!1&&r.ended===!0&&r.length===0)}function Tf(t){return t&&t[Bs]!=null?t[Bs]:typeof t?.readable!=\"boolean\"?null:Ji(t)?!1:Qi(t)&&t.readable&&!If(t)}function Rf(t){return typeof t?.writable!=\"boolean\"?null:Ji(t)?!1:Yi(t)&&t.writable&&!Af(t)}function nb(t,e){return et(t)?Ji(t)?!0:!(e?.readable!==!1&&Tf(t)||e?.writable!==!1&&Rf(t)):null}function sb(t){var e,r;return et(t)?t.writableErrored?t.writableErrored:(e=(r=t._writableState)===null||r===void 0?void 0:r.errored)!==null&&e!==void 0?e:null:null}function ob(t){var e,r;return et(t)?t.readableErrored?t.readableErrored:(e=(r=t._readableState)===null||r===void 0?void 0:r.errored)!==null&&e!==void 0?e:null:null}function ab(t){if(!et(t))return null;if(typeof t.closed==\"boolean\")return t.closed;let e=t._writableState,r=t._readableState;return typeof e?.closed==\"boolean\"||typeof r?.closed==\"boolean\"?e?.closed||r?.closed:typeof t._closed==\"boolean\"&&Cf(t)?t._closed:null}function Cf(t){return typeof t._closed==\"boolean\"&&typeof t._defaultKeepAlive==\"boolean\"&&typeof t._removedConnection==\"boolean\"&&typeof t._removedContLen==\"boolean\"}function Bf(t){return typeof t._sent100==\"boolean\"&&Cf(t)}function lb(t){var e;return typeof t._consuming==\"boolean\"&&typeof t._dumped==\"boolean\"&&((e=t.req)===null||e===void 0?void 0:e.upgradeOrConnect)===void 0}function ub(t){if(!et(t))return null;let e=t._writableState,r=t._readableState,i=e||r;return!i&&Bf(t)||!!(i&&i.autoDestroy&&i.emitClose&&i.closed===!1)}function fb(t){var e;return!!(t&&((e=t[mf])!==null&&e!==void 0?e:t.readableDidRead||t.readableAborted))}function cb(t){var e,r,i,n,o,s,a,u,c,h;return!!(t&&((e=(r=(i=(n=(o=(s=t[_f])!==null&&s!==void 0?s:t.readableErrored)!==null&&o!==void 0?o:t.writableErrored)!==null&&n!==void 0?n:(a=t._readableState)===null||a===void 0?void 0:a.errorEmitted)!==null&&i!==void 0?i:(u=t._writableState)===null||u===void 0?void 0:u.errorEmitted)!==null&&r!==void 0?r:(c=t._readableState)===null||c===void 0?void 0:c.errored)!==null&&e!==void 0?e:!((h=t._writableState)===null||h===void 0)&&h.errored))}Pf.exports={kDestroyed:wf,isDisturbed:fb,kIsDisturbed:mf,isErrored:cb,kIsErrored:_f,isReadable:Tf,kIsReadable:Bs,kIsClosedPromise:Jy,kControllerErrorFunction:Xy,isClosed:ab,isDestroyed:Ji,isDuplexNodeStream:Zy,isFinished:nb,isIterable:tb,isReadableNodeStream:Qi,isReadableStream:vf,isReadableEnded:ib,isReadableFinished:If,isReadableErrored:ob,isNodeStream:et,isWebStream:eb,isWritable:Rf,isWritableNodeStream:Yi,isWritableStream:Ef,isWritableEnded:Af,isWritableFinished:rb,isWritableErrored:sb,isServerRequest:lb,isServerResponse:Bf,willEmitClose:ub,isTransformStream:Sf}});var mt=M(($I,Ms)=>{v();m();_();var Nt=Ut(),{AbortError:Df,codes:hb}=Se(),{ERR_INVALID_ARG_TYPE:db,ERR_STREAM_PREMATURE_CLOSE:Of}=hb,{kEmptyObject:Os,once:ks}=Je(),{validateAbortSignal:pb,validateFunction:gb,validateObject:yb,validateBoolean:bb}=ui(),{Promise:wb,PromisePrototypeThen:_b}=ce(),{isClosed:mb,isReadable:kf,isReadableNodeStream:Ps,isReadableStream:vb,isReadableFinished:xf,isReadableErrored:Mf,isWritable:Lf,isWritableNodeStream:Uf,isWritableStream:Eb,isWritableFinished:Nf,isWritableErrored:qf,isNodeStream:Sb,willEmitClose:Ab,kIsClosedPromise:Ib}=tt();function Tb(t){return t.setHeader&&typeof t.abort==\"function\"}var xs=()=>{};function jf(t,e,r){var i,n;if(arguments.length===2?(r=e,e=Os):e==null?e=Os:yb(e,\"options\"),gb(r,\"callback\"),pb(e.signal,\"options.signal\"),r=ks(r),vb(t)||Eb(t))return Rb(t,e,r);if(!Sb(t))throw new db(\"stream\",[\"ReadableStream\",\"WritableStream\",\"Stream\"],t);let o=(i=e.readable)!==null&&i!==void 0?i:Ps(t),s=(n=e.writable)!==null&&n!==void 0?n:Uf(t),a=t._writableState,u=t._readableState,c=()=>{t.writable||g()},h=Ab(t)&&Ps(t)===o&&Uf(t)===s,d=Nf(t,!1),g=()=>{d=!0,t.destroyed&&(h=!1),!(h&&(!t.readable||o))&&(!o||y)&&r.call(t)},y=xf(t,!1),w=()=>{y=!0,t.destroyed&&(h=!1),!(h&&(!t.writable||s))&&(!s||d)&&r.call(t)},E=N=>{r.call(t,N)},S=mb(t),I=()=>{S=!0;let N=qf(t)||Mf(t);if(N&&typeof N!=\"boolean\")return r.call(t,N);if(o&&!y&&Ps(t,!0)&&!xf(t,!1))return r.call(t,new Of);if(s&&!d&&!Nf(t,!1))return r.call(t,new Of);r.call(t)},C=()=>{S=!0;let N=qf(t)||Mf(t);if(N&&typeof N!=\"boolean\")return r.call(t,N);r.call(t)},R=()=>{t.req.on(\"finish\",g)};Tb(t)?(t.on(\"complete\",g),h||t.on(\"abort\",I),t.req?R():t.on(\"request\",R)):s&&!a&&(t.on(\"end\",c),t.on(\"close\",c)),!h&&typeof t.aborted==\"boolean\"&&t.on(\"aborted\",I),t.on(\"end\",w),t.on(\"finish\",g),e.error!==!1&&t.on(\"error\",E),t.on(\"close\",I),S?Nt.nextTick(I):a!=null&&a.errorEmitted||u!=null&&u.errorEmitted?h||Nt.nextTick(C):(!o&&(!h||kf(t))&&(d||Lf(t)===!1)||!s&&(!h||Lf(t))&&(y||kf(t)===!1)||u&&t.req&&t.aborted)&&Nt.nextTick(C);let U=()=>{r=xs,t.removeListener(\"aborted\",I),t.removeListener(\"complete\",g),t.removeListener(\"abort\",I),t.removeListener(\"request\",R),t.req&&t.req.removeListener(\"finish\",g),t.removeListener(\"end\",c),t.removeListener(\"close\",c),t.removeListener(\"finish\",g),t.removeListener(\"end\",w),t.removeListener(\"error\",E),t.removeListener(\"close\",I)};if(e.signal&&!S){let N=()=>{let W=r;U(),W.call(t,new Df(void 0,{cause:e.signal.reason}))};if(e.signal.aborted)Nt.nextTick(N);else{let W=r;r=ks((...K)=>{e.signal.removeEventListener(\"abort\",N),W.apply(t,K)}),e.signal.addEventListener(\"abort\",N)}}return U}function Rb(t,e,r){let i=!1,n=xs;if(e.signal)if(n=()=>{i=!0,r.call(t,new Df(void 0,{cause:e.signal.reason}))},e.signal.aborted)Nt.nextTick(n);else{let s=r;r=ks((...a)=>{e.signal.removeEventListener(\"abort\",n),s.apply(t,a)}),e.signal.addEventListener(\"abort\",n)}let o=(...s)=>{i||Nt.nextTick(()=>r.apply(t,s))};return _b(t[Ib].promise,o,o),xs}function Cb(t,e){var r;let i=!1;return e===null&&(e=Os),(r=e)!==null&&r!==void 0&&r.cleanup&&(bb(e.cleanup,\"cleanup\"),i=e.cleanup),new wb((n,o)=>{let s=jf(t,e,a=>{i&&s(),a?o(a):n()})})}Ms.exports=jf;Ms.exports.finished=Cb});var tr=M((ZI,Gf)=>{\"use strict\";v();m();_();var rt=Ut(),{aggregateTwoErrors:Bb,codes:{ERR_MULTIPLE_CALLBACK:Pb},AbortError:Ob}=Se(),{Symbol:$f}=ce(),{kDestroyed:kb,isDestroyed:xb,isFinished:Mb,isServerRequest:Lb}=tt(),Hf=$f(\"kDestroy\"),Ls=$f(\"kConstruct\");function Vf(t,e,r){t&&(t.stack,e&&!e.errored&&(e.errored=t),r&&!r.errored&&(r.errored=t))}function Ub(t,e){let r=this._readableState,i=this._writableState,n=i||r;return i!=null&&i.destroyed||r!=null&&r.destroyed?(typeof e==\"function\"&&e(),this):(Vf(t,i,r),i&&(i.destroyed=!0),r&&(r.destroyed=!0),n.constructed?Ff(this,t,e):this.once(Hf,function(o){Ff(this,Bb(o,t),e)}),this)}function Ff(t,e,r){let i=!1;function n(o){if(i)return;i=!0;let s=t._readableState,a=t._writableState;Vf(o,a,s),a&&(a.closed=!0),s&&(s.closed=!0),typeof r==\"function\"&&r(o),o?rt.nextTick(Nb,t,o):rt.nextTick(zf,t)}try{t._destroy(e||null,n)}catch(o){n(o)}}function Nb(t,e){Us(t,e),zf(t)}function zf(t){let e=t._readableState,r=t._writableState;r&&(r.closeEmitted=!0),e&&(e.closeEmitted=!0),(r!=null&&r.emitClose||e!=null&&e.emitClose)&&t.emit(\"close\")}function Us(t,e){let r=t._readableState,i=t._writableState;i!=null&&i.errorEmitted||r!=null&&r.errorEmitted||(i&&(i.errorEmitted=!0),r&&(r.errorEmitted=!0),t.emit(\"error\",e))}function qb(){let t=this._readableState,e=this._writableState;t&&(t.constructed=!0,t.closed=!1,t.closeEmitted=!1,t.destroyed=!1,t.errored=null,t.errorEmitted=!1,t.reading=!1,t.ended=t.readable===!1,t.endEmitted=t.readable===!1),e&&(e.constructed=!0,e.destroyed=!1,e.closed=!1,e.closeEmitted=!1,e.errored=null,e.errorEmitted=!1,e.finalCalled=!1,e.prefinished=!1,e.ended=e.writable===!1,e.ending=e.writable===!1,e.finished=e.writable===!1)}function Ns(t,e,r){let i=t._readableState,n=t._writableState;if(n!=null&&n.destroyed||i!=null&&i.destroyed)return this;i!=null&&i.autoDestroy||n!=null&&n.autoDestroy?t.destroy(e):e&&(e.stack,n&&!n.errored&&(n.errored=e),i&&!i.errored&&(i.errored=e),r?rt.nextTick(Us,t,e):Us(t,e))}function Db(t,e){if(typeof t._construct!=\"function\")return;let r=t._readableState,i=t._writableState;r&&(r.constructed=!1),i&&(i.constructed=!1),t.once(Ls,e),!(t.listenerCount(Ls)>1)&&rt.nextTick(jb,t)}function jb(t){let e=!1;function r(i){if(e){Ns(t,i??new Pb);return}e=!0;let n=t._readableState,o=t._writableState,s=o||n;n&&(n.constructed=!0),o&&(o.constructed=!0),s.destroyed?t.emit(Hf,i):i?Ns(t,i,!0):rt.nextTick(Fb,t)}try{t._construct(i=>{rt.nextTick(r,i)})}catch(i){rt.nextTick(r,i)}}function Fb(t){t.emit(Ls)}function Wf(t){return t?.setHeader&&typeof t.abort==\"function\"}function Kf(t){t.emit(\"close\")}function Wb(t,e){t.emit(\"error\",e),rt.nextTick(Kf,t)}function $b(t,e){!t||xb(t)||(!e&&!Mb(t)&&(e=new Ob),Lb(t)?(t.socket=null,t.destroy(e)):Wf(t)?t.abort():Wf(t.req)?t.req.abort():typeof t.destroy==\"function\"?t.destroy(e):typeof t.close==\"function\"?t.close():e?rt.nextTick(Wb,t,e):rt.nextTick(Kf,t),t.destroyed||(t[kb]=!0))}Gf.exports={construct:Db,destroyer:$b,destroy:Ub,undestroy:qb,errorOrDestroy:Ns}});function Y(){Y.init.call(this)}function Xi(t){if(typeof t!=\"function\")throw new TypeError('The \"listener\" argument must be of type Function. Received type '+typeof t)}function nc(t){return t._maxListeners===void 0?Y.defaultMaxListeners:t._maxListeners}function Xf(t,e,r,i){var n,o,s,a;if(Xi(r),(o=t._events)===void 0?(o=t._events=Object.create(null),t._eventsCount=0):(o.newListener!==void 0&&(t.emit(\"newListener\",e,r.listener?r.listener:r),o=t._events),s=o[e]),s===void 0)s=o[e]=r,++t._eventsCount;else if(typeof s==\"function\"?s=o[e]=i?[r,s]:[s,r]:i?s.unshift(r):s.push(r),(n=nc(t))>0&&s.length>n&&!s.warned){s.warned=!0;var u=new Error(\"Possible EventEmitter memory leak detected. \"+s.length+\" \"+String(e)+\" listeners added. Use emitter.setMaxListeners() to increase limit\");u.name=\"MaxListenersExceededWarning\",u.emitter=t,u.type=e,u.count=s.length,a=u,console&&console.warn&&console.warn(a)}return t}function Hb(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function Zf(t,e,r){var i={fired:!1,wrapFn:void 0,target:t,type:e,listener:r},n=Hb.bind(i);return n.listener=r,i.wrapFn=n,n}function ec(t,e,r){var i=t._events;if(i===void 0)return[];var n=i[e];return n===void 0?[]:typeof n==\"function\"?r?[n.listener||n]:[n]:r?function(o){for(var s=new Array(o.length),a=0;a<s.length;++a)s[a]=o[a].listener||o[a];return s}(n):sc(n,n.length)}function tc(t){var e=this._events;if(e!==void 0){var r=e[t];if(typeof r==\"function\")return 1;if(r!==void 0)return r.length}return 0}function sc(t,e){for(var r=new Array(e),i=0;i<e;++i)r[i]=t[i];return r}var rc,ic,Lr,Qf,Yf,Jf,Be,qs=be(()=>{v();m();_();Lr=typeof Reflect==\"object\"?Reflect:null,Qf=Lr&&typeof Lr.apply==\"function\"?Lr.apply:function(t,e,r){return Function.prototype.apply.call(t,e,r)};ic=Lr&&typeof Lr.ownKeys==\"function\"?Lr.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};Yf=Number.isNaN||function(t){return t!=t};rc=Y,Y.EventEmitter=Y,Y.prototype._events=void 0,Y.prototype._eventsCount=0,Y.prototype._maxListeners=void 0;Jf=10;Object.defineProperty(Y,\"defaultMaxListeners\",{enumerable:!0,get:function(){return Jf},set:function(t){if(typeof t!=\"number\"||t<0||Yf(t))throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received '+t+\".\");Jf=t}}),Y.init=function(){this._events!==void 0&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},Y.prototype.setMaxListeners=function(t){if(typeof t!=\"number\"||t<0||Yf(t))throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received '+t+\".\");return this._maxListeners=t,this},Y.prototype.getMaxListeners=function(){return nc(this)},Y.prototype.emit=function(t){for(var e=[],r=1;r<arguments.length;r++)e.push(arguments[r]);var i=t===\"error\",n=this._events;if(n!==void 0)i=i&&n.error===void 0;else if(!i)return!1;if(i){var o;if(e.length>0&&(o=e[0]),o instanceof Error)throw o;var s=new Error(\"Unhandled error.\"+(o?\" (\"+o.message+\")\":\"\"));throw s.context=o,s}var a=n[t];if(a===void 0)return!1;if(typeof a==\"function\")Qf(a,this,e);else{var u=a.length,c=sc(a,u);for(r=0;r<u;++r)Qf(c[r],this,e)}return!0},Y.prototype.addListener=function(t,e){return Xf(this,t,e,!1)},Y.prototype.on=Y.prototype.addListener,Y.prototype.prependListener=function(t,e){return Xf(this,t,e,!0)},Y.prototype.once=function(t,e){return Xi(e),this.on(t,Zf(this,t,e)),this},Y.prototype.prependOnceListener=function(t,e){return Xi(e),this.prependListener(t,Zf(this,t,e)),this},Y.prototype.removeListener=function(t,e){var r,i,n,o,s;if(Xi(e),(i=this._events)===void 0)return this;if((r=i[t])===void 0)return this;if(r===e||r.listener===e)--this._eventsCount==0?this._events=Object.create(null):(delete i[t],i.removeListener&&this.emit(\"removeListener\",t,r.listener||e));else if(typeof r!=\"function\"){for(n=-1,o=r.length-1;o>=0;o--)if(r[o]===e||r[o].listener===e){s=r[o].listener,n=o;break}if(n<0)return this;n===0?r.shift():function(a,u){for(;u+1<a.length;u++)a[u]=a[u+1];a.pop()}(r,n),r.length===1&&(i[t]=r[0]),i.removeListener!==void 0&&this.emit(\"removeListener\",t,s||e)}return this},Y.prototype.off=Y.prototype.removeListener,Y.prototype.removeAllListeners=function(t){var e,r,i;if((r=this._events)===void 0)return this;if(r.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):r[t]!==void 0&&(--this._eventsCount==0?this._events=Object.create(null):delete r[t]),this;if(arguments.length===0){var n,o=Object.keys(r);for(i=0;i<o.length;++i)(n=o[i])!==\"removeListener\"&&this.removeAllListeners(n);return this.removeAllListeners(\"removeListener\"),this._events=Object.create(null),this._eventsCount=0,this}if(typeof(e=r[t])==\"function\")this.removeListener(t,e);else if(e!==void 0)for(i=e.length-1;i>=0;i--)this.removeListener(t,e[i]);return this},Y.prototype.listeners=function(t){return ec(this,t,!0)},Y.prototype.rawListeners=function(t){return ec(this,t,!1)},Y.listenerCount=function(t,e){return typeof t.listenerCount==\"function\"?t.listenerCount(e):tc.call(t,e)},Y.prototype.listenerCount=tc,Y.prototype.eventNames=function(){return this._eventsCount>0?ic(this._events):[]};Be=rc;Be.EventEmitter;Be.defaultMaxListeners;Be.init;Be.listenerCount;Be.EventEmitter;Be.defaultMaxListeners;Be.init;Be.listenerCount});var rr={};Qt(rr,{EventEmitter:()=>Vb,default:()=>Be,defaultMaxListeners:()=>zb,init:()=>Kb,listenerCount:()=>Gb,on:()=>Qb,once:()=>Yb});var Vb,zb,Kb,Gb,Qb,Yb,ir=be(()=>{v();m();_();qs();qs();Be.once=function(t,e){return new Promise((r,i)=>{function n(...s){o!==void 0&&t.removeListener(\"error\",o),r(s)}let o;e!==\"error\"&&(o=s=>{t.removeListener(name,n),i(s)},t.once(\"error\",o)),t.once(e,n)})};Be.on=function(t,e){let r=[],i=[],n=null,o=!1,s={async next(){let c=r.shift();if(c)return createIterResult(c,!1);if(n){let h=Promise.reject(n);return n=null,h}return o?createIterResult(void 0,!0):new Promise((h,d)=>i.push({resolve:h,reject:d}))},async return(){t.removeListener(e,a),t.removeListener(\"error\",u),o=!0;for(let c of i)c.resolve(createIterResult(void 0,!0));return createIterResult(void 0,!0)},throw(c){n=c,t.removeListener(e,a),t.removeListener(\"error\",u)},[Symbol.asyncIterator](){return this}};return t.on(e,a),t.on(\"error\",u),s;function a(...c){let h=i.shift();h?h.resolve(createIterResult(c,!1)):r.push(c)}function u(c){o=!0;let h=i.shift();h?h.reject(c):n=c,s.return()}};({EventEmitter:Vb,defaultMaxListeners:zb,init:Kb,listenerCount:Gb,on:Qb,once:Yb}=Be)});var tn=M((PT,ac)=>{\"use strict\";v();m();_();var{ArrayIsArray:Jb,ObjectSetPrototypeOf:oc}=ce(),{EventEmitter:Zi}=(ir(),Z(rr));function en(t){Zi.call(this,t)}oc(en.prototype,Zi.prototype);oc(en,Zi);en.prototype.pipe=function(t,e){let r=this;function i(h){t.writable&&t.write(h)===!1&&r.pause&&r.pause()}r.on(\"data\",i);function n(){r.readable&&r.resume&&r.resume()}t.on(\"drain\",n),!t._isStdio&&(!e||e.end!==!1)&&(r.on(\"end\",s),r.on(\"close\",a));let o=!1;function s(){o||(o=!0,t.end())}function a(){o||(o=!0,typeof t.destroy==\"function\"&&t.destroy())}function u(h){c(),Zi.listenerCount(this,\"error\")===0&&this.emit(\"error\",h)}Ds(r,\"error\",u),Ds(t,\"error\",u);function c(){r.removeListener(\"data\",i),t.removeListener(\"drain\",n),r.removeListener(\"end\",s),r.removeListener(\"close\",a),r.removeListener(\"error\",u),t.removeListener(\"error\",u),r.removeListener(\"end\",c),r.removeListener(\"close\",c),t.removeListener(\"close\",c)}return r.on(\"end\",c),r.on(\"close\",c),t.on(\"close\",c),t.emit(\"pipe\",r),t};function Ds(t,e,r){if(typeof t.prependListener==\"function\")return t.prependListener(e,r);!t._events||!t._events[e]?t.on(e,r):Jb(t._events[e])?t._events[e].unshift(r):t._events[e]=[r,t._events[e]]}ac.exports={Stream:en,prependListener:Ds}});var fi=M((jT,rn)=>{\"use strict\";v();m();_();var{AbortError:lc,codes:Xb}=Se(),{isNodeStream:uc,isWebStream:Zb,kControllerErrorFunction:ew}=tt(),tw=mt(),{ERR_INVALID_ARG_TYPE:fc}=Xb,rw=(t,e)=>{if(typeof t!=\"object\"||!(\"aborted\"in t))throw new fc(e,\"AbortSignal\",t)};rn.exports.addAbortSignal=function(e,r){if(rw(e,\"signal\"),!uc(r)&&!Zb(r))throw new fc(\"stream\",[\"ReadableStream\",\"WritableStream\",\"Stream\"],r);return rn.exports.addAbortSignalNoValidate(e,r)};rn.exports.addAbortSignalNoValidate=function(t,e){if(typeof t!=\"object\"||!(\"aborted\"in t))return e;let r=uc(e)?()=>{e.destroy(new lc(void 0,{cause:t.reason}))}:()=>{e[ew](new lc(void 0,{cause:t.reason}))};return t.aborted?r():(t.addEventListener(\"abort\",r),tw(e,()=>t.removeEventListener(\"abort\",r))),e}});var dc=M((JT,hc)=>{\"use strict\";v();m();_();var{StringPrototypeSlice:cc,SymbolIterator:iw,TypedArrayPrototypeSet:nn,Uint8Array:nw}=ce(),{Buffer:js}=(we(),Z(ve)),{inspect:sw}=Je();hc.exports=class{constructor(){this.head=null,this.tail=null,this.length=0}push(e){let r={data:e,next:null};this.length>0?this.tail.next=r:this.head=r,this.tail=r,++this.length}unshift(e){let r={data:e,next:this.head};this.length===0&&(this.tail=r),this.head=r,++this.length}shift(){if(this.length===0)return;let e=this.head.data;return this.length===1?this.head=this.tail=null:this.head=this.head.next,--this.length,e}clear(){this.head=this.tail=null,this.length=0}join(e){if(this.length===0)return\"\";let r=this.head,i=\"\"+r.data;for(;(r=r.next)!==null;)i+=e+r.data;return i}concat(e){if(this.length===0)return js.alloc(0);let r=js.allocUnsafe(e>>>0),i=this.head,n=0;for(;i;)nn(r,i.data,n),n+=i.data.length,i=i.next;return r}consume(e,r){let i=this.head.data;if(e<i.length){let n=i.slice(0,e);return this.head.data=i.slice(e),n}return e===i.length?this.shift():r?this._getString(e):this._getBuffer(e)}first(){return this.head.data}*[iw](){for(let e=this.head;e;e=e.next)yield e.data}_getString(e){let r=\"\",i=this.head,n=0;do{let o=i.data;if(e>o.length)r+=o,e-=o.length;else{e===o.length?(r+=o,++n,i.next?this.head=i.next:this.head=this.tail=null):(r+=cc(o,0,e),this.head=i,i.data=cc(o,e));break}++n}while((i=i.next)!==null);return this.length-=n,r}_getBuffer(e){let r=js.allocUnsafe(e),i=e,n=this.head,o=0;do{let s=n.data;if(e>s.length)nn(r,s,i-e),e-=s.length;else{e===s.length?(nn(r,s,i-e),++o,n.next?this.head=n.next:this.head=this.tail=null):(nn(r,new nw(s.buffer,s.byteOffset,e),i-e),this.head=n,n.data=s.slice(e));break}++o}while((n=n.next)!==null);return this.length-=o,r}[Symbol.for(\"nodejs.util.inspect.custom\")](e,r){return sw(this,{...r,depth:0,customInspect:!1})}}});var sn=M((a2,gc)=>{\"use strict\";v();m();_();var{MathFloor:ow,NumberIsInteger:aw}=ce(),{ERR_INVALID_ARG_VALUE:lw}=Se().codes;function uw(t,e,r){return t.highWaterMark!=null?t.highWaterMark:e?t[r]:null}function pc(t){return t?16:16*1024}function fw(t,e,r,i){let n=uw(e,i,r);if(n!=null){if(!aw(n)||n<0){let o=i?`options.${r}`:\"options.highWaterMark\";throw new lw(o,n)}return ow(n)}return pc(t.objectMode)}gc.exports={getHighWaterMark:fw,getDefaultHighWaterMark:pc}});function wc(t){var e=t.length;if(e%4>0)throw new Error(\"Invalid string. Length must be a multiple of 4\");var r=t.indexOf(\"=\");return r===-1&&(r=e),[r,r===e?0:4-r%4]}function cw(t,e,r){for(var i,n,o=[],s=e;s<r;s+=3)i=(t[s]<<16&16711680)+(t[s+1]<<8&65280)+(255&t[s+2]),o.push($e[(n=i)>>18&63]+$e[n>>12&63]+$e[n>>6&63]+$e[63&n]);return o.join(\"\")}function vt(t){if(t>2147483647)throw new RangeError('The value \"'+t+'\" is invalid for option \"size\"');var e=new Uint8Array(t);return Object.setPrototypeOf(e,x.prototype),e}function x(t,e,r){if(typeof t==\"number\"){if(typeof e==\"string\")throw new TypeError('The \"string\" argument must be of type string. Received type number');return Hs(t)}return Cc(t,e,r)}function Cc(t,e,r){if(typeof t==\"string\")return function(o,s){if(typeof s==\"string\"&&s!==\"\"||(s=\"utf8\"),!x.isEncoding(s))throw new TypeError(\"Unknown encoding: \"+s);var a=0|Pc(o,s),u=vt(a),c=u.write(o,s);return c!==a&&(u=u.slice(0,c)),u}(t,e);if(ArrayBuffer.isView(t))return Fs(t);if(t==null)throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof t);if(Et(t,ArrayBuffer)||t&&Et(t.buffer,ArrayBuffer)||typeof SharedArrayBuffer<\"u\"&&(Et(t,SharedArrayBuffer)||t&&Et(t.buffer,SharedArrayBuffer)))return mc(t,e,r);if(typeof t==\"number\")throw new TypeError('The \"value\" argument must not be of type number. Received type number');var i=t.valueOf&&t.valueOf();if(i!=null&&i!==t)return x.from(i,e,r);var n=function(o){if(x.isBuffer(o)){var s=0|Ks(o.length),a=vt(s);return a.length===0||o.copy(a,0,0,s),a}if(o.length!==void 0)return typeof o.length!=\"number\"||Gs(o.length)?vt(0):Fs(o);if(o.type===\"Buffer\"&&Array.isArray(o.data))return Fs(o.data)}(t);if(n)return n;if(typeof Symbol<\"u\"&&Symbol.toPrimitive!=null&&typeof t[Symbol.toPrimitive]==\"function\")return x.from(t[Symbol.toPrimitive](\"string\"),e,r);throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof t)}function Bc(t){if(typeof t!=\"number\")throw new TypeError('\"size\" argument must be of type number');if(t<0)throw new RangeError('The value \"'+t+'\" is invalid for option \"size\"')}function Hs(t){return Bc(t),vt(t<0?0:0|Ks(t))}function Fs(t){for(var e=t.length<0?0:0|Ks(t.length),r=vt(e),i=0;i<e;i+=1)r[i]=255&t[i];return r}function mc(t,e,r){if(e<0||t.byteLength<e)throw new RangeError('\"offset\" is outside of buffer bounds');if(t.byteLength<e+(r||0))throw new RangeError('\"length\" is outside of buffer bounds');var i;return i=e===void 0&&r===void 0?new Uint8Array(t):r===void 0?new Uint8Array(t,e):new Uint8Array(t,e,r),Object.setPrototypeOf(i,x.prototype),i}function Ks(t){if(t>=2147483647)throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+2147483647 .toString(16)+\" bytes\");return 0|t}function Pc(t,e){if(x.isBuffer(t))return t.length;if(ArrayBuffer.isView(t)||Et(t,ArrayBuffer))return t.byteLength;if(typeof t!=\"string\")throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof t);var r=t.length,i=arguments.length>2&&arguments[2]===!0;if(!i&&r===0)return 0;for(var n=!1;;)switch(e){case\"ascii\":case\"latin1\":case\"binary\":return r;case\"utf8\":case\"utf-8\":return Vs(t).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return 2*r;case\"hex\":return r>>>1;case\"base64\":return Mc(t).length;default:if(n)return i?-1:Vs(t).length;e=(\"\"+e).toLowerCase(),n=!0}}function dw(t,e,r){var i=!1;if((e===void 0||e<0)&&(e=0),e>this.length||((r===void 0||r>this.length)&&(r=this.length),r<=0)||(r>>>=0)<=(e>>>=0))return\"\";for(t||(t=\"utf8\");;)switch(t){case\"hex\":return Ew(this,e,r);case\"utf8\":case\"utf-8\":return kc(this,e,r);case\"ascii\":return mw(this,e,r);case\"latin1\":case\"binary\":return vw(this,e,r);case\"base64\":return _w(this,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return Sw(this,e,r);default:if(i)throw new TypeError(\"Unknown encoding: \"+t);t=(t+\"\").toLowerCase(),i=!0}}function sr(t,e,r){var i=t[e];t[e]=t[r],t[r]=i}function vc(t,e,r,i,n){if(t.length===0)return-1;if(typeof r==\"string\"?(i=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),Gs(r=+r)&&(r=n?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(n)return-1;r=t.length-1}else if(r<0){if(!n)return-1;r=0}if(typeof e==\"string\"&&(e=x.from(e,i)),x.isBuffer(e))return e.length===0?-1:Ec(t,e,r,i,n);if(typeof e==\"number\")return e&=255,typeof Uint8Array.prototype.indexOf==\"function\"?n?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):Ec(t,[e],r,i,n);throw new TypeError(\"val must be string, number or Buffer\")}function Ec(t,e,r,i,n){var o,s=1,a=t.length,u=e.length;if(i!==void 0&&((i=String(i).toLowerCase())===\"ucs2\"||i===\"ucs-2\"||i===\"utf16le\"||i===\"utf-16le\")){if(t.length<2||e.length<2)return-1;s=2,a/=2,u/=2,r/=2}function c(y,w){return s===1?y[w]:y.readUInt16BE(w*s)}if(n){var h=-1;for(o=r;o<a;o++)if(c(t,o)===c(e,h===-1?0:o-h)){if(h===-1&&(h=o),o-h+1===u)return h*s}else h!==-1&&(o-=o-h),h=-1}else for(r+u>a&&(r=a-u),o=r;o>=0;o--){for(var d=!0,g=0;g<u;g++)if(c(t,o+g)!==c(e,g)){d=!1;break}if(d)return o}return-1}function pw(t,e,r,i){r=Number(r)||0;var n=t.length-r;i?(i=Number(i))>n&&(i=n):i=n;var o=e.length;i>o/2&&(i=o/2);for(var s=0;s<i;++s){var a=parseInt(e.substr(2*s,2),16);if(Gs(a))return s;t[r+s]=a}return s}function gw(t,e,r,i){return un(Vs(e,t.length-r),t,r,i)}function Oc(t,e,r,i){return un(function(n){for(var o=[],s=0;s<n.length;++s)o.push(255&n.charCodeAt(s));return o}(e),t,r,i)}function yw(t,e,r,i){return Oc(t,e,r,i)}function bw(t,e,r,i){return un(Mc(e),t,r,i)}function ww(t,e,r,i){return un(function(n,o){for(var s,a,u,c=[],h=0;h<n.length&&!((o-=2)<0);++h)s=n.charCodeAt(h),a=s>>8,u=s%256,c.push(u),c.push(a);return c}(e,t.length-r),t,r,i)}function _w(t,e,r){return e===0&&r===t.length?$s.fromByteArray(t):$s.fromByteArray(t.slice(e,r))}function kc(t,e,r){r=Math.min(t.length,r);for(var i=[],n=e;n<r;){var o,s,a,u,c=t[n],h=null,d=c>239?4:c>223?3:c>191?2:1;if(n+d<=r)switch(d){case 1:c<128&&(h=c);break;case 2:(192&(o=t[n+1]))==128&&(u=(31&c)<<6|63&o)>127&&(h=u);break;case 3:o=t[n+1],s=t[n+2],(192&o)==128&&(192&s)==128&&(u=(15&c)<<12|(63&o)<<6|63&s)>2047&&(u<55296||u>57343)&&(h=u);break;case 4:o=t[n+1],s=t[n+2],a=t[n+3],(192&o)==128&&(192&s)==128&&(192&a)==128&&(u=(15&c)<<18|(63&o)<<12|(63&s)<<6|63&a)>65535&&u<1114112&&(h=u)}h===null?(h=65533,d=1):h>65535&&(h-=65536,i.push(h>>>10&1023|55296),h=56320|1023&h),i.push(h),n+=d}return function(g){var y=g.length;if(y<=4096)return String.fromCharCode.apply(String,g);for(var w=\"\",E=0;E<y;)w+=String.fromCharCode.apply(String,g.slice(E,E+=4096));return w}(i)}function mw(t,e,r){var i=\"\";r=Math.min(t.length,r);for(var n=e;n<r;++n)i+=String.fromCharCode(127&t[n]);return i}function vw(t,e,r){var i=\"\";r=Math.min(t.length,r);for(var n=e;n<r;++n)i+=String.fromCharCode(t[n]);return i}function Ew(t,e,r){var i=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>i)&&(r=i);for(var n=\"\",o=e;o<r;++o)n+=Iw[t[o]];return n}function Sw(t,e,r){for(var i=t.slice(e,r),n=\"\",o=0;o<i.length;o+=2)n+=String.fromCharCode(i[o]+256*i[o+1]);return n}function ye(t,e,r){if(t%1!=0||t<0)throw new RangeError(\"offset is not uint\");if(t+e>r)throw new RangeError(\"Trying to access beyond buffer length\")}function Pe(t,e,r,i,n,o){if(!x.isBuffer(t))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(e>n||e<o)throw new RangeError('\"value\" argument is out of bounds');if(r+i>t.length)throw new RangeError(\"Index out of range\")}function xc(t,e,r,i,n,o){if(r+i>t.length)throw new RangeError(\"Index out of range\");if(r<0)throw new RangeError(\"Index out of range\")}function Sc(t,e,r,i,n){return e=+e,r>>>=0,n||xc(t,0,r,4),Ur.write(t,e,r,i,23,4),r+4}function Ac(t,e,r,i,n){return e=+e,r>>>=0,n||xc(t,0,r,8),Ur.write(t,e,r,i,52,8),r+8}function Vs(t,e){var r;e=e||1/0;for(var i=t.length,n=null,o=[],s=0;s<i;++s){if((r=t.charCodeAt(s))>55295&&r<57344){if(!n){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(s+1===i){(e-=3)>-1&&o.push(239,191,189);continue}n=r;continue}if(r<56320){(e-=3)>-1&&o.push(239,191,189),n=r;continue}r=65536+(n-55296<<10|r-56320)}else n&&(e-=3)>-1&&o.push(239,191,189);if(n=null,r<128){if((e-=1)<0)break;o.push(r)}else if(r<2048){if((e-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error(\"Invalid code point\");if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function Mc(t){return $s.toByteArray(function(e){if((e=(e=e.split(\"=\")[0]).trim().replace(Aw,\"\")).length<2)return\"\";for(;e.length%4!=0;)e+=\"=\";return e}(t))}function un(t,e,r,i){for(var n=0;n<i&&!(n+r>=e.length||n>=t.length);++n)e[n+r]=t[n];return n}function Et(t,e){return t instanceof e||t!=null&&t.constructor!=null&&t.constructor.name!=null&&t.constructor.name===e.name}function Gs(t){return t!=t}function Ic(t,e){for(var r in t)e[r]=t[r]}function or(t,e,r){return it(t,e,r)}function ci(t){var e;switch(this.encoding=function(r){var i=function(n){if(!n)return\"utf8\";for(var o;;)switch(n){case\"utf8\":case\"utf-8\":return\"utf8\";case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return\"utf16le\";case\"latin1\":case\"binary\":return\"latin1\";case\"base64\":case\"ascii\":case\"hex\":return n;default:if(o)return;n=(\"\"+n).toLowerCase(),o=!0}}(r);if(typeof i!=\"string\"&&(zs.isEncoding===Tc||!Tc(r)))throw new Error(\"Unknown encoding: \"+r);return i||r}(t),this.encoding){case\"utf16le\":this.text=Cw,this.end=Bw,e=4;break;case\"utf8\":this.fillLast=Rw,e=4;break;case\"base64\":this.text=Pw,this.end=Ow,e=3;break;default:return this.write=kw,this.end=xw,void 0}this.lastNeed=0,this.lastTotal=0,this.lastChar=zs.allocUnsafe(e)}function Ws(t){return t<=127?0:t>>5==6?2:t>>4==14?3:t>>3==30?4:t>>6==2?-1:-2}function Rw(t){var e=this.lastTotal-this.lastNeed,r=function(i,n,o){if((192&n[0])!=128)return i.lastNeed=0,\"\\uFFFD\";if(i.lastNeed>1&&n.length>1){if((192&n[1])!=128)return i.lastNeed=1,\"\\uFFFD\";if(i.lastNeed>2&&n.length>2&&(192&n[2])!=128)return i.lastNeed=2,\"\\uFFFD\"}}(this,t);return r!==void 0?r:this.lastNeed<=t.length?(t.copy(this.lastChar,e,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(t.copy(this.lastChar,e,0,t.length),this.lastNeed-=t.length,void 0)}function Cw(t,e){if((t.length-e)%2==0){var r=t.toString(\"utf16le\",e);if(r){var i=r.charCodeAt(r.length-1);if(i>=55296&&i<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=t[t.length-1],t.toString(\"utf16le\",e,t.length-1)}function Bw(t){var e=t&&t.length?this.write(t):\"\";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return e+this.lastChar.toString(\"utf16le\",0,r)}return e}function Pw(t,e){var r=(t.length-e)%3;return r===0?t.toString(\"base64\",e):(this.lastNeed=3-r,this.lastTotal=3,r===1?this.lastChar[0]=t[t.length-1]:(this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1]),t.toString(\"base64\",e,t.length-r))}function Ow(t){var e=t&&t.length?this.write(t):\"\";return this.lastNeed?e+this.lastChar.toString(\"base64\",0,3-this.lastNeed):e}function kw(t){return t.toString(this.encoding)}function xw(t){return t&&t.length?this.write(t):\"\"}var Rc,$e,ke,yc,on,nr,bc,hw,St,$s,Ur,_c,Aw,Iw,an,ln,it,Tw,ar,zs,Tc,Qs=be(()=>{v();m();_();for(Rc={byteLength:function(t){var e=wc(t),r=e[0],i=e[1];return 3*(r+i)/4-i},toByteArray:function(t){var e,r,i=wc(t),n=i[0],o=i[1],s=new yc(function(c,h,d){return 3*(h+d)/4-d}(0,n,o)),a=0,u=o>0?n-4:n;for(r=0;r<u;r+=4)e=ke[t.charCodeAt(r)]<<18|ke[t.charCodeAt(r+1)]<<12|ke[t.charCodeAt(r+2)]<<6|ke[t.charCodeAt(r+3)],s[a++]=e>>16&255,s[a++]=e>>8&255,s[a++]=255&e;return o===2&&(e=ke[t.charCodeAt(r)]<<2|ke[t.charCodeAt(r+1)]>>4,s[a++]=255&e),o===1&&(e=ke[t.charCodeAt(r)]<<10|ke[t.charCodeAt(r+1)]<<4|ke[t.charCodeAt(r+2)]>>2,s[a++]=e>>8&255,s[a++]=255&e),s},fromByteArray:function(t){for(var e,r=t.length,i=r%3,n=[],o=0,s=r-i;o<s;o+=16383)n.push(cw(t,o,o+16383>s?s:o+16383));return i===1?(e=t[r-1],n.push($e[e>>2]+$e[e<<4&63]+\"==\")):i===2&&(e=(t[r-2]<<8)+t[r-1],n.push($e[e>>10]+$e[e>>4&63]+$e[e<<2&63]+\"=\")),n.join(\"\")}},$e=[],ke=[],yc=typeof Uint8Array<\"u\"?Uint8Array:Array,on=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",nr=0,bc=on.length;nr<bc;++nr)$e[nr]=on[nr],ke[on.charCodeAt(nr)]=nr;ke[\"-\".charCodeAt(0)]=62,ke[\"_\".charCodeAt(0)]=63;hw={read:function(t,e,r,i,n){var o,s,a=8*n-i-1,u=(1<<a)-1,c=u>>1,h=-7,d=r?n-1:0,g=r?-1:1,y=t[e+d];for(d+=g,o=y&(1<<-h)-1,y>>=-h,h+=a;h>0;o=256*o+t[e+d],d+=g,h-=8);for(s=o&(1<<-h)-1,o>>=-h,h+=i;h>0;s=256*s+t[e+d],d+=g,h-=8);if(o===0)o=1-c;else{if(o===u)return s?NaN:1/0*(y?-1:1);s+=Math.pow(2,i),o-=c}return(y?-1:1)*s*Math.pow(2,o-i)},write:function(t,e,r,i,n,o){var s,a,u,c=8*o-n-1,h=(1<<c)-1,d=h>>1,g=n===23?Math.pow(2,-24)-Math.pow(2,-77):0,y=i?0:o-1,w=i?1:-1,E=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=h):(s=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-s))<1&&(s--,u*=2),(e+=s+d>=1?g/u:g*Math.pow(2,1-d))*u>=2&&(s++,u/=2),s+d>=h?(a=0,s=h):s+d>=1?(a=(e*u-1)*Math.pow(2,n),s+=d):(a=e*Math.pow(2,d-1)*Math.pow(2,n),s=0));n>=8;t[r+y]=255&a,y+=w,a/=256,n-=8);for(s=s<<n|a,c+=n;c>0;t[r+y]=255&s,y+=w,s/=256,c-=8);t[r+y-w]|=128*E}},St={},$s=Rc,Ur=hw,_c=typeof Symbol==\"function\"&&typeof Symbol.for==\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;St.Buffer=x,St.SlowBuffer=function(t){return+t!=t&&(t=0),x.alloc(+t)},St.INSPECT_MAX_BYTES=50;St.kMaxLength=2147483647,x.TYPED_ARRAY_SUPPORT=function(){try{var t=new Uint8Array(1),e={foo:function(){return 42}};return Object.setPrototypeOf(e,Uint8Array.prototype),Object.setPrototypeOf(t,e),t.foo()===42}catch{return!1}}(),x.TYPED_ARRAY_SUPPORT||typeof console>\"u\"||typeof console.error!=\"function\"||console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"),Object.defineProperty(x.prototype,\"parent\",{enumerable:!0,get:function(){if(x.isBuffer(this))return this.buffer}}),Object.defineProperty(x.prototype,\"offset\",{enumerable:!0,get:function(){if(x.isBuffer(this))return this.byteOffset}}),x.poolSize=8192,x.from=function(t,e,r){return Cc(t,e,r)},Object.setPrototypeOf(x.prototype,Uint8Array.prototype),Object.setPrototypeOf(x,Uint8Array),x.alloc=function(t,e,r){return function(i,n,o){return Bc(i),i<=0?vt(i):n!==void 0?typeof o==\"string\"?vt(i).fill(n,o):vt(i).fill(n):vt(i)}(t,e,r)},x.allocUnsafe=function(t){return Hs(t)},x.allocUnsafeSlow=function(t){return Hs(t)},x.isBuffer=function(t){return t!=null&&t._isBuffer===!0&&t!==x.prototype},x.compare=function(t,e){if(Et(t,Uint8Array)&&(t=x.from(t,t.offset,t.byteLength)),Et(e,Uint8Array)&&(e=x.from(e,e.offset,e.byteLength)),!x.isBuffer(t)||!x.isBuffer(e))throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');if(t===e)return 0;for(var r=t.length,i=e.length,n=0,o=Math.min(r,i);n<o;++n)if(t[n]!==e[n]){r=t[n],i=e[n];break}return r<i?-1:i<r?1:0},x.isEncoding=function(t){switch(String(t).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}},x.concat=function(t,e){if(!Array.isArray(t))throw new TypeError('\"list\" argument must be an Array of Buffers');if(t.length===0)return x.alloc(0);var r;if(e===void 0)for(e=0,r=0;r<t.length;++r)e+=t[r].length;var i=x.allocUnsafe(e),n=0;for(r=0;r<t.length;++r){var o=t[r];if(Et(o,Uint8Array)&&(o=x.from(o)),!x.isBuffer(o))throw new TypeError('\"list\" argument must be an Array of Buffers');o.copy(i,n),n+=o.length}return i},x.byteLength=Pc,x.prototype._isBuffer=!0,x.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(var e=0;e<t;e+=2)sr(this,e,e+1);return this},x.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(var e=0;e<t;e+=4)sr(this,e,e+3),sr(this,e+1,e+2);return this},x.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(var e=0;e<t;e+=8)sr(this,e,e+7),sr(this,e+1,e+6),sr(this,e+2,e+5),sr(this,e+3,e+4);return this},x.prototype.toString=function(){var t=this.length;return t===0?\"\":arguments.length===0?kc(this,0,t):dw.apply(this,arguments)},x.prototype.toLocaleString=x.prototype.toString,x.prototype.equals=function(t){if(!x.isBuffer(t))throw new TypeError(\"Argument must be a Buffer\");return this===t||x.compare(this,t)===0},x.prototype.inspect=function(){var t=\"\",e=St.INSPECT_MAX_BYTES;return t=this.toString(\"hex\",0,e).replace(/(.{2})/g,\"$1 \").trim(),this.length>e&&(t+=\" ... \"),\"<Buffer \"+t+\">\"},_c&&(x.prototype[_c]=x.prototype.inspect),x.prototype.compare=function(t,e,r,i,n){if(Et(t,Uint8Array)&&(t=x.from(t,t.offset,t.byteLength)),!x.isBuffer(t))throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type '+typeof t);if(e===void 0&&(e=0),r===void 0&&(r=t?t.length:0),i===void 0&&(i=0),n===void 0&&(n=this.length),e<0||r>t.length||i<0||n>this.length)throw new RangeError(\"out of range index\");if(i>=n&&e>=r)return 0;if(i>=n)return-1;if(e>=r)return 1;if(this===t)return 0;for(var o=(n>>>=0)-(i>>>=0),s=(r>>>=0)-(e>>>=0),a=Math.min(o,s),u=this.slice(i,n),c=t.slice(e,r),h=0;h<a;++h)if(u[h]!==c[h]){o=u[h],s=c[h];break}return o<s?-1:s<o?1:0},x.prototype.includes=function(t,e,r){return this.indexOf(t,e,r)!==-1},x.prototype.indexOf=function(t,e,r){return vc(this,t,e,r,!0)},x.prototype.lastIndexOf=function(t,e,r){return vc(this,t,e,r,!1)},x.prototype.write=function(t,e,r,i){if(e===void 0)i=\"utf8\",r=this.length,e=0;else if(r===void 0&&typeof e==\"string\")i=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");e>>>=0,isFinite(r)?(r>>>=0,i===void 0&&(i=\"utf8\")):(i=r,r=void 0)}var n=this.length-e;if((r===void 0||r>n)&&(r=n),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");i||(i=\"utf8\");for(var o=!1;;)switch(i){case\"hex\":return pw(this,t,e,r);case\"utf8\":case\"utf-8\":return gw(this,t,e,r);case\"ascii\":return Oc(this,t,e,r);case\"latin1\":case\"binary\":return yw(this,t,e,r);case\"base64\":return bw(this,t,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ww(this,t,e,r);default:if(o)throw new TypeError(\"Unknown encoding: \"+i);i=(\"\"+i).toLowerCase(),o=!0}},x.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};x.prototype.slice=function(t,e){var r=this.length;(t=~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),(e=e===void 0?r:~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t);var i=this.subarray(t,e);return Object.setPrototypeOf(i,x.prototype),i},x.prototype.readUIntLE=function(t,e,r){t>>>=0,e>>>=0,r||ye(t,e,this.length);for(var i=this[t],n=1,o=0;++o<e&&(n*=256);)i+=this[t+o]*n;return i},x.prototype.readUIntBE=function(t,e,r){t>>>=0,e>>>=0,r||ye(t,e,this.length);for(var i=this[t+--e],n=1;e>0&&(n*=256);)i+=this[t+--e]*n;return i},x.prototype.readUInt8=function(t,e){return t>>>=0,e||ye(t,1,this.length),this[t]},x.prototype.readUInt16LE=function(t,e){return t>>>=0,e||ye(t,2,this.length),this[t]|this[t+1]<<8},x.prototype.readUInt16BE=function(t,e){return t>>>=0,e||ye(t,2,this.length),this[t]<<8|this[t+1]},x.prototype.readUInt32LE=function(t,e){return t>>>=0,e||ye(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},x.prototype.readUInt32BE=function(t,e){return t>>>=0,e||ye(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},x.prototype.readIntLE=function(t,e,r){t>>>=0,e>>>=0,r||ye(t,e,this.length);for(var i=this[t],n=1,o=0;++o<e&&(n*=256);)i+=this[t+o]*n;return i>=(n*=128)&&(i-=Math.pow(2,8*e)),i},x.prototype.readIntBE=function(t,e,r){t>>>=0,e>>>=0,r||ye(t,e,this.length);for(var i=e,n=1,o=this[t+--i];i>0&&(n*=256);)o+=this[t+--i]*n;return o>=(n*=128)&&(o-=Math.pow(2,8*e)),o},x.prototype.readInt8=function(t,e){return t>>>=0,e||ye(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},x.prototype.readInt16LE=function(t,e){t>>>=0,e||ye(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},x.prototype.readInt16BE=function(t,e){t>>>=0,e||ye(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},x.prototype.readInt32LE=function(t,e){return t>>>=0,e||ye(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},x.prototype.readInt32BE=function(t,e){return t>>>=0,e||ye(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},x.prototype.readFloatLE=function(t,e){return t>>>=0,e||ye(t,4,this.length),Ur.read(this,t,!0,23,4)},x.prototype.readFloatBE=function(t,e){return t>>>=0,e||ye(t,4,this.length),Ur.read(this,t,!1,23,4)},x.prototype.readDoubleLE=function(t,e){return t>>>=0,e||ye(t,8,this.length),Ur.read(this,t,!0,52,8)},x.prototype.readDoubleBE=function(t,e){return t>>>=0,e||ye(t,8,this.length),Ur.read(this,t,!1,52,8)},x.prototype.writeUIntLE=function(t,e,r,i){t=+t,e>>>=0,r>>>=0,i||Pe(this,t,e,r,Math.pow(2,8*r)-1,0);var n=1,o=0;for(this[e]=255&t;++o<r&&(n*=256);)this[e+o]=t/n&255;return e+r},x.prototype.writeUIntBE=function(t,e,r,i){t=+t,e>>>=0,r>>>=0,i||Pe(this,t,e,r,Math.pow(2,8*r)-1,0);var n=r-1,o=1;for(this[e+n]=255&t;--n>=0&&(o*=256);)this[e+n]=t/o&255;return e+r},x.prototype.writeUInt8=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,1,255,0),this[e]=255&t,e+1},x.prototype.writeUInt16LE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,2,65535,0),this[e]=255&t,this[e+1]=t>>>8,e+2},x.prototype.writeUInt16BE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,2,65535,0),this[e]=t>>>8,this[e+1]=255&t,e+2},x.prototype.writeUInt32LE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,4,4294967295,0),this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t,e+4},x.prototype.writeUInt32BE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,4,4294967295,0),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},x.prototype.writeIntLE=function(t,e,r,i){if(t=+t,e>>>=0,!i){var n=Math.pow(2,8*r-1);Pe(this,t,e,r,n-1,-n)}var o=0,s=1,a=0;for(this[e]=255&t;++o<r&&(s*=256);)t<0&&a===0&&this[e+o-1]!==0&&(a=1),this[e+o]=(t/s>>0)-a&255;return e+r},x.prototype.writeIntBE=function(t,e,r,i){if(t=+t,e>>>=0,!i){var n=Math.pow(2,8*r-1);Pe(this,t,e,r,n-1,-n)}var o=r-1,s=1,a=0;for(this[e+o]=255&t;--o>=0&&(s*=256);)t<0&&a===0&&this[e+o+1]!==0&&(a=1),this[e+o]=(t/s>>0)-a&255;return e+r},x.prototype.writeInt8=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,1,127,-128),t<0&&(t=255+t+1),this[e]=255&t,e+1},x.prototype.writeInt16LE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,2,32767,-32768),this[e]=255&t,this[e+1]=t>>>8,e+2},x.prototype.writeInt16BE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,2,32767,-32768),this[e]=t>>>8,this[e+1]=255&t,e+2},x.prototype.writeInt32LE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,4,2147483647,-2147483648),this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24,e+4},x.prototype.writeInt32BE=function(t,e,r){return t=+t,e>>>=0,r||Pe(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},x.prototype.writeFloatLE=function(t,e,r){return Sc(this,t,e,!0,r)},x.prototype.writeFloatBE=function(t,e,r){return Sc(this,t,e,!1,r)},x.prototype.writeDoubleLE=function(t,e,r){return Ac(this,t,e,!0,r)},x.prototype.writeDoubleBE=function(t,e,r){return Ac(this,t,e,!1,r)},x.prototype.copy=function(t,e,r,i){if(!x.isBuffer(t))throw new TypeError(\"argument should be a Buffer\");if(r||(r=0),i||i===0||(i=this.length),e>=t.length&&(e=t.length),e||(e=0),i>0&&i<r&&(i=r),i===r||t.length===0||this.length===0)return 0;if(e<0)throw new RangeError(\"targetStart out of bounds\");if(r<0||r>=this.length)throw new RangeError(\"Index out of range\");if(i<0)throw new RangeError(\"sourceEnd out of bounds\");i>this.length&&(i=this.length),t.length-e<i-r&&(i=t.length-e+r);var n=i-r;if(this===t&&typeof Uint8Array.prototype.copyWithin==\"function\")this.copyWithin(e,r,i);else if(this===t&&r<e&&e<i)for(var o=n-1;o>=0;--o)t[o+e]=this[o+r];else Uint8Array.prototype.set.call(t,this.subarray(r,i),e);return n},x.prototype.fill=function(t,e,r,i){if(typeof t==\"string\"){if(typeof e==\"string\"?(i=e,e=0,r=this.length):typeof r==\"string\"&&(i=r,r=this.length),i!==void 0&&typeof i!=\"string\")throw new TypeError(\"encoding must be a string\");if(typeof i==\"string\"&&!x.isEncoding(i))throw new TypeError(\"Unknown encoding: \"+i);if(t.length===1){var n=t.charCodeAt(0);(i===\"utf8\"&&n<128||i===\"latin1\")&&(t=n)}}else typeof t==\"number\"?t&=255:typeof t==\"boolean\"&&(t=Number(t));if(e<0||this.length<e||this.length<r)throw new RangeError(\"Out of range index\");if(r<=e)return this;var o;if(e>>>=0,r=r===void 0?this.length:r>>>0,t||(t=0),typeof t==\"number\")for(o=e;o<r;++o)this[o]=t;else{var s=x.isBuffer(t)?t:x.from(t,i),a=s.length;if(a===0)throw new TypeError('The value \"'+t+'\" is invalid for argument \"value\"');for(o=0;o<r-e;++o)this[o+e]=s[o%a]}return this};Aw=/[^+/0-9A-Za-z-_]/g;Iw=function(){for(var t=new Array(256),e=0;e<16;++e)for(var r=16*e,i=0;i<16;++i)t[r+i]=\"0123456789abcdef\"[e]+\"0123456789abcdef\"[i];return t}();St.Buffer;St.INSPECT_MAX_BYTES;St.kMaxLength;an={},ln=St,it=ln.Buffer;it.from&&it.alloc&&it.allocUnsafe&&it.allocUnsafeSlow?an=ln:(Ic(ln,an),an.Buffer=or),or.prototype=Object.create(it.prototype),Ic(it,or),or.from=function(t,e,r){if(typeof t==\"number\")throw new TypeError(\"Argument must not be a number\");return it(t,e,r)},or.alloc=function(t,e,r){if(typeof t!=\"number\")throw new TypeError(\"Argument must be a number\");var i=it(t);return e!==void 0?typeof r==\"string\"?i.fill(e,r):i.fill(e):i.fill(0),i},or.allocUnsafe=function(t){if(typeof t!=\"number\")throw new TypeError(\"Argument must be a number\");return it(t)},or.allocUnsafeSlow=function(t){if(typeof t!=\"number\")throw new TypeError(\"Argument must be a number\");return ln.SlowBuffer(t)};Tw=an,ar={},zs=Tw.Buffer,Tc=zs.isEncoding||function(t){switch((t=\"\"+t)&&t.toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":case\"raw\":return!0;default:return!1}};ar.StringDecoder=ci,ci.prototype.write=function(t){if(t.length===0)return\"\";var e,r;if(this.lastNeed){if((e=this.fillLast(t))===void 0)return\"\";r=this.lastNeed,this.lastNeed=0}else r=0;return r<t.length?e?e+this.text(t,r):this.text(t,r):e||\"\"},ci.prototype.end=function(t){var e=t&&t.length?this.write(t):\"\";return this.lastNeed?e+\"\\uFFFD\":e},ci.prototype.text=function(t,e){var r=function(n,o,s){var a=o.length-1;if(a<s)return 0;var u=Ws(o[a]);return u>=0?(u>0&&(n.lastNeed=u-1),u):--a<s||u===-2?0:(u=Ws(o[a]))>=0?(u>0&&(n.lastNeed=u-2),u):--a<s||u===-2?0:(u=Ws(o[a]))>=0?(u>0&&(u===2?u=0:n.lastNeed=u-3),u):0}(this,t,e);if(!this.lastNeed)return t.toString(\"utf8\",e);this.lastTotal=r;var i=t.length-(r-this.lastNeed);return t.copy(this.lastChar,0,i),t.toString(\"utf8\",e,i)},ci.prototype.fillLast=function(t){if(this.lastNeed<=t.length)return t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,t.length),this.lastNeed-=t.length};ar.StringDecoder;ar.StringDecoder});var Lc={};Qt(Lc,{StringDecoder:()=>Mw,default:()=>ar});var Mw,Uc=be(()=>{v();m();_();Qs();Qs();Mw=ar.StringDecoder});var Ys=M((q2,jc)=>{\"use strict\";v();m();_();var Nc=Ut(),{PromisePrototypeThen:Lw,SymbolAsyncIterator:qc,SymbolIterator:Dc}=ce(),{Buffer:Uw}=(we(),Z(ve)),{ERR_INVALID_ARG_TYPE:Nw,ERR_STREAM_NULL_VALUES:qw}=Se().codes;function Dw(t,e,r){let i;if(typeof e==\"string\"||e instanceof Uw)return new t({objectMode:!0,...r,read(){this.push(e),this.push(null)}});let n;if(e&&e[qc])n=!0,i=e[qc]();else if(e&&e[Dc])n=!1,i=e[Dc]();else throw new Nw(\"iterable\",[\"Iterable\"],e);let o=new t({objectMode:!0,highWaterMark:1,...r}),s=!1;o._read=function(){s||(s=!0,u())},o._destroy=function(c,h){Lw(a(c),()=>Nc.nextTick(h,c),d=>Nc.nextTick(h,d||c))};async function a(c){let h=c!=null,d=typeof i.throw==\"function\";if(h&&d){let{value:g,done:y}=await i.throw(c);if(await g,y)return}if(typeof i.return==\"function\"){let{value:g}=await i.return();await g}}async function u(){for(;;){try{let{value:c,done:h}=n?await i.next():i.next();if(h)o.push(null);else{let d=c&&typeof c.then==\"function\"?await c:c;if(d===null)throw s=!1,new qw;if(o.push(d))continue;s=!1}}catch(c){o.destroy(c)}break}}return o}jc.exports=Dw});var hi=M((G2,Zc)=>{v();m();_();var He=Ut(),{ArrayPrototypeIndexOf:jw,NumberIsInteger:Fw,NumberIsNaN:Ww,NumberParseInt:$w,ObjectDefineProperties:$c,ObjectKeys:Hw,ObjectSetPrototypeOf:Hc,Promise:Vw,SafeSet:zw,SymbolAsyncIterator:Kw,Symbol:Gw}=ce();Zc.exports=F;F.ReadableState=ro;var{EventEmitter:Qw}=(ir(),Z(rr)),{Stream:qt,prependListener:Yw}=tn(),{Buffer:Js}=(we(),Z(ve)),{addAbortSignal:Jw}=fi(),Xw=mt(),H=Je().debuglog(\"stream\",t=>{H=t}),Zw=dc(),qr=tr(),{getHighWaterMark:e_,getDefaultHighWaterMark:t_}=sn(),{aggregateTwoErrors:Fc,codes:{ERR_INVALID_ARG_TYPE:r_,ERR_METHOD_NOT_IMPLEMENTED:i_,ERR_OUT_OF_RANGE:n_,ERR_STREAM_PUSH_AFTER_EOF:s_,ERR_STREAM_UNSHIFT_AFTER_END_EVENT:o_}}=Se(),{validateObject:a_}=ui(),lr=Gw(\"kPaused\"),{StringDecoder:Vc}=(Uc(),Z(Lc)),l_=Ys();Hc(F.prototype,qt.prototype);Hc(F,qt);var Xs=()=>{},{errorOrDestroy:Nr}=qr;function ro(t,e,r){typeof r!=\"boolean\"&&(r=e instanceof nt()),this.objectMode=!!(t&&t.objectMode),r&&(this.objectMode=this.objectMode||!!(t&&t.readableObjectMode)),this.highWaterMark=t?e_(this,t,\"readableHighWaterMark\",r):t_(!1),this.buffer=new Zw,this.length=0,this.pipes=[],this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.constructed=!0,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this[lr]=null,this.errorEmitted=!1,this.emitClose=!t||t.emitClose!==!1,this.autoDestroy=!t||t.autoDestroy!==!1,this.destroyed=!1,this.errored=null,this.closed=!1,this.closeEmitted=!1,this.defaultEncoding=t&&t.defaultEncoding||\"utf8\",this.awaitDrainWriters=null,this.multiAwaitDrain=!1,this.readingMore=!1,this.dataEmitted=!1,this.decoder=null,this.encoding=null,t&&t.encoding&&(this.decoder=new Vc(t.encoding),this.encoding=t.encoding)}function F(t){if(!(this instanceof F))return new F(t);let e=this instanceof nt();this._readableState=new ro(t,this,e),t&&(typeof t.read==\"function\"&&(this._read=t.read),typeof t.destroy==\"function\"&&(this._destroy=t.destroy),typeof t.construct==\"function\"&&(this._construct=t.construct),t.signal&&!e&&Jw(t.signal,this)),qt.call(this,t),qr.construct(this,()=>{this._readableState.needReadable&&fn(this,this._readableState)})}F.prototype.destroy=qr.destroy;F.prototype._undestroy=qr.undestroy;F.prototype._destroy=function(t,e){e(t)};F.prototype[Qw.captureRejectionSymbol]=function(t){this.destroy(t)};F.prototype.push=function(t,e){return zc(this,t,e,!1)};F.prototype.unshift=function(t,e){return zc(this,t,e,!0)};function zc(t,e,r,i){H(\"readableAddChunk\",e);let n=t._readableState,o;if(n.objectMode||(typeof e==\"string\"?(r=r||n.defaultEncoding,n.encoding!==r&&(i&&n.encoding?e=Js.from(e,r).toString(n.encoding):(e=Js.from(e,r),r=\"\"))):e instanceof Js?r=\"\":qt._isUint8Array(e)?(e=qt._uint8ArrayToBuffer(e),r=\"\"):e!=null&&(o=new r_(\"chunk\",[\"string\",\"Buffer\",\"Uint8Array\"],e))),o)Nr(t,o);else if(e===null)n.reading=!1,c_(t,n);else if(n.objectMode||e&&e.length>0)if(i)if(n.endEmitted)Nr(t,new o_);else{if(n.destroyed||n.errored)return!1;Zs(t,n,e,!0)}else if(n.ended)Nr(t,new s_);else{if(n.destroyed||n.errored)return!1;n.reading=!1,n.decoder&&!r?(e=n.decoder.write(e),n.objectMode||e.length!==0?Zs(t,n,e,!1):fn(t,n)):Zs(t,n,e,!1)}else i||(n.reading=!1,fn(t,n));return!n.ended&&(n.length<n.highWaterMark||n.length===0)}function Zs(t,e,r,i){e.flowing&&e.length===0&&!e.sync&&t.listenerCount(\"data\")>0?(e.multiAwaitDrain?e.awaitDrainWriters.clear():e.awaitDrainWriters=null,e.dataEmitted=!0,t.emit(\"data\",r)):(e.length+=e.objectMode?1:r.length,i?e.buffer.unshift(r):e.buffer.push(r),e.needReadable&&cn(t)),fn(t,e)}F.prototype.isPaused=function(){let t=this._readableState;return t[lr]===!0||t.flowing===!1};F.prototype.setEncoding=function(t){let e=new Vc(t);this._readableState.decoder=e,this._readableState.encoding=this._readableState.decoder.encoding;let r=this._readableState.buffer,i=\"\";for(let n of r)i+=e.write(n);return r.clear(),i!==\"\"&&r.push(i),this._readableState.length=i.length,this};var u_=1073741824;function f_(t){if(t>u_)throw new n_(\"size\",\"<= 1GiB\",t);return t--,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t++,t}function Wc(t,e){return t<=0||e.length===0&&e.ended?0:e.objectMode?1:Ww(t)?e.flowing&&e.length?e.buffer.first().length:e.length:t<=e.length?t:e.ended?e.length:0}F.prototype.read=function(t){H(\"read\",t),t===void 0?t=NaN:Fw(t)||(t=$w(t,10));let e=this._readableState,r=t;if(t>e.highWaterMark&&(e.highWaterMark=f_(t)),t!==0&&(e.emittedReadable=!1),t===0&&e.needReadable&&((e.highWaterMark!==0?e.length>=e.highWaterMark:e.length>0)||e.ended))return H(\"read: emitReadable\",e.length,e.ended),e.length===0&&e.ended?eo(this):cn(this),null;if(t=Wc(t,e),t===0&&e.ended)return e.length===0&&eo(this),null;let i=e.needReadable;if(H(\"need readable\",i),(e.length===0||e.length-t<e.highWaterMark)&&(i=!0,H(\"length less than watermark\",i)),e.ended||e.reading||e.destroyed||e.errored||!e.constructed)i=!1,H(\"reading, ended or constructing\",i);else if(i){H(\"do read\"),e.reading=!0,e.sync=!0,e.length===0&&(e.needReadable=!0);try{this._read(e.highWaterMark)}catch(o){Nr(this,o)}e.sync=!1,e.reading||(t=Wc(r,e))}let n;return t>0?n=Jc(t,e):n=null,n===null?(e.needReadable=e.length<=e.highWaterMark,t=0):(e.length-=t,e.multiAwaitDrain?e.awaitDrainWriters.clear():e.awaitDrainWriters=null),e.length===0&&(e.ended||(e.needReadable=!0),r!==t&&e.ended&&eo(this)),n!==null&&!e.errorEmitted&&!e.closeEmitted&&(e.dataEmitted=!0,this.emit(\"data\",n)),n};function c_(t,e){if(H(\"onEofChunk\"),!e.ended){if(e.decoder){let r=e.decoder.end();r&&r.length&&(e.buffer.push(r),e.length+=e.objectMode?1:r.length)}e.ended=!0,e.sync?cn(t):(e.needReadable=!1,e.emittedReadable=!0,Kc(t))}}function cn(t){let e=t._readableState;H(\"emitReadable\",e.needReadable,e.emittedReadable),e.needReadable=!1,e.emittedReadable||(H(\"emitReadable\",e.flowing),e.emittedReadable=!0,He.nextTick(Kc,t))}function Kc(t){let e=t._readableState;H(\"emitReadable_\",e.destroyed,e.length,e.ended),!e.destroyed&&!e.errored&&(e.length||e.ended)&&(t.emit(\"readable\"),e.emittedReadable=!1),e.needReadable=!e.flowing&&!e.ended&&e.length<=e.highWaterMark,Qc(t)}function fn(t,e){!e.readingMore&&e.constructed&&(e.readingMore=!0,He.nextTick(h_,t,e))}function h_(t,e){for(;!e.reading&&!e.ended&&(e.length<e.highWaterMark||e.flowing&&e.length===0);){let r=e.length;if(H(\"maybeReadMore read 0\"),t.read(0),r===e.length)break}e.readingMore=!1}F.prototype._read=function(t){throw new i_(\"_read()\")};F.prototype.pipe=function(t,e){let r=this,i=this._readableState;i.pipes.length===1&&(i.multiAwaitDrain||(i.multiAwaitDrain=!0,i.awaitDrainWriters=new zw(i.awaitDrainWriters?[i.awaitDrainWriters]:[]))),i.pipes.push(t),H(\"pipe count=%d opts=%j\",i.pipes.length,e);let o=(!e||e.end!==!1)&&t!==He.stdout&&t!==He.stderr?a:S;i.endEmitted?He.nextTick(o):r.once(\"end\",o),t.on(\"unpipe\",s);function s(I,C){H(\"onunpipe\"),I===r&&C&&C.hasUnpiped===!1&&(C.hasUnpiped=!0,h())}function a(){H(\"onend\"),t.end()}let u,c=!1;function h(){H(\"cleanup\"),t.removeListener(\"close\",w),t.removeListener(\"finish\",E),u&&t.removeListener(\"drain\",u),t.removeListener(\"error\",y),t.removeListener(\"unpipe\",s),r.removeListener(\"end\",a),r.removeListener(\"end\",S),r.removeListener(\"data\",g),c=!0,u&&i.awaitDrainWriters&&(!t._writableState||t._writableState.needDrain)&&u()}function d(){c||(i.pipes.length===1&&i.pipes[0]===t?(H(\"false write response, pause\",0),i.awaitDrainWriters=t,i.multiAwaitDrain=!1):i.pipes.length>1&&i.pipes.includes(t)&&(H(\"false write response, pause\",i.awaitDrainWriters.size),i.awaitDrainWriters.add(t)),r.pause()),u||(u=d_(r,t),t.on(\"drain\",u))}r.on(\"data\",g);function g(I){H(\"ondata\");let C=t.write(I);H(\"dest.write\",C),C===!1&&d()}function y(I){if(H(\"onerror\",I),S(),t.removeListener(\"error\",y),t.listenerCount(\"error\")===0){let C=t._writableState||t._readableState;C&&!C.errorEmitted?Nr(t,I):t.emit(\"error\",I)}}Yw(t,\"error\",y);function w(){t.removeListener(\"finish\",E),S()}t.once(\"close\",w);function E(){H(\"onfinish\"),t.removeListener(\"close\",w),S()}t.once(\"finish\",E);function S(){H(\"unpipe\"),r.unpipe(t)}return t.emit(\"pipe\",r),t.writableNeedDrain===!0?i.flowing&&d():i.flowing||(H(\"pipe resume\"),r.resume()),t};function d_(t,e){return function(){let i=t._readableState;i.awaitDrainWriters===e?(H(\"pipeOnDrain\",1),i.awaitDrainWriters=null):i.multiAwaitDrain&&(H(\"pipeOnDrain\",i.awaitDrainWriters.size),i.awaitDrainWriters.delete(e)),(!i.awaitDrainWriters||i.awaitDrainWriters.size===0)&&t.listenerCount(\"data\")&&t.resume()}}F.prototype.unpipe=function(t){let e=this._readableState,r={hasUnpiped:!1};if(e.pipes.length===0)return this;if(!t){let n=e.pipes;e.pipes=[],this.pause();for(let o=0;o<n.length;o++)n[o].emit(\"unpipe\",this,{hasUnpiped:!1});return this}let i=jw(e.pipes,t);return i===-1?this:(e.pipes.splice(i,1),e.pipes.length===0&&this.pause(),t.emit(\"unpipe\",this,r),this)};F.prototype.on=function(t,e){let r=qt.prototype.on.call(this,t,e),i=this._readableState;return t===\"data\"?(i.readableListening=this.listenerCount(\"readable\")>0,i.flowing!==!1&&this.resume()):t===\"readable\"&&!i.endEmitted&&!i.readableListening&&(i.readableListening=i.needReadable=!0,i.flowing=!1,i.emittedReadable=!1,H(\"on readable\",i.length,i.reading),i.length?cn(this):i.reading||He.nextTick(p_,this)),r};F.prototype.addListener=F.prototype.on;F.prototype.removeListener=function(t,e){let r=qt.prototype.removeListener.call(this,t,e);return t===\"readable\"&&He.nextTick(Gc,this),r};F.prototype.off=F.prototype.removeListener;F.prototype.removeAllListeners=function(t){let e=qt.prototype.removeAllListeners.apply(this,arguments);return(t===\"readable\"||t===void 0)&&He.nextTick(Gc,this),e};function Gc(t){let e=t._readableState;e.readableListening=t.listenerCount(\"readable\")>0,e.resumeScheduled&&e[lr]===!1?e.flowing=!0:t.listenerCount(\"data\")>0?t.resume():e.readableListening||(e.flowing=null)}function p_(t){H(\"readable nexttick read 0\"),t.read(0)}F.prototype.resume=function(){let t=this._readableState;return t.flowing||(H(\"resume\"),t.flowing=!t.readableListening,g_(this,t)),t[lr]=!1,this};function g_(t,e){e.resumeScheduled||(e.resumeScheduled=!0,He.nextTick(y_,t,e))}function y_(t,e){H(\"resume\",e.reading),e.reading||t.read(0),e.resumeScheduled=!1,t.emit(\"resume\"),Qc(t),e.flowing&&!e.reading&&t.read(0)}F.prototype.pause=function(){return H(\"call pause flowing=%j\",this._readableState.flowing),this._readableState.flowing!==!1&&(H(\"pause\"),this._readableState.flowing=!1,this.emit(\"pause\")),this._readableState[lr]=!0,this};function Qc(t){let e=t._readableState;for(H(\"flow\",e.flowing);e.flowing&&t.read()!==null;);}F.prototype.wrap=function(t){let e=!1;t.on(\"data\",i=>{!this.push(i)&&t.pause&&(e=!0,t.pause())}),t.on(\"end\",()=>{this.push(null)}),t.on(\"error\",i=>{Nr(this,i)}),t.on(\"close\",()=>{this.destroy()}),t.on(\"destroy\",()=>{this.destroy()}),this._read=()=>{e&&t.resume&&(e=!1,t.resume())};let r=Hw(t);for(let i=1;i<r.length;i++){let n=r[i];this[n]===void 0&&typeof t[n]==\"function\"&&(this[n]=t[n].bind(t))}return this};F.prototype[Kw]=function(){return Yc(this)};F.prototype.iterator=function(t){return t!==void 0&&a_(t,\"options\"),Yc(this,t)};function Yc(t,e){typeof t.read!=\"function\"&&(t=F.wrap(t,{objectMode:!0}));let r=b_(t,e);return r.stream=t,r}async function*b_(t,e){let r=Xs;function i(s){this===t?(r(),r=Xs):r=s}t.on(\"readable\",i);let n,o=Xw(t,{writable:!1},s=>{n=s?Fc(n,s):null,r(),r=Xs});try{for(;;){let s=t.destroyed?null:t.read();if(s!==null)yield s;else{if(n)throw n;if(n===null)return;await new Vw(i)}}}catch(s){throw n=Fc(n,s),n}finally{(n||e?.destroyOnReturn!==!1)&&(n===void 0||t._readableState.autoDestroy)?qr.destroyer(t,null):(t.off(\"readable\",i),o())}}$c(F.prototype,{readable:{__proto__:null,get(){let t=this._readableState;return!!t&&t.readable!==!1&&!t.destroyed&&!t.errorEmitted&&!t.endEmitted},set(t){this._readableState&&(this._readableState.readable=!!t)}},readableDidRead:{__proto__:null,enumerable:!1,get:function(){return this._readableState.dataEmitted}},readableAborted:{__proto__:null,enumerable:!1,get:function(){return!!(this._readableState.readable!==!1&&(this._readableState.destroyed||this._readableState.errored)&&!this._readableState.endEmitted)}},readableHighWaterMark:{__proto__:null,enumerable:!1,get:function(){return this._readableState.highWaterMark}},readableBuffer:{__proto__:null,enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}},readableFlowing:{__proto__:null,enumerable:!1,get:function(){return this._readableState.flowing},set:function(t){this._readableState&&(this._readableState.flowing=t)}},readableLength:{__proto__:null,enumerable:!1,get(){return this._readableState.length}},readableObjectMode:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.objectMode:!1}},readableEncoding:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.encoding:null}},errored:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.errored:null}},closed:{__proto__:null,get(){return this._readableState?this._readableState.closed:!1}},destroyed:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.destroyed:!1},set(t){this._readableState&&(this._readableState.destroyed=t)}},readableEnded:{__proto__:null,enumerable:!1,get(){return this._readableState?this._readableState.endEmitted:!1}}});$c(ro.prototype,{pipesCount:{__proto__:null,get(){return this.pipes.length}},paused:{__proto__:null,get(){return this[lr]!==!1},set(t){this[lr]=!!t}}});F._fromList=Jc;function Jc(t,e){if(e.length===0)return null;let r;return e.objectMode?r=e.buffer.shift():!t||t>=e.length?(e.decoder?r=e.buffer.join(\"\"):e.buffer.length===1?r=e.buffer.first():r=e.buffer.concat(e.length),e.buffer.clear()):r=e.buffer.consume(t,e.decoder),r}function eo(t){let e=t._readableState;H(\"endReadable\",e.endEmitted),e.endEmitted||(e.ended=!0,He.nextTick(w_,e,t))}function w_(t,e){if(H(\"endReadableNT\",t.endEmitted,t.length),!t.errored&&!t.closeEmitted&&!t.endEmitted&&t.length===0){if(t.endEmitted=!0,e.emit(\"end\"),e.writable&&e.allowHalfOpen===!1)He.nextTick(__,e);else if(t.autoDestroy){let r=e._writableState;(!r||r.autoDestroy&&(r.finished||r.writable===!1))&&e.destroy()}}}function __(t){t.writable&&!t.writableEnded&&!t.destroyed&&t.end()}F.from=function(t,e){return l_(F,t,e)};var to;function Xc(){return to===void 0&&(to={}),to}F.fromWeb=function(t,e){return Xc().newStreamReadableFromReadableStream(t,e)};F.toWeb=function(t,e){return Xc().newReadableStreamFromStreamReadable(t,e)};F.wrap=function(t,e){var r,i;return new F({objectMode:(r=(i=t.readableObjectMode)!==null&&i!==void 0?i:t.objectMode)!==null&&r!==void 0?r:!0,...e,destroy(n,o){qr.destroyer(t,n),o(n)}}).wrap(t)}});var uo=M((nR,ch)=>{v();m();_();var ur=Ut(),{ArrayPrototypeSlice:rh,Error:m_,FunctionPrototypeSymbolHasInstance:ih,ObjectDefineProperty:nh,ObjectDefineProperties:v_,ObjectSetPrototypeOf:sh,StringPrototypeToLowerCase:E_,Symbol:S_,SymbolHasInstance:A_}=ce();ch.exports=ie;ie.WritableState=gi;var{EventEmitter:I_}=(ir(),Z(rr)),di=tn().Stream,{Buffer:hn}=(we(),Z(ve)),gn=tr(),{addAbortSignal:T_}=fi(),{getHighWaterMark:R_,getDefaultHighWaterMark:C_}=sn(),{ERR_INVALID_ARG_TYPE:B_,ERR_METHOD_NOT_IMPLEMENTED:P_,ERR_MULTIPLE_CALLBACK:oh,ERR_STREAM_CANNOT_PIPE:O_,ERR_STREAM_DESTROYED:pi,ERR_STREAM_ALREADY_FINISHED:k_,ERR_STREAM_NULL_VALUES:x_,ERR_STREAM_WRITE_AFTER_END:M_,ERR_UNKNOWN_ENCODING:ah}=Se().codes,{errorOrDestroy:Dr}=gn;sh(ie.prototype,di.prototype);sh(ie,di);function so(){}var jr=S_(\"kOnFinished\");function gi(t,e,r){typeof r!=\"boolean\"&&(r=e instanceof nt()),this.objectMode=!!(t&&t.objectMode),r&&(this.objectMode=this.objectMode||!!(t&&t.writableObjectMode)),this.highWaterMark=t?R_(this,t,\"writableHighWaterMark\",r):C_(!1),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;let i=!!(t&&t.decodeStrings===!1);this.decodeStrings=!i,this.defaultEncoding=t&&t.defaultEncoding||\"utf8\",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=U_.bind(void 0,e),this.writecb=null,this.writelen=0,this.afterWriteTickInfo=null,pn(this),this.pendingcb=0,this.constructed=!0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!t||t.emitClose!==!1,this.autoDestroy=!t||t.autoDestroy!==!1,this.errored=null,this.closed=!1,this.closeEmitted=!1,this[jr]=[]}function pn(t){t.buffered=[],t.bufferedIndex=0,t.allBuffers=!0,t.allNoop=!0}gi.prototype.getBuffer=function(){return rh(this.buffered,this.bufferedIndex)};nh(gi.prototype,\"bufferedRequestCount\",{__proto__:null,get(){return this.buffered.length-this.bufferedIndex}});function ie(t){let e=this instanceof nt();if(!e&&!ih(ie,this))return new ie(t);this._writableState=new gi(t,this,e),t&&(typeof t.write==\"function\"&&(this._write=t.write),typeof t.writev==\"function\"&&(this._writev=t.writev),typeof t.destroy==\"function\"&&(this._destroy=t.destroy),typeof t.final==\"function\"&&(this._final=t.final),typeof t.construct==\"function\"&&(this._construct=t.construct),t.signal&&T_(t.signal,this)),di.call(this,t),gn.construct(this,()=>{let r=this._writableState;r.writing||ao(this,r),lo(this,r)})}nh(ie,A_,{__proto__:null,value:function(t){return ih(this,t)?!0:this!==ie?!1:t&&t._writableState instanceof gi}});ie.prototype.pipe=function(){Dr(this,new O_)};function lh(t,e,r,i){let n=t._writableState;if(typeof r==\"function\")i=r,r=n.defaultEncoding;else{if(!r)r=n.defaultEncoding;else if(r!==\"buffer\"&&!hn.isEncoding(r))throw new ah(r);typeof i!=\"function\"&&(i=so)}if(e===null)throw new x_;if(!n.objectMode)if(typeof e==\"string\")n.decodeStrings!==!1&&(e=hn.from(e,r),r=\"buffer\");else if(e instanceof hn)r=\"buffer\";else if(di._isUint8Array(e))e=di._uint8ArrayToBuffer(e),r=\"buffer\";else throw new B_(\"chunk\",[\"string\",\"Buffer\",\"Uint8Array\"],e);let o;return n.ending?o=new M_:n.destroyed&&(o=new pi(\"write\")),o?(ur.nextTick(i,o),Dr(t,o,!0),o):(n.pendingcb++,L_(t,n,e,r,i))}ie.prototype.write=function(t,e,r){return lh(this,t,e,r)===!0};ie.prototype.cork=function(){this._writableState.corked++};ie.prototype.uncork=function(){let t=this._writableState;t.corked&&(t.corked--,t.writing||ao(this,t))};ie.prototype.setDefaultEncoding=function(e){if(typeof e==\"string\"&&(e=E_(e)),!hn.isEncoding(e))throw new ah(e);return this._writableState.defaultEncoding=e,this};function L_(t,e,r,i,n){let o=e.objectMode?1:r.length;e.length+=o;let s=e.length<e.highWaterMark;return s||(e.needDrain=!0),e.writing||e.corked||e.errored||!e.constructed?(e.buffered.push({chunk:r,encoding:i,callback:n}),e.allBuffers&&i!==\"buffer\"&&(e.allBuffers=!1),e.allNoop&&n!==so&&(e.allNoop=!1)):(e.writelen=o,e.writecb=n,e.writing=!0,e.sync=!0,t._write(r,i,e.onwrite),e.sync=!1),s&&!e.errored&&!e.destroyed}function eh(t,e,r,i,n,o,s){e.writelen=i,e.writecb=s,e.writing=!0,e.sync=!0,e.destroyed?e.onwrite(new pi(\"write\")):r?t._writev(n,e.onwrite):t._write(n,o,e.onwrite),e.sync=!1}function th(t,e,r,i){--e.pendingcb,i(r),oo(e),Dr(t,r)}function U_(t,e){let r=t._writableState,i=r.sync,n=r.writecb;if(typeof n!=\"function\"){Dr(t,new oh);return}r.writing=!1,r.writecb=null,r.length-=r.writelen,r.writelen=0,e?(e.stack,r.errored||(r.errored=e),t._readableState&&!t._readableState.errored&&(t._readableState.errored=e),i?ur.nextTick(th,t,r,e,n):th(t,r,e,n)):(r.buffered.length>r.bufferedIndex&&ao(t,r),i?r.afterWriteTickInfo!==null&&r.afterWriteTickInfo.cb===n?r.afterWriteTickInfo.count++:(r.afterWriteTickInfo={count:1,cb:n,stream:t,state:r},ur.nextTick(N_,r.afterWriteTickInfo)):uh(t,r,1,n))}function N_({stream:t,state:e,count:r,cb:i}){return e.afterWriteTickInfo=null,uh(t,e,r,i)}function uh(t,e,r,i){for(!e.ending&&!t.destroyed&&e.length===0&&e.needDrain&&(e.needDrain=!1,t.emit(\"drain\"));r-- >0;)e.pendingcb--,i();e.destroyed&&oo(e),lo(t,e)}function oo(t){if(t.writing)return;for(let n=t.bufferedIndex;n<t.buffered.length;++n){var e;let{chunk:o,callback:s}=t.buffered[n],a=t.objectMode?1:o.length;t.length-=a,s((e=t.errored)!==null&&e!==void 0?e:new pi(\"write\"))}let r=t[jr].splice(0);for(let n=0;n<r.length;n++){var i;r[n]((i=t.errored)!==null&&i!==void 0?i:new pi(\"end\"))}pn(t)}function ao(t,e){if(e.corked||e.bufferProcessing||e.destroyed||!e.constructed)return;let{buffered:r,bufferedIndex:i,objectMode:n}=e,o=r.length-i;if(!o)return;let s=i;if(e.bufferProcessing=!0,o>1&&t._writev){e.pendingcb-=o-1;let a=e.allNoop?so:c=>{for(let h=s;h<r.length;++h)r[h].callback(c)},u=e.allNoop&&s===0?r:rh(r,s);u.allBuffers=e.allBuffers,eh(t,e,!0,e.length,u,\"\",a),pn(e)}else{do{let{chunk:a,encoding:u,callback:c}=r[s];r[s++]=null;let h=n?1:a.length;eh(t,e,!1,h,a,u,c)}while(s<r.length&&!e.writing);s===r.length?pn(e):s>256?(r.splice(0,s),e.bufferedIndex=0):e.bufferedIndex=s}e.bufferProcessing=!1}ie.prototype._write=function(t,e,r){if(this._writev)this._writev([{chunk:t,encoding:e}],r);else throw new P_(\"_write()\")};ie.prototype._writev=null;ie.prototype.end=function(t,e,r){let i=this._writableState;typeof t==\"function\"?(r=t,t=null,e=null):typeof e==\"function\"&&(r=e,e=null);let n;if(t!=null){let o=lh(this,t,e);o instanceof m_&&(n=o)}return i.corked&&(i.corked=1,this.uncork()),n||(!i.errored&&!i.ending?(i.ending=!0,lo(this,i,!0),i.ended=!0):i.finished?n=new k_(\"end\"):i.destroyed&&(n=new pi(\"end\"))),typeof r==\"function\"&&(n||i.finished?ur.nextTick(r,n):i[jr].push(r)),this};function dn(t){return t.ending&&!t.destroyed&&t.constructed&&t.length===0&&!t.errored&&t.buffered.length===0&&!t.finished&&!t.writing&&!t.errorEmitted&&!t.closeEmitted}function q_(t,e){let r=!1;function i(n){if(r){Dr(t,n??oh());return}if(r=!0,e.pendingcb--,n){let o=e[jr].splice(0);for(let s=0;s<o.length;s++)o[s](n);Dr(t,n,e.sync)}else dn(e)&&(e.prefinished=!0,t.emit(\"prefinish\"),e.pendingcb++,ur.nextTick(no,t,e))}e.sync=!0,e.pendingcb++;try{t._final(i)}catch(n){i(n)}e.sync=!1}function D_(t,e){!e.prefinished&&!e.finalCalled&&(typeof t._final==\"function\"&&!e.destroyed?(e.finalCalled=!0,q_(t,e)):(e.prefinished=!0,t.emit(\"prefinish\")))}function lo(t,e,r){dn(e)&&(D_(t,e),e.pendingcb===0&&(r?(e.pendingcb++,ur.nextTick((i,n)=>{dn(n)?no(i,n):n.pendingcb--},t,e)):dn(e)&&(e.pendingcb++,no(t,e))))}function no(t,e){e.pendingcb--,e.finished=!0;let r=e[jr].splice(0);for(let i=0;i<r.length;i++)r[i]();if(t.emit(\"finish\"),e.autoDestroy){let i=t._readableState;(!i||i.autoDestroy&&(i.endEmitted||i.readable===!1))&&t.destroy()}}v_(ie.prototype,{closed:{__proto__:null,get(){return this._writableState?this._writableState.closed:!1}},destroyed:{__proto__:null,get(){return this._writableState?this._writableState.destroyed:!1},set(t){this._writableState&&(this._writableState.destroyed=t)}},writable:{__proto__:null,get(){let t=this._writableState;return!!t&&t.writable!==!1&&!t.destroyed&&!t.errored&&!t.ending&&!t.ended},set(t){this._writableState&&(this._writableState.writable=!!t)}},writableFinished:{__proto__:null,get(){return this._writableState?this._writableState.finished:!1}},writableObjectMode:{__proto__:null,get(){return this._writableState?this._writableState.objectMode:!1}},writableBuffer:{__proto__:null,get(){return this._writableState&&this._writableState.getBuffer()}},writableEnded:{__proto__:null,get(){return this._writableState?this._writableState.ending:!1}},writableNeedDrain:{__proto__:null,get(){let t=this._writableState;return t?!t.destroyed&&!t.ending&&t.needDrain:!1}},writableHighWaterMark:{__proto__:null,get(){return this._writableState&&this._writableState.highWaterMark}},writableCorked:{__proto__:null,get(){return this._writableState?this._writableState.corked:0}},writableLength:{__proto__:null,get(){return this._writableState&&this._writableState.length}},errored:{__proto__:null,enumerable:!1,get(){return this._writableState?this._writableState.errored:null}},writableAborted:{__proto__:null,enumerable:!1,get:function(){return!!(this._writableState.writable!==!1&&(this._writableState.destroyed||this._writableState.errored)&&!this._writableState.finished)}}});var j_=gn.destroy;ie.prototype.destroy=function(t,e){let r=this._writableState;return!r.destroyed&&(r.bufferedIndex<r.buffered.length||r[jr].length)&&ur.nextTick(oo,r),j_.call(this,t,e),this};ie.prototype._undestroy=gn.undestroy;ie.prototype._destroy=function(t,e){e(t)};ie.prototype[I_.captureRejectionSymbol]=function(t){this.destroy(t)};var io;function fh(){return io===void 0&&(io={}),io}ie.fromWeb=function(t,e){return fh().newStreamWritableFromWritableStream(t,e)};ie.toWeb=function(t){return fh().newWritableStreamFromStreamWritable(t)}});var Sh=M((pR,Eh)=>{v();m();_();var fo=Ut(),F_=(we(),Z(ve)),{isReadable:W_,isWritable:$_,isIterable:hh,isNodeStream:H_,isReadableNodeStream:dh,isWritableNodeStream:ph,isDuplexNodeStream:V_}=tt(),gh=mt(),{AbortError:vh,codes:{ERR_INVALID_ARG_TYPE:z_,ERR_INVALID_RETURN_VALUE:yh}}=Se(),{destroyer:Fr}=tr(),K_=nt(),G_=hi(),{createDeferredPromise:bh}=Je(),wh=Ys(),_h=globalThis.Blob||F_.Blob,Q_=typeof _h<\"u\"?function(e){return e instanceof _h}:function(e){return!1},Y_=globalThis.AbortController||Hi().AbortController,{FunctionPrototypeCall:mh}=ce(),fr=class extends K_{constructor(e){super(e),e?.readable===!1&&(this._readableState.readable=!1,this._readableState.ended=!0,this._readableState.endEmitted=!0),e?.writable===!1&&(this._writableState.writable=!1,this._writableState.ending=!0,this._writableState.ended=!0,this._writableState.finished=!0)}};Eh.exports=function t(e,r){if(V_(e))return e;if(dh(e))return yn({readable:e});if(ph(e))return yn({writable:e});if(H_(e))return yn({writable:!1,readable:!1});if(typeof e==\"function\"){let{value:n,write:o,final:s,destroy:a}=J_(e);if(hh(n))return wh(fr,n,{objectMode:!0,write:o,final:s,destroy:a});let u=n?.then;if(typeof u==\"function\"){let c,h=mh(u,n,d=>{if(d!=null)throw new yh(\"nully\",\"body\",d)},d=>{Fr(c,d)});return c=new fr({objectMode:!0,readable:!1,write:o,final(d){s(async()=>{try{await h,fo.nextTick(d,null)}catch(g){fo.nextTick(d,g)}})},destroy:a})}throw new yh(\"Iterable, AsyncIterable or AsyncFunction\",r,n)}if(Q_(e))return t(e.arrayBuffer());if(hh(e))return wh(fr,e,{objectMode:!0,writable:!1});if(typeof e?.writable==\"object\"||typeof e?.readable==\"object\"){let n=e!=null&&e.readable?dh(e?.readable)?e?.readable:t(e.readable):void 0,o=e!=null&&e.writable?ph(e?.writable)?e?.writable:t(e.writable):void 0;return yn({readable:n,writable:o})}let i=e?.then;if(typeof i==\"function\"){let n;return mh(i,e,o=>{o!=null&&n.push(o),n.push(null)},o=>{Fr(n,o)}),n=new fr({objectMode:!0,writable:!1,read(){}})}throw new z_(r,[\"Blob\",\"ReadableStream\",\"WritableStream\",\"Stream\",\"Iterable\",\"AsyncIterable\",\"Function\",\"{ readable, writable } pair\",\"Promise\"],e)};function J_(t){let{promise:e,resolve:r}=bh(),i=new Y_,n=i.signal;return{value:t(async function*(){for(;;){let s=e;e=null;let{chunk:a,done:u,cb:c}=await s;if(fo.nextTick(c),u)return;if(n.aborted)throw new vh(void 0,{cause:n.reason});({promise:e,resolve:r}=bh()),yield a}}(),{signal:n}),write(s,a,u){let c=r;r=null,c({chunk:s,done:!1,cb:u})},final(s){let a=r;r=null,a({done:!0,cb:s})},destroy(s,a){i.abort(),a(s)}}}function yn(t){let e=t.readable&&typeof t.readable.read!=\"function\"?G_.wrap(t.readable):t.readable,r=t.writable,i=!!W_(e),n=!!$_(r),o,s,a,u,c;function h(d){let g=u;u=null,g?g(d):d&&c.destroy(d)}return c=new fr({readableObjectMode:!!(e!=null&&e.readableObjectMode),writableObjectMode:!!(r!=null&&r.writableObjectMode),readable:i,writable:n}),n&&(gh(r,d=>{n=!1,d&&Fr(e,d),h(d)}),c._write=function(d,g,y){r.write(d,g)?y():o=y},c._final=function(d){r.end(),s=d},r.on(\"drain\",function(){if(o){let d=o;o=null,d()}}),r.on(\"finish\",function(){if(s){let d=s;s=null,d()}})),i&&(gh(e,d=>{i=!1,d&&Fr(e,d),h(d)}),e.on(\"readable\",function(){if(a){let d=a;a=null,d()}}),e.on(\"end\",function(){c.push(null)}),c._read=function(){for(;;){let d=e.read();if(d===null){a=c._read;return}if(!c.push(d))return}}),c._destroy=function(d,g){!d&&u!==null&&(d=new vh),a=null,o=null,s=null,u===null?g(d):(u=g,Fr(r,d),Fr(e,d))},c}});var nt=M((AR,Th)=>{\"use strict\";v();m();_();var{ObjectDefineProperties:X_,ObjectGetOwnPropertyDescriptor:At,ObjectKeys:Z_,ObjectSetPrototypeOf:Ah}=ce();Th.exports=Ve;var po=hi(),Ne=uo();Ah(Ve.prototype,po.prototype);Ah(Ve,po);{let t=Z_(Ne.prototype);for(let e=0;e<t.length;e++){let r=t[e];Ve.prototype[r]||(Ve.prototype[r]=Ne.prototype[r])}}function Ve(t){if(!(this instanceof Ve))return new Ve(t);po.call(this,t),Ne.call(this,t),t?(this.allowHalfOpen=t.allowHalfOpen!==!1,t.readable===!1&&(this._readableState.readable=!1,this._readableState.ended=!0,this._readableState.endEmitted=!0),t.writable===!1&&(this._writableState.writable=!1,this._writableState.ending=!0,this._writableState.ended=!0,this._writableState.finished=!0)):this.allowHalfOpen=!0}X_(Ve.prototype,{writable:{__proto__:null,...At(Ne.prototype,\"writable\")},writableHighWaterMark:{__proto__:null,...At(Ne.prototype,\"writableHighWaterMark\")},writableObjectMode:{__proto__:null,...At(Ne.prototype,\"writableObjectMode\")},writableBuffer:{__proto__:null,...At(Ne.prototype,\"writableBuffer\")},writableLength:{__proto__:null,...At(Ne.prototype,\"writableLength\")},writableFinished:{__proto__:null,...At(Ne.prototype,\"writableFinished\")},writableCorked:{__proto__:null,...At(Ne.prototype,\"writableCorked\")},writableEnded:{__proto__:null,...At(Ne.prototype,\"writableEnded\")},writableNeedDrain:{__proto__:null,...At(Ne.prototype,\"writableNeedDrain\")},destroyed:{__proto__:null,get(){return this._readableState===void 0||this._writableState===void 0?!1:this._readableState.destroyed&&this._writableState.destroyed},set(t){this._readableState&&this._writableState&&(this._readableState.destroyed=t,this._writableState.destroyed=t)}}});var co;function Ih(){return co===void 0&&(co={}),co}Ve.fromWeb=function(t,e){return Ih().newStreamDuplexFromReadableWritablePair(t,e)};Ve.toWeb=function(t){return Ih().newReadableWritablePairFromDuplex(t)};var ho;Ve.from=function(t){return ho||(ho=Sh()),ho(t,\"body\")}});var bo=M((MR,Ch)=>{\"use strict\";v();m();_();var{ObjectSetPrototypeOf:Rh,Symbol:e0}=ce();Ch.exports=It;var{ERR_METHOD_NOT_IMPLEMENTED:t0}=Se().codes,yo=nt(),{getHighWaterMark:r0}=sn();Rh(It.prototype,yo.prototype);Rh(It,yo);var yi=e0(\"kCallback\");function It(t){if(!(this instanceof It))return new It(t);let e=t?r0(this,t,\"readableHighWaterMark\",!0):null;e===0&&(t={...t,highWaterMark:null,readableHighWaterMark:e,writableHighWaterMark:t.writableHighWaterMark||0}),yo.call(this,t),this._readableState.sync=!1,this[yi]=null,t&&(typeof t.transform==\"function\"&&(this._transform=t.transform),typeof t.flush==\"function\"&&(this._flush=t.flush)),this.on(\"prefinish\",i0)}function go(t){typeof this._flush==\"function\"&&!this.destroyed?this._flush((e,r)=>{if(e){t?t(e):this.destroy(e);return}r!=null&&this.push(r),this.push(null),t&&t()}):(this.push(null),t&&t())}function i0(){this._final!==go&&go.call(this)}It.prototype._final=go;It.prototype._transform=function(t,e,r){throw new t0(\"_transform()\")};It.prototype._write=function(t,e,r){let i=this._readableState,n=this._writableState,o=i.length;this._transform(t,e,(s,a)=>{if(s){r(s);return}a!=null&&this.push(a),n.ended||o===i.length||i.length<i.highWaterMark?r():this[yi]=r})};It.prototype._read=function(){if(this[yi]){let t=this[yi];this[yi]=null,t()}}});var _o=M((HR,Ph)=>{\"use strict\";v();m();_();var{ObjectSetPrototypeOf:Bh}=ce();Ph.exports=Wr;var wo=bo();Bh(Wr.prototype,wo.prototype);Bh(Wr,wo);function Wr(t){if(!(this instanceof Wr))return new Wr(t);wo.call(this,t)}Wr.prototype._transform=function(t,e,r){r(null,t)}});var mn=M((eC,Lh)=>{v();m();_();var bi=Ut(),{ArrayIsArray:n0,Promise:s0,SymbolAsyncIterator:o0}=ce(),_n=mt(),{once:a0}=Je(),l0=tr(),Oh=nt(),{aggregateTwoErrors:u0,codes:{ERR_INVALID_ARG_TYPE:Ro,ERR_INVALID_RETURN_VALUE:mo,ERR_MISSING_ARGS:f0,ERR_STREAM_DESTROYED:c0,ERR_STREAM_PREMATURE_CLOSE:h0},AbortError:d0}=Se(),{validateFunction:p0,validateAbortSignal:g0}=ui(),{isIterable:cr,isReadable:vo,isReadableNodeStream:wn,isNodeStream:kh,isTransformStream:$r,isWebStream:y0,isReadableStream:Eo,isReadableEnded:b0}=tt(),w0=globalThis.AbortController||Hi().AbortController,So,Ao;function xh(t,e,r){let i=!1;t.on(\"close\",()=>{i=!0});let n=_n(t,{readable:e,writable:r},o=>{i=!o});return{destroy:o=>{i||(i=!0,l0.destroyer(t,o||new c0(\"pipe\")))},cleanup:n}}function _0(t){return p0(t[t.length-1],\"streams[stream.length - 1]\"),t.pop()}function Io(t){if(cr(t))return t;if(wn(t))return m0(t);throw new Ro(\"val\",[\"Readable\",\"Iterable\",\"AsyncIterable\"],t)}async function*m0(t){Ao||(Ao=hi()),yield*Ao.prototype[o0].call(t)}async function bn(t,e,r,{end:i}){let n,o=null,s=c=>{if(c&&(n=c),o){let h=o;o=null,h()}},a=()=>new s0((c,h)=>{n?h(n):o=()=>{n?h(n):c()}});e.on(\"drain\",s);let u=_n(e,{readable:!1},s);try{e.writableNeedDrain&&await a();for await(let c of t)e.write(c)||await a();i&&e.end(),await a(),r()}catch(c){r(n!==c?u0(n,c):c)}finally{u(),e.off(\"drain\",s)}}async function To(t,e,r,{end:i}){$r(e)&&(e=e.writable);let n=e.getWriter();try{for await(let o of t)await n.ready,n.write(o).catch(()=>{});await n.ready,i&&await n.close(),r()}catch(o){try{await n.abort(o),r(o)}catch(s){r(s)}}}function v0(...t){return Mh(t,a0(_0(t)))}function Mh(t,e,r){if(t.length===1&&n0(t[0])&&(t=t[0]),t.length<2)throw new f0(\"streams\");let i=new w0,n=i.signal,o=r?.signal,s=[];g0(o,\"options.signal\");function a(){y(new d0)}o?.addEventListener(\"abort\",a);let u,c,h=[],d=0;function g(C){y(C,--d===0)}function y(C,R){if(C&&(!u||u.code===\"ERR_STREAM_PREMATURE_CLOSE\")&&(u=C),!(!u&&!R)){for(;h.length;)h.shift()(u);o?.removeEventListener(\"abort\",a),i.abort(),R&&(u||s.forEach(U=>U()),bi.nextTick(e,u,c))}}let w;for(let C=0;C<t.length;C++){let R=t[C],U=C<t.length-1,N=C>0,W=U||r?.end!==!1,K=C===t.length-1;if(kh(R)){let z=function(Q){Q&&Q.name!==\"AbortError\"&&Q.code!==\"ERR_STREAM_PREMATURE_CLOSE\"&&g(Q)};var I=z;if(W){let{destroy:Q,cleanup:de}=xh(R,U,N);h.push(Q),vo(R)&&K&&s.push(de)}R.on(\"error\",z),vo(R)&&K&&s.push(()=>{R.removeListener(\"error\",z)})}if(C===0)if(typeof R==\"function\"){if(w=R({signal:n}),!cr(w))throw new mo(\"Iterable, AsyncIterable or Stream\",\"source\",w)}else cr(R)||wn(R)||$r(R)?w=R:w=Oh.from(R);else if(typeof R==\"function\"){if($r(w)){var E;w=Io((E=w)===null||E===void 0?void 0:E.readable)}else w=Io(w);if(w=R(w,{signal:n}),U){if(!cr(w,!0))throw new mo(\"AsyncIterable\",`transform[${C-1}]`,w)}else{var S;So||(So=_o());let z=new So({objectMode:!0}),Q=(S=w)===null||S===void 0?void 0:S.then;if(typeof Q==\"function\")d++,Q.call(w,pe=>{c=pe,pe!=null&&z.write(pe),W&&z.end(),bi.nextTick(g)},pe=>{z.destroy(pe),bi.nextTick(g,pe)});else if(cr(w,!0))d++,bn(w,z,g,{end:W});else if(Eo(w)||$r(w)){let pe=w.readable||w;d++,bn(pe,z,g,{end:W})}else throw new mo(\"AsyncIterable or Promise\",\"destination\",w);w=z;let{destroy:de,cleanup:Gt}=xh(w,!1,!0);h.push(de),K&&s.push(Gt)}}else if(kh(R)){if(wn(w)){d+=2;let z=E0(w,R,g,{end:W});vo(R)&&K&&s.push(z)}else if($r(w)||Eo(w)){let z=w.readable||w;d++,bn(z,R,g,{end:W})}else if(cr(w))d++,bn(w,R,g,{end:W});else throw new Ro(\"val\",[\"Readable\",\"Iterable\",\"AsyncIterable\",\"ReadableStream\",\"TransformStream\"],w);w=R}else if(y0(R)){if(wn(w))d++,To(Io(w),R,g,{end:W});else if(Eo(w)||cr(w))d++,To(w,R,g,{end:W});else if($r(w))d++,To(w.readable,R,g,{end:W});else throw new Ro(\"val\",[\"Readable\",\"Iterable\",\"AsyncIterable\",\"ReadableStream\",\"TransformStream\"],w);w=R}else w=Oh.from(R)}return(n!=null&&n.aborted||o!=null&&o.aborted)&&bi.nextTick(a),w}function E0(t,e,r,{end:i}){let n=!1;if(e.on(\"close\",()=>{n||r(new h0)}),t.pipe(e,{end:!1}),i){let s=function(){n=!0,e.end()};var o=s;b0(t)?bi.nextTick(s):t.once(\"end\",s)}else r();return _n(t,{readable:!0,writable:!1},s=>{let a=t._readableState;s&&s.code===\"ERR_STREAM_PREMATURE_CLOSE\"&&a&&a.ended&&!a.errored&&!a.errorEmitted?t.once(\"end\",r).once(\"error\",r):r(s)}),_n(e,{readable:!1,writable:!0},r)}Lh.exports={pipelineImpl:Mh,pipeline:v0}});var Bo=M((fC,Fh)=>{\"use strict\";v();m();_();var{pipeline:S0}=mn(),vn=nt(),{destroyer:A0}=tr(),{isNodeStream:En,isReadable:Uh,isWritable:Nh,isWebStream:Co,isTransformStream:hr,isWritableStream:qh,isReadableStream:Dh}=tt(),{AbortError:I0,codes:{ERR_INVALID_ARG_VALUE:jh,ERR_MISSING_ARGS:T0}}=Se(),R0=mt();Fh.exports=function(...e){if(e.length===0)throw new T0(\"streams\");if(e.length===1)return vn.from(e[0]);let r=[...e];if(typeof e[0]==\"function\"&&(e[0]=vn.from(e[0])),typeof e[e.length-1]==\"function\"){let y=e.length-1;e[y]=vn.from(e[y])}for(let y=0;y<e.length;++y)if(!(!En(e[y])&&!Co(e[y]))){if(y<e.length-1&&!(Uh(e[y])||Dh(e[y])||hr(e[y])))throw new jh(`streams[${y}]`,r[y],\"must be readable\");if(y>0&&!(Nh(e[y])||qh(e[y])||hr(e[y])))throw new jh(`streams[${y}]`,r[y],\"must be writable\")}let i,n,o,s,a;function u(y){let w=s;s=null,w?w(y):y?a.destroy(y):!g&&!d&&a.destroy()}let c=e[0],h=S0(e,u),d=!!(Nh(c)||qh(c)||hr(c)),g=!!(Uh(h)||Dh(h)||hr(h));if(a=new vn({writableObjectMode:!!(c!=null&&c.writableObjectMode),readableObjectMode:!!(h!=null&&h.writableObjectMode),writable:d,readable:g}),d){if(En(c))a._write=function(w,E,S){c.write(w,E)?S():i=S},a._final=function(w){c.end(),n=w},c.on(\"drain\",function(){if(i){let w=i;i=null,w()}});else if(Co(c)){let E=(hr(c)?c.writable:c).getWriter();a._write=async function(S,I,C){try{await E.ready,E.write(S).catch(()=>{}),C()}catch(R){C(R)}},a._final=async function(S){try{await E.ready,E.close().catch(()=>{}),n=S}catch(I){S(I)}}}let y=hr(h)?h.readable:h;R0(y,()=>{if(n){let w=n;n=null,w()}})}if(g){if(En(h))h.on(\"readable\",function(){if(o){let y=o;o=null,y()}}),h.on(\"end\",function(){a.push(null)}),a._read=function(){for(;;){let y=h.read();if(y===null){o=a._read;return}if(!a.push(y))return}};else if(Co(h)){let w=(hr(h)?h.readable:h).getReader();a._read=async function(){for(;;)try{let{value:E,done:S}=await w.read();if(!a.push(E))return;if(S){a.push(null);return}}catch{return}}}}return a._destroy=function(y,w){!y&&s!==null&&(y=new I0),o=null,i=null,n=null,s===null?w(y):(s=w,En(h)&&A0(h,y))},a}});var Qh=M((mC,ko)=>{\"use strict\";v();m();_();var Vh=globalThis.AbortController||Hi().AbortController,{codes:{ERR_INVALID_ARG_VALUE:C0,ERR_INVALID_ARG_TYPE:wi,ERR_MISSING_ARGS:B0,ERR_OUT_OF_RANGE:P0},AbortError:st}=Se(),{validateAbortSignal:dr,validateInteger:O0,validateObject:pr}=ui(),k0=ce().Symbol(\"kWeak\"),{finished:x0}=mt(),M0=Bo(),{addAbortSignalNoValidate:L0}=fi(),{isWritable:U0,isNodeStream:N0}=tt(),{ArrayPrototypePush:q0,MathFloor:D0,Number:j0,NumberIsNaN:F0,Promise:Wh,PromiseReject:$h,PromisePrototypeThen:W0,Symbol:zh}=ce(),Sn=zh(\"kEmpty\"),Hh=zh(\"kEof\");function $0(t,e){if(e!=null&&pr(e,\"options\"),e?.signal!=null&&dr(e.signal,\"options.signal\"),N0(t)&&!U0(t))throw new C0(\"stream\",t,\"must be writable\");let r=M0(this,t);return e!=null&&e.signal&&L0(e.signal,r),r}function An(t,e){if(typeof t!=\"function\")throw new wi(\"fn\",[\"Function\",\"AsyncFunction\"],t);e!=null&&pr(e,\"options\"),e?.signal!=null&&dr(e.signal,\"options.signal\");let r=1;return e?.concurrency!=null&&(r=D0(e.concurrency)),O0(r,\"concurrency\",1),async function*(){var n,o;let s=new Vh,a=this,u=[],c=s.signal,h={signal:c},d=()=>s.abort();e!=null&&(n=e.signal)!==null&&n!==void 0&&n.aborted&&d(),e==null||(o=e.signal)===null||o===void 0||o.addEventListener(\"abort\",d);let g,y,w=!1;function E(){w=!0}async function S(){try{for await(let R of a){var I;if(w)return;if(c.aborted)throw new st;try{R=t(R,h)}catch(U){R=$h(U)}R!==Sn&&(typeof((I=R)===null||I===void 0?void 0:I.catch)==\"function\"&&R.catch(E),u.push(R),g&&(g(),g=null),!w&&u.length&&u.length>=r&&await new Wh(U=>{y=U}))}u.push(Hh)}catch(R){let U=$h(R);W0(U,void 0,E),u.push(U)}finally{var C;w=!0,g&&(g(),g=null),e==null||(C=e.signal)===null||C===void 0||C.removeEventListener(\"abort\",d)}}S();try{for(;;){for(;u.length>0;){let I=await u[0];if(I===Hh)return;if(c.aborted)throw new st;I!==Sn&&(yield I),u.shift(),y&&(y(),y=null)}await new Wh(I=>{g=I})}}finally{s.abort(),w=!0,y&&(y(),y=null)}}.call(this)}function H0(t=void 0){return t!=null&&pr(t,\"options\"),t?.signal!=null&&dr(t.signal,\"options.signal\"),async function*(){let r=0;for await(let n of this){var i;if(t!=null&&(i=t.signal)!==null&&i!==void 0&&i.aborted)throw new st({cause:t.signal.reason});yield[r++,n]}}.call(this)}async function Kh(t,e=void 0){for await(let r of Oo.call(this,t,e))return!0;return!1}async function V0(t,e=void 0){if(typeof t!=\"function\")throw new wi(\"fn\",[\"Function\",\"AsyncFunction\"],t);return!await Kh.call(this,async(...r)=>!await t(...r),e)}async function z0(t,e){for await(let r of Oo.call(this,t,e))return r}async function K0(t,e){if(typeof t!=\"function\")throw new wi(\"fn\",[\"Function\",\"AsyncFunction\"],t);async function r(i,n){return await t(i,n),Sn}for await(let i of An.call(this,r,e));}function Oo(t,e){if(typeof t!=\"function\")throw new wi(\"fn\",[\"Function\",\"AsyncFunction\"],t);async function r(i,n){return await t(i,n)?i:Sn}return An.call(this,r,e)}var Po=class extends B0{constructor(){super(\"reduce\"),this.message=\"Reduce of an empty stream requires an initial value\"}};async function G0(t,e,r){var i;if(typeof t!=\"function\")throw new wi(\"reducer\",[\"Function\",\"AsyncFunction\"],t);r!=null&&pr(r,\"options\"),r?.signal!=null&&dr(r.signal,\"options.signal\");let n=arguments.length>1;if(r!=null&&(i=r.signal)!==null&&i!==void 0&&i.aborted){let c=new st(void 0,{cause:r.signal.reason});throw this.once(\"error\",()=>{}),await x0(this.destroy(c)),c}let o=new Vh,s=o.signal;if(r!=null&&r.signal){let c={once:!0,[k0]:this};r.signal.addEventListener(\"abort\",()=>o.abort(),c)}let a=!1;try{for await(let c of this){var u;if(a=!0,r!=null&&(u=r.signal)!==null&&u!==void 0&&u.aborted)throw new st;n?e=await t(e,c,{signal:s}):(e=c,n=!0)}if(!a&&!n)throw new Po}finally{o.abort()}return e}async function Q0(t){t!=null&&pr(t,\"options\"),t?.signal!=null&&dr(t.signal,\"options.signal\");let e=[];for await(let i of this){var r;if(t!=null&&(r=t.signal)!==null&&r!==void 0&&r.aborted)throw new st(void 0,{cause:t.signal.reason});q0(e,i)}return e}function Y0(t,e){let r=An.call(this,t,e);return async function*(){for await(let n of r)yield*n}.call(this)}function Gh(t){if(t=j0(t),F0(t))return 0;if(t<0)throw new P0(\"number\",\">= 0\",t);return t}function J0(t,e=void 0){return e!=null&&pr(e,\"options\"),e?.signal!=null&&dr(e.signal,\"options.signal\"),t=Gh(t),async function*(){var i;if(e!=null&&(i=e.signal)!==null&&i!==void 0&&i.aborted)throw new st;for await(let o of this){var n;if(e!=null&&(n=e.signal)!==null&&n!==void 0&&n.aborted)throw new st;t--<=0&&(yield o)}}.call(this)}function X0(t,e=void 0){return e!=null&&pr(e,\"options\"),e?.signal!=null&&dr(e.signal,\"options.signal\"),t=Gh(t),async function*(){var i;if(e!=null&&(i=e.signal)!==null&&i!==void 0&&i.aborted)throw new st;for await(let o of this){var n;if(e!=null&&(n=e.signal)!==null&&n!==void 0&&n.aborted)throw new st;if(t-- >0)yield o;else return}}.call(this)}ko.exports.streamReturningOperators={asIndexedPairs:H0,drop:J0,filter:Oo,flatMap:Y0,map:An,take:X0,compose:$0};ko.exports.promiseReturningOperators={every:V0,forEach:K0,reduce:G0,toArray:Q0,some:Kh,find:z0}});var xo=M((PC,Yh)=>{\"use strict\";v();m();_();var{ArrayPrototypePop:Z0,Promise:em}=ce(),{isIterable:tm,isNodeStream:rm,isWebStream:im}=tt(),{pipelineImpl:nm}=mn(),{finished:sm}=mt();Mo();function om(...t){return new em((e,r)=>{let i,n,o=t[t.length-1];if(o&&typeof o==\"object\"&&!rm(o)&&!tm(o)&&!im(o)){let s=Z0(t);i=s.signal,n=s.end}nm(t,(s,a)=>{s?r(s):e(a)},{signal:i,end:n})})}Yh.exports={finished:sm,pipeline:om}});var Mo=M((jC,sd)=>{v();m();_();var{Buffer:am}=(we(),Z(ve)),{ObjectDefineProperty:Tt,ObjectKeys:Zh,ReflectApply:ed}=ce(),{promisify:{custom:td}}=Je(),{streamReturningOperators:Jh,promiseReturningOperators:Xh}=Qh(),{codes:{ERR_ILLEGAL_CONSTRUCTOR:rd}}=Se(),lm=Bo(),{pipeline:id}=mn(),{destroyer:um}=tr(),nd=mt(),Lo=xo(),Uo=tt(),le=sd.exports=tn().Stream;le.isDisturbed=Uo.isDisturbed;le.isErrored=Uo.isErrored;le.isReadable=Uo.isReadable;le.Readable=hi();for(let t of Zh(Jh)){let r=function(...i){if(new.target)throw rd();return le.Readable.from(ed(e,this,i))};No=r;let e=Jh[t];Tt(r,\"name\",{__proto__:null,value:e.name}),Tt(r,\"length\",{__proto__:null,value:e.length}),Tt(le.Readable.prototype,t,{__proto__:null,value:r,enumerable:!1,configurable:!0,writable:!0})}var No;for(let t of Zh(Xh)){let r=function(...n){if(new.target)throw rd();return ed(e,this,n)};No=r;let e=Xh[t];Tt(r,\"name\",{__proto__:null,value:e.name}),Tt(r,\"length\",{__proto__:null,value:e.length}),Tt(le.Readable.prototype,t,{__proto__:null,value:r,enumerable:!1,configurable:!0,writable:!0})}var No;le.Writable=uo();le.Duplex=nt();le.Transform=bo();le.PassThrough=_o();le.pipeline=id;var{addAbortSignal:fm}=fi();le.addAbortSignal=fm;le.finished=nd;le.destroy=um;le.compose=lm;Tt(le,\"promises\",{__proto__:null,configurable:!0,enumerable:!0,get(){return Lo}});Tt(id,td,{__proto__:null,enumerable:!0,get(){return Lo.pipeline}});Tt(nd,td,{__proto__:null,enumerable:!0,get(){return Lo.finished}});le.Stream=le;le._isUint8Array=function(e){return e instanceof Uint8Array};le._uint8ArrayToBuffer=function(e){return am.from(e.buffer,e.byteOffset,e.byteLength)}});var Dt=M((YC,ue)=>{\"use strict\";v();m();_();var he=Mo(),cm=xo(),hm=he.Readable.destroy;ue.exports=he.Readable;ue.exports._uint8ArrayToBuffer=he._uint8ArrayToBuffer;ue.exports._isUint8Array=he._isUint8Array;ue.exports.isDisturbed=he.isDisturbed;ue.exports.isErrored=he.isErrored;ue.exports.isReadable=he.isReadable;ue.exports.Readable=he.Readable;ue.exports.Writable=he.Writable;ue.exports.Duplex=he.Duplex;ue.exports.Transform=he.Transform;ue.exports.PassThrough=he.PassThrough;ue.exports.addAbortSignal=he.addAbortSignal;ue.exports.finished=he.finished;ue.exports.destroy=he.destroy;ue.exports.destroy=hm;ue.exports.pipeline=he.pipeline;ue.exports.compose=he.compose;Object.defineProperty(he,\"promises\",{configurable:!0,enumerable:!0,get(){return cm}});ue.exports.Stream=he.Stream;ue.exports.default=ue.exports});var od=M((oB,qo)=>{v();m();_();typeof Object.create==\"function\"?qo.exports=function(e,r){r&&(e.super_=r,e.prototype=Object.create(r.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:qo.exports=function(e,r){if(r){e.super_=r;var i=function(){};i.prototype=r.prototype,e.prototype=new i,e.prototype.constructor=e}}});var ud=M((yB,ld)=>{\"use strict\";v();m();_();var{Buffer:ze}=(we(),Z(ve)),ad=Symbol.for(\"BufferList\");function ee(t){if(!(this instanceof ee))return new ee(t);ee._init.call(this,t)}ee._init=function(e){Object.defineProperty(this,ad,{value:!0}),this._bufs=[],this.length=0,e&&this.append(e)};ee.prototype._new=function(e){return new ee(e)};ee.prototype._offset=function(e){if(e===0)return[0,0];let r=0;for(let i=0;i<this._bufs.length;i++){let n=r+this._bufs[i].length;if(e<n||i===this._bufs.length-1)return[i,e-r];r=n}};ee.prototype._reverseOffset=function(t){let e=t[0],r=t[1];for(let i=0;i<e;i++)r+=this._bufs[i].length;return r};ee.prototype.get=function(e){if(e>this.length||e<0)return;let r=this._offset(e);return this._bufs[r[0]][r[1]]};ee.prototype.slice=function(e,r){return typeof e==\"number\"&&e<0&&(e+=this.length),typeof r==\"number\"&&r<0&&(r+=this.length),this.copy(null,0,e,r)};ee.prototype.copy=function(e,r,i,n){if((typeof i!=\"number\"||i<0)&&(i=0),(typeof n!=\"number\"||n>this.length)&&(n=this.length),i>=this.length||n<=0)return e||ze.alloc(0);let o=!!e,s=this._offset(i),a=n-i,u=a,c=o&&r||0,h=s[1];if(i===0&&n===this.length){if(!o)return this._bufs.length===1?this._bufs[0]:ze.concat(this._bufs,this.length);for(let d=0;d<this._bufs.length;d++)this._bufs[d].copy(e,c),c+=this._bufs[d].length;return e}if(u<=this._bufs[s[0]].length-h)return o?this._bufs[s[0]].copy(e,r,h,h+u):this._bufs[s[0]].slice(h,h+u);o||(e=ze.allocUnsafe(a));for(let d=s[0];d<this._bufs.length;d++){let g=this._bufs[d].length-h;if(u>g)this._bufs[d].copy(e,c,h),c+=g;else{this._bufs[d].copy(e,c,h,h+u),c+=g;break}u-=g,h&&(h=0)}return e.length>c?e.slice(0,c):e};ee.prototype.shallowSlice=function(e,r){if(e=e||0,r=typeof r!=\"number\"?this.length:r,e<0&&(e+=this.length),r<0&&(r+=this.length),e===r)return this._new();let i=this._offset(e),n=this._offset(r),o=this._bufs.slice(i[0],n[0]+1);return n[1]===0?o.pop():o[o.length-1]=o[o.length-1].slice(0,n[1]),i[1]!==0&&(o[0]=o[0].slice(i[1])),this._new(o)};ee.prototype.toString=function(e,r,i){return this.slice(r,i).toString(e)};ee.prototype.consume=function(e){if(e=Math.trunc(e),Number.isNaN(e)||e<=0)return this;for(;this._bufs.length;)if(e>=this._bufs[0].length)e-=this._bufs[0].length,this.length-=this._bufs[0].length,this._bufs.shift();else{this._bufs[0]=this._bufs[0].slice(e),this.length-=e;break}return this};ee.prototype.duplicate=function(){let e=this._new();for(let r=0;r<this._bufs.length;r++)e.append(this._bufs[r]);return e};ee.prototype.append=function(e){if(e==null)return this;if(e.buffer)this._appendBuffer(ze.from(e.buffer,e.byteOffset,e.byteLength));else if(Array.isArray(e))for(let r=0;r<e.length;r++)this.append(e[r]);else if(this._isBufferList(e))for(let r=0;r<e._bufs.length;r++)this.append(e._bufs[r]);else typeof e==\"number\"&&(e=e.toString()),this._appendBuffer(ze.from(e));return this};ee.prototype._appendBuffer=function(e){this._bufs.push(e),this.length+=e.length};ee.prototype.indexOf=function(t,e,r){if(r===void 0&&typeof e==\"string\"&&(r=e,e=void 0),typeof t==\"function\"||Array.isArray(t))throw new TypeError('The \"value\" argument must be one of type string, Buffer, BufferList, or Uint8Array.');if(typeof t==\"number\"?t=ze.from([t]):typeof t==\"string\"?t=ze.from(t,r):this._isBufferList(t)?t=t.slice():Array.isArray(t.buffer)?t=ze.from(t.buffer,t.byteOffset,t.byteLength):ze.isBuffer(t)||(t=ze.from(t)),e=Number(e||0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;let i=this._offset(e),n=i[0],o=i[1];for(;n<this._bufs.length;n++){let s=this._bufs[n];for(;o<s.length;)if(s.length-o>=t.length){let u=s.indexOf(t,o);if(u!==-1)return this._reverseOffset([n,u]);o=s.length-t.length+1}else{let u=this._reverseOffset([n,o]);if(this._match(u,t))return u;o++}o=0}return-1};ee.prototype._match=function(t,e){if(this.length-t<e.length)return!1;for(let r=0;r<e.length;r++)if(this.get(t+r)!==e[r])return!1;return!0};(function(){let t={readDoubleBE:8,readDoubleLE:8,readFloatBE:4,readFloatLE:4,readBigInt64BE:8,readBigInt64LE:8,readBigUInt64BE:8,readBigUInt64LE:8,readInt32BE:4,readInt32LE:4,readUInt32BE:4,readUInt32LE:4,readInt16BE:2,readInt16LE:2,readUInt16BE:2,readUInt16LE:2,readInt8:1,readUInt8:1,readIntBE:null,readIntLE:null,readUIntBE:null,readUIntLE:null};for(let e in t)(function(r){t[r]===null?ee.prototype[r]=function(i,n){return this.slice(i,i+n)[r](0,n)}:ee.prototype[r]=function(i=0){return this.slice(i,i+t[r])[r](0)}})(e)})();ee.prototype._isBufferList=function(e){return e instanceof ee||ee.isBufferList(e)};ee.isBufferList=function(e){return e!=null&&e[ad]};ld.exports=ee});var fd=M((TB,In)=>{\"use strict\";v();m();_();var Do=Dt().Duplex,dm=od(),_i=ud();function Ee(t){if(!(this instanceof Ee))return new Ee(t);if(typeof t==\"function\"){this._callback=t;let e=function(i){this._callback&&(this._callback(i),this._callback=null)}.bind(this);this.on(\"pipe\",function(i){i.on(\"error\",e)}),this.on(\"unpipe\",function(i){i.removeListener(\"error\",e)}),t=null}_i._init.call(this,t),Do.call(this)}dm(Ee,Do);Object.assign(Ee.prototype,_i.prototype);Ee.prototype._new=function(e){return new Ee(e)};Ee.prototype._write=function(e,r,i){this._appendBuffer(e),typeof i==\"function\"&&i()};Ee.prototype._read=function(e){if(!this.length)return this.push(null);e=Math.min(e,this.length),this.push(this.slice(0,e)),this.consume(e)};Ee.prototype.end=function(e){Do.prototype.end.call(this,e),this._callback&&(this._callback(null,this.slice()),this._callback=null)};Ee.prototype._destroy=function(e,r){this._bufs.length=0,this.length=0,r(e)};Ee.prototype._isBufferList=function(e){return e instanceof Ee||e instanceof _i||Ee.isBufferList(e)};Ee.isBufferList=_i.isBufferList;In.exports=Ee;In.exports.BufferListStream=Ee;In.exports.BufferList=_i});var hd=M((UB,cd)=>{v();m();_();var jo=class{constructor(){this.cmd=null,this.retain=!1,this.qos=0,this.dup=!1,this.length=-1,this.topic=null,this.payload=null}};cd.exports=jo});var Fo=M((zB,dd)=>{v();m();_();var L=dd.exports,{Buffer:Oe}=(we(),Z(ve));L.types={0:\"reserved\",1:\"connect\",2:\"connack\",3:\"publish\",4:\"puback\",5:\"pubrec\",6:\"pubrel\",7:\"pubcomp\",8:\"subscribe\",9:\"suback\",10:\"unsubscribe\",11:\"unsuback\",12:\"pingreq\",13:\"pingresp\",14:\"disconnect\",15:\"auth\"};L.requiredHeaderFlags={1:0,2:0,4:0,5:0,6:2,7:0,8:2,9:0,10:2,11:0,12:0,13:0,14:0,15:0};L.requiredHeaderFlagsErrors={};for(let t in L.requiredHeaderFlags){let e=L.requiredHeaderFlags[t];L.requiredHeaderFlagsErrors[t]=\"Invalid header flag bits, must be 0x\"+e.toString(16)+\" for \"+L.types[t]+\" packet\"}L.codes={};for(let t in L.types){let e=L.types[t];L.codes[e]=t}L.CMD_SHIFT=4;L.CMD_MASK=240;L.DUP_MASK=8;L.QOS_MASK=3;L.QOS_SHIFT=1;L.RETAIN_MASK=1;L.VARBYTEINT_MASK=127;L.VARBYTEINT_FIN_MASK=128;L.VARBYTEINT_MAX=268435455;L.SESSIONPRESENT_MASK=1;L.SESSIONPRESENT_HEADER=Oe.from([L.SESSIONPRESENT_MASK]);L.CONNACK_HEADER=Oe.from([L.codes.connack<<L.CMD_SHIFT]);L.USERNAME_MASK=128;L.PASSWORD_MASK=64;L.WILL_RETAIN_MASK=32;L.WILL_QOS_MASK=24;L.WILL_QOS_SHIFT=3;L.WILL_FLAG_MASK=4;L.CLEAN_SESSION_MASK=2;L.CONNECT_HEADER=Oe.from([L.codes.connect<<L.CMD_SHIFT]);L.properties={sessionExpiryInterval:17,willDelayInterval:24,receiveMaximum:33,maximumPacketSize:39,topicAliasMaximum:34,requestResponseInformation:25,requestProblemInformation:23,userProperties:38,authenticationMethod:21,authenticationData:22,payloadFormatIndicator:1,messageExpiryInterval:2,contentType:3,responseTopic:8,correlationData:9,maximumQoS:36,retainAvailable:37,assignedClientIdentifier:18,reasonString:31,wildcardSubscriptionAvailable:40,subscriptionIdentifiersAvailable:41,sharedSubscriptionAvailable:42,serverKeepAlive:19,responseInformation:26,serverReference:28,topicAlias:35,subscriptionIdentifier:11};L.propertiesCodes={};for(let t in L.properties){let e=L.properties[t];L.propertiesCodes[e]=t}L.propertiesTypes={sessionExpiryInterval:\"int32\",willDelayInterval:\"int32\",receiveMaximum:\"int16\",maximumPacketSize:\"int32\",topicAliasMaximum:\"int16\",requestResponseInformation:\"byte\",requestProblemInformation:\"byte\",userProperties:\"pair\",authenticationMethod:\"string\",authenticationData:\"binary\",payloadFormatIndicator:\"byte\",messageExpiryInterval:\"int32\",contentType:\"string\",responseTopic:\"string\",correlationData:\"binary\",maximumQoS:\"int8\",retainAvailable:\"byte\",assignedClientIdentifier:\"string\",reasonString:\"string\",wildcardSubscriptionAvailable:\"byte\",subscriptionIdentifiersAvailable:\"byte\",sharedSubscriptionAvailable:\"byte\",serverKeepAlive:\"int16\",responseInformation:\"string\",serverReference:\"string\",topicAlias:\"int16\",subscriptionIdentifier:\"var\"};function jt(t){return[0,1,2].map(e=>[0,1].map(r=>[0,1].map(i=>{let n=Oe.alloc(1);return n.writeUInt8(L.codes[t]<<L.CMD_SHIFT|(r?L.DUP_MASK:0)|e<<L.QOS_SHIFT|i,0,!0),n})))}L.PUBLISH_HEADER=jt(\"publish\");L.SUBSCRIBE_HEADER=jt(\"subscribe\");L.SUBSCRIBE_OPTIONS_QOS_MASK=3;L.SUBSCRIBE_OPTIONS_NL_MASK=1;L.SUBSCRIBE_OPTIONS_NL_SHIFT=2;L.SUBSCRIBE_OPTIONS_RAP_MASK=1;L.SUBSCRIBE_OPTIONS_RAP_SHIFT=3;L.SUBSCRIBE_OPTIONS_RH_MASK=3;L.SUBSCRIBE_OPTIONS_RH_SHIFT=4;L.SUBSCRIBE_OPTIONS_RH=[0,16,32];L.SUBSCRIBE_OPTIONS_NL=4;L.SUBSCRIBE_OPTIONS_RAP=8;L.SUBSCRIBE_OPTIONS_QOS=[0,1,2];L.UNSUBSCRIBE_HEADER=jt(\"unsubscribe\");L.ACKS={unsuback:jt(\"unsuback\"),puback:jt(\"puback\"),pubcomp:jt(\"pubcomp\"),pubrel:jt(\"pubrel\"),pubrec:jt(\"pubrec\")};L.SUBACK_HEADER=Oe.from([L.codes.suback<<L.CMD_SHIFT]);L.VERSION3=Oe.from([3]);L.VERSION4=Oe.from([4]);L.VERSION5=Oe.from([5]);L.VERSION131=Oe.from([131]);L.VERSION132=Oe.from([132]);L.QOS=[0,1,2].map(t=>Oe.from([t]));L.EMPTY={pingreq:Oe.from([L.codes.pingreq<<4,0]),pingresp:Oe.from([L.codes.pingresp<<4,0]),disconnect:Oe.from([L.codes.disconnect<<4,0])};L.MQTT5_PUBACK_PUBREC_CODES={0:\"Success\",16:\"No matching subscribers\",128:\"Unspecified error\",131:\"Implementation specific error\",135:\"Not authorized\",144:\"Topic Name invalid\",145:\"Packet identifier in use\",151:\"Quota exceeded\",153:\"Payload format invalid\"};L.MQTT5_PUBREL_PUBCOMP_CODES={0:\"Success\",146:\"Packet Identifier not found\"};L.MQTT5_SUBACK_CODES={0:\"Granted QoS 0\",1:\"Granted QoS 1\",2:\"Granted QoS 2\",128:\"Unspecified error\",131:\"Implementation specific error\",135:\"Not authorized\",143:\"Topic Filter invalid\",145:\"Packet Identifier in use\",151:\"Quota exceeded\",158:\"Shared Subscriptions not supported\",161:\"Subscription Identifiers not supported\",162:\"Wildcard Subscriptions not supported\"};L.MQTT5_UNSUBACK_CODES={0:\"Success\",17:\"No subscription existed\",128:\"Unspecified error\",131:\"Implementation specific error\",135:\"Not authorized\",143:\"Topic Filter invalid\",145:\"Packet Identifier in use\"};L.MQTT5_DISCONNECT_CODES={0:\"Normal disconnection\",4:\"Disconnect with Will Message\",128:\"Unspecified error\",129:\"Malformed Packet\",130:\"Protocol Error\",131:\"Implementation specific error\",135:\"Not authorized\",137:\"Server busy\",139:\"Server shutting down\",141:\"Keep Alive timeout\",142:\"Session taken over\",143:\"Topic Filter invalid\",144:\"Topic Name invalid\",147:\"Receive Maximum exceeded\",148:\"Topic Alias invalid\",149:\"Packet too large\",150:\"Message rate too high\",151:\"Quota exceeded\",152:\"Administrative action\",153:\"Payload format invalid\",154:\"Retain not supported\",155:\"QoS not supported\",156:\"Use another server\",157:\"Server moved\",158:\"Shared Subscriptions not supported\",159:\"Connection rate exceeded\",160:\"Maximum connect time\",161:\"Subscription Identifiers not supported\",162:\"Wildcard Subscriptions not supported\"};L.MQTT5_AUTH_CODES={0:\"Success\",24:\"Continue authentication\",25:\"Re-authenticate\"}});var gd=M((rP,pd)=>{v();m();_();var Hr=1e3,Vr=Hr*60,zr=Vr*60,gr=zr*24,pm=gr*7,gm=gr*365.25;pd.exports=function(t,e){e=e||{};var r=typeof t;if(r===\"string\"&&t.length>0)return ym(t);if(r===\"number\"&&isFinite(t))return e.long?wm(t):bm(t);throw new Error(\"val is not a non-empty string or a valid number. val=\"+JSON.stringify(t))};function ym(t){if(t=String(t),!(t.length>100)){var e=/^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);if(e){var r=parseFloat(e[1]),i=(e[2]||\"ms\").toLowerCase();switch(i){case\"years\":case\"year\":case\"yrs\":case\"yr\":case\"y\":return r*gm;case\"weeks\":case\"week\":case\"w\":return r*pm;case\"days\":case\"day\":case\"d\":return r*gr;case\"hours\":case\"hour\":case\"hrs\":case\"hr\":case\"h\":return r*zr;case\"minutes\":case\"minute\":case\"mins\":case\"min\":case\"m\":return r*Vr;case\"seconds\":case\"second\":case\"secs\":case\"sec\":case\"s\":return r*Hr;case\"milliseconds\":case\"millisecond\":case\"msecs\":case\"msec\":case\"ms\":return r;default:return}}}}function bm(t){var e=Math.abs(t);return e>=gr?Math.round(t/gr)+\"d\":e>=zr?Math.round(t/zr)+\"h\":e>=Vr?Math.round(t/Vr)+\"m\":e>=Hr?Math.round(t/Hr)+\"s\":t+\"ms\"}function wm(t){var e=Math.abs(t);return e>=gr?Tn(t,e,gr,\"day\"):e>=zr?Tn(t,e,zr,\"hour\"):e>=Vr?Tn(t,e,Vr,\"minute\"):e>=Hr?Tn(t,e,Hr,\"second\"):t+\" ms\"}function Tn(t,e,r,i){var n=e>=r*1.5;return Math.round(t/r)+\" \"+i+(n?\"s\":\"\")}});var bd=M((hP,yd)=>{v();m();_();function _m(t){r.debug=r,r.default=r,r.coerce=u,r.disable=o,r.enable=n,r.enabled=s,r.humanize=gd(),r.destroy=c,Object.keys(t).forEach(h=>{r[h]=t[h]}),r.names=[],r.skips=[],r.formatters={};function e(h){let d=0;for(let g=0;g<h.length;g++)d=(d<<5)-d+h.charCodeAt(g),d|=0;return r.colors[Math.abs(d)%r.colors.length]}r.selectColor=e;function r(h){let d,g=null,y,w;function E(...S){if(!E.enabled)return;let I=E,C=Number(new Date),R=C-(d||C);I.diff=R,I.prev=d,I.curr=C,d=C,S[0]=r.coerce(S[0]),typeof S[0]!=\"string\"&&S.unshift(\"%O\");let U=0;S[0]=S[0].replace(/%([a-zA-Z%])/g,(W,K)=>{if(W===\"%%\")return\"%\";U++;let z=r.formatters[K];if(typeof z==\"function\"){let Q=S[U];W=z.call(I,Q),S.splice(U,1),U--}return W}),r.formatArgs.call(I,S),(I.log||r.log).apply(I,S)}return E.namespace=h,E.useColors=r.useColors(),E.color=r.selectColor(h),E.extend=i,E.destroy=r.destroy,Object.defineProperty(E,\"enabled\",{enumerable:!0,configurable:!1,get:()=>g!==null?g:(y!==r.namespaces&&(y=r.namespaces,w=r.enabled(h)),w),set:S=>{g=S}}),typeof r.init==\"function\"&&r.init(E),E}function i(h,d){let g=r(this.namespace+(typeof d>\"u\"?\":\":d)+h);return g.log=this.log,g}function n(h){r.save(h),r.namespaces=h,r.names=[],r.skips=[];let d,g=(typeof h==\"string\"?h:\"\").split(/[\\s,]+/),y=g.length;for(d=0;d<y;d++)g[d]&&(h=g[d].replace(/\\*/g,\".*?\"),h[0]===\"-\"?r.skips.push(new RegExp(\"^\"+h.slice(1)+\"$\")):r.names.push(new RegExp(\"^\"+h+\"$\")))}function o(){let h=[...r.names.map(a),...r.skips.map(a).map(d=>\"-\"+d)].join(\",\");return r.enable(\"\"),h}function s(h){if(h[h.length-1]===\"*\")return!0;let d,g;for(d=0,g=r.skips.length;d<g;d++)if(r.skips[d].test(h))return!1;for(d=0,g=r.names.length;d<g;d++)if(r.names[d].test(h))return!0;return!1}function a(h){return h.toString().substring(2,h.toString().length-2).replace(/\\.\\*\\?$/,\"*\")}function u(h){return h instanceof Error?h.stack||h.message:h}function c(){console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\")}return r.enable(r.load()),r}yd.exports=_m});var ot=M((xe,Rn)=>{v();m();_();xe.formatArgs=vm;xe.save=Em;xe.load=Sm;xe.useColors=mm;xe.storage=Am();xe.destroy=(()=>{let t=!1;return()=>{t||(t=!0,console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"))}})();xe.colors=[\"#0000CC\",\"#0000FF\",\"#0033CC\",\"#0033FF\",\"#0066CC\",\"#0066FF\",\"#0099CC\",\"#0099FF\",\"#00CC00\",\"#00CC33\",\"#00CC66\",\"#00CC99\",\"#00CCCC\",\"#00CCFF\",\"#3300CC\",\"#3300FF\",\"#3333CC\",\"#3333FF\",\"#3366CC\",\"#3366FF\",\"#3399CC\",\"#3399FF\",\"#33CC00\",\"#33CC33\",\"#33CC66\",\"#33CC99\",\"#33CCCC\",\"#33CCFF\",\"#6600CC\",\"#6600FF\",\"#6633CC\",\"#6633FF\",\"#66CC00\",\"#66CC33\",\"#9900CC\",\"#9900FF\",\"#9933CC\",\"#9933FF\",\"#99CC00\",\"#99CC33\",\"#CC0000\",\"#CC0033\",\"#CC0066\",\"#CC0099\",\"#CC00CC\",\"#CC00FF\",\"#CC3300\",\"#CC3333\",\"#CC3366\",\"#CC3399\",\"#CC33CC\",\"#CC33FF\",\"#CC6600\",\"#CC6633\",\"#CC9900\",\"#CC9933\",\"#CCCC00\",\"#CCCC33\",\"#FF0000\",\"#FF0033\",\"#FF0066\",\"#FF0099\",\"#FF00CC\",\"#FF00FF\",\"#FF3300\",\"#FF3333\",\"#FF3366\",\"#FF3399\",\"#FF33CC\",\"#FF33FF\",\"#FF6600\",\"#FF6633\",\"#FF9900\",\"#FF9933\",\"#FFCC00\",\"#FFCC33\"];function mm(){return typeof window<\"u\"&&window.process&&(window.process.type===\"renderer\"||window.process.__nwjs)?!0:typeof B<\"u\"&&B.userAgent&&B.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)?!1:typeof document<\"u\"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<\"u\"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof B<\"u\"&&B.userAgent&&B.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof B<\"u\"&&B.userAgent&&B.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/)}function vm(t){if(t[0]=(this.useColors?\"%c\":\"\")+this.namespace+(this.useColors?\" %c\":\" \")+t[0]+(this.useColors?\"%c \":\" \")+\"+\"+Rn.exports.humanize(this.diff),!this.useColors)return;let e=\"color: \"+this.color;t.splice(1,0,e,\"color: inherit\");let r=0,i=0;t[0].replace(/%[a-zA-Z%]/g,n=>{n!==\"%%\"&&(r++,n===\"%c\"&&(i=r))}),t.splice(i,0,e)}xe.log=console.debug||console.log||(()=>{});function Em(t){try{t?xe.storage.setItem(\"debug\",t):xe.storage.removeItem(\"debug\")}catch{}}function Sm(){let t;try{t=xe.storage.getItem(\"debug\")}catch{}return!t&&typeof P<\"u\"&&\"env\"in P&&(t=P.env.DEBUG),t}function Am(){try{return localStorage}catch{}}Rn.exports=bd()(xe);var{formatters:Im}=Rn.exports;Im.j=function(t){try{return JSON.stringify(t)}catch(e){return\"[UnexpectedJSONParseError]: \"+e.message}}});var md=M((OP,_d)=>{v();m();_();var Tm=fd(),{EventEmitter:Rm}=(ir(),Z(rr)),wd=hd(),V=Fo(),D=ot()(\"mqtt-packet:parser\"),Wo=class t extends Rm{constructor(){super(),this.parser=this.constructor.parser}static parser(e){return this instanceof t?(this.settings=e||{},this._states=[\"_parseHeader\",\"_parseLength\",\"_parsePayload\",\"_newPacket\"],this._resetState(),this):new t().parser(e)}_resetState(){D(\"_resetState: resetting packet, error, _list, and _stateCounter\"),this.packet=new wd,this.error=null,this._list=Tm(),this._stateCounter=0}parse(e){for(this.error&&this._resetState(),this._list.append(e),D(\"parse: current state: %s\",this._states[this._stateCounter]);(this.packet.length!==-1||this._list.length>0)&&this[this._states[this._stateCounter]]()&&!this.error;)this._stateCounter++,D(\"parse: state complete. _stateCounter is now: %d\",this._stateCounter),D(\"parse: packet.length: %d, buffer list length: %d\",this.packet.length,this._list.length),this._stateCounter>=this._states.length&&(this._stateCounter=0);return D(\"parse: exited while loop. packet: %d, buffer list length: %d\",this.packet.length,this._list.length),this._list.length}_parseHeader(){let e=this._list.readUInt8(0),r=e>>V.CMD_SHIFT;this.packet.cmd=V.types[r];let i=e&15,n=V.requiredHeaderFlags[r];return n!=null&&i!==n?this._emitError(new Error(V.requiredHeaderFlagsErrors[r])):(this.packet.retain=(e&V.RETAIN_MASK)!==0,this.packet.qos=e>>V.QOS_SHIFT&V.QOS_MASK,this.packet.qos>2?this._emitError(new Error(\"Packet must not have both QoS bits set to 1\")):(this.packet.dup=(e&V.DUP_MASK)!==0,D(\"_parseHeader: packet: %o\",this.packet),this._list.consume(1),!0))}_parseLength(){let e=this._parseVarByteNum(!0);return e&&(this.packet.length=e.value,this._list.consume(e.bytes)),D(\"_parseLength %d\",e.value),!!e}_parsePayload(){D(\"_parsePayload: payload %O\",this._list);let e=!1;if(this.packet.length===0||this._list.length>=this.packet.length){switch(this._pos=0,this.packet.cmd){case\"connect\":this._parseConnect();break;case\"connack\":this._parseConnack();break;case\"publish\":this._parsePublish();break;case\"puback\":case\"pubrec\":case\"pubrel\":case\"pubcomp\":this._parseConfirmation();break;case\"subscribe\":this._parseSubscribe();break;case\"suback\":this._parseSuback();break;case\"unsubscribe\":this._parseUnsubscribe();break;case\"unsuback\":this._parseUnsuback();break;case\"pingreq\":case\"pingresp\":break;case\"disconnect\":this._parseDisconnect();break;case\"auth\":this._parseAuth();break;default:this._emitError(new Error(\"Not supported\"))}e=!0}return D(\"_parsePayload complete result: %s\",e),e}_parseConnect(){D(\"_parseConnect\");let e,r,i,n,o={},s=this.packet,a=this._parseString();if(a===null)return this._emitError(new Error(\"Cannot parse protocolId\"));if(a!==\"MQTT\"&&a!==\"MQIsdp\")return this._emitError(new Error(\"Invalid protocolId\"));if(s.protocolId=a,this._pos>=this._list.length)return this._emitError(new Error(\"Packet too short\"));if(s.protocolVersion=this._list.readUInt8(this._pos),s.protocolVersion>=128&&(s.bridgeMode=!0,s.protocolVersion=s.protocolVersion-128),s.protocolVersion!==3&&s.protocolVersion!==4&&s.protocolVersion!==5)return this._emitError(new Error(\"Invalid protocol version\"));if(this._pos++,this._pos>=this._list.length)return this._emitError(new Error(\"Packet too short\"));if(this._list.readUInt8(this._pos)&1)return this._emitError(new Error(\"Connect flag bit 0 must be 0, but got 1\"));o.username=this._list.readUInt8(this._pos)&V.USERNAME_MASK,o.password=this._list.readUInt8(this._pos)&V.PASSWORD_MASK,o.will=this._list.readUInt8(this._pos)&V.WILL_FLAG_MASK;let u=!!(this._list.readUInt8(this._pos)&V.WILL_RETAIN_MASK),c=(this._list.readUInt8(this._pos)&V.WILL_QOS_MASK)>>V.WILL_QOS_SHIFT;if(o.will)s.will={},s.will.retain=u,s.will.qos=c;else{if(u)return this._emitError(new Error(\"Will Retain Flag must be set to zero when Will Flag is set to 0\"));if(c)return this._emitError(new Error(\"Will QoS must be set to zero when Will Flag is set to 0\"))}if(s.clean=(this._list.readUInt8(this._pos)&V.CLEAN_SESSION_MASK)!==0,this._pos++,s.keepalive=this._parseNum(),s.keepalive===-1)return this._emitError(new Error(\"Packet too short\"));if(s.protocolVersion===5){let d=this._parseProperties();Object.getOwnPropertyNames(d).length&&(s.properties=d)}let h=this._parseString();if(h===null)return this._emitError(new Error(\"Packet too short\"));if(s.clientId=h,D(\"_parseConnect: packet.clientId: %s\",s.clientId),o.will){if(s.protocolVersion===5){let d=this._parseProperties();Object.getOwnPropertyNames(d).length&&(s.will.properties=d)}if(e=this._parseString(),e===null)return this._emitError(new Error(\"Cannot parse will topic\"));if(s.will.topic=e,D(\"_parseConnect: packet.will.topic: %s\",s.will.topic),r=this._parseBuffer(),r===null)return this._emitError(new Error(\"Cannot parse will payload\"));s.will.payload=r,D(\"_parseConnect: packet.will.paylaod: %s\",s.will.payload)}if(o.username){if(n=this._parseString(),n===null)return this._emitError(new Error(\"Cannot parse username\"));s.username=n,D(\"_parseConnect: packet.username: %s\",s.username)}if(o.password){if(i=this._parseBuffer(),i===null)return this._emitError(new Error(\"Cannot parse password\"));s.password=i}return this.settings=s,D(\"_parseConnect: complete\"),s}_parseConnack(){D(\"_parseConnack\");let e=this.packet;if(this._list.length<1)return null;let r=this._list.readUInt8(this._pos++);if(r>1)return this._emitError(new Error(\"Invalid connack flags, bits 7-1 must be set to 0\"));if(e.sessionPresent=!!(r&V.SESSIONPRESENT_MASK),this.settings.protocolVersion===5)this._list.length>=2?e.reasonCode=this._list.readUInt8(this._pos++):e.reasonCode=0;else{if(this._list.length<2)return null;e.returnCode=this._list.readUInt8(this._pos++)}if(e.returnCode===-1||e.reasonCode===-1)return this._emitError(new Error(\"Cannot parse return code\"));if(this.settings.protocolVersion===5){let i=this._parseProperties();Object.getOwnPropertyNames(i).length&&(e.properties=i)}D(\"_parseConnack: complete\")}_parsePublish(){D(\"_parsePublish\");let e=this.packet;if(e.topic=this._parseString(),e.topic===null)return this._emitError(new Error(\"Cannot parse topic\"));if(!(e.qos>0&&!this._parseMessageId())){if(this.settings.protocolVersion===5){let r=this._parseProperties();Object.getOwnPropertyNames(r).length&&(e.properties=r)}e.payload=this._list.slice(this._pos,e.length),D(\"_parsePublish: payload from buffer list: %o\",e.payload)}}_parseSubscribe(){D(\"_parseSubscribe\");let e=this.packet,r,i,n,o,s,a,u;if(e.subscriptions=[],!!this._parseMessageId()){if(this.settings.protocolVersion===5){let c=this._parseProperties();Object.getOwnPropertyNames(c).length&&(e.properties=c)}if(e.length<=0)return this._emitError(new Error(\"Malformed subscribe, no payload specified\"));for(;this._pos<e.length;){if(r=this._parseString(),r===null)return this._emitError(new Error(\"Cannot parse topic\"));if(this._pos>=e.length)return this._emitError(new Error(\"Malformed Subscribe Payload\"));if(i=this._parseByte(),this.settings.protocolVersion===5){if(i&192)return this._emitError(new Error(\"Invalid subscribe topic flag bits, bits 7-6 must be 0\"))}else if(i&252)return this._emitError(new Error(\"Invalid subscribe topic flag bits, bits 7-2 must be 0\"));if(n=i&V.SUBSCRIBE_OPTIONS_QOS_MASK,n>2)return this._emitError(new Error(\"Invalid subscribe QoS, must be <= 2\"));if(a=(i>>V.SUBSCRIBE_OPTIONS_NL_SHIFT&V.SUBSCRIBE_OPTIONS_NL_MASK)!==0,s=(i>>V.SUBSCRIBE_OPTIONS_RAP_SHIFT&V.SUBSCRIBE_OPTIONS_RAP_MASK)!==0,o=i>>V.SUBSCRIBE_OPTIONS_RH_SHIFT&V.SUBSCRIBE_OPTIONS_RH_MASK,o>2)return this._emitError(new Error(\"Invalid retain handling, must be <= 2\"));u={topic:r,qos:n},this.settings.protocolVersion===5?(u.nl=a,u.rap=s,u.rh=o):this.settings.bridgeMode&&(u.rh=0,u.rap=!0,u.nl=!0),D(\"_parseSubscribe: push subscription `%s` to subscription\",u),e.subscriptions.push(u)}}}_parseSuback(){D(\"_parseSuback\");let e=this.packet;if(this.packet.granted=[],!!this._parseMessageId()){if(this.settings.protocolVersion===5){let r=this._parseProperties();Object.getOwnPropertyNames(r).length&&(e.properties=r)}if(e.length<=0)return this._emitError(new Error(\"Malformed suback, no payload specified\"));for(;this._pos<this.packet.length;){let r=this._list.readUInt8(this._pos++);if(this.settings.protocolVersion===5){if(!V.MQTT5_SUBACK_CODES[r])return this._emitError(new Error(\"Invalid suback code\"))}else if(r>2&&r!==128)return this._emitError(new Error(\"Invalid suback QoS, must be 0, 1, 2 or 128\"));this.packet.granted.push(r)}}}_parseUnsubscribe(){D(\"_parseUnsubscribe\");let e=this.packet;if(e.unsubscriptions=[],!!this._parseMessageId()){if(this.settings.protocolVersion===5){let r=this._parseProperties();Object.getOwnPropertyNames(r).length&&(e.properties=r)}if(e.length<=0)return this._emitError(new Error(\"Malformed unsubscribe, no payload specified\"));for(;this._pos<e.length;){let r=this._parseString();if(r===null)return this._emitError(new Error(\"Cannot parse topic\"));D(\"_parseUnsubscribe: push topic `%s` to unsubscriptions\",r),e.unsubscriptions.push(r)}}}_parseUnsuback(){D(\"_parseUnsuback\");let e=this.packet;if(!this._parseMessageId())return this._emitError(new Error(\"Cannot parse messageId\"));if((this.settings.protocolVersion===3||this.settings.protocolVersion===4)&&e.length!==2)return this._emitError(new Error(\"Malformed unsuback, payload length must be 2\"));if(e.length<=0)return this._emitError(new Error(\"Malformed unsuback, no payload specified\"));if(this.settings.protocolVersion===5){let r=this._parseProperties();for(Object.getOwnPropertyNames(r).length&&(e.properties=r),e.granted=[];this._pos<this.packet.length;){let i=this._list.readUInt8(this._pos++);if(!V.MQTT5_UNSUBACK_CODES[i])return this._emitError(new Error(\"Invalid unsuback code\"));this.packet.granted.push(i)}}}_parseConfirmation(){D(\"_parseConfirmation: packet.cmd: `%s`\",this.packet.cmd);let e=this.packet;if(this._parseMessageId(),this.settings.protocolVersion===5){if(e.length>2){switch(e.reasonCode=this._parseByte(),this.packet.cmd){case\"puback\":case\"pubrec\":if(!V.MQTT5_PUBACK_PUBREC_CODES[e.reasonCode])return this._emitError(new Error(\"Invalid \"+this.packet.cmd+\" reason code\"));break;case\"pubrel\":case\"pubcomp\":if(!V.MQTT5_PUBREL_PUBCOMP_CODES[e.reasonCode])return this._emitError(new Error(\"Invalid \"+this.packet.cmd+\" reason code\"));break}D(\"_parseConfirmation: packet.reasonCode `%d`\",e.reasonCode)}else e.reasonCode=0;if(e.length>3){let r=this._parseProperties();Object.getOwnPropertyNames(r).length&&(e.properties=r)}}return!0}_parseDisconnect(){let e=this.packet;if(D(\"_parseDisconnect\"),this.settings.protocolVersion===5){this._list.length>0?(e.reasonCode=this._parseByte(),V.MQTT5_DISCONNECT_CODES[e.reasonCode]||this._emitError(new Error(\"Invalid disconnect reason code\"))):e.reasonCode=0;let r=this._parseProperties();Object.getOwnPropertyNames(r).length&&(e.properties=r)}return D(\"_parseDisconnect result: true\"),!0}_parseAuth(){D(\"_parseAuth\");let e=this.packet;if(this.settings.protocolVersion!==5)return this._emitError(new Error(\"Not supported auth packet for this version MQTT\"));if(e.reasonCode=this._parseByte(),!V.MQTT5_AUTH_CODES[e.reasonCode])return this._emitError(new Error(\"Invalid auth reason code\"));let r=this._parseProperties();return Object.getOwnPropertyNames(r).length&&(e.properties=r),D(\"_parseAuth: result: true\"),!0}_parseMessageId(){let e=this.packet;return e.messageId=this._parseNum(),e.messageId===null?(this._emitError(new Error(\"Cannot parse messageId\")),!1):(D(\"_parseMessageId: packet.messageId %d\",e.messageId),!0)}_parseString(e){let r=this._parseNum(),i=r+this._pos;if(r===-1||i>this._list.length||i>this.packet.length)return null;let n=this._list.toString(\"utf8\",this._pos,i);return this._pos+=r,D(\"_parseString: result: %s\",n),n}_parseStringPair(){return D(\"_parseStringPair\"),{name:this._parseString(),value:this._parseString()}}_parseBuffer(){let e=this._parseNum(),r=e+this._pos;if(e===-1||r>this._list.length||r>this.packet.length)return null;let i=this._list.slice(this._pos,r);return this._pos+=e,D(\"_parseBuffer: result: %o\",i),i}_parseNum(){if(this._list.length-this._pos<2)return-1;let e=this._list.readUInt16BE(this._pos);return this._pos+=2,D(\"_parseNum: result: %s\",e),e}_parse4ByteNum(){if(this._list.length-this._pos<4)return-1;let e=this._list.readUInt32BE(this._pos);return this._pos+=4,D(\"_parse4ByteNum: result: %s\",e),e}_parseVarByteNum(e){D(\"_parseVarByteNum\");let r=4,i=0,n=1,o=0,s=!1,a,u=this._pos?this._pos:0;for(;i<r&&u+i<this._list.length;){if(a=this._list.readUInt8(u+i++),o+=n*(a&V.VARBYTEINT_MASK),n*=128,!(a&V.VARBYTEINT_FIN_MASK)){s=!0;break}if(this._list.length<=i)break}return!s&&i===r&&this._list.length>=i&&this._emitError(new Error(\"Invalid variable byte integer\")),u&&(this._pos+=i),s?e?s={bytes:i,value:o}:s=o:s=!1,D(\"_parseVarByteNum: result: %o\",s),s}_parseByte(){let e;return this._pos<this._list.length&&(e=this._list.readUInt8(this._pos),this._pos++),D(\"_parseByte: result: %o\",e),e}_parseByType(e){switch(D(\"_parseByType: type: %s\",e),e){case\"byte\":return this._parseByte()!==0;case\"int8\":return this._parseByte();case\"int16\":return this._parseNum();case\"int32\":return this._parse4ByteNum();case\"var\":return this._parseVarByteNum();case\"string\":return this._parseString();case\"pair\":return this._parseStringPair();case\"binary\":return this._parseBuffer()}}_parseProperties(){D(\"_parseProperties\");let e=this._parseVarByteNum(),i=this._pos+e,n={};for(;this._pos<i;){let o=this._parseByte();if(!o)return this._emitError(new Error(\"Cannot parse property code type\")),!1;let s=V.propertiesCodes[o];if(!s)return this._emitError(new Error(\"Unknown property\")),!1;if(s===\"userProperties\"){n[s]||(n[s]=Object.create(null));let a=this._parseByType(V.propertiesTypes[s]);if(n[s][a.name])if(Array.isArray(n[s][a.name]))n[s][a.name].push(a.value);else{let u=n[s][a.name];n[s][a.name]=[u],n[s][a.name].push(a.value)}else n[s][a.name]=a.value;continue}n[s]?Array.isArray(n[s])?n[s].push(this._parseByType(V.propertiesTypes[s])):(n[s]=[n[s]],n[s].push(this._parseByType(V.propertiesTypes[s]))):n[s]=this._parseByType(V.propertiesTypes[s])}return n}_newPacket(){return D(\"_newPacket\"),this.packet&&(this._list.consume(this.packet.length),D(\"_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d\",this.packet.cmd,this.packet.payload,this.packet.length),this.emit(\"packet\",this.packet)),D(\"_newPacket: new packet\"),this.packet=new wd,this._pos=0,!0}_emitError(e){D(\"_emitError\",e),this.error=e,this.emit(\"error\",e)}};_d.exports=Wo});var Ad=M((FP,Sd)=>{v();m();_();var{Buffer:mi}=(we(),Z(ve)),Cm=65536,vd={},Bm=mi.isBuffer(mi.from([1,2]).subarray(0,1));function Ed(t){let e=mi.allocUnsafe(2);return e.writeUInt8(t>>8,0),e.writeUInt8(t&255,0+1),e}function Pm(){for(let t=0;t<Cm;t++)vd[t]=Ed(t)}function Om(t){let r=0,i=0,n=mi.allocUnsafe(4);do r=t%128|0,t=t/128|0,t>0&&(r=r|128),n.writeUInt8(r,i++);while(t>0&&i<4);return t>0&&(i=0),Bm?n.subarray(0,i):n.slice(0,i)}function km(t){let e=mi.allocUnsafe(4);return e.writeUInt32BE(t,0),e}Sd.exports={cache:vd,generateCache:Pm,generateNumber:Ed,genBufVariableByteInt:Om,generate4ByteBuffer:km}});var Id=M((JP,$o)=>{\"use strict\";v();m();_();typeof P>\"u\"||!P.version||P.version.indexOf(\"v0.\")===0||P.version.indexOf(\"v1.\")===0&&P.version.indexOf(\"v1.8.\")!==0?$o.exports={nextTick:xm}:$o.exports=P;function xm(t,e,r,i){if(typeof t!=\"function\")throw new TypeError('\"callback\" argument must be a function');var n=arguments.length,o,s;switch(n){case 0:case 1:return P.nextTick(t);case 2:return P.nextTick(function(){t.call(null,e)});case 3:return P.nextTick(function(){t.call(null,e,r)});case 4:return P.nextTick(function(){t.call(null,e,r,i)});default:for(o=new Array(n-1),s=0;s<o.length;)o[s++]=arguments[s];return P.nextTick(function(){t.apply(null,o)})}}});var zo=M((aO,xd)=>{v();m();_();var j=Fo(),{Buffer:q}=(we(),Z(ve)),Mm=q.allocUnsafe(0),Lm=q.from([0]),vi=Ad(),Um=Id().nextTick,qe=ot()(\"mqtt-packet:writeToStream\"),Cn=vi.cache,Nm=vi.generateNumber,qm=vi.generateCache,Ho=vi.genBufVariableByteInt,Dm=vi.generate4ByteBuffer,Ie=Vo,Bn=!0;function Od(t,e,r){switch(qe(\"generate called\"),e.cork&&(e.cork(),Um(jm,e)),Bn&&(Bn=!1,qm()),qe(\"generate: packet.cmd: %s\",t.cmd),t.cmd){case\"connect\":return Fm(t,e,r);case\"connack\":return Wm(t,e,r);case\"publish\":return $m(t,e,r);case\"puback\":case\"pubrec\":case\"pubrel\":case\"pubcomp\":return Hm(t,e,r);case\"subscribe\":return Vm(t,e,r);case\"suback\":return zm(t,e,r);case\"unsubscribe\":return Km(t,e,r);case\"unsuback\":return Gm(t,e,r);case\"pingreq\":case\"pingresp\":return Qm(t,e,r);case\"disconnect\":return Ym(t,e,r);case\"auth\":return Jm(t,e,r);default:return e.destroy(new Error(\"Unknown command\")),!1}}Object.defineProperty(Od,\"cacheNumbers\",{get(){return Ie===Vo},set(t){t?((!Cn||Object.keys(Cn).length===0)&&(Bn=!0),Ie=Vo):(Bn=!1,Ie=Xm)}});function jm(t){t.uncork()}function Fm(t,e,r){let i=t||{},n=i.protocolId||\"MQTT\",o=i.protocolVersion||4,s=i.will,a=i.clean,u=i.keepalive||0,c=i.clientId||\"\",h=i.username,d=i.password,g=i.properties;a===void 0&&(a=!0);let y=0;if(!n||typeof n!=\"string\"&&!q.isBuffer(n))return e.destroy(new Error(\"Invalid protocolId\")),!1;if(y+=n.length+2,o!==3&&o!==4&&o!==5)return e.destroy(new Error(\"Invalid protocol version\")),!1;if(y+=1,(typeof c==\"string\"||q.isBuffer(c))&&(c||o>=4)&&(c||a))y+=q.byteLength(c)+2;else{if(o<4)return e.destroy(new Error(\"clientId must be supplied before 3.1.1\")),!1;if(a*1===0)return e.destroy(new Error(\"clientId must be given if cleanSession set to 0\")),!1}if(typeof u!=\"number\"||u<0||u>65535||u%1!==0)return e.destroy(new Error(\"Invalid keepalive\")),!1;y+=2,y+=1;let w,E;if(o===5){if(w=Ft(e,g),!w)return!1;y+=w.length}if(s){if(typeof s!=\"object\")return e.destroy(new Error(\"Invalid will\")),!1;if(!s.topic||typeof s.topic!=\"string\")return e.destroy(new Error(\"Invalid will topic\")),!1;if(y+=q.byteLength(s.topic)+2,y+=2,s.payload)if(s.payload.length>=0)typeof s.payload==\"string\"?y+=q.byteLength(s.payload):y+=s.payload.length;else return e.destroy(new Error(\"Invalid will payload\")),!1;if(E={},o===5){if(E=Ft(e,s.properties),!E)return!1;y+=E.length}}let S=!1;if(h!=null)if(Pd(h))S=!0,y+=q.byteLength(h)+2;else return e.destroy(new Error(\"Invalid username\")),!1;if(d!=null){if(!S)return e.destroy(new Error(\"Username is required to use password\")),!1;if(Pd(d))y+=kd(d)+2;else return e.destroy(new Error(\"Invalid password\")),!1}e.write(j.CONNECT_HEADER),De(e,y),Kr(e,n),i.bridgeMode&&(o+=128),e.write(o===131?j.VERSION131:o===132?j.VERSION132:o===4?j.VERSION4:o===5?j.VERSION5:j.VERSION3);let I=0;return I|=h!=null?j.USERNAME_MASK:0,I|=d!=null?j.PASSWORD_MASK:0,I|=s&&s.retain?j.WILL_RETAIN_MASK:0,I|=s&&s.qos?s.qos<<j.WILL_QOS_SHIFT:0,I|=s?j.WILL_FLAG_MASK:0,I|=a?j.CLEAN_SESSION_MASK:0,e.write(q.from([I])),Ie(e,u),o===5&&w.write(),Kr(e,c),s&&(o===5&&E.write(),yr(e,s.topic),Kr(e,s.payload)),h!=null&&Kr(e,h),d!=null&&Kr(e,d),!0}function Wm(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=i===5?n.reasonCode:n.returnCode,s=n.properties,a=2;if(typeof o!=\"number\")return e.destroy(new Error(\"Invalid return code\")),!1;let u=null;if(i===5){if(u=Ft(e,s),!u)return!1;a+=u.length}return e.write(j.CONNACK_HEADER),De(e,a),e.write(n.sessionPresent?j.SESSIONPRESENT_HEADER:Lm),e.write(q.from([o])),u?.write(),!0}function $m(t,e,r){qe(\"publish: packet: %o\",t);let i=r?r.protocolVersion:4,n=t||{},o=n.qos||0,s=n.retain?j.RETAIN_MASK:0,a=n.topic,u=n.payload||Mm,c=n.messageId,h=n.properties,d=0;if(typeof a==\"string\")d+=q.byteLength(a)+2;else if(q.isBuffer(a))d+=a.length+2;else return e.destroy(new Error(\"Invalid topic\")),!1;if(q.isBuffer(u)?d+=u.length:d+=q.byteLength(u),o&&typeof c!=\"number\")return e.destroy(new Error(\"Invalid messageId\")),!1;o&&(d+=2);let g=null;if(i===5){if(g=Ft(e,h),!g)return!1;d+=g.length}return e.write(j.PUBLISH_HEADER[o][n.dup?1:0][s?1:0]),De(e,d),Ie(e,kd(a)),e.write(a),o>0&&Ie(e,c),g?.write(),qe(\"publish: payload: %o\",u),e.write(u)}function Hm(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.cmd||\"puback\",s=n.messageId,a=n.dup&&o===\"pubrel\"?j.DUP_MASK:0,u=0,c=n.reasonCode,h=n.properties,d=i===5?3:2;if(o===\"pubrel\"&&(u=1),typeof s!=\"number\")return e.destroy(new Error(\"Invalid messageId\")),!1;let g=null;if(i===5&&typeof h==\"object\"){if(g=Ei(e,h,r,d),!g)return!1;d+=g.length}return e.write(j.ACKS[o][u][a][0]),d===3&&(d+=c!==0?1:-1),De(e,d),Ie(e,s),i===5&&d!==2&&e.write(q.from([c])),g!==null?g.write():d===4&&e.write(q.from([0])),!0}function Vm(t,e,r){qe(\"subscribe: packet: \");let i=r?r.protocolVersion:4,n=t||{},o=n.dup?j.DUP_MASK:0,s=n.messageId,a=n.subscriptions,u=n.properties,c=0;if(typeof s!=\"number\")return e.destroy(new Error(\"Invalid messageId\")),!1;c+=2;let h=null;if(i===5){if(h=Ft(e,u),!h)return!1;c+=h.length}if(typeof a==\"object\"&&a.length)for(let g=0;g<a.length;g+=1){let y=a[g].topic,w=a[g].qos;if(typeof y!=\"string\")return e.destroy(new Error(\"Invalid subscriptions - invalid topic\")),!1;if(typeof w!=\"number\")return e.destroy(new Error(\"Invalid subscriptions - invalid qos\")),!1;if(i===5){if(typeof(a[g].nl||!1)!=\"boolean\")return e.destroy(new Error(\"Invalid subscriptions - invalid No Local\")),!1;if(typeof(a[g].rap||!1)!=\"boolean\")return e.destroy(new Error(\"Invalid subscriptions - invalid Retain as Published\")),!1;let I=a[g].rh||0;if(typeof I!=\"number\"||I>2)return e.destroy(new Error(\"Invalid subscriptions - invalid Retain Handling\")),!1}c+=q.byteLength(y)+2+1}else return e.destroy(new Error(\"Invalid subscriptions\")),!1;qe(\"subscribe: writing to stream: %o\",j.SUBSCRIBE_HEADER),e.write(j.SUBSCRIBE_HEADER[1][o?1:0][0]),De(e,c),Ie(e,s),h!==null&&h.write();let d=!0;for(let g of a){let y=g.topic,w=g.qos,E=+g.nl,S=+g.rap,I=g.rh,C;yr(e,y),C=j.SUBSCRIBE_OPTIONS_QOS[w],i===5&&(C|=E?j.SUBSCRIBE_OPTIONS_NL:0,C|=S?j.SUBSCRIBE_OPTIONS_RAP:0,C|=I?j.SUBSCRIBE_OPTIONS_RH[I]:0),d=e.write(q.from([C]))}return d}function zm(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.messageId,s=n.granted,a=n.properties,u=0;if(typeof o!=\"number\")return e.destroy(new Error(\"Invalid messageId\")),!1;if(u+=2,typeof s==\"object\"&&s.length)for(let h=0;h<s.length;h+=1){if(typeof s[h]!=\"number\")return e.destroy(new Error(\"Invalid qos vector\")),!1;u+=1}else return e.destroy(new Error(\"Invalid qos vector\")),!1;let c=null;if(i===5){if(c=Ei(e,a,r,u),!c)return!1;u+=c.length}return e.write(j.SUBACK_HEADER),De(e,u),Ie(e,o),c!==null&&c.write(),e.write(q.from(s))}function Km(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.messageId,s=n.dup?j.DUP_MASK:0,a=n.unsubscriptions,u=n.properties,c=0;if(typeof o!=\"number\")return e.destroy(new Error(\"Invalid messageId\")),!1;if(c+=2,typeof a==\"object\"&&a.length)for(let g=0;g<a.length;g+=1){if(typeof a[g]!=\"string\")return e.destroy(new Error(\"Invalid unsubscriptions\")),!1;c+=q.byteLength(a[g])+2}else return e.destroy(new Error(\"Invalid unsubscriptions\")),!1;let h=null;if(i===5){if(h=Ft(e,u),!h)return!1;c+=h.length}e.write(j.UNSUBSCRIBE_HEADER[1][s?1:0][0]),De(e,c),Ie(e,o),h!==null&&h.write();let d=!0;for(let g=0;g<a.length;g++)d=yr(e,a[g]);return d}function Gm(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.messageId,s=n.dup?j.DUP_MASK:0,a=n.granted,u=n.properties,c=n.cmd,h=0,d=2;if(typeof o!=\"number\")return e.destroy(new Error(\"Invalid messageId\")),!1;if(i===5)if(typeof a==\"object\"&&a.length)for(let y=0;y<a.length;y+=1){if(typeof a[y]!=\"number\")return e.destroy(new Error(\"Invalid qos vector\")),!1;d+=1}else return e.destroy(new Error(\"Invalid qos vector\")),!1;let g=null;if(i===5){if(g=Ei(e,u,r,d),!g)return!1;d+=g.length}return e.write(j.ACKS[c][h][s][0]),De(e,d),Ie(e,o),g!==null&&g.write(),i===5&&e.write(q.from(a)),!0}function Qm(t,e,r){return e.write(j.EMPTY[t.cmd])}function Ym(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.reasonCode,s=n.properties,a=i===5?1:0,u=null;if(i===5){if(u=Ei(e,s,r,a),!u)return!1;a+=u.length}return e.write(q.from([j.codes.disconnect<<4])),De(e,a),i===5&&e.write(q.from([o])),u!==null&&u.write(),!0}function Jm(t,e,r){let i=r?r.protocolVersion:4,n=t||{},o=n.reasonCode,s=n.properties,a=i===5?1:0;i!==5&&e.destroy(new Error(\"Invalid mqtt version for auth packet\"));let u=Ei(e,s,r,a);return u?(a+=u.length,e.write(q.from([j.codes.auth<<4])),De(e,a),e.write(q.from([o])),u!==null&&u.write(),!0):!1}var Td={};function De(t,e){if(e>j.VARBYTEINT_MAX)return t.destroy(new Error(`Invalid variable byte integer: ${e}`)),!1;let r=Td[e];return r||(r=Ho(e),e<16384&&(Td[e]=r)),qe(\"writeVarByteInt: writing to stream: %o\",r),t.write(r)}function yr(t,e){let r=q.byteLength(e);return Ie(t,r),qe(\"writeString: %s\",e),t.write(e,\"utf8\")}function Rd(t,e,r){yr(t,e),yr(t,r)}function Vo(t,e){return qe(\"writeNumberCached: number: %d\",e),qe(\"writeNumberCached: %o\",Cn[e]),t.write(Cn[e])}function Xm(t,e){let r=Nm(e);return qe(\"writeNumberGenerated: %o\",r),t.write(r)}function Zm(t,e){let r=Dm(e);return qe(\"write4ByteNumber: %o\",r),t.write(r)}function Kr(t,e){typeof e==\"string\"?yr(t,e):e?(Ie(t,e.length),t.write(e)):Ie(t,0)}function Ft(t,e){if(typeof e!=\"object\"||e.length!=null)return{length:1,write(){Bd(t,{},0)}};let r=0;function i(o,s){let a=j.propertiesTypes[o],u=0;switch(a){case\"byte\":{if(typeof s!=\"boolean\")return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+1;break}case\"int8\":{if(typeof s!=\"number\"||s<0||s>255)return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+1;break}case\"binary\":{if(s&&s===null)return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+q.byteLength(s)+2;break}case\"int16\":{if(typeof s!=\"number\"||s<0||s>65535)return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+2;break}case\"int32\":{if(typeof s!=\"number\"||s<0||s>4294967295)return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+4;break}case\"var\":{if(typeof s!=\"number\"||s<0||s>268435455)return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+q.byteLength(Ho(s));break}case\"string\":{if(typeof s!=\"string\")return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=1+2+q.byteLength(s.toString());break}case\"pair\":{if(typeof s!=\"object\")return t.destroy(new Error(`Invalid ${o}: ${s}`)),!1;u+=Object.getOwnPropertyNames(s).reduce((c,h)=>{let d=s[h];return Array.isArray(d)?c+=d.reduce((g,y)=>(g+=1+2+q.byteLength(h.toString())+2+q.byteLength(y.toString()),g),0):c+=1+2+q.byteLength(h.toString())+2+q.byteLength(s[h].toString()),c},0);break}default:return t.destroy(new Error(`Invalid property ${o}: ${s}`)),!1}return u}if(e)for(let o in e){let s=0,a=0,u=e[o];if(Array.isArray(u))for(let c=0;c<u.length;c++){if(a=i(o,u[c]),!a)return!1;s+=a}else{if(a=i(o,u),!a)return!1;s=a}if(!s)return!1;r+=s}return{length:q.byteLength(Ho(r))+r,write(){Bd(t,e,r)}}}function Ei(t,e,r,i){let n=[\"reasonString\",\"userProperties\"],o=r&&r.properties&&r.properties.maximumPacketSize?r.properties.maximumPacketSize:0,s=Ft(t,e);if(o)for(;i+s.length>o;){let a=n.shift();if(a&&e[a])delete e[a],s=Ft(t,e);else return!1}return s}function Cd(t,e,r){switch(j.propertiesTypes[e]){case\"byte\":{t.write(q.from([j.properties[e]])),t.write(q.from([+r]));break}case\"int8\":{t.write(q.from([j.properties[e]])),t.write(q.from([r]));break}case\"binary\":{t.write(q.from([j.properties[e]])),Kr(t,r);break}case\"int16\":{t.write(q.from([j.properties[e]])),Ie(t,r);break}case\"int32\":{t.write(q.from([j.properties[e]])),Zm(t,r);break}case\"var\":{t.write(q.from([j.properties[e]])),De(t,r);break}case\"string\":{t.write(q.from([j.properties[e]])),yr(t,r);break}case\"pair\":{Object.getOwnPropertyNames(r).forEach(n=>{let o=r[n];Array.isArray(o)?o.forEach(s=>{t.write(q.from([j.properties[e]])),Rd(t,n.toString(),s.toString())}):(t.write(q.from([j.properties[e]])),Rd(t,n.toString(),o.toString()))});break}default:return t.destroy(new Error(`Invalid property ${e} value: ${r}`)),!1}}function Bd(t,e,r){De(t,r);for(let i in e)if(Object.prototype.hasOwnProperty.call(e,i)&&e[i]!==null){let n=e[i];if(Array.isArray(n))for(let o=0;o<n.length;o++)Cd(t,i,n[o]);else Cd(t,i,n)}}function kd(t){return t?t instanceof q?t.length:q.byteLength(t):0}function Pd(t){return typeof t==\"string\"||t instanceof q}xd.exports=Od});var Ud=M((bO,Ld)=>{v();m();_();var e1=zo(),{EventEmitter:t1}=(ir(),Z(rr)),{Buffer:Md}=(we(),Z(ve));function r1(t,e){let r=new Ko;return e1(t,r,e),r.concat()}var Ko=class extends t1{constructor(){super(),this._array=new Array(20),this._i=0}write(e){return this._array[this._i++]=e,!0}concat(){let e=0,r=new Array(this._array.length),i=this._array,n=0,o;for(o=0;o<i.length&&i[o]!==void 0;o++)typeof i[o]!=\"string\"?r[o]=i[o].length:r[o]=Md.byteLength(i[o]),e+=r[o];let s=Md.allocUnsafe(e);for(o=0;o<i.length&&i[o]!==void 0;o++)typeof i[o]!=\"string\"?(i[o].copy(s,n),n+=r[o]):(s.write(i[o],n),n+=r[o]);return s}destroy(e){e&&this.emit(\"error\",e)}};Ld.exports=r1});var Nd=M(Pn=>{v();m();_();Pn.parser=md().parser;Pn.generate=Ud();Pn.writeToStream=zo()});var Yo=M(Qo=>{\"use strict\";v();m();_();Object.defineProperty(Qo,\"__esModule\",{value:!0});var Go=class{constructor(){this.nextId=Math.max(1,Math.floor(Math.random()*65535))}allocate(){let e=this.nextId++;return this.nextId===65536&&(this.nextId=1),e}getLastAllocated(){return this.nextId===1?65535:this.nextId-1}register(e){return!0}deallocate(e){}clear(){}};Qo.default=Go});var Dd=M((KO,qd)=>{\"use strict\";v();m();_();qd.exports=i1;function Gr(t){return t instanceof k?k.from(t):new t.constructor(t.buffer.slice(),t.byteOffset,t.length)}function i1(t){if(t=t||{},t.circles)return n1(t);return t.proto?i:r;function e(n,o){for(var s=Object.keys(n),a=new Array(s.length),u=0;u<s.length;u++){var c=s[u],h=n[c];typeof h!=\"object\"||h===null?a[c]=h:h instanceof Date?a[c]=new Date(h):ArrayBuffer.isView(h)?a[c]=Gr(h):a[c]=o(h)}return a}function r(n){if(typeof n!=\"object\"||n===null)return n;if(n instanceof Date)return new Date(n);if(Array.isArray(n))return e(n,r);if(n instanceof Map)return new Map(e(Array.from(n),r));if(n instanceof Set)return new Set(e(Array.from(n),r));var o={};for(var s in n)if(Object.hasOwnProperty.call(n,s)!==!1){var a=n[s];typeof a!=\"object\"||a===null?o[s]=a:a instanceof Date?o[s]=new Date(a):a instanceof Map?o[s]=new Map(e(Array.from(a),r)):a instanceof Set?o[s]=new Set(e(Array.from(a),r)):ArrayBuffer.isView(a)?o[s]=Gr(a):o[s]=r(a)}return o}function i(n){if(typeof n!=\"object\"||n===null)return n;if(n instanceof Date)return new Date(n);if(Array.isArray(n))return e(n,i);if(n instanceof Map)return new Map(e(Array.from(n),i));if(n instanceof Set)return new Set(e(Array.from(n),i));var o={};for(var s in n){var a=n[s];typeof a!=\"object\"||a===null?o[s]=a:a instanceof Date?o[s]=new Date(a):a instanceof Map?o[s]=new Map(e(Array.from(a),i)):a instanceof Set?o[s]=new Set(e(Array.from(a),i)):ArrayBuffer.isView(a)?o[s]=Gr(a):o[s]=i(a)}return o}}function n1(t){var e=[],r=[];return t.proto?o:n;function i(s,a){for(var u=Object.keys(s),c=new Array(u.length),h=0;h<u.length;h++){var d=u[h],g=s[d];if(typeof g!=\"object\"||g===null)c[d]=g;else if(g instanceof Date)c[d]=new Date(g);else if(ArrayBuffer.isView(g))c[d]=Gr(g);else{var y=e.indexOf(g);y!==-1?c[d]=r[y]:c[d]=a(g)}}return c}function n(s){if(typeof s!=\"object\"||s===null)return s;if(s instanceof Date)return new Date(s);if(Array.isArray(s))return i(s,n);if(s instanceof Map)return new Map(i(Array.from(s),n));if(s instanceof Set)return new Set(i(Array.from(s),n));var a={};e.push(s),r.push(a);for(var u in s)if(Object.hasOwnProperty.call(s,u)!==!1){var c=s[u];if(typeof c!=\"object\"||c===null)a[u]=c;else if(c instanceof Date)a[u]=new Date(c);else if(c instanceof Map)a[u]=new Map(i(Array.from(c),n));else if(c instanceof Set)a[u]=new Set(i(Array.from(c),n));else if(ArrayBuffer.isView(c))a[u]=Gr(c);else{var h=e.indexOf(c);h!==-1?a[u]=r[h]:a[u]=n(c)}}return e.pop(),r.pop(),a}function o(s){if(typeof s!=\"object\"||s===null)return s;if(s instanceof Date)return new Date(s);if(Array.isArray(s))return i(s,o);if(s instanceof Map)return new Map(i(Array.from(s),o));if(s instanceof Set)return new Set(i(Array.from(s),o));var a={};e.push(s),r.push(a);for(var u in s){var c=s[u];if(typeof c!=\"object\"||c===null)a[u]=c;else if(c instanceof Date)a[u]=new Date(c);else if(c instanceof Map)a[u]=new Map(i(Array.from(c),o));else if(c instanceof Set)a[u]=new Set(i(Array.from(c),o));else if(ArrayBuffer.isView(c))a[u]=Gr(c);else{var h=e.indexOf(c);h!==-1?a[u]=r[h]:a[u]=o(c)}}return e.pop(),r.pop(),a}}});var Fd=M((ik,jd)=>{\"use strict\";v();m();_();jd.exports=Dd()()});var $d=M(Qr=>{\"use strict\";v();m();_();Object.defineProperty(Qr,\"__esModule\",{value:!0});Qr.validateTopics=Qr.validateTopic=void 0;function Wd(t){let e=t.split(\"/\");for(let r=0;r<e.length;r++)if(e[r]!==\"+\"){if(e[r]===\"#\")return r===e.length-1;if(e[r].indexOf(\"+\")!==-1||e[r].indexOf(\"#\")!==-1)return!1}return!0}Qr.validateTopic=Wd;function s1(t){if(t.length===0)return\"empty_topic_list\";for(let e=0;e<t.length;e++)if(!Wd(t[e]))return t[e];return null}Qr.validateTopics=s1});var Zo=M(Xo=>{\"use strict\";v();m();_();Object.defineProperty(Xo,\"__esModule\",{value:!0});var o1=Dt(),a1={objectMode:!0},l1={clean:!0},Jo=class{constructor(e){this.options=e||{},this.options=Object.assign(Object.assign({},l1),e),this._inflights=new Map}put(e,r){return this._inflights.set(e.messageId,e),r&&r(),this}createStream(){let e=new o1.Readable(a1),r=[],i=!1,n=0;return this._inflights.forEach((o,s)=>{r.push(o)}),e._read=()=>{!i&&n<r.length?e.push(r[n++]):e.push(null)},e.destroy=o=>{if(!i)return i=!0,setTimeout(()=>{e.emit(\"close\")},0),e},e}del(e,r){let i=this._inflights.get(e.messageId);return i?(this._inflights.delete(e.messageId),r(null,i)):r&&r(new Error(\"missing packet\")),this}get(e,r){let i=this._inflights.get(e.messageId);return i?r(null,i):r&&r(new Error(\"missing packet\")),this}close(e){this.options.clean&&(this._inflights=null),e&&e()}};Xo.default=Jo});var Vd=M(ea=>{\"use strict\";v();m();_();Object.defineProperty(ea,\"__esModule\",{value:!0});var Hd=[0,16,128,131,135,144,145,151,153],u1=(t,e,r)=>{t.log(\"handlePublish: packet %o\",e),r=typeof r<\"u\"?r:t.noop;let i=e.topic.toString(),n=e.payload,{qos:o}=e,{messageId:s}=e,{options:a}=t;if(t.options.protocolVersion===5){let u;if(e.properties&&(u=e.properties.topicAlias),typeof u<\"u\")if(i.length===0)if(u>0&&u<=65535){let c=t.topicAliasRecv.getTopicByAlias(u);if(c)i=c,t.log(\"handlePublish :: topic complemented by alias. topic: %s - alias: %d\",i,u);else{t.log(\"handlePublish :: unregistered topic alias. alias: %d\",u),t.emit(\"error\",new Error(\"Received unregistered Topic Alias\"));return}}else{t.log(\"handlePublish :: topic alias out of range. alias: %d\",u),t.emit(\"error\",new Error(\"Received Topic Alias is out of range\"));return}else if(t.topicAliasRecv.put(i,u))t.log(\"handlePublish :: registered topic: %s - alias: %d\",i,u);else{t.log(\"handlePublish :: topic alias out of range. alias: %d\",u),t.emit(\"error\",new Error(\"Received Topic Alias is out of range\"));return}}switch(t.log(\"handlePublish: qos %d\",o),o){case 2:{a.customHandleAcks(i,n,e,(u,c)=>{if(typeof u==\"number\"&&(c=u,u=null),u)return t.emit(\"error\",u);if(Hd.indexOf(c)===-1)return t.emit(\"error\",new Error(\"Wrong reason code for pubrec\"));c?t._sendPacket({cmd:\"pubrec\",messageId:s,reasonCode:c},r):t.incomingStore.put(e,()=>{t._sendPacket({cmd:\"pubrec\",messageId:s},r)})});break}case 1:{a.customHandleAcks(i,n,e,(u,c)=>{if(typeof u==\"number\"&&(c=u,u=null),u)return t.emit(\"error\",u);if(Hd.indexOf(c)===-1)return t.emit(\"error\",new Error(\"Wrong reason code for puback\"));c||t.emit(\"message\",i,n,e),t.handleMessage(e,h=>{if(h)return r&&r(h);t._sendPacket({cmd:\"puback\",messageId:s,reasonCode:c},r)})});break}case 0:t.emit(\"message\",i,n,e),t.handleMessage(e,r);break;default:t.log(\"handlePublish: unknown QoS. Doing nothing.\");break}};ea.default=u1});var Yr=M(Wt=>{\"use strict\";v();m();_();Object.defineProperty(Wt,\"__esModule\",{value:!0});Wt.nextTick=Wt.applyMixin=Wt.ErrorWithReasonCode=void 0;var ta=class t extends Error{constructor(e,r){super(e),this.code=r,Object.setPrototypeOf(this,t.prototype),Object.getPrototypeOf(this).name=\"ErrorWithReasonCode\"}};Wt.ErrorWithReasonCode=ta;function f1(t,e,r=!1){var i;let n=[e];for(;;){let o=n[0],s=Object.getPrototypeOf(o);if(s?.prototype)n.unshift(s);else break}for(let o of n)for(let s of Object.getOwnPropertyNames(o.prototype))(r||s!==\"constructor\")&&Object.defineProperty(t.prototype,s,(i=Object.getOwnPropertyDescriptor(o.prototype,s))!==null&&i!==void 0?i:Object.create(null))}Wt.applyMixin=f1;Wt.nextTick=P?P.nextTick:t=>{setTimeout(t,0)}});var Si=M(br=>{\"use strict\";v();m();_();Object.defineProperty(br,\"__esModule\",{value:!0});br.ReasonCodes=void 0;br.ReasonCodes={0:\"\",1:\"Unacceptable protocol version\",2:\"Identifier rejected\",3:\"Server unavailable\",4:\"Bad username or password\",5:\"Not authorized\",16:\"No matching subscribers\",17:\"No subscription existed\",128:\"Unspecified error\",129:\"Malformed Packet\",130:\"Protocol Error\",131:\"Implementation specific error\",132:\"Unsupported Protocol Version\",133:\"Client Identifier not valid\",134:\"Bad User Name or Password\",135:\"Not authorized\",136:\"Server unavailable\",137:\"Server busy\",138:\"Banned\",139:\"Server shutting down\",140:\"Bad authentication method\",141:\"Keep Alive timeout\",142:\"Session taken over\",143:\"Topic Filter invalid\",144:\"Topic Name invalid\",145:\"Packet identifier in use\",146:\"Packet Identifier not found\",147:\"Receive Maximum exceeded\",148:\"Topic Alias invalid\",149:\"Packet too large\",150:\"Message rate too high\",151:\"Quota exceeded\",152:\"Administrative action\",153:\"Payload format invalid\",154:\"Retain not supported\",155:\"QoS not supported\",156:\"Use another server\",157:\"Server moved\",158:\"Shared Subscriptions not supported\",159:\"Connection rate exceeded\",160:\"Maximum connect time\",161:\"Subscription Identifiers not supported\",162:\"Wildcard Subscriptions not supported\"};var c1=(t,e)=>{let{messageId:r}=e,i=e.cmd,n=null,o=t.outgoing[r]?t.outgoing[r].cb:null,s;if(!o){t.log(\"_handleAck :: Server sent an ack in error. Ignoring.\");return}switch(t.log(\"_handleAck :: packet type\",i),i){case\"pubcomp\":case\"puback\":{let a=e.reasonCode;a&&a>0&&a!==16?(s=new Error(`Publish error: ${br.ReasonCodes[a]}`),s.code=a,t._removeOutgoingAndStoreMessage(r,()=>{o(s,e)})):t._removeOutgoingAndStoreMessage(r,o);break}case\"pubrec\":{n={cmd:\"pubrel\",qos:2,messageId:r};let a=e.reasonCode;a&&a>0&&a!==16?(s=new Error(`Publish error: ${br.ReasonCodes[a]}`),s.code=a,t._removeOutgoingAndStoreMessage(r,()=>{o(s,e)})):t._sendPacket(n);break}case\"suback\":{delete t.outgoing[r],t.messageIdProvider.deallocate(r);let a=e.granted;for(let u=0;u<a.length;u++)if(a[u]&128){let c=t.messageIdToTopic[r];c&&c.forEach(h=>{delete t._resubscribeTopics[h]})}delete t.messageIdToTopic[r],t._invokeStoreProcessingQueue(),o(null,e);break}case\"unsuback\":{delete t.outgoing[r],t.messageIdProvider.deallocate(r),t._invokeStoreProcessingQueue(),o(null);break}default:t.emit(\"error\",new Error(\"unrecognized packet type\"))}t.disconnecting&&Object.keys(t.outgoing).length===0&&t.emit(\"outgoingEmpty\")};br.default=c1});var Kd=M(ra=>{\"use strict\";v();m();_();Object.defineProperty(ra,\"__esModule\",{value:!0});var zd=Yr(),h1=Si(),d1=(t,e)=>{let{options:r}=t,i=r.protocolVersion,n=i===5?e.reasonCode:e.returnCode;if(i!==5){let o=new zd.ErrorWithReasonCode(`Protocol error: Auth packets are only supported in MQTT 5. Your version:${i}`,n);t.emit(\"error\",o);return}t.handleAuth(e,(o,s)=>{if(o){t.emit(\"error\",o);return}if(n===24)t.reconnecting=!1,t._sendPacket(s);else{let a=new zd.ErrorWithReasonCode(`Connection refused: ${h1.ReasonCodes[n]}`,n);t.emit(\"error\",a)}})};ra.default=d1});var Xd=M(kn=>{\"use strict\";v();m();_();Object.defineProperty(kn,\"__esModule\",{value:!0});kn.LRUCache=void 0;var Ai=typeof performance==\"object\"&&performance&&typeof performance.now==\"function\"?performance:Date,Qd=new Set,ia=typeof P==\"object\"&&P?P:{},Yd=(t,e,r,i)=>{typeof ia.emitWarning==\"function\"?ia.emitWarning(t,e,r,i):console.error(`[${r}] ${e}: ${t}`)},On=globalThis.AbortController,Gd=globalThis.AbortSignal;if(typeof On>\"u\"){Gd=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(i,n){this._onabort.push(n)}},On=class{constructor(){e()}signal=new Gd;abort(i){if(!this.signal.aborted){this.signal.reason=i,this.signal.aborted=!0;for(let n of this.signal._onabort)n(i);this.signal.onabort?.(i)}}};let t=ia.env?.LRU_CACHE_IGNORE_AC_WARNING!==\"1\",e=()=>{t&&(t=!1,Yd(\"AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.\",\"NO_ABORT_CONTROLLER\",\"ENOTSUP\",e))}}var p1=t=>!Qd.has(t),Ex=Symbol(\"type\"),$t=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),Jd=t=>$t(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?Jr:null:null,Jr=class extends Array{constructor(e){super(e),this.fill(0)}},na=class t{heap;length;static#l=!1;static create(e){let r=Jd(e);if(!r)return[];t.#l=!0;let i=new t(e,r);return t.#l=!1,i}constructor(e,r){if(!t.#l)throw new TypeError(\"instantiate Stack using Stack.create(n)\");this.heap=new r(e),this.length=0}push(e){this.heap[this.length++]=e}pop(){return this.heap[--this.length]}},sa=class t{#l;#c;#p;#g;#B;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#i;#y;#n;#r;#e;#u;#h;#a;#s;#b;#o;#E;#S;#w;#_;#I;#f;static unsafeExposeInternals(e){return{starts:e.#S,ttls:e.#w,sizes:e.#E,keyMap:e.#n,keyList:e.#r,valList:e.#e,next:e.#u,prev:e.#h,get head(){return e.#a},get tail(){return e.#s},free:e.#b,isBackgroundFetch:r=>e.#t(r),backgroundFetch:(r,i,n,o)=>e.#k(r,i,n,o),moveToTail:r=>e.#C(r),indexes:r=>e.#m(r),rindexes:r=>e.#v(r),isStale:r=>e.#d(r)}}get max(){return this.#l}get maxSize(){return this.#c}get calculatedSize(){return this.#y}get size(){return this.#i}get fetchMethod(){return this.#B}get dispose(){return this.#p}get disposeAfter(){return this.#g}constructor(e){let{max:r=0,ttl:i,ttlResolution:n=1,ttlAutopurge:o,updateAgeOnGet:s,updateAgeOnHas:a,allowStale:u,dispose:c,disposeAfter:h,noDisposeOnSet:d,noUpdateTTL:g,maxSize:y=0,maxEntrySize:w=0,sizeCalculation:E,fetchMethod:S,noDeleteOnFetchRejection:I,noDeleteOnStaleGet:C,allowStaleOnFetchRejection:R,allowStaleOnFetchAbort:U,ignoreFetchAbort:N}=e;if(r!==0&&!$t(r))throw new TypeError(\"max option must be a nonnegative integer\");let W=r?Jd(r):Array;if(!W)throw new Error(\"invalid max value: \"+r);if(this.#l=r,this.#c=y,this.maxEntrySize=w||this.#c,this.sizeCalculation=E,this.sizeCalculation){if(!this.#c&&!this.maxEntrySize)throw new TypeError(\"cannot set sizeCalculation without setting maxSize or maxEntrySize\");if(typeof this.sizeCalculation!=\"function\")throw new TypeError(\"sizeCalculation set to non-function\")}if(S!==void 0&&typeof S!=\"function\")throw new TypeError(\"fetchMethod must be a function if specified\");if(this.#B=S,this.#I=!!S,this.#n=new Map,this.#r=new Array(r).fill(void 0),this.#e=new Array(r).fill(void 0),this.#u=new W(r),this.#h=new W(r),this.#a=0,this.#s=0,this.#b=na.create(r),this.#i=0,this.#y=0,typeof c==\"function\"&&(this.#p=c),typeof h==\"function\"?(this.#g=h,this.#o=[]):(this.#g=void 0,this.#o=void 0),this.#_=!!this.#p,this.#f=!!this.#g,this.noDisposeOnSet=!!d,this.noUpdateTTL=!!g,this.noDeleteOnFetchRejection=!!I,this.allowStaleOnFetchRejection=!!R,this.allowStaleOnFetchAbort=!!U,this.ignoreFetchAbort=!!N,this.maxEntrySize!==0){if(this.#c!==0&&!$t(this.#c))throw new TypeError(\"maxSize must be a positive integer if specified\");if(!$t(this.maxEntrySize))throw new TypeError(\"maxEntrySize must be a positive integer if specified\");this.#q()}if(this.allowStale=!!u,this.noDeleteOnStaleGet=!!C,this.updateAgeOnGet=!!s,this.updateAgeOnHas=!!a,this.ttlResolution=$t(n)||n===0?n:1,this.ttlAutopurge=!!o,this.ttl=i||0,this.ttl){if(!$t(this.ttl))throw new TypeError(\"ttl must be a positive integer if specified\");this.#x()}if(this.#l===0&&this.ttl===0&&this.#c===0)throw new TypeError(\"At least one of max, maxSize, or ttl is required\");if(!this.ttlAutopurge&&!this.#l&&!this.#c){let K=\"LRU_CACHE_UNBOUNDED\";p1(K)&&(Qd.add(K),Yd(\"TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.\",\"UnboundedCacheWarning\",K,t))}}getRemainingTTL(e){return this.#n.has(e)?1/0:0}#x(){let e=new Jr(this.#l),r=new Jr(this.#l);this.#w=e,this.#S=r,this.#M=(o,s,a=Ai.now())=>{if(r[o]=s!==0?a:0,e[o]=s,s!==0&&this.ttlAutopurge){let u=setTimeout(()=>{this.#d(o)&&this.delete(this.#r[o])},s+1);u.unref&&u.unref()}},this.#T=o=>{r[o]=e[o]!==0?Ai.now():0},this.#A=(o,s)=>{if(e[s]){let a=e[s],u=r[s];o.ttl=a,o.start=u,o.now=i||n();let c=o.now-u;o.remainingTTL=a-c}};let i=0,n=()=>{let o=Ai.now();if(this.ttlResolution>0){i=o;let s=setTimeout(()=>i=0,this.ttlResolution);s.unref&&s.unref()}return o};this.getRemainingTTL=o=>{let s=this.#n.get(o);if(s===void 0)return 0;let a=e[s],u=r[s];if(a===0||u===0)return 1/0;let c=(i||n())-u;return a-c},this.#d=o=>e[o]!==0&&r[o]!==0&&(i||n())-r[o]>e[o]}#T=()=>{};#A=()=>{};#M=()=>{};#d=()=>!1;#q(){let e=new Jr(this.#l);this.#y=0,this.#E=e,this.#R=r=>{this.#y-=e[r],e[r]=0},this.#L=(r,i,n,o)=>{if(this.#t(i))return 0;if(!$t(n))if(o){if(typeof o!=\"function\")throw new TypeError(\"sizeCalculation must be a function\");if(n=o(i,r),!$t(n))throw new TypeError(\"sizeCalculation return invalid (expect positive integer)\")}else throw new TypeError(\"invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.\");return n},this.#P=(r,i,n)=>{if(e[r]=i,this.#c){let o=this.#c-e[r];for(;this.#y>o;)this.#O(!0)}this.#y+=e[r],n&&(n.entrySize=i,n.totalCalculatedSize=this.#y)}}#R=e=>{};#P=(e,r,i)=>{};#L=(e,r,i,n)=>{if(i||n)throw new TypeError(\"cannot set size without setting maxSize or maxEntrySize on cache\");return 0};*#m({allowStale:e=this.allowStale}={}){if(this.#i)for(let r=this.#s;!(!this.#U(r)||((e||!this.#d(r))&&(yield r),r===this.#a));)r=this.#h[r]}*#v({allowStale:e=this.allowStale}={}){if(this.#i)for(let r=this.#a;!(!this.#U(r)||((e||!this.#d(r))&&(yield r),r===this.#s));)r=this.#u[r]}#U(e){return e!==void 0&&this.#n.get(this.#r[e])===e}*entries(){for(let e of this.#m())this.#e[e]!==void 0&&this.#r[e]!==void 0&&!this.#t(this.#e[e])&&(yield[this.#r[e],this.#e[e]])}*rentries(){for(let e of this.#v())this.#e[e]!==void 0&&this.#r[e]!==void 0&&!this.#t(this.#e[e])&&(yield[this.#r[e],this.#e[e]])}*keys(){for(let e of this.#m()){let r=this.#r[e];r!==void 0&&!this.#t(this.#e[e])&&(yield r)}}*rkeys(){for(let e of this.#v()){let r=this.#r[e];r!==void 0&&!this.#t(this.#e[e])&&(yield r)}}*values(){for(let e of this.#m())this.#e[e]!==void 0&&!this.#t(this.#e[e])&&(yield this.#e[e])}*rvalues(){for(let e of this.#v())this.#e[e]!==void 0&&!this.#t(this.#e[e])&&(yield this.#e[e])}[Symbol.iterator](){return this.entries()}find(e,r={}){for(let i of this.#m()){let n=this.#e[i],o=this.#t(n)?n.__staleWhileFetching:n;if(o!==void 0&&e(o,this.#r[i],this))return this.get(this.#r[i],r)}}forEach(e,r=this){for(let i of this.#m()){let n=this.#e[i],o=this.#t(n)?n.__staleWhileFetching:n;o!==void 0&&e.call(r,o,this.#r[i],this)}}rforEach(e,r=this){for(let i of this.#v()){let n=this.#e[i],o=this.#t(n)?n.__staleWhileFetching:n;o!==void 0&&e.call(r,o,this.#r[i],this)}}purgeStale(){let e=!1;for(let r of this.#v({allowStale:!0}))this.#d(r)&&(this.delete(this.#r[r]),e=!0);return e}dump(){let e=[];for(let r of this.#m({allowStale:!0})){let i=this.#r[r],n=this.#e[r],o=this.#t(n)?n.__staleWhileFetching:n;if(o===void 0||i===void 0)continue;let s={value:o};if(this.#w&&this.#S){s.ttl=this.#w[r];let a=Ai.now()-this.#S[r];s.start=Math.floor(Date.now()-a)}this.#E&&(s.size=this.#E[r]),e.unshift([i,s])}return e}load(e){this.clear();for(let[r,i]of e){if(i.start){let n=Date.now()-i.start;i.start=Ai.now()-n}this.set(r,i.value,i)}}set(e,r,i={}){if(r===void 0)return this.delete(e),this;let{ttl:n=this.ttl,start:o,noDisposeOnSet:s=this.noDisposeOnSet,sizeCalculation:a=this.sizeCalculation,status:u}=i,{noUpdateTTL:c=this.noUpdateTTL}=i,h=this.#L(e,r,i.size||0,a);if(this.maxEntrySize&&h>this.maxEntrySize)return u&&(u.set=\"miss\",u.maxEntrySizeExceeded=!0),this.delete(e),this;let d=this.#i===0?void 0:this.#n.get(e);if(d===void 0)d=this.#i===0?this.#s:this.#b.length!==0?this.#b.pop():this.#i===this.#l?this.#O(!1):this.#i,this.#r[d]=e,this.#e[d]=r,this.#n.set(e,d),this.#u[this.#s]=d,this.#h[d]=this.#s,this.#s=d,this.#i++,this.#P(d,h,u),u&&(u.set=\"add\"),c=!1;else{this.#C(d);let g=this.#e[d];if(r!==g){if(this.#I&&this.#t(g)){g.__abortController.abort(new Error(\"replaced\"));let{__staleWhileFetching:y}=g;y!==void 0&&!s&&(this.#_&&this.#p?.(y,e,\"set\"),this.#f&&this.#o?.push([y,e,\"set\"]))}else s||(this.#_&&this.#p?.(g,e,\"set\"),this.#f&&this.#o?.push([g,e,\"set\"]));if(this.#R(d),this.#P(d,h,u),this.#e[d]=r,u){u.set=\"replace\";let y=g&&this.#t(g)?g.__staleWhileFetching:g;y!==void 0&&(u.oldValue=y)}}else u&&(u.set=\"update\")}if(n!==0&&!this.#w&&this.#x(),this.#w&&(c||this.#M(d,n,o),u&&this.#A(u,d)),!s&&this.#f&&this.#o){let g=this.#o,y;for(;y=g?.shift();)this.#g?.(...y)}return this}pop(){try{for(;this.#i;){let e=this.#e[this.#a];if(this.#O(!0),this.#t(e)){if(e.__staleWhileFetching)return e.__staleWhileFetching}else if(e!==void 0)return e}}finally{if(this.#f&&this.#o){let e=this.#o,r;for(;r=e?.shift();)this.#g?.(...r)}}}#O(e){let r=this.#a,i=this.#r[r],n=this.#e[r];return this.#I&&this.#t(n)?n.__abortController.abort(new Error(\"evicted\")):(this.#_||this.#f)&&(this.#_&&this.#p?.(n,i,\"evict\"),this.#f&&this.#o?.push([n,i,\"evict\"])),this.#R(r),e&&(this.#r[r]=void 0,this.#e[r]=void 0,this.#b.push(r)),this.#i===1?(this.#a=this.#s=0,this.#b.length=0):this.#a=this.#u[r],this.#n.delete(i),this.#i--,r}has(e,r={}){let{updateAgeOnHas:i=this.updateAgeOnHas,status:n}=r,o=this.#n.get(e);if(o!==void 0){let s=this.#e[o];if(this.#t(s)&&s.__staleWhileFetching===void 0)return!1;if(this.#d(o))n&&(n.has=\"stale\",this.#A(n,o));else return i&&this.#T(o),n&&(n.has=\"hit\",this.#A(n,o)),!0}else n&&(n.has=\"miss\");return!1}peek(e,r={}){let{allowStale:i=this.allowStale}=r,n=this.#n.get(e);if(n!==void 0&&(i||!this.#d(n))){let o=this.#e[n];return this.#t(o)?o.__staleWhileFetching:o}}#k(e,r,i,n){let o=r===void 0?void 0:this.#e[r];if(this.#t(o))return o;let s=new On,{signal:a}=i;a?.addEventListener(\"abort\",()=>s.abort(a.reason),{signal:s.signal});let u={signal:s.signal,options:i,context:n},c=(E,S=!1)=>{let{aborted:I}=s.signal,C=i.ignoreFetchAbort&&E!==void 0;if(i.status&&(I&&!S?(i.status.fetchAborted=!0,i.status.fetchError=s.signal.reason,C&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),I&&!C&&!S)return d(s.signal.reason);let R=y;return this.#e[r]===y&&(E===void 0?R.__staleWhileFetching?this.#e[r]=R.__staleWhileFetching:this.delete(e):(i.status&&(i.status.fetchUpdated=!0),this.set(e,E,u.options))),E},h=E=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=E),d(E)),d=E=>{let{aborted:S}=s.signal,I=S&&i.allowStaleOnFetchAbort,C=I||i.allowStaleOnFetchRejection,R=C||i.noDeleteOnFetchRejection,U=y;if(this.#e[r]===y&&(!R||U.__staleWhileFetching===void 0?this.delete(e):I||(this.#e[r]=U.__staleWhileFetching)),C)return i.status&&U.__staleWhileFetching!==void 0&&(i.status.returnedStale=!0),U.__staleWhileFetching;if(U.__returned===U)throw E},g=(E,S)=>{let I=this.#B?.(e,o,u);I&&I instanceof Promise&&I.then(C=>E(C===void 0?void 0:C),S),s.signal.addEventListener(\"abort\",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(E(void 0),i.allowStaleOnFetchAbort&&(E=C=>c(C,!0)))})};i.status&&(i.status.fetchDispatched=!0);let y=new Promise(g).then(c,h),w=Object.assign(y,{__abortController:s,__staleWhileFetching:o,__returned:void 0});return r===void 0?(this.set(e,w,{...u.options,status:void 0}),r=this.#n.get(e)):this.#e[r]=w,w}#t(e){if(!this.#I)return!1;let r=e;return!!r&&r instanceof Promise&&r.hasOwnProperty(\"__staleWhileFetching\")&&r.__abortController instanceof On}async fetch(e,r={}){let{allowStale:i=this.allowStale,updateAgeOnGet:n=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,ttl:s=this.ttl,noDisposeOnSet:a=this.noDisposeOnSet,size:u=0,sizeCalculation:c=this.sizeCalculation,noUpdateTTL:h=this.noUpdateTTL,noDeleteOnFetchRejection:d=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:g=this.allowStaleOnFetchRejection,ignoreFetchAbort:y=this.ignoreFetchAbort,allowStaleOnFetchAbort:w=this.allowStaleOnFetchAbort,context:E,forceRefresh:S=!1,status:I,signal:C}=r;if(!this.#I)return I&&(I.fetch=\"get\"),this.get(e,{allowStale:i,updateAgeOnGet:n,noDeleteOnStaleGet:o,status:I});let R={allowStale:i,updateAgeOnGet:n,noDeleteOnStaleGet:o,ttl:s,noDisposeOnSet:a,size:u,sizeCalculation:c,noUpdateTTL:h,noDeleteOnFetchRejection:d,allowStaleOnFetchRejection:g,allowStaleOnFetchAbort:w,ignoreFetchAbort:y,status:I,signal:C},U=this.#n.get(e);if(U===void 0){I&&(I.fetch=\"miss\");let N=this.#k(e,U,R,E);return N.__returned=N}else{let N=this.#e[U];if(this.#t(N)){let de=i&&N.__staleWhileFetching!==void 0;return I&&(I.fetch=\"inflight\",de&&(I.returnedStale=!0)),de?N.__staleWhileFetching:N.__returned=N}let W=this.#d(U);if(!S&&!W)return I&&(I.fetch=\"hit\"),this.#C(U),n&&this.#T(U),I&&this.#A(I,U),N;let K=this.#k(e,U,R,E),Q=K.__staleWhileFetching!==void 0&&i;return I&&(I.fetch=W?\"stale\":\"refresh\",Q&&W&&(I.returnedStale=!0)),Q?K.__staleWhileFetching:K.__returned=K}}get(e,r={}){let{allowStale:i=this.allowStale,updateAgeOnGet:n=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,status:s}=r,a=this.#n.get(e);if(a!==void 0){let u=this.#e[a],c=this.#t(u);return s&&this.#A(s,a),this.#d(a)?(s&&(s.get=\"stale\"),c?(s&&i&&u.__staleWhileFetching!==void 0&&(s.returnedStale=!0),i?u.__staleWhileFetching:void 0):(o||this.delete(e),s&&i&&(s.returnedStale=!0),i?u:void 0)):(s&&(s.get=\"hit\"),c?u.__staleWhileFetching:(this.#C(a),n&&this.#T(a),u))}else s&&(s.get=\"miss\")}#N(e,r){this.#h[r]=e,this.#u[e]=r}#C(e){e!==this.#s&&(e===this.#a?this.#a=this.#u[e]:this.#N(this.#h[e],this.#u[e]),this.#N(this.#s,e),this.#s=e)}delete(e){let r=!1;if(this.#i!==0){let i=this.#n.get(e);if(i!==void 0)if(r=!0,this.#i===1)this.clear();else{this.#R(i);let n=this.#e[i];this.#t(n)?n.__abortController.abort(new Error(\"deleted\")):(this.#_||this.#f)&&(this.#_&&this.#p?.(n,e,\"delete\"),this.#f&&this.#o?.push([n,e,\"delete\"])),this.#n.delete(e),this.#r[i]=void 0,this.#e[i]=void 0,i===this.#s?this.#s=this.#h[i]:i===this.#a?this.#a=this.#u[i]:(this.#u[this.#h[i]]=this.#u[i],this.#h[this.#u[i]]=this.#h[i]),this.#i--,this.#b.push(i)}}if(this.#f&&this.#o?.length){let i=this.#o,n;for(;n=i?.shift();)this.#g?.(...n)}return r}clear(){for(let e of this.#v({allowStale:!0})){let r=this.#e[e];if(this.#t(r))r.__abortController.abort(new Error(\"deleted\"));else{let i=this.#r[e];this.#_&&this.#p?.(r,i,\"delete\"),this.#f&&this.#o?.push([r,i,\"delete\"])}}if(this.#n.clear(),this.#e.fill(void 0),this.#r.fill(void 0),this.#w&&this.#S&&(this.#w.fill(0),this.#S.fill(0)),this.#E&&this.#E.fill(0),this.#a=0,this.#s=0,this.#b.length=0,this.#y=0,this.#i=0,this.#f&&this.#o){let e=this.#o,r;for(;r=e?.shift();)this.#g?.(...r)}}};kn.LRUCache=sa});var at=M(Ht=>{\"use strict\";v();m();_();Object.defineProperty(Ht,\"t\",{value:!0});Ht.ContainerIterator=Ht.Container=Ht.Base=void 0;var oa=class{constructor(e=0){this.iteratorType=e}equals(e){return this.o===e.o}};Ht.ContainerIterator=oa;var xn=class{constructor(){this.i=0}get length(){return this.i}size(){return this.i}empty(){return this.i===0}};Ht.Base=xn;var aa=class extends xn{};Ht.Container=aa});var Zd=M(Mn=>{\"use strict\";v();m();_();Object.defineProperty(Mn,\"t\",{value:!0});Mn.default=void 0;var g1=at(),la=class extends g1.Base{constructor(e=[]){super(),this.S=[];let r=this;e.forEach(function(i){r.push(i)})}clear(){this.i=0,this.S=[]}push(e){return this.S.push(e),this.i+=1,this.i}pop(){if(this.i!==0)return this.i-=1,this.S.pop()}top(){return this.S[this.i-1]}},y1=la;Mn.default=y1});var ep=M(Ln=>{\"use strict\";v();m();_();Object.defineProperty(Ln,\"t\",{value:!0});Ln.default=void 0;var b1=at(),ua=class extends b1.Base{constructor(e=[]){super(),this.j=0,this.q=[];let r=this;e.forEach(function(i){r.push(i)})}clear(){this.q=[],this.i=this.j=0}push(e){let r=this.q.length;if(this.j/r>.5&&this.j+this.i>=r&&r>4096){let i=this.i;for(let n=0;n<i;++n)this.q[n]=this.q[this.j+n];this.j=0,this.q[this.i]=e}else this.q[this.j+this.i]=e;return++this.i}pop(){if(this.i===0)return;let e=this.q[this.j++];return this.i-=1,e}front(){if(this.i!==0)return this.q[this.j]}},w1=ua;Ln.default=w1});var tp=M(Un=>{\"use strict\";v();m();_();Object.defineProperty(Un,\"t\",{value:!0});Un.default=void 0;var _1=at(),fa=class extends _1.Base{constructor(e=[],r=function(n,o){return n>o?-1:n<o?1:0},i=!0){if(super(),this.v=r,Array.isArray(e))this.C=i?[...e]:e;else{this.C=[];let o=this;e.forEach(function(s){o.C.push(s)})}this.i=this.C.length;let n=this.i>>1;for(let o=this.i-1>>1;o>=0;--o)this.k(o,n)}m(e){let r=this.C[e];for(;e>0;){let i=e-1>>1,n=this.C[i];if(this.v(n,r)<=0)break;this.C[e]=n,e=i}this.C[e]=r}k(e,r){let i=this.C[e];for(;e<r;){let n=e<<1|1,o=n+1,s=this.C[n];if(o<this.i&&this.v(s,this.C[o])>0&&(n=o,s=this.C[o]),this.v(s,i)>=0)break;this.C[e]=s,e=n}this.C[e]=i}clear(){this.i=0,this.C.length=0}push(e){this.C.push(e),this.m(this.i),this.i+=1}pop(){if(this.i===0)return;let e=this.C[0],r=this.C.pop();return this.i-=1,this.i&&(this.C[0]=r,this.k(0,this.i>>1)),e}top(){return this.C[0]}find(e){return this.C.indexOf(e)>=0}remove(e){let r=this.C.indexOf(e);return r<0?!1:(r===0?this.pop():r===this.i-1?(this.C.pop(),this.i-=1):(this.C.splice(r,1,this.C.pop()),this.i-=1,this.m(r),this.k(r,this.i>>1)),!0)}updateItem(e){let r=this.C.indexOf(e);return r<0?!1:(this.m(r),this.k(r,this.i>>1),!0)}toArray(){return[...this.C]}},m1=fa;Un.default=m1});var qn=M(Nn=>{\"use strict\";v();m();_();Object.defineProperty(Nn,\"t\",{value:!0});Nn.default=void 0;var v1=at(),ca=class extends v1.Container{},E1=ca;Nn.default=E1});var lt=M(ha=>{\"use strict\";v();m();_();Object.defineProperty(ha,\"t\",{value:!0});ha.throwIteratorAccessError=S1;function S1(){throw new RangeError(\"Iterator access denied!\")}});var pa=M(jn=>{\"use strict\";v();m();_();Object.defineProperty(jn,\"t\",{value:!0});jn.RandomIterator=void 0;var A1=at(),Dn=lt(),da=class extends A1.ContainerIterator{constructor(e,r){super(r),this.o=e,this.iteratorType===0?(this.pre=function(){return this.o===0&&(0,Dn.throwIteratorAccessError)(),this.o-=1,this},this.next=function(){return this.o===this.container.size()&&(0,Dn.throwIteratorAccessError)(),this.o+=1,this}):(this.pre=function(){return this.o===this.container.size()-1&&(0,Dn.throwIteratorAccessError)(),this.o+=1,this},this.next=function(){return this.o===-1&&(0,Dn.throwIteratorAccessError)(),this.o-=1,this})}get pointer(){return this.container.getElementByPos(this.o)}set pointer(e){this.container.setElementByPos(this.o,e)}};jn.RandomIterator=da});var rp=M(Fn=>{\"use strict\";v();m();_();Object.defineProperty(Fn,\"t\",{value:!0});Fn.default=void 0;var I1=R1(qn()),T1=pa();function R1(t){return t&&t.t?t:{default:t}}var wr=class t extends T1.RandomIterator{constructor(e,r,i){super(e,i),this.container=r}copy(){return new t(this.o,this.container,this.iteratorType)}},ga=class extends I1.default{constructor(e=[],r=!0){if(super(),Array.isArray(e))this.J=r?[...e]:e,this.i=e.length;else{this.J=[];let i=this;e.forEach(function(n){i.pushBack(n)})}}clear(){this.i=0,this.J.length=0}begin(){return new wr(0,this)}end(){return new wr(this.i,this)}rBegin(){return new wr(this.i-1,this,1)}rEnd(){return new wr(-1,this,1)}front(){return this.J[0]}back(){return this.J[this.i-1]}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;return this.J[e]}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;return this.J.splice(e,1),this.i-=1,this.i}eraseElementByValue(e){let r=0;for(let i=0;i<this.i;++i)this.J[i]!==e&&(this.J[r++]=this.J[i]);return this.i=this.J.length=r,this.i}eraseElementByIterator(e){let r=e.o;return e=e.next(),this.eraseElementByPos(r),e}pushBack(e){return this.J.push(e),this.i+=1,this.i}popBack(){if(this.i!==0)return this.i-=1,this.J.pop()}setElementByPos(e,r){if(e<0||e>this.i-1)throw new RangeError;this.J[e]=r}insert(e,r,i=1){if(e<0||e>this.i)throw new RangeError;return this.J.splice(e,0,...new Array(i).fill(r)),this.i+=i,this.i}find(e){for(let r=0;r<this.i;++r)if(this.J[r]===e)return new wr(r,this);return this.end()}reverse(){this.J.reverse()}unique(){let e=1;for(let r=1;r<this.i;++r)this.J[r]!==this.J[r-1]&&(this.J[e++]=this.J[r]);return this.i=this.J.length=e,this.i}sort(e){this.J.sort(e)}forEach(e){for(let r=0;r<this.i;++r)e(this.J[r],r,this)}[Symbol.iterator](){return function*(){yield*this.J}.bind(this)()}},C1=ga;Fn.default=C1});var ip=M(Wn=>{\"use strict\";v();m();_();Object.defineProperty(Wn,\"t\",{value:!0});Wn.default=void 0;var B1=O1(qn()),P1=at(),_r=lt();function O1(t){return t&&t.t?t:{default:t}}var mr=class t extends P1.ContainerIterator{constructor(e,r,i,n){super(n),this.o=e,this.h=r,this.container=i,this.iteratorType===0?(this.pre=function(){return this.o.L===this.h&&(0,_r.throwIteratorAccessError)(),this.o=this.o.L,this},this.next=function(){return this.o===this.h&&(0,_r.throwIteratorAccessError)(),this.o=this.o.B,this}):(this.pre=function(){return this.o.B===this.h&&(0,_r.throwIteratorAccessError)(),this.o=this.o.B,this},this.next=function(){return this.o===this.h&&(0,_r.throwIteratorAccessError)(),this.o=this.o.L,this})}get pointer(){return this.o===this.h&&(0,_r.throwIteratorAccessError)(),this.o.l}set pointer(e){this.o===this.h&&(0,_r.throwIteratorAccessError)(),this.o.l=e}copy(){return new t(this.o,this.h,this.container,this.iteratorType)}},ya=class extends B1.default{constructor(e=[]){super(),this.h={},this.p=this._=this.h.L=this.h.B=this.h;let r=this;e.forEach(function(i){r.pushBack(i)})}V(e){let{L:r,B:i}=e;r.B=i,i.L=r,e===this.p&&(this.p=i),e===this._&&(this._=r),this.i-=1}G(e,r){let i=r.B,n={l:e,L:r,B:i};r.B=n,i.L=n,r===this.h&&(this.p=n),i===this.h&&(this._=n),this.i+=1}clear(){this.i=0,this.p=this._=this.h.L=this.h.B=this.h}begin(){return new mr(this.p,this.h,this)}end(){return new mr(this.h,this.h,this)}rBegin(){return new mr(this._,this.h,this,1)}rEnd(){return new mr(this.h,this.h,this,1)}front(){return this.p.l}back(){return this._.l}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=this.p;for(;e--;)r=r.B;return r.l}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=this.p;for(;e--;)r=r.B;return this.V(r),this.i}eraseElementByValue(e){let r=this.p;for(;r!==this.h;)r.l===e&&this.V(r),r=r.B;return this.i}eraseElementByIterator(e){let r=e.o;return r===this.h&&(0,_r.throwIteratorAccessError)(),e=e.next(),this.V(r),e}pushBack(e){return this.G(e,this._),this.i}popBack(){if(this.i===0)return;let e=this._.l;return this.V(this._),e}pushFront(e){return this.G(e,this.h),this.i}popFront(){if(this.i===0)return;let e=this.p.l;return this.V(this.p),e}setElementByPos(e,r){if(e<0||e>this.i-1)throw new RangeError;let i=this.p;for(;e--;)i=i.B;i.l=r}insert(e,r,i=1){if(e<0||e>this.i)throw new RangeError;if(i<=0)return this.i;if(e===0)for(;i--;)this.pushFront(r);else if(e===this.i)for(;i--;)this.pushBack(r);else{let n=this.p;for(let s=1;s<e;++s)n=n.B;let o=n.B;for(this.i+=i;i--;)n.B={l:r,L:n},n.B.L=n,n=n.B;n.B=o,o.L=n}return this.i}find(e){let r=this.p;for(;r!==this.h;){if(r.l===e)return new mr(r,this.h,this);r=r.B}return this.end()}reverse(){if(this.i<=1)return;let e=this.p,r=this._,i=0;for(;i<<1<this.i;){let n=e.l;e.l=r.l,r.l=n,e=e.B,r=r.L,i+=1}}unique(){if(this.i<=1)return this.i;let e=this.p;for(;e!==this.h;){let r=e;for(;r.B!==this.h&&r.l===r.B.l;)r=r.B,this.i-=1;e.B=r.B,e.B.L=e,e=e.B}return this.i}sort(e){if(this.i<=1)return;let r=[];this.forEach(function(n){r.push(n)}),r.sort(e);let i=this.p;r.forEach(function(n){i.l=n,i=i.B})}merge(e){let r=this;if(this.i===0)e.forEach(function(i){r.pushBack(i)});else{let i=this.p;e.forEach(function(n){for(;i!==r.h&&i.l<=n;)i=i.B;r.G(n,i.L)})}return this.i}forEach(e){let r=this.p,i=0;for(;r!==this.h;)e(r.l,i++,this),r=r.B}[Symbol.iterator](){return function*(){if(this.i===0)return;let e=this.p;for(;e!==this.h;)yield e.l,e=e.B}.bind(this)()}},k1=ya;Wn.default=k1});var np=M($n=>{\"use strict\";v();m();_();Object.defineProperty($n,\"t\",{value:!0});$n.default=void 0;var x1=L1(qn()),M1=pa();function L1(t){return t&&t.t?t:{default:t}}var vr=class t extends M1.RandomIterator{constructor(e,r,i){super(e,i),this.container=r}copy(){return new t(this.o,this.container,this.iteratorType)}},ba=class extends x1.default{constructor(e=[],r=4096){super(),this.j=0,this.D=0,this.R=0,this.N=0,this.P=0,this.A=[];let i=(()=>{if(typeof e.length==\"number\")return e.length;if(typeof e.size==\"number\")return e.size;if(typeof e.size==\"function\")return e.size();throw new TypeError(\"Cannot get the length or size of the container\")})();this.F=r,this.P=Math.max(Math.ceil(i/this.F),1);for(let s=0;s<this.P;++s)this.A.push(new Array(this.F));let n=Math.ceil(i/this.F);this.j=this.R=(this.P>>1)-(n>>1),this.D=this.N=this.F-i%this.F>>1;let o=this;e.forEach(function(s){o.pushBack(s)})}T(){let e=[],r=Math.max(this.P>>1,1);for(let i=0;i<r;++i)e[i]=new Array(this.F);for(let i=this.j;i<this.P;++i)e[e.length]=this.A[i];for(let i=0;i<this.R;++i)e[e.length]=this.A[i];e[e.length]=[...this.A[this.R]],this.j=r,this.R=e.length-1;for(let i=0;i<r;++i)e[e.length]=new Array(this.F);this.A=e,this.P=e.length}O(e){let r=this.D+e+1,i=r%this.F,n=i-1,o=this.j+(r-i)/this.F;return i===0&&(o-=1),o%=this.P,n<0&&(n+=this.F),{curNodeBucketIndex:o,curNodePointerIndex:n}}clear(){this.A=[new Array(this.F)],this.P=1,this.j=this.R=this.i=0,this.D=this.N=this.F>>1}begin(){return new vr(0,this)}end(){return new vr(this.i,this)}rBegin(){return new vr(this.i-1,this,1)}rEnd(){return new vr(-1,this,1)}front(){if(this.i!==0)return this.A[this.j][this.D]}back(){if(this.i!==0)return this.A[this.R][this.N]}pushBack(e){return this.i&&(this.N<this.F-1?this.N+=1:this.R<this.P-1?(this.R+=1,this.N=0):(this.R=0,this.N=0),this.R===this.j&&this.N===this.D&&this.T()),this.i+=1,this.A[this.R][this.N]=e,this.i}popBack(){if(this.i===0)return;let e=this.A[this.R][this.N];return this.i!==1&&(this.N>0?this.N-=1:this.R>0?(this.R-=1,this.N=this.F-1):(this.R=this.P-1,this.N=this.F-1)),this.i-=1,e}pushFront(e){return this.i&&(this.D>0?this.D-=1:this.j>0?(this.j-=1,this.D=this.F-1):(this.j=this.P-1,this.D=this.F-1),this.j===this.R&&this.D===this.N&&this.T()),this.i+=1,this.A[this.j][this.D]=e,this.i}popFront(){if(this.i===0)return;let e=this.A[this.j][this.D];return this.i!==1&&(this.D<this.F-1?this.D+=1:this.j<this.P-1?(this.j+=1,this.D=0):(this.j=0,this.D=0)),this.i-=1,e}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let{curNodeBucketIndex:r,curNodePointerIndex:i}=this.O(e);return this.A[r][i]}setElementByPos(e,r){if(e<0||e>this.i-1)throw new RangeError;let{curNodeBucketIndex:i,curNodePointerIndex:n}=this.O(e);this.A[i][n]=r}insert(e,r,i=1){if(e<0||e>this.i)throw new RangeError;if(e===0)for(;i--;)this.pushFront(r);else if(e===this.i)for(;i--;)this.pushBack(r);else{let n=[];for(let o=e;o<this.i;++o)n.push(this.getElementByPos(o));this.cut(e-1);for(let o=0;o<i;++o)this.pushBack(r);for(let o=0;o<n.length;++o)this.pushBack(n[o])}return this.i}cut(e){if(e<0)return this.clear(),0;let{curNodeBucketIndex:r,curNodePointerIndex:i}=this.O(e);return this.R=r,this.N=i,this.i=e+1,this.i}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;if(e===0)this.popFront();else if(e===this.i-1)this.popBack();else{let r=[];for(let n=e+1;n<this.i;++n)r.push(this.getElementByPos(n));this.cut(e),this.popBack();let i=this;r.forEach(function(n){i.pushBack(n)})}return this.i}eraseElementByValue(e){if(this.i===0)return 0;let r=[];for(let n=0;n<this.i;++n){let o=this.getElementByPos(n);o!==e&&r.push(o)}let i=r.length;for(let n=0;n<i;++n)this.setElementByPos(n,r[n]);return this.cut(i-1)}eraseElementByIterator(e){let r=e.o;return this.eraseElementByPos(r),e=e.next(),e}find(e){for(let r=0;r<this.i;++r)if(this.getElementByPos(r)===e)return new vr(r,this);return this.end()}reverse(){let e=0,r=this.i-1;for(;e<r;){let i=this.getElementByPos(e);this.setElementByPos(e,this.getElementByPos(r)),this.setElementByPos(r,i),e+=1,r-=1}}unique(){if(this.i<=1)return this.i;let e=1,r=this.getElementByPos(0);for(let i=1;i<this.i;++i){let n=this.getElementByPos(i);n!==r&&(r=n,this.setElementByPos(e++,n))}for(;this.i>e;)this.popBack();return this.i}sort(e){let r=[];for(let i=0;i<this.i;++i)r.push(this.getElementByPos(i));r.sort(e);for(let i=0;i<this.i;++i)this.setElementByPos(i,r[i])}shrinkToFit(){if(this.i===0)return;let e=[];this.forEach(function(r){e.push(r)}),this.P=Math.max(Math.ceil(this.i/this.F),1),this.i=this.j=this.R=this.D=this.N=0,this.A=[];for(let r=0;r<this.P;++r)this.A.push(new Array(this.F));for(let r=0;r<e.length;++r)this.pushBack(e[r])}forEach(e){for(let r=0;r<this.i;++r)e(this.getElementByPos(r),r,this)}[Symbol.iterator](){return function*(){for(let e=0;e<this.i;++e)yield this.getElementByPos(e)}.bind(this)()}},U1=ba;$n.default=U1});var sp=M(Xr=>{\"use strict\";v();m();_();Object.defineProperty(Xr,\"t\",{value:!0});Xr.TreeNodeEnableIndex=Xr.TreeNode=void 0;var Hn=class{constructor(e,r){this.ee=1,this.u=void 0,this.l=void 0,this.U=void 0,this.W=void 0,this.tt=void 0,this.u=e,this.l=r}L(){let e=this;if(e.ee===1&&e.tt.tt===e)e=e.W;else if(e.U)for(e=e.U;e.W;)e=e.W;else{let r=e.tt;for(;r.U===e;)e=r,r=e.tt;e=r}return e}B(){let e=this;if(e.W){for(e=e.W;e.U;)e=e.U;return e}else{let r=e.tt;for(;r.W===e;)e=r,r=e.tt;return e.W!==r?r:e}}te(){let e=this.tt,r=this.W,i=r.U;return e.tt===this?e.tt=r:e.U===this?e.U=r:e.W=r,r.tt=e,r.U=this,this.tt=r,this.W=i,i&&(i.tt=this),r}se(){let e=this.tt,r=this.U,i=r.W;return e.tt===this?e.tt=r:e.U===this?e.U=r:e.W=r,r.tt=e,r.W=this,this.tt=r,this.U=i,i&&(i.tt=this),r}};Xr.TreeNode=Hn;var wa=class extends Hn{constructor(){super(...arguments),this.rt=1}te(){let e=super.te();return this.ie(),e.ie(),e}se(){let e=super.se();return this.ie(),e.ie(),e}ie(){this.rt=1,this.U&&(this.rt+=this.U.rt),this.W&&(this.rt+=this.W.rt)}};Xr.TreeNodeEnableIndex=wa});var ma=M(Vn=>{\"use strict\";v();m();_();Object.defineProperty(Vn,\"t\",{value:!0});Vn.default=void 0;var op=sp(),N1=at(),ap=lt(),_a=class extends N1.Container{constructor(e=function(i,n){return i<n?-1:i>n?1:0},r=!1){super(),this.Y=void 0,this.v=e,r?(this.re=op.TreeNodeEnableIndex,this.M=function(i,n,o){let s=this.ne(i,n,o);if(s){let a=s.tt;for(;a!==this.h;)a.rt+=1,a=a.tt;let u=this.he(s);if(u){let{parentNode:c,grandParent:h,curNode:d}=u;c.ie(),h.ie(),d.ie()}}return this.i},this.V=function(i){let n=this.fe(i);for(;n!==this.h;)n.rt-=1,n=n.tt}):(this.re=op.TreeNode,this.M=function(i,n,o){let s=this.ne(i,n,o);return s&&this.he(s),this.i},this.V=this.fe),this.h=new this.re}X(e,r){let i=this.h;for(;e;){let n=this.v(e.u,r);if(n<0)e=e.W;else if(n>0)i=e,e=e.U;else return e}return i}Z(e,r){let i=this.h;for(;e;)this.v(e.u,r)<=0?e=e.W:(i=e,e=e.U);return i}$(e,r){let i=this.h;for(;e;){let n=this.v(e.u,r);if(n<0)i=e,e=e.W;else if(n>0)e=e.U;else return e}return i}rr(e,r){let i=this.h;for(;e;)this.v(e.u,r)<0?(i=e,e=e.W):e=e.U;return i}ue(e){for(;;){let r=e.tt;if(r===this.h)return;if(e.ee===1){e.ee=0;return}if(e===r.U){let i=r.W;if(i.ee===1)i.ee=0,r.ee=1,r===this.Y?this.Y=r.te():r.te();else if(i.W&&i.W.ee===1){i.ee=r.ee,r.ee=0,i.W.ee=0,r===this.Y?this.Y=r.te():r.te();return}else i.U&&i.U.ee===1?(i.ee=1,i.U.ee=0,i.se()):(i.ee=1,e=r)}else{let i=r.U;if(i.ee===1)i.ee=0,r.ee=1,r===this.Y?this.Y=r.se():r.se();else if(i.U&&i.U.ee===1){i.ee=r.ee,r.ee=0,i.U.ee=0,r===this.Y?this.Y=r.se():r.se();return}else i.W&&i.W.ee===1?(i.ee=1,i.W.ee=0,i.te()):(i.ee=1,e=r)}}}fe(e){if(this.i===1)return this.clear(),this.h;let r=e;for(;r.U||r.W;){if(r.W)for(r=r.W;r.U;)r=r.U;else r=r.U;[e.u,r.u]=[r.u,e.u],[e.l,r.l]=[r.l,e.l],e=r}this.h.U===r?this.h.U=r.tt:this.h.W===r&&(this.h.W=r.tt),this.ue(r);let i=r.tt;return r===i.U?i.U=void 0:i.W=void 0,this.i-=1,this.Y.ee=0,i}oe(e,r){return e===void 0?!1:this.oe(e.U,r)||r(e)?!0:this.oe(e.W,r)}he(e){for(;;){let r=e.tt;if(r.ee===0)return;let i=r.tt;if(r===i.U){let n=i.W;if(n&&n.ee===1){if(n.ee=r.ee=0,i===this.Y)return;i.ee=1,e=i;continue}else if(e===r.W){if(e.ee=0,e.U&&(e.U.tt=r),e.W&&(e.W.tt=i),r.W=e.U,i.U=e.W,e.U=r,e.W=i,i===this.Y)this.Y=e,this.h.tt=e;else{let o=i.tt;o.U===i?o.U=e:o.W=e}return e.tt=i.tt,r.tt=e,i.tt=e,i.ee=1,{parentNode:r,grandParent:i,curNode:e}}else r.ee=0,i===this.Y?this.Y=i.se():i.se(),i.ee=1}else{let n=i.U;if(n&&n.ee===1){if(n.ee=r.ee=0,i===this.Y)return;i.ee=1,e=i;continue}else if(e===r.U){if(e.ee=0,e.U&&(e.U.tt=i),e.W&&(e.W.tt=r),i.W=e.U,r.U=e.W,e.U=i,e.W=r,i===this.Y)this.Y=e,this.h.tt=e;else{let o=i.tt;o.U===i?o.U=e:o.W=e}return e.tt=i.tt,r.tt=e,i.tt=e,i.ee=1,{parentNode:r,grandParent:i,curNode:e}}else r.ee=0,i===this.Y?this.Y=i.te():i.te(),i.ee=1}return}}ne(e,r,i){if(this.Y===void 0){this.i+=1,this.Y=new this.re(e,r),this.Y.ee=0,this.Y.tt=this.h,this.h.tt=this.Y,this.h.U=this.Y,this.h.W=this.Y;return}let n,o=this.h.U,s=this.v(o.u,e);if(s===0){o.l=r;return}else if(s>0)o.U=new this.re(e,r),o.U.tt=o,n=o.U,this.h.U=n;else{let a=this.h.W,u=this.v(a.u,e);if(u===0){a.l=r;return}else if(u<0)a.W=new this.re(e,r),a.W.tt=a,n=a.W,this.h.W=n;else{if(i!==void 0){let c=i.o;if(c!==this.h){let h=this.v(c.u,e);if(h===0){c.l=r;return}else if(h>0){let d=c.L(),g=this.v(d.u,e);if(g===0){d.l=r;return}else g<0&&(n=new this.re(e,r),d.W===void 0?(d.W=n,n.tt=d):(c.U=n,n.tt=c))}}}if(n===void 0)for(n=this.Y;;){let c=this.v(n.u,e);if(c>0){if(n.U===void 0){n.U=new this.re(e,r),n.U.tt=n,n=n.U;break}n=n.U}else if(c<0){if(n.W===void 0){n.W=new this.re(e,r),n.W.tt=n,n=n.W;break}n=n.W}else{n.l=r;return}}}}return this.i+=1,n}I(e,r){for(;e;){let i=this.v(e.u,r);if(i<0)e=e.W;else if(i>0)e=e.U;else return e}return e||this.h}clear(){this.i=0,this.Y=void 0,this.h.tt=void 0,this.h.U=this.h.W=void 0}updateKeyByIterator(e,r){let i=e.o;if(i===this.h&&(0,ap.throwIteratorAccessError)(),this.i===1)return i.u=r,!0;if(i===this.h.U)return this.v(i.B().u,r)>0?(i.u=r,!0):!1;if(i===this.h.W)return this.v(i.L().u,r)<0?(i.u=r,!0):!1;let n=i.L().u;if(this.v(n,r)>=0)return!1;let o=i.B().u;return this.v(o,r)<=0?!1:(i.u=r,!0)}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=0,i=this;return this.oe(this.Y,function(n){return e===r?(i.V(n),!0):(r+=1,!1)}),this.i}eraseElementByKey(e){if(this.i===0)return!1;let r=this.I(this.Y,e);return r===this.h?!1:(this.V(r),!0)}eraseElementByIterator(e){let r=e.o;r===this.h&&(0,ap.throwIteratorAccessError)();let i=r.W===void 0;return e.iteratorType===0?i&&e.next():(!i||r.U===void 0)&&e.next(),this.V(r),e}forEach(e){let r=0;for(let i of this)e(i,r++,this)}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r,i=0;for(let n of this){if(i===e){r=n;break}i+=1}return r}getHeight(){if(this.i===0)return 0;let e=function(r){return r?Math.max(e(r.U),e(r.W))+1:0};return e(this.Y)}},q1=_a;Vn.default=q1});var Ea=M(Kn=>{\"use strict\";v();m();_();Object.defineProperty(Kn,\"t\",{value:!0});Kn.default=void 0;var D1=at(),zn=lt(),va=class extends D1.ContainerIterator{constructor(e,r,i){super(i),this.o=e,this.h=r,this.iteratorType===0?(this.pre=function(){return this.o===this.h.U&&(0,zn.throwIteratorAccessError)(),this.o=this.o.L(),this},this.next=function(){return this.o===this.h&&(0,zn.throwIteratorAccessError)(),this.o=this.o.B(),this}):(this.pre=function(){return this.o===this.h.W&&(0,zn.throwIteratorAccessError)(),this.o=this.o.B(),this},this.next=function(){return this.o===this.h&&(0,zn.throwIteratorAccessError)(),this.o=this.o.L(),this})}get index(){let e=this.o,r=this.h.tt;if(e===this.h)return r?r.rt-1:0;let i=0;for(e.U&&(i+=e.U.rt);e!==r;){let n=e.tt;e===n.W&&(i+=1,n.U&&(i+=n.U.rt)),e=n}return i}},j1=va;Kn.default=j1});var up=M(Gn=>{\"use strict\";v();m();_();Object.defineProperty(Gn,\"t\",{value:!0});Gn.default=void 0;var F1=lp(ma()),W1=lp(Ea()),$1=lt();function lp(t){return t&&t.t?t:{default:t}}var Ke=class t extends W1.default{constructor(e,r,i,n){super(e,r,n),this.container=i}get pointer(){return this.o===this.h&&(0,$1.throwIteratorAccessError)(),this.o.u}copy(){return new t(this.o,this.h,this.container,this.iteratorType)}},Sa=class extends F1.default{constructor(e=[],r,i){super(r,i);let n=this;e.forEach(function(o){n.insert(o)})}*K(e){e!==void 0&&(yield*this.K(e.U),yield e.u,yield*this.K(e.W))}begin(){return new Ke(this.h.U||this.h,this.h,this)}end(){return new Ke(this.h,this.h,this)}rBegin(){return new Ke(this.h.W||this.h,this.h,this,1)}rEnd(){return new Ke(this.h,this.h,this,1)}front(){return this.h.U?this.h.U.u:void 0}back(){return this.h.W?this.h.W.u:void 0}insert(e,r){return this.M(e,void 0,r)}find(e){let r=this.I(this.Y,e);return new Ke(r,this.h,this)}lowerBound(e){let r=this.X(this.Y,e);return new Ke(r,this.h,this)}upperBound(e){let r=this.Z(this.Y,e);return new Ke(r,this.h,this)}reverseLowerBound(e){let r=this.$(this.Y,e);return new Ke(r,this.h,this)}reverseUpperBound(e){let r=this.rr(this.Y,e);return new Ke(r,this.h,this)}union(e){let r=this;return e.forEach(function(i){r.insert(i)}),this.i}[Symbol.iterator](){return this.K(this.Y)}},H1=Sa;Gn.default=H1});var cp=M(Qn=>{\"use strict\";v();m();_();Object.defineProperty(Qn,\"t\",{value:!0});Qn.default=void 0;var V1=fp(ma()),z1=fp(Ea()),K1=lt();function fp(t){return t&&t.t?t:{default:t}}var Ge=class t extends z1.default{constructor(e,r,i,n){super(e,r,n),this.container=i}get pointer(){this.o===this.h&&(0,K1.throwIteratorAccessError)();let e=this;return new Proxy([],{get(r,i){if(i===\"0\")return e.o.u;if(i===\"1\")return e.o.l},set(r,i,n){if(i!==\"1\")throw new TypeError(\"props must be 1\");return e.o.l=n,!0}})}copy(){return new t(this.o,this.h,this.container,this.iteratorType)}},Aa=class extends V1.default{constructor(e=[],r,i){super(r,i);let n=this;e.forEach(function(o){n.setElement(o[0],o[1])})}*K(e){e!==void 0&&(yield*this.K(e.U),yield[e.u,e.l],yield*this.K(e.W))}begin(){return new Ge(this.h.U||this.h,this.h,this)}end(){return new Ge(this.h,this.h,this)}rBegin(){return new Ge(this.h.W||this.h,this.h,this,1)}rEnd(){return new Ge(this.h,this.h,this,1)}front(){if(this.i===0)return;let e=this.h.U;return[e.u,e.l]}back(){if(this.i===0)return;let e=this.h.W;return[e.u,e.l]}lowerBound(e){let r=this.X(this.Y,e);return new Ge(r,this.h,this)}upperBound(e){let r=this.Z(this.Y,e);return new Ge(r,this.h,this)}reverseLowerBound(e){let r=this.$(this.Y,e);return new Ge(r,this.h,this)}reverseUpperBound(e){let r=this.rr(this.Y,e);return new Ge(r,this.h,this)}setElement(e,r,i){return this.M(e,r,i)}find(e){let r=this.I(this.Y,e);return new Ge(r,this.h,this)}getElementByKey(e){return this.I(this.Y,e).l}union(e){let r=this;return e.forEach(function(i){r.setElement(i[0],i[1])}),this.i}[Symbol.iterator](){return this.K(this.Y)}},G1=Aa;Qn.default=G1});var Ta=M(Ia=>{\"use strict\";v();m();_();Object.defineProperty(Ia,\"t\",{value:!0});Ia.default=Q1;function Q1(t){let e=typeof t;return e===\"object\"&&t!==null||e===\"function\"}});var Pa=M(Zr=>{\"use strict\";v();m();_();Object.defineProperty(Zr,\"t\",{value:!0});Zr.HashContainerIterator=Zr.HashContainer=void 0;var hp=at(),Ra=Y1(Ta()),Ii=lt();function Y1(t){return t&&t.t?t:{default:t}}var Ca=class extends hp.ContainerIterator{constructor(e,r,i){super(i),this.o=e,this.h=r,this.iteratorType===0?(this.pre=function(){return this.o.L===this.h&&(0,Ii.throwIteratorAccessError)(),this.o=this.o.L,this},this.next=function(){return this.o===this.h&&(0,Ii.throwIteratorAccessError)(),this.o=this.o.B,this}):(this.pre=function(){return this.o.B===this.h&&(0,Ii.throwIteratorAccessError)(),this.o=this.o.B,this},this.next=function(){return this.o===this.h&&(0,Ii.throwIteratorAccessError)(),this.o=this.o.L,this})}};Zr.HashContainerIterator=Ca;var Ba=class extends hp.Container{constructor(){super(),this.H=[],this.g={},this.HASH_TAG=Symbol(\"@@HASH_TAG\"),Object.setPrototypeOf(this.g,null),this.h={},this.h.L=this.h.B=this.p=this._=this.h}V(e){let{L:r,B:i}=e;r.B=i,i.L=r,e===this.p&&(this.p=i),e===this._&&(this._=r),this.i-=1}M(e,r,i){i===void 0&&(i=(0,Ra.default)(e));let n;if(i){let o=e[this.HASH_TAG];if(o!==void 0)return this.H[o].l=r,this.i;Object.defineProperty(e,this.HASH_TAG,{value:this.H.length,configurable:!0}),n={u:e,l:r,L:this._,B:this.h},this.H.push(n)}else{let o=this.g[e];if(o)return o.l=r,this.i;n={u:e,l:r,L:this._,B:this.h},this.g[e]=n}return this.i===0?(this.p=n,this.h.B=n):this._.B=n,this._=n,this.h.L=n,++this.i}I(e,r){if(r===void 0&&(r=(0,Ra.default)(e)),r){let i=e[this.HASH_TAG];return i===void 0?this.h:this.H[i]}else return this.g[e]||this.h}clear(){let e=this.HASH_TAG;this.H.forEach(function(r){delete r.u[e]}),this.H=[],this.g={},Object.setPrototypeOf(this.g,null),this.i=0,this.p=this._=this.h.L=this.h.B=this.h}eraseElementByKey(e,r){let i;if(r===void 0&&(r=(0,Ra.default)(e)),r){let n=e[this.HASH_TAG];if(n===void 0)return!1;delete e[this.HASH_TAG],i=this.H[n],delete this.H[n]}else{if(i=this.g[e],i===void 0)return!1;delete this.g[e]}return this.V(i),!0}eraseElementByIterator(e){let r=e.o;return r===this.h&&(0,Ii.throwIteratorAccessError)(),this.V(r),e.next()}eraseElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=this.p;for(;e--;)r=r.B;return this.V(r),this.i}};Zr.HashContainer=Ba});var pp=M(Yn=>{\"use strict\";v();m();_();Object.defineProperty(Yn,\"t\",{value:!0});Yn.default=void 0;var dp=Pa(),J1=lt(),Er=class t extends dp.HashContainerIterator{constructor(e,r,i,n){super(e,r,n),this.container=i}get pointer(){return this.o===this.h&&(0,J1.throwIteratorAccessError)(),this.o.u}copy(){return new t(this.o,this.h,this.container,this.iteratorType)}},Oa=class extends dp.HashContainer{constructor(e=[]){super();let r=this;e.forEach(function(i){r.insert(i)})}begin(){return new Er(this.p,this.h,this)}end(){return new Er(this.h,this.h,this)}rBegin(){return new Er(this._,this.h,this,1)}rEnd(){return new Er(this.h,this.h,this,1)}front(){return this.p.u}back(){return this._.u}insert(e,r){return this.M(e,void 0,r)}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=this.p;for(;e--;)r=r.B;return r.u}find(e,r){let i=this.I(e,r);return new Er(i,this.h,this)}forEach(e){let r=0,i=this.p;for(;i!==this.h;)e(i.u,r++,this),i=i.B}[Symbol.iterator](){return function*(){let e=this.p;for(;e!==this.h;)yield e.u,e=e.B}.bind(this)()}},X1=Oa;Yn.default=X1});var yp=M(Jn=>{\"use strict\";v();m();_();Object.defineProperty(Jn,\"t\",{value:!0});Jn.default=void 0;var gp=Pa(),Z1=tv(Ta()),ev=lt();function tv(t){return t&&t.t?t:{default:t}}var Sr=class t extends gp.HashContainerIterator{constructor(e,r,i,n){super(e,r,n),this.container=i}get pointer(){this.o===this.h&&(0,ev.throwIteratorAccessError)();let e=this;return new Proxy([],{get(r,i){if(i===\"0\")return e.o.u;if(i===\"1\")return e.o.l},set(r,i,n){if(i!==\"1\")throw new TypeError(\"props must be 1\");return e.o.l=n,!0}})}copy(){return new t(this.o,this.h,this.container,this.iteratorType)}},ka=class extends gp.HashContainer{constructor(e=[]){super();let r=this;e.forEach(function(i){r.setElement(i[0],i[1])})}begin(){return new Sr(this.p,this.h,this)}end(){return new Sr(this.h,this.h,this)}rBegin(){return new Sr(this._,this.h,this,1)}rEnd(){return new Sr(this.h,this.h,this,1)}front(){if(this.i!==0)return[this.p.u,this.p.l]}back(){if(this.i!==0)return[this._.u,this._.l]}setElement(e,r,i){return this.M(e,r,i)}getElementByKey(e,r){if(r===void 0&&(r=(0,Z1.default)(e)),r){let n=e[this.HASH_TAG];return n!==void 0?this.H[n].l:void 0}let i=this.g[e];return i?i.l:void 0}getElementByPos(e){if(e<0||e>this.i-1)throw new RangeError;let r=this.p;for(;e--;)r=r.B;return[r.u,r.l]}find(e,r){let i=this.I(e,r);return new Sr(i,this.h,this)}forEach(e){let r=0,i=this.p;for(;i!==this.h;)e([i.u,i.l],r++,this),i=i.B}[Symbol.iterator](){return function*(){let e=this.p;for(;e!==this.h;)yield[e.u,e.l],e=e.B}.bind(this)()}},rv=ka;Jn.default=rv});var bp=M(je=>{\"use strict\";v();m();_();Object.defineProperty(je,\"t\",{value:!0});Object.defineProperty(je,\"Deque\",{enumerable:!0,get:function(){return lv.default}});Object.defineProperty(je,\"HashMap\",{enumerable:!0,get:function(){return hv.default}});Object.defineProperty(je,\"HashSet\",{enumerable:!0,get:function(){return cv.default}});Object.defineProperty(je,\"LinkList\",{enumerable:!0,get:function(){return av.default}});Object.defineProperty(je,\"OrderedMap\",{enumerable:!0,get:function(){return fv.default}});Object.defineProperty(je,\"OrderedSet\",{enumerable:!0,get:function(){return uv.default}});Object.defineProperty(je,\"PriorityQueue\",{enumerable:!0,get:function(){return sv.default}});Object.defineProperty(je,\"Queue\",{enumerable:!0,get:function(){return nv.default}});Object.defineProperty(je,\"Stack\",{enumerable:!0,get:function(){return iv.default}});Object.defineProperty(je,\"Vector\",{enumerable:!0,get:function(){return ov.default}});var iv=ut(Zd()),nv=ut(ep()),sv=ut(tp()),ov=ut(rp()),av=ut(ip()),lv=ut(np()),uv=ut(up()),fv=ut(cp()),cv=ut(pp()),hv=ut(yp());function ut(t){return t&&t.t?t:{default:t}}});var _p=M((bN,wp)=>{\"use strict\";v();m();_();var dv=bp().OrderedSet,ft=ot()(\"number-allocator:trace\"),pv=ot()(\"number-allocator:error\");function Te(t,e){this.low=t,this.high=e}Te.prototype.equals=function(t){return this.low===t.low&&this.high===t.high};Te.prototype.compare=function(t){return this.low<t.low&&this.high<t.low?-1:t.low<this.low&&t.high<this.low?1:0};function ct(t,e){if(!(this instanceof ct))return new ct(t,e);this.min=t,this.max=e,this.ss=new dv([],(r,i)=>r.compare(i)),ft(\"Create\"),this.clear()}ct.prototype.firstVacant=function(){return this.ss.size()===0?null:this.ss.front().low};ct.prototype.alloc=function(){if(this.ss.size()===0)return ft(\"alloc():empty\"),null;let t=this.ss.begin(),e=t.pointer.low,r=t.pointer.high,i=e;return i+1<=r?this.ss.updateKeyByIterator(t,new Te(e+1,r)):this.ss.eraseElementByPos(0),ft(\"alloc():\"+i),i};ct.prototype.use=function(t){let e=new Te(t,t),r=this.ss.lowerBound(e);if(!r.equals(this.ss.end())){let i=r.pointer.low,n=r.pointer.high;return r.pointer.equals(e)?(this.ss.eraseElementByIterator(r),ft(\"use():\"+t),!0):i>t?!1:i===t?(this.ss.updateKeyByIterator(r,new Te(i+1,n)),ft(\"use():\"+t),!0):n===t?(this.ss.updateKeyByIterator(r,new Te(i,n-1)),ft(\"use():\"+t),!0):(this.ss.updateKeyByIterator(r,new Te(t+1,n)),this.ss.insert(new Te(i,t-1)),ft(\"use():\"+t),!0)}return ft(\"use():failed\"),!1};ct.prototype.free=function(t){if(t<this.min||t>this.max){pv(\"free():\"+t+\" is out of range\");return}let e=new Te(t,t),r=this.ss.upperBound(e);if(r.equals(this.ss.end())){if(r.equals(this.ss.begin())){this.ss.insert(e);return}r.pre();let i=r.pointer.high;r.pointer.high+1===t?this.ss.updateKeyByIterator(r,new Te(i,t)):this.ss.insert(e)}else if(r.equals(this.ss.begin()))if(t+1===r.pointer.low){let i=r.pointer.high;this.ss.updateKeyByIterator(r,new Te(t,i))}else this.ss.insert(e);else{let i=r.pointer.low,n=r.pointer.high;r.pre();let o=r.pointer.low;r.pointer.high+1===t?t+1===i?(this.ss.eraseElementByIterator(r),this.ss.updateKeyByIterator(r,new Te(o,n))):this.ss.updateKeyByIterator(r,new Te(o,t)):t+1===i?(this.ss.eraseElementByIterator(r.next()),this.ss.insert(new Te(t,n))):this.ss.insert(e)}ft(\"free():\"+t)};ct.prototype.clear=function(){ft(\"clear()\"),this.ss.clear(),this.ss.insert(new Te(this.min,this.max))};ct.prototype.intervalCount=function(){return this.ss.size()};ct.prototype.dump=function(){console.log(\"length:\"+this.ss.size());for(let t of this.ss)console.log(t)};wp.exports=ct});var xa=M((RN,mp)=>{v();m();_();var gv=_p();mp.exports.NumberAllocator=gv});var vp=M(La=>{\"use strict\";v();m();_();Object.defineProperty(La,\"__esModule\",{value:!0});var yv=Xd(),bv=xa(),Ma=class{constructor(e){e>0&&(this.aliasToTopic=new yv.LRUCache({max:e}),this.topicToAlias={},this.numberAllocator=new bv.NumberAllocator(1,e),this.max=e,this.length=0)}put(e,r){if(r===0||r>this.max)return!1;let i=this.aliasToTopic.get(r);return i&&delete this.topicToAlias[i],this.aliasToTopic.set(r,e),this.topicToAlias[e]=r,this.numberAllocator.use(r),this.length=this.aliasToTopic.size,!0}getTopicByAlias(e){return this.aliasToTopic.get(e)}getAliasByTopic(e){let r=this.topicToAlias[e];return typeof r<\"u\"&&this.aliasToTopic.get(r),r}clear(){this.aliasToTopic.clear(),this.topicToAlias={},this.numberAllocator.clear(),this.length=0}getLruAlias(){let e=this.numberAllocator.firstVacant();return e||[...this.aliasToTopic.keys()][this.aliasToTopic.size-1]}};La.default=Ma});var Ep=M(Ti=>{\"use strict\";v();m();_();var wv=Ti&&Ti.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Ti,\"__esModule\",{value:!0});var _v=Si(),mv=wv(vp()),vv=Yr(),Ev=(t,e)=>{t.log(\"_handleConnack\");let{options:r}=t,n=r.protocolVersion===5?e.reasonCode:e.returnCode;if(clearTimeout(t.connackTimer),delete t.topicAliasSend,e.properties){if(e.properties.topicAliasMaximum){if(e.properties.topicAliasMaximum>65535){t.emit(\"error\",new Error(\"topicAliasMaximum from broker is out of range\"));return}e.properties.topicAliasMaximum>0&&(t.topicAliasSend=new mv.default(e.properties.topicAliasMaximum))}e.properties.serverKeepAlive&&r.keepalive&&(r.keepalive=e.properties.serverKeepAlive,t._shiftPingInterval()),e.properties.maximumPacketSize&&(r.properties||(r.properties={}),r.properties.maximumPacketSize=e.properties.maximumPacketSize)}if(n===0)t.reconnecting=!1,t._onConnect(e);else if(n>0){let o=new vv.ErrorWithReasonCode(`Connection refused: ${_v.ReasonCodes[n]}`,n);t.emit(\"error\",o)}};Ti.default=Ev});var Sp=M(Ua=>{\"use strict\";v();m();_();Object.defineProperty(Ua,\"__esModule\",{value:!0});var Sv=(t,e,r)=>{t.log(\"handling pubrel packet\");let i=typeof r<\"u\"?r:t.noop,{messageId:n}=e,o={cmd:\"pubcomp\",messageId:n};t.incomingStore.get(e,(s,a)=>{s?t._sendPacket(o,i):(t.emit(\"message\",a.topic,a.payload,a),t.handleMessage(a,u=>{if(u)return i(u);t.incomingStore.del(a,t.noop),t._sendPacket(o,i)}))})};Ua.default=Sv});var Ap=M(Ri=>{\"use strict\";v();m();_();var Ci=Ri&&Ri.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Ri,\"__esModule\",{value:!0});var Av=Ci(Vd()),Iv=Ci(Kd()),Tv=Ci(Ep()),Rv=Ci(Si()),Cv=Ci(Sp()),Bv=(t,e,r)=>{let{options:i}=t;if(i.protocolVersion===5&&i.properties&&i.properties.maximumPacketSize&&i.properties.maximumPacketSize<e.length)return t.emit(\"error\",new Error(`exceeding packets size ${e.cmd}`)),t.end({reasonCode:149,properties:{reasonString:\"Maximum packet size was exceeded\"}}),t;switch(t.log(\"_handlePacket :: emitting packetreceive\"),t.emit(\"packetreceive\",e),e.cmd){case\"publish\":(0,Av.default)(t,e,r);break;case\"puback\":case\"pubrec\":case\"pubcomp\":case\"suback\":case\"unsuback\":(0,Rv.default)(t,e),r();break;case\"pubrel\":(0,Cv.default)(t,e,r);break;case\"connack\":(0,Tv.default)(t,e),r();break;case\"auth\":(0,Iv.default)(t,e),r();break;case\"pingresp\":t.pingResp=!0,r();break;case\"disconnect\":t.emit(\"disconnect\",e),r();break;default:t.log(\"_handlePacket :: unknown command\"),r();break}};Ri.default=Bv});var Ip=M(ei=>{\"use strict\";v();m();_();var Pv=ei&&ei.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(ei,\"__esModule\",{value:!0});ei.TypedEventEmitter=void 0;var Ov=Pv((ir(),Z(rr))),kv=Yr(),Xn=class{};ei.TypedEventEmitter=Xn;(0,kv.applyMixin)(Xn,Ov.default)});var Pi=M(Bi=>{\"use strict\";v();m();_();Object.defineProperty(Bi,\"__esModule\",{value:!0});Bi.isWebWorker=void 0;var xv=()=>typeof window<\"u\"&&typeof window.document<\"u\",Tp=()=>{var t,e;return!!(typeof self==\"object\"&&(!((e=(t=self?.constructor)===null||t===void 0?void 0:t.name)===null||e===void 0)&&e.includes(\"WorkerGlobalScope\")))},Mv=()=>typeof B<\"u\"&&B.product===\"ReactNative\",Lv=xv()||Tp()||Mv();Bi.isWebWorker=Tp();Bi.default=Lv});var Cp=M((Zn,Rp)=>{v();m();_();(function(t,e){typeof Zn==\"object\"&&typeof Rp<\"u\"?e(Zn):typeof define==\"function\"&&__webpack_require__.amdO?define([\"exports\"],e):(t=typeof globalThis<\"u\"?globalThis:t||self,e(t.fastUniqueNumbers={}))})(Zn,function(t){\"use strict\";var e=function(g){return function(y){var w=g(y);return y.add(w),w}},r=function(g){return function(y,w){return g.set(y,w),w}},i=Number.MAX_SAFE_INTEGER===void 0?9007199254740991:Number.MAX_SAFE_INTEGER,n=536870912,o=n*2,s=function(g,y){return function(w){var E=y.get(w),S=E===void 0?w.size:E<o?E+1:0;if(!w.has(S))return g(w,S);if(w.size<n){for(;w.has(S);)S=Math.floor(Math.random()*o);return g(w,S)}if(w.size>i)throw new Error(\"Congratulations, you created a collection of unique numbers which uses all available integers!\");for(;w.has(S);)S=Math.floor(Math.random()*i);return g(w,S)}},a=new WeakMap,u=r(a),c=s(u,a),h=e(c);t.addUniqueNumber=h,t.generateUniqueNumber=c})});var Pp=M((es,Bp)=>{v();m();_();(function(t,e){typeof es==\"object\"&&typeof Bp<\"u\"?e(es,Cp()):typeof define==\"function\"&&__webpack_require__.amdO?define([\"exports\",\"fast-unique-numbers\"],e):(t=typeof globalThis<\"u\"?globalThis:t||self,e(t.workerTimersBroker={},t.fastUniqueNumbers))})(es,function(t,e){\"use strict\";var r=function(s){return s.method!==void 0&&s.method===\"call\"},i=function(s){return s.error===null&&typeof s.id==\"number\"},n=function(s){var a=new Map([[0,function(){}]]),u=new Map([[0,function(){}]]),c=new Map,h=new Worker(s);h.addEventListener(\"message\",function(E){var S=E.data;if(r(S)){var I=S.params,C=I.timerId,R=I.timerType;if(R===\"interval\"){var U=a.get(C);if(typeof U==\"number\"){var N=c.get(U);if(N===void 0||N.timerId!==C||N.timerType!==R)throw new Error(\"The timer is in an undefined state.\")}else if(typeof U<\"u\")U();else throw new Error(\"The timer is in an undefined state.\")}else if(R===\"timeout\"){var W=u.get(C);if(typeof W==\"number\"){var K=c.get(W);if(K===void 0||K.timerId!==C||K.timerType!==R)throw new Error(\"The timer is in an undefined state.\")}else if(typeof W<\"u\")W(),u.delete(C);else throw new Error(\"The timer is in an undefined state.\")}}else if(i(S)){var z=S.id,Q=c.get(z);if(Q===void 0)throw new Error(\"The timer is in an undefined state.\");var de=Q.timerId,Gt=Q.timerType;c.delete(z),Gt===\"interval\"?a.delete(de):u.delete(de)}else{var pe=S.error.message;throw new Error(pe)}});var d=function(S){var I=e.generateUniqueNumber(c);c.set(I,{timerId:S,timerType:\"interval\"}),a.set(S,I),h.postMessage({id:I,method:\"clear\",params:{timerId:S,timerType:\"interval\"}})},g=function(S){var I=e.generateUniqueNumber(c);c.set(I,{timerId:S,timerType:\"timeout\"}),u.set(S,I),h.postMessage({id:I,method:\"clear\",params:{timerId:S,timerType:\"timeout\"}})},y=function(S){var I=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,C=e.generateUniqueNumber(a);return a.set(C,function(){S(),typeof a.get(C)==\"function\"&&h.postMessage({id:null,method:\"set\",params:{delay:I,now:performance.now(),timerId:C,timerType:\"interval\"}})}),h.postMessage({id:null,method:\"set\",params:{delay:I,now:performance.now(),timerId:C,timerType:\"interval\"}}),C},w=function(S){var I=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,C=e.generateUniqueNumber(u);return u.set(C,S),h.postMessage({id:null,method:\"set\",params:{delay:I,now:performance.now(),timerId:C,timerType:\"timeout\"}}),C};return{clearInterval:d,clearTimeout:g,setInterval:y,setTimeout:w}};t.load=n})});var kp=M((ts,Op)=>{v();m();_();(function(t,e){typeof ts==\"object\"&&typeof Op<\"u\"?e(ts,Pp()):typeof define==\"function\"&&__webpack_require__.amdO?define([\"exports\",\"worker-timers-broker\"],e):(t=typeof globalThis<\"u\"?globalThis:t||self,e(t.workerTimers={},t.workerTimersBroker))})(ts,function(t,e){\"use strict\";var r=function(h,d){var g=null;return function(){if(g!==null)return g;var y=new Blob([d],{type:\"application/javascript; charset=utf-8\"}),w=URL.createObjectURL(y);return g=h(w),setTimeout(function(){return URL.revokeObjectURL(w)}),g}},i=`(()=>{var e={472:(e,t,r)=>{var o,i;void 0===(i=\"function\"==typeof(o=function(){\"use strict\";var e=new Map,t=new Map,r=function(t){var r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id \"'.concat(t,'\".'));clearTimeout(r),e.delete(t)},o=function(e){var r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id \"'.concat(e,'\".'));clearTimeout(r),t.delete(e)},i=function(e,t){var r,o=performance.now();return{expected:o+(r=e-Math.max(0,o-t)),remainingDelay:r}},n=function e(t,r,o,i){var n=performance.now();n>o?postMessage({id:null,method:\"call\",params:{timerId:r,timerType:i}}):t.set(r,setTimeout(e,o-n,t,r,o,i))},a=function(t,r,o){var a=i(t,o),s=a.expected,d=a.remainingDelay;e.set(r,setTimeout(n,d,e,r,s,\"interval\"))},s=function(e,r,o){var a=i(e,o),s=a.expected,d=a.remainingDelay;t.set(r,setTimeout(n,d,t,r,s,\"timeout\"))};addEventListener(\"message\",(function(e){var t=e.data;try{if(\"clear\"===t.method){var i=t.id,n=t.params,d=n.timerId,c=n.timerType;if(\"interval\"===c)r(d),postMessage({error:null,id:i});else{if(\"timeout\"!==c)throw new Error('The given type \"'.concat(c,'\" is not supported'));o(d),postMessage({error:null,id:i})}}else{if(\"set\"!==t.method)throw new Error('The given method \"'.concat(t.method,'\" is not supported'));var u=t.params,l=u.delay,p=u.now,m=u.timerId,v=u.timerType;if(\"interval\"===v)a(l,m,p);else{if(\"timeout\"!==v)throw new Error('The given type \"'.concat(v,'\" is not supported'));s(l,m,p)}}}catch(e){postMessage({error:{message:e.message},id:t.id,result:null})}}))})?o.call(t,r,t,e):o)||(e.exports=i)}},t={};function r(o){var i=t[o];if(void 0!==i)return i.exports;var n=t[o]={exports:{}};return e[o](n,n.exports,r),n.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{\"use strict\";r(472)})()})();`,n=r(e.load,i),o=function(h){return n().clearInterval(h)},s=function(h){return n().clearTimeout(h)},a=function(){var h;return(h=n()).setInterval.apply(h,arguments)},u=function(){var h;return(h=n()).setTimeout.apply(h,arguments)};t.clearInterval=o,t.clearTimeout=s,t.setInterval=a,t.setTimeout=u})});var Mp=M(Rt=>{\"use strict\";v();m();_();var Uv=Rt&&Rt.__createBinding||(Object.create?function(t,e,r,i){i===void 0&&(i=r);var n=Object.getOwnPropertyDescriptor(e,r);(!n||(\"get\"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,i,n)}:function(t,e,r,i){i===void 0&&(i=r),t[i]=e[r]}),Nv=Rt&&Rt.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),qv=Rt&&Rt.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(t!=null)for(var r in t)r!==\"default\"&&Object.prototype.hasOwnProperty.call(t,r)&&Uv(e,t,r);return Nv(e,t),e};Object.defineProperty(Rt,\"__esModule\",{value:!0});var rs=qv(Pi()),xp=kp(),Dv={set:rs.default&&!rs.isWebWorker?xp.setTimeout:(t,e)=>setTimeout(t,e),clear:rs.default&&!rs.isWebWorker?xp.clearTimeout:t=>clearTimeout(t)};Rt.default=Dv});var qa=M(Oi=>{\"use strict\";v();m();_();var jv=Oi&&Oi.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Oi,\"__esModule\",{value:!0});var Lp=jv(Mp()),Na=class{constructor(e,r){this.keepalive=e*1e3,this.checkPing=r,this.reschedule()}clear(){this.timer&&(Lp.default.clear(this.timer),this.timer=null)}reschedule(){this.clear(),this.timer=Lp.default.set(()=>{this.checkPing(),this.timer&&this.reschedule()},this.keepalive)}};Oi.default=Na});var ns=M(Qe=>{\"use strict\";v();m();_();var Fv=Qe&&Qe.__createBinding||(Object.create?function(t,e,r,i){i===void 0&&(i=r);var n=Object.getOwnPropertyDescriptor(e,r);(!n||(\"get\"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,i,n)}:function(t,e,r,i){i===void 0&&(i=r),t[i]=e[r]}),Wv=Qe&&Qe.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),jp=Qe&&Qe.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(t!=null)for(var r in t)r!==\"default\"&&Object.prototype.hasOwnProperty.call(t,r)&&Fv(e,t,r);return Wv(e,t),e},Vt=Qe&&Qe.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Qe,\"__esModule\",{value:!0});var $v=Vt(Gu()),Da=Vt(Nd()),Hv=Vt(Yo()),Vv=Dt(),Up=Vt(Fd()),Np=jp($d()),zv=Vt(ot()),is=Vt(Zo()),Kv=Vt(Ap()),Fa=Yr(),Gv=Ip(),Qv=Vt(qa()),qp=jp(Pi()),ja=globalThis.setImmediate||((...t)=>{let e=t.shift();(0,Fa.nextTick)(()=>{e(...t)})}),Dp={keepalive:60,reschedulePings:!0,protocolId:\"MQTT\",protocolVersion:4,reconnectPeriod:1e3,connectTimeout:30*1e3,clean:!0,resubscribe:!0,writeCache:!0},Wa=class t extends Gv.TypedEventEmitter{static defaultId(){return`mqttjs_${Math.random().toString(16).substr(2,8)}`}constructor(e,r){super(),this.options=r||{};for(let i in Dp)typeof this.options[i]>\"u\"?this.options[i]=Dp[i]:this.options[i]=r[i];this.log=this.options.log||(0,zv.default)(\"mqttjs:client\"),this.noop=this._noop.bind(this),this.log(\"MqttClient :: version:\",\"5.4.0\"),qp.isWebWorker?this.log(\"MqttClient :: environment\",\"webworker\"):this.log(\"MqttClient :: environment\",qp.default?\"browser\":\"node\"),this.log(\"MqttClient :: options.protocol\",r.protocol),this.log(\"MqttClient :: options.protocolVersion\",r.protocolVersion),this.log(\"MqttClient :: options.username\",r.username),this.log(\"MqttClient :: options.keepalive\",r.keepalive),this.log(\"MqttClient :: options.reconnectPeriod\",r.reconnectPeriod),this.log(\"MqttClient :: options.rejectUnauthorized\",r.rejectUnauthorized),this.log(\"MqttClient :: options.properties.topicAliasMaximum\",r.properties?r.properties.topicAliasMaximum:void 0),this.options.clientId=typeof r.clientId==\"string\"?r.clientId:t.defaultId(),this.log(\"MqttClient :: clientId\",this.options.clientId),this.options.customHandleAcks=r.protocolVersion===5&&r.customHandleAcks?r.customHandleAcks:(...i)=>{i[3](null,0)},this.options.writeCache||(Da.default.writeToStream.cacheNumbers=!1),this.streamBuilder=e,this.messageIdProvider=typeof this.options.messageIdProvider>\"u\"?new Hv.default:this.options.messageIdProvider,this.outgoingStore=r.outgoingStore||new is.default,this.incomingStore=r.incomingStore||new is.default,this.queueQoSZero=r.queueQoSZero===void 0?!0:r.queueQoSZero,this._resubscribeTopics={},this.messageIdToTopic={},this.pingTimer=null,this.connected=!1,this.disconnecting=!1,this.reconnecting=!1,this.queue=[],this.connackTimer=null,this.reconnectTimer=null,this._storeProcessing=!1,this._packetIdsDuringStoreProcessing={},this._storeProcessingQueue=[],this.outgoing={},this._firstConnection=!0,r.properties&&r.properties.topicAliasMaximum>0&&(r.properties.topicAliasMaximum>65535?this.log(\"MqttClient :: options.properties.topicAliasMaximum is out of range\"):this.topicAliasRecv=new $v.default(r.properties.topicAliasMaximum)),this.on(\"connect\",()=>{let{queue:i}=this,n=()=>{let o=i.shift();this.log(\"deliver :: entry %o\",o);let s=null;if(!o){this._resubscribe();return}s=o.packet,this.log(\"deliver :: call _sendPacket for %o\",s);let a=!0;s.messageId&&s.messageId!==0&&(this.messageIdProvider.register(s.messageId)||(a=!1)),a?this._sendPacket(s,u=>{o.cb&&o.cb(u),n()}):(this.log(\"messageId: %d has already used. The message is skipped and removed.\",s.messageId),n())};this.log(\"connect :: sending queued packets\"),n()}),this.on(\"close\",()=>{this.log(\"close :: connected set to `false`\"),this.connected=!1,this.log(\"close :: clearing connackTimer\"),clearTimeout(this.connackTimer),this.log(\"close :: clearing ping timer\"),this.pingTimer&&(this.pingTimer.clear(),this.pingTimer=null),this.topicAliasRecv&&this.topicAliasRecv.clear(),this.log(\"close :: calling _setupReconnect\"),this._setupReconnect()}),this.options.manualConnect||(this.log(\"MqttClient :: setting up stream\"),this.connect())}handleAuth(e,r){r()}handleMessage(e,r){r()}_nextId(){return this.messageIdProvider.allocate()}getLastMessageId(){return this.messageIdProvider.getLastAllocated()}connect(){var e;let r=new Vv.Writable,i=Da.default.parser(this.options),n=null,o=[];this.log(\"connect :: calling method to clear reconnect\"),this._clearReconnect(),this.log(\"connect :: using streamBuilder provided to client to create stream\"),this.stream=this.streamBuilder(this),i.on(\"packet\",h=>{this.log(\"parser :: on packet push to packets array.\"),o.push(h)});let s=()=>{this.log(\"work :: getting next packet in queue\");let h=o.shift();if(h)this.log(\"work :: packet pulled from queue\"),(0,Kv.default)(this,h,a);else{this.log(\"work :: no packets in queue\");let d=n;n=null,this.log(\"work :: done flag is %s\",!!d),d&&d()}},a=()=>{if(o.length)(0,Fa.nextTick)(s);else{let h=n;n=null,h()}};r._write=(h,d,g)=>{n=g,this.log(\"writable stream :: parsing buffer\"),i.parse(h),s()};let u=h=>{this.log(\"streamErrorHandler :: error\",h.message),h.code?(this.log(\"streamErrorHandler :: emitting error\"),this.emit(\"error\",h)):this.noop(h)};this.log(\"connect :: pipe stream to writable stream\"),this.stream.pipe(r),this.stream.on(\"error\",u),this.stream.on(\"close\",()=>{this.log(\"(%s)stream :: on close\",this.options.clientId),this._flushVolatile(),this.log(\"stream: emit close to MqttClient\"),this.emit(\"close\")}),this.log(\"connect: sending packet `connect`\");let c={cmd:\"connect\",protocolId:this.options.protocolId,protocolVersion:this.options.protocolVersion,clean:this.options.clean,clientId:this.options.clientId,keepalive:this.options.keepalive,username:this.options.username,password:this.options.password,properties:this.options.properties};if(this.options.will&&(c.will=Object.assign(Object.assign({},this.options.will),{payload:(e=this.options.will)===null||e===void 0?void 0:e.payload})),this.topicAliasRecv&&(c.properties||(c.properties={}),this.topicAliasRecv&&(c.properties.topicAliasMaximum=this.topicAliasRecv.max)),this._writePacket(c),i.on(\"error\",this.emit.bind(this,\"error\")),this.options.properties){if(!this.options.properties.authenticationMethod&&this.options.properties.authenticationData)return this.end(()=>this.emit(\"error\",new Error(\"Packet has no Authentication Method\"))),this;if(this.options.properties.authenticationMethod&&this.options.authPacket&&typeof this.options.authPacket==\"object\"){let h=Object.assign({cmd:\"auth\",reasonCode:0},this.options.authPacket);this._writePacket(h)}}return this.stream.setMaxListeners(1e3),clearTimeout(this.connackTimer),this.connackTimer=setTimeout(()=>{this.log(\"!!connectTimeout hit!! Calling _cleanUp with force `true`\"),this.emit(\"error\",new Error(\"connack timeout\")),this._cleanUp(!0)},this.options.connectTimeout),this}publish(e,r,i,n){this.log(\"publish :: message `%s` to topic `%s`\",r,e);let{options:o}=this;typeof i==\"function\"&&(n=i,i=null),i=i||{},i=Object.assign(Object.assign({},{qos:0,retain:!1,dup:!1}),i);let{qos:a,retain:u,dup:c,properties:h,cbStorePut:d}=i;if(this._checkDisconnecting(n))return this;let g=()=>{let y=0;if((a===1||a===2)&&(y=this._nextId(),y===null))return this.log(\"No messageId left\"),!1;let w={cmd:\"publish\",topic:e,payload:r,qos:a,retain:u,messageId:y,dup:c};switch(o.protocolVersion===5&&(w.properties=h),this.log(\"publish :: qos\",a),a){case 1:case 2:this.outgoing[w.messageId]={volatile:!1,cb:n||this.noop},this.log(\"MqttClient:publish: packet cmd: %s\",w.cmd),this._sendPacket(w,void 0,d);break;default:this.log(\"MqttClient:publish: packet cmd: %s\",w.cmd),this._sendPacket(w,n,d);break}return!0};return(this._storeProcessing||this._storeProcessingQueue.length>0||!g())&&this._storeProcessingQueue.push({invoke:g,cbStorePut:i.cbStorePut,callback:n}),this}publishAsync(e,r,i){return new Promise((n,o)=>{this.publish(e,r,i,(s,a)=>{s?o(s):n(a)})})}subscribe(e,r,i){let n=this.options.protocolVersion;typeof r==\"function\"&&(i=r),i=i||this.noop;let o=!1,s=[];typeof e==\"string\"?(e=[e],s=e):Array.isArray(e)?s=e:typeof e==\"object\"&&(o=e.resubscribe,delete e.resubscribe,s=Object.keys(e));let a=Np.validateTopics(s);if(a!==null)return ja(i,new Error(`Invalid topic ${a}`)),this;if(this._checkDisconnecting(i))return this.log(\"subscribe: discconecting true\"),this;let u={qos:0};n===5&&(u.nl=!1,u.rap=!1,u.rh=0),r=Object.assign(Object.assign({},u),r);let c=r.properties,h=[],d=(y,w)=>{if(w=w||r,!Object.prototype.hasOwnProperty.call(this._resubscribeTopics,y)||this._resubscribeTopics[y].qos<w.qos||o){let E={topic:y,qos:w.qos};n===5&&(E.nl=w.nl,E.rap=w.rap,E.rh=w.rh,E.properties=c),this.log(\"subscribe: pushing topic `%s` and qos `%s` to subs list\",E.topic,E.qos),h.push(E)}};if(Array.isArray(e)?e.forEach(y=>{this.log(\"subscribe: array topic %s\",y),d(y)}):Object.keys(e).forEach(y=>{this.log(\"subscribe: object topic %s, %o\",y,e[y]),d(y,e[y])}),!h.length)return i(null,[]),this;let g=()=>{let y=this._nextId();if(y===null)return this.log(\"No messageId left\"),!1;let w={cmd:\"subscribe\",subscriptions:h,messageId:y};if(c&&(w.properties=c),this.options.resubscribe){this.log(\"subscribe :: resubscribe true\");let E=[];h.forEach(S=>{if(this.options.reconnectPeriod>0){let I={qos:S.qos};n===5&&(I.nl=S.nl||!1,I.rap=S.rap||!1,I.rh=S.rh||0,I.properties=S.properties),this._resubscribeTopics[S.topic]=I,E.push(S.topic)}}),this.messageIdToTopic[w.messageId]=E}return this.outgoing[w.messageId]={volatile:!0,cb(E,S){if(!E){let{granted:I}=S;for(let C=0;C<I.length;C+=1)h[C].qos=I[C]}i(E,h)}},this.log(\"subscribe :: call _sendPacket\"),this._sendPacket(w),!0};return(this._storeProcessing||this._storeProcessingQueue.length>0||!g())&&this._storeProcessingQueue.push({invoke:g,callback:i}),this}subscribeAsync(e,r){return new Promise((i,n)=>{this.subscribe(e,r,(o,s)=>{o?n(o):i(s)})})}unsubscribe(e,r,i){typeof e==\"string\"&&(e=[e]),typeof r==\"function\"&&(i=r),i=i||this.noop;let n=Np.validateTopics(e);if(n!==null)return ja(i,new Error(`Invalid topic ${n}`)),this;if(this._checkDisconnecting(i))return this;let o=()=>{let s=this._nextId();if(s===null)return this.log(\"No messageId left\"),!1;let a={cmd:\"unsubscribe\",messageId:s,unsubscriptions:[]};return typeof e==\"string\"?a.unsubscriptions=[e]:Array.isArray(e)&&(a.unsubscriptions=e),this.options.resubscribe&&a.unsubscriptions.forEach(u=>{delete this._resubscribeTopics[u]}),typeof r==\"object\"&&r.properties&&(a.properties=r.properties),this.outgoing[a.messageId]={volatile:!0,cb:i},this.log(\"unsubscribe: call _sendPacket\"),this._sendPacket(a),!0};return(this._storeProcessing||this._storeProcessingQueue.length>0||!o())&&this._storeProcessingQueue.push({invoke:o,callback:i}),this}unsubscribeAsync(e,r){return new Promise((i,n)=>{this.unsubscribe(e,r,(o,s)=>{o?n(o):i(s)})})}end(e,r,i){this.log(\"end :: (%s)\",this.options.clientId),(e==null||typeof e!=\"boolean\")&&(i=i||r,r=e,e=!1),typeof r!=\"object\"&&(i=i||r,r=null),this.log(\"end :: cb? %s\",!!i),(!i||typeof i!=\"function\")&&(i=this.noop);let n=()=>{this.log(\"end :: closeStores: closing incoming and outgoing stores\"),this.disconnected=!0,this.incomingStore.close(s=>{this.outgoingStore.close(a=>{if(this.log(\"end :: closeStores: emitting end\"),this.emit(\"end\"),i){let u=s||a;this.log(\"end :: closeStores: invoking callback with args\"),i(u)}})}),this._deferredReconnect&&this._deferredReconnect()},o=()=>{this.log(\"end :: (%s) :: finish :: calling _cleanUp with force %s\",this.options.clientId,e),this._cleanUp(e,()=>{this.log(\"end :: finish :: calling process.nextTick on closeStores\"),(0,Fa.nextTick)(n)},r)};return this.disconnecting?(i(),this):(this._clearReconnect(),this.disconnecting=!0,!e&&Object.keys(this.outgoing).length>0?(this.log(\"end :: (%s) :: calling finish in 10ms once outgoing is empty\",this.options.clientId),this.once(\"outgoingEmpty\",setTimeout.bind(null,o,10))):(this.log(\"end :: (%s) :: immediately calling finish\",this.options.clientId),o()),this)}endAsync(e,r){return new Promise((i,n)=>{this.end(e,r,o=>{o?n(o):i()})})}removeOutgoingMessage(e){if(this.outgoing[e]){let{cb:r}=this.outgoing[e];this._removeOutgoingAndStoreMessage(e,()=>{r(new Error(\"Message removed\"))})}return this}reconnect(e){this.log(\"client reconnect\");let r=()=>{e?(this.options.incomingStore=e.incomingStore,this.options.outgoingStore=e.outgoingStore):(this.options.incomingStore=null,this.options.outgoingStore=null),this.incomingStore=this.options.incomingStore||new is.default,this.outgoingStore=this.options.outgoingStore||new is.default,this.disconnecting=!1,this.disconnected=!1,this._deferredReconnect=null,this._reconnect()};return this.disconnecting&&!this.disconnected?this._deferredReconnect=r:r(),this}_flushVolatile(){this.outgoing&&(this.log(\"_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function\"),Object.keys(this.outgoing).forEach(e=>{this.outgoing[e].volatile&&typeof this.outgoing[e].cb==\"function\"&&(this.outgoing[e].cb(new Error(\"Connection closed\")),delete this.outgoing[e])}))}_flush(){this.outgoing&&(this.log(\"_flush: queue exists? %b\",!!this.outgoing),Object.keys(this.outgoing).forEach(e=>{typeof this.outgoing[e].cb==\"function\"&&(this.outgoing[e].cb(new Error(\"Connection closed\")),delete this.outgoing[e])}))}_removeTopicAliasAndRecoverTopicName(e){let r;e.properties&&(r=e.properties.topicAlias);let i=e.topic.toString();if(this.log(\"_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o\",r,i),i.length===0){if(typeof r>\"u\")return new Error(\"Unregistered Topic Alias\");if(i=this.topicAliasSend.getTopicByAlias(r),typeof i>\"u\")return new Error(\"Unregistered Topic Alias\");e.topic=i}r&&delete e.properties.topicAlias}_checkDisconnecting(e){return this.disconnecting&&(e&&e!==this.noop?e(new Error(\"client disconnecting\")):this.emit(\"error\",new Error(\"client disconnecting\"))),this.disconnecting}_reconnect(){this.log(\"_reconnect: emitting reconnect to client\"),this.emit(\"reconnect\"),this.connected?(this.end(()=>{this.connect()}),this.log(\"client already connected. disconnecting first.\")):(this.log(\"_reconnect: calling connect\"),this.connect())}_setupReconnect(){!this.disconnecting&&!this.reconnectTimer&&this.options.reconnectPeriod>0?(this.reconnecting||(this.log(\"_setupReconnect :: emit `offline` state\"),this.emit(\"offline\"),this.log(\"_setupReconnect :: set `reconnecting` to `true`\"),this.reconnecting=!0),this.log(\"_setupReconnect :: setting reconnectTimer for %d ms\",this.options.reconnectPeriod),this.reconnectTimer=setInterval(()=>{this.log(\"reconnectTimer :: reconnect triggered!\"),this._reconnect()},this.options.reconnectPeriod)):this.log(\"_setupReconnect :: doing nothing...\")}_clearReconnect(){this.log(\"_clearReconnect : clearing reconnect timer\"),this.reconnectTimer&&(clearInterval(this.reconnectTimer),this.reconnectTimer=null)}_cleanUp(e,r,i={}){if(r&&(this.log(\"_cleanUp :: done callback provided for on stream close\"),this.stream.on(\"close\",r)),this.log(\"_cleanUp :: forced? %s\",e),e)this.options.reconnectPeriod===0&&this.options.clean&&this._flush(),this.log(\"_cleanUp :: (%s) :: destroying stream\",this.options.clientId),this.stream.destroy();else{let n=Object.assign({cmd:\"disconnect\"},i);this.log(\"_cleanUp :: (%s) :: call _sendPacket with disconnect packet\",this.options.clientId),this._sendPacket(n,()=>{this.log(\"_cleanUp :: (%s) :: destroying stream\",this.options.clientId),ja(()=>{this.stream.end(()=>{this.log(\"_cleanUp :: (%s) :: stream destroyed\",this.options.clientId)})})})}!this.disconnecting&&!this.reconnecting&&(this.log(\"_cleanUp :: client not disconnecting/reconnecting. Clearing and resetting reconnect.\"),this._clearReconnect(),this._setupReconnect()),this.pingTimer&&(this.log(\"_cleanUp :: clearing pingTimer\"),this.pingTimer.clear(),this.pingTimer=null),r&&!this.connected&&(this.log(\"_cleanUp :: (%s) :: removing stream `done` callback `close` listener\",this.options.clientId),this.stream.removeListener(\"close\",r),r())}_storeAndSend(e,r,i){this.log(\"storeAndSend :: store packet with cmd %s to outgoingStore\",e.cmd);let n=e,o;if(n.cmd===\"publish\"&&(n=(0,Up.default)(e),o=this._removeTopicAliasAndRecoverTopicName(n),o))return r&&r(o);this.outgoingStore.put(n,s=>{if(s)return r&&r(s);i(),this._writePacket(e,r)})}_applyTopicAlias(e){if(this.options.protocolVersion===5&&e.cmd===\"publish\"){let r;e.properties&&(r=e.properties.topicAlias);let i=e.topic.toString();if(this.topicAliasSend)if(r){if(i.length!==0&&(this.log(\"applyTopicAlias :: register topic: %s - alias: %d\",i,r),!this.topicAliasSend.put(i,r)))return this.log(\"applyTopicAlias :: error out of range. topic: %s - alias: %d\",i,r),new Error(\"Sending Topic Alias out of range\")}else i.length!==0&&(this.options.autoAssignTopicAlias?(r=this.topicAliasSend.getAliasByTopic(i),r?(e.topic=\"\",e.properties=Object.assign(Object.assign({},e.properties),{topicAlias:r}),this.log(\"applyTopicAlias :: auto assign(use) topic: %s - alias: %d\",i,r)):(r=this.topicAliasSend.getLruAlias(),this.topicAliasSend.put(i,r),e.properties=Object.assign(Object.assign({},e.properties),{topicAlias:r}),this.log(\"applyTopicAlias :: auto assign topic: %s - alias: %d\",i,r))):this.options.autoUseTopicAlias&&(r=this.topicAliasSend.getAliasByTopic(i),r&&(e.topic=\"\",e.properties=Object.assign(Object.assign({},e.properties),{topicAlias:r}),this.log(\"applyTopicAlias :: auto use topic: %s - alias: %d\",i,r))));else if(r)return this.log(\"applyTopicAlias :: error out of range. topic: %s - alias: %d\",i,r),new Error(\"Sending Topic Alias out of range\")}}_noop(e){this.log(\"noop ::\",e)}_writePacket(e,r){this.log(\"_writePacket :: packet: %O\",e),this.log(\"_writePacket :: emitting `packetsend`\"),this.emit(\"packetsend\",e),this._shiftPingInterval(),this.log(\"_writePacket :: writing to stream\");let i=Da.default.writeToStream(e,this.stream,this.options);this.log(\"_writePacket :: writeToStream result %s\",i),!i&&r&&r!==this.noop?(this.log(\"_writePacket :: handle events on `drain` once through callback.\"),this.stream.once(\"drain\",r)):r&&(this.log(\"_writePacket :: invoking cb\"),r())}_sendPacket(e,r,i,n){this.log(\"_sendPacket :: (%s) ::  start\",this.options.clientId),i=i||this.noop,r=r||this.noop;let o=this._applyTopicAlias(e);if(o){r(o);return}if(!this.connected){if(e.cmd===\"auth\"){this._writePacket(e,r);return}this.log(\"_sendPacket :: client not connected. Storing packet offline.\"),this._storePacket(e,r,i);return}if(n){this._writePacket(e,r);return}switch(e.cmd){case\"publish\":break;case\"pubrel\":this._storeAndSend(e,r,i);return;default:this._writePacket(e,r);return}switch(e.qos){case 2:case 1:this._storeAndSend(e,r,i);break;case 0:default:this._writePacket(e,r);break}this.log(\"_sendPacket :: (%s) ::  end\",this.options.clientId)}_storePacket(e,r,i){this.log(\"_storePacket :: packet: %o\",e),this.log(\"_storePacket :: cb? %s\",!!r),i=i||this.noop;let n=e;if(n.cmd===\"publish\"){n=(0,Up.default)(e);let s=this._removeTopicAliasAndRecoverTopicName(n);if(s)return r&&r(s)}let o=n.qos||0;o===0&&this.queueQoSZero||n.cmd!==\"publish\"?this.queue.push({packet:n,cb:r}):o>0?(r=this.outgoing[n.messageId]?this.outgoing[n.messageId].cb:null,this.outgoingStore.put(n,s=>{if(s)return r&&r(s);i()})):r&&r(new Error(\"No connection to broker\"))}_setupPingTimer(){this.log(\"_setupPingTimer :: keepalive %d (seconds)\",this.options.keepalive),!this.pingTimer&&this.options.keepalive&&(this.pingResp=!0,this.pingTimer=new Qv.default(this.options.keepalive,()=>{this._checkPing()}))}_shiftPingInterval(){this.pingTimer&&this.options.keepalive&&this.options.reschedulePings&&this.pingTimer.reschedule()}_checkPing(){this.log(\"_checkPing :: checking ping...\"),this.pingResp?(this.log(\"_checkPing :: ping response received. Clearing flag and sending `pingreq`\"),this.pingResp=!1,this._sendPacket({cmd:\"pingreq\"})):(this.emit(\"error\",new Error(\"Keepalive timeout\")),this.log(\"_checkPing :: calling _cleanUp with force true\"),this._cleanUp(!0))}_resubscribe(){this.log(\"_resubscribe\");let e=Object.keys(this._resubscribeTopics);if(!this._firstConnection&&(this.options.clean||this.options.protocolVersion>=4&&!this.connackPacket.sessionPresent)&&e.length>0)if(this.options.resubscribe)if(this.options.protocolVersion===5){this.log(\"_resubscribe: protocolVersion 5\");for(let r=0;r<e.length;r++){let i={};i[e[r]]=this._resubscribeTopics[e[r]],i.resubscribe=!0,this.subscribe(i,{properties:i[e[r]].properties})}}else this._resubscribeTopics.resubscribe=!0,this.subscribe(this._resubscribeTopics);else this._resubscribeTopics={};this._firstConnection=!1}_onConnect(e){if(this.disconnected){this.emit(\"connect\",e);return}this.connackPacket=e,this.messageIdProvider.clear(),this._setupPingTimer(),this.connected=!0;let r=()=>{let i=this.outgoingStore.createStream(),n=()=>{i.destroy(),i=null,this._flushStoreProcessingQueue(),o()},o=()=>{this._storeProcessing=!1,this._packetIdsDuringStoreProcessing={}};this.once(\"close\",n),i.on(\"error\",a=>{o(),this._flushStoreProcessingQueue(),this.removeListener(\"close\",n),this.emit(\"error\",a)});let s=()=>{if(!i)return;let a=i.read(1),u;if(!a){i.once(\"readable\",s);return}if(this._storeProcessing=!0,this._packetIdsDuringStoreProcessing[a.messageId]){s();return}!this.disconnecting&&!this.reconnectTimer?(u=this.outgoing[a.messageId]?this.outgoing[a.messageId].cb:null,this.outgoing[a.messageId]={volatile:!1,cb(c,h){u&&u(c,h),s()}},this._packetIdsDuringStoreProcessing[a.messageId]=!0,this.messageIdProvider.register(a.messageId)?this._sendPacket(a,void 0,void 0,!0):this.log(\"messageId: %d has already used.\",a.messageId)):i.destroy&&i.destroy()};i.on(\"end\",()=>{let a=!0;for(let u in this._packetIdsDuringStoreProcessing)if(!this._packetIdsDuringStoreProcessing[u]){a=!1;break}this.removeListener(\"close\",n),a?(o(),this._invokeAllStoreProcessingQueue(),this.emit(\"connect\",e)):r()}),s()};r()}_invokeStoreProcessingQueue(){if(!this._storeProcessing&&this._storeProcessingQueue.length>0){let e=this._storeProcessingQueue[0];if(e&&e.invoke())return this._storeProcessingQueue.shift(),!0}return!1}_invokeAllStoreProcessingQueue(){for(;this._invokeStoreProcessingQueue(););}_flushStoreProcessingQueue(){for(let e of this._storeProcessingQueue)e.cbStorePut&&e.cbStorePut(new Error(\"Connection closed\")),e.callback&&e.callback(new Error(\"Connection closed\"));this._storeProcessingQueue.splice(0)}_removeOutgoingAndStoreMessage(e,r){delete this.outgoing[e],this.outgoingStore.del({messageId:e},(i,n)=>{r(i,n),this.messageIdProvider.deallocate(e),this._invokeStoreProcessingQueue()})}};Qe.default=Wa});var Fp=M(Ha=>{\"use strict\";v();m();_();Object.defineProperty(Ha,\"__esModule\",{value:!0});var Yv=xa(),$a=class{constructor(){this.numberAllocator=new Yv.NumberAllocator(1,65535)}allocate(){return this.lastId=this.numberAllocator.alloc(),this.lastId}getLastAllocated(){return this.lastId}register(e){return this.numberAllocator.use(e)}deallocate(e){this.numberAllocator.free(e)}clear(){this.numberAllocator.clear()}};Ha.default=$a});function Ar(t){throw new RangeError(eE[t])}function Wp(t,e){let r=t.split(\"@\"),i=\"\";r.length>1&&(i=r[0]+\"@\",t=r[1]);let n=function(o,s){let a=[],u=o.length;for(;u--;)a[u]=s(o[u]);return a}((t=t.replace(Zv,\".\")).split(\".\"),e).join(\".\");return i+n}function zp(t){let e=[],r=0,i=t.length;for(;r<i;){let n=t.charCodeAt(r++);if(n>=55296&&n<=56319&&r<i){let o=t.charCodeAt(r++);(64512&o)==56320?e.push(((1023&n)<<10)+(1023&o)+65536):(e.push(n),r--)}else e.push(n)}return e}var Jv,Xv,Zv,eE,ht,Va,$p,Kp,Hp,Vp,zt,Gp=be(()=>{v();m();_();Jv=/^xn--/,Xv=/[^\\0-\\x7E]/,Zv=/[\\x2E\\u3002\\uFF0E\\uFF61]/g,eE={overflow:\"Overflow: input needs wider integers to process\",\"not-basic\":\"Illegal input >= 0x80 (not a basic code point)\",\"invalid-input\":\"Invalid input\"},ht=Math.floor,Va=String.fromCharCode;$p=function(t,e){return t+22+75*(t<26)-((e!=0)<<5)},Kp=function(t,e,r){let i=0;for(t=r?ht(t/700):t>>1,t+=ht(t/e);t>455;i+=36)t=ht(t/35);return ht(i+36*t/(t+38))},Hp=function(t){let e=[],r=t.length,i=0,n=128,o=72,s=t.lastIndexOf(\"-\");s<0&&(s=0);for(let u=0;u<s;++u)t.charCodeAt(u)>=128&&Ar(\"not-basic\"),e.push(t.charCodeAt(u));for(let u=s>0?s+1:0;u<r;){let c=i;for(let d=1,g=36;;g+=36){u>=r&&Ar(\"invalid-input\");let y=(a=t.charCodeAt(u++))-48<10?a-22:a-65<26?a-65:a-97<26?a-97:36;(y>=36||y>ht((2147483647-i)/d))&&Ar(\"overflow\"),i+=y*d;let w=g<=o?1:g>=o+26?26:g-o;if(y<w)break;let E=36-w;d>ht(2147483647/E)&&Ar(\"overflow\"),d*=E}let h=e.length+1;o=Kp(i-c,h,c==0),ht(i/h)>2147483647-n&&Ar(\"overflow\"),n+=ht(i/h),i%=h,e.splice(i++,0,n)}var a;return String.fromCodePoint(...e)},Vp=function(t){let e=[],r=(t=zp(t)).length,i=128,n=0,o=72;for(let u of t)u<128&&e.push(Va(u));let s=e.length,a=s;for(s&&e.push(\"-\");a<r;){let u=2147483647;for(let h of t)h>=i&&h<u&&(u=h);let c=a+1;u-i>ht((2147483647-n)/c)&&Ar(\"overflow\"),n+=(u-i)*c,i=u;for(let h of t)if(h<i&&++n>2147483647&&Ar(\"overflow\"),h==i){let d=n;for(let g=36;;g+=36){let y=g<=o?1:g>=o+26?26:g-o;if(d<y)break;let w=d-y,E=36-y;e.push(Va($p(y+w%E,0))),d=ht(w/E)}e.push(Va($p(d,0))),o=Kp(n,c,a==s),n=0,++a}++n,++i}return e.join(\"\")},zt={version:\"2.1.0\",ucs2:{decode:zp,encode:t=>String.fromCodePoint(...t)},decode:Hp,encode:Vp,toASCII:function(t){return Wp(t,function(e){return Xv.test(e)?\"xn--\"+Vp(e):e})},toUnicode:function(t){return Wp(t,function(e){return Jv.test(e)?Hp(e.slice(4).toLowerCase()):e})}};zt.decode;zt.encode;zt.toASCII;zt.toUnicode;zt.ucs2;zt.version});function tE(t,e){return Object.prototype.hasOwnProperty.call(t,e)}var rE,ki,iE,dt,Qp=be(()=>{v();m();_();rE=function(t,e,r,i){e=e||\"&\",r=r||\"=\";var n={};if(typeof t!=\"string\"||t.length===0)return n;var o=/\\+/g;t=t.split(e);var s=1e3;i&&typeof i.maxKeys==\"number\"&&(s=i.maxKeys);var a=t.length;s>0&&a>s&&(a=s);for(var u=0;u<a;++u){var c,h,d,g,y=t[u].replace(o,\"%20\"),w=y.indexOf(r);w>=0?(c=y.substr(0,w),h=y.substr(w+1)):(c=y,h=\"\"),d=decodeURIComponent(c),g=decodeURIComponent(h),tE(n,d)?Array.isArray(n[d])?n[d].push(g):n[d]=[n[d],g]:n[d]=g}return n},ki=function(t){switch(typeof t){case\"string\":return t;case\"boolean\":return t?\"true\":\"false\";case\"number\":return isFinite(t)?t:\"\";default:return\"\"}},iE=function(t,e,r,i){return e=e||\"&\",r=r||\"=\",t===null&&(t=void 0),typeof t==\"object\"?Object.keys(t).map(function(n){var o=encodeURIComponent(ki(n))+r;return Array.isArray(t[n])?t[n].map(function(s){return o+encodeURIComponent(ki(s))}).join(e):o+encodeURIComponent(ki(t[n]))}).join(e):i?encodeURIComponent(ki(i))+r+encodeURIComponent(ki(t)):\"\"},dt={};dt.decode=dt.parse=rE,dt.encode=dt.stringify=iE;dt.decode;dt.encode;dt.parse;dt.stringify});function za(){throw new Error(\"setTimeout has not been defined\")}function Ka(){throw new Error(\"clearTimeout has not been defined\")}function Xp(t){if(Bt===setTimeout)return setTimeout(t,0);if((Bt===za||!Bt)&&setTimeout)return Bt=setTimeout,setTimeout(t,0);try{return Bt(t,0)}catch{try{return Bt.call(null,t,0)}catch{return Bt.call(this||ri,t,0)}}}function nE(){ti&&Ir&&(ti=!1,Ir.length?Ot=Ir.concat(Ot):ss=-1,Ot.length&&Zp())}function Zp(){if(!ti){var t=Xp(nE);ti=!0;for(var e=Ot.length;e;){for(Ir=Ot,Ot=[];++ss<e;)Ir&&Ir[ss].run();ss=-1,e=Ot.length}Ir=null,ti=!1,function(r){if(Pt===clearTimeout)return clearTimeout(r);if((Pt===Ka||!Pt)&&clearTimeout)return Pt=clearTimeout,clearTimeout(r);try{Pt(r)}catch{try{return Pt.call(null,r)}catch{return Pt.call(this||ri,r)}}}(t)}}function Yp(t,e){(this||ri).fun=t,(this||ri).array=e}function Ct(){}var Jp,Bt,Pt,ri,fe,Ir,Ot,ti,ss,ne,eg=be(()=>{v();m();_();ri=typeof globalThis<\"u\"?globalThis:typeof self<\"u\"?self:__webpack_require__.g,fe=Jp={};(function(){try{Bt=typeof setTimeout==\"function\"?setTimeout:za}catch{Bt=za}try{Pt=typeof clearTimeout==\"function\"?clearTimeout:Ka}catch{Pt=Ka}})();Ot=[],ti=!1,ss=-1;fe.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];Ot.push(new Yp(t,e)),Ot.length!==1||ti||Xp(Zp)},Yp.prototype.run=function(){(this||ri).fun.apply(null,(this||ri).array)},fe.title=\"browser\",fe.browser=!0,fe.env={},fe.argv=[],fe.version=\"\",fe.versions={},fe.on=Ct,fe.addListener=Ct,fe.once=Ct,fe.off=Ct,fe.removeListener=Ct,fe.removeAllListeners=Ct,fe.emit=Ct,fe.prependListener=Ct,fe.prependOnceListener=Ct,fe.listeners=function(t){return[]},fe.binding=function(t){throw new Error(\"process.binding is not supported\")},fe.cwd=function(){return\"/\"},fe.chdir=function(t){throw new Error(\"process.chdir is not supported\")},fe.umask=function(){return 0};ne=Jp;ne.addListener;ne.argv;ne.binding;ne.browser;ne.chdir;ne.cwd;ne.emit;ne.env;ne.listeners;ne.nextTick;ne.off;ne.on;ne.once;ne.prependListener;ne.prependOnceListener;ne.removeAllListeners;ne.removeListener;ne.title;ne.umask;ne.version;ne.versions});function sE(){if(tg)return Ga;tg=!0;var t=Ga={},e,r;function i(){throw new Error(\"setTimeout has not been defined\")}function n(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{typeof setTimeout==\"function\"?e=setTimeout:e=i}catch{e=i}try{typeof clearTimeout==\"function\"?r=clearTimeout:r=n}catch{r=n}})();function o(E){if(e===setTimeout)return setTimeout(E,0);if((e===i||!e)&&setTimeout)return e=setTimeout,setTimeout(E,0);try{return e(E,0)}catch{try{return e.call(null,E,0)}catch{return e.call(this||ii,E,0)}}}function s(E){if(r===clearTimeout)return clearTimeout(E);if((r===n||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(E);try{return r(E)}catch{try{return r.call(null,E)}catch{return r.call(this||ii,E)}}}var a=[],u=!1,c,h=-1;function d(){!u||!c||(u=!1,c.length?a=c.concat(a):h=-1,a.length&&g())}function g(){if(!u){var E=o(d);u=!0;for(var S=a.length;S;){for(c=a,a=[];++h<S;)c&&c[h].run();h=-1,S=a.length}c=null,u=!1,s(E)}}t.nextTick=function(E){var S=new Array(arguments.length-1);if(arguments.length>1)for(var I=1;I<arguments.length;I++)S[I-1]=arguments[I];a.push(new y(E,S)),a.length===1&&!u&&o(g)};function y(E,S){(this||ii).fun=E,(this||ii).array=S}y.prototype.run=function(){(this||ii).fun.apply(null,(this||ii).array)},t.title=\"browser\",t.browser=!0,t.env={},t.argv=[],t.version=\"\",t.versions={};function w(){}return t.on=w,t.addListener=w,t.once=w,t.off=w,t.removeListener=w,t.removeAllListeners=w,t.emit=w,t.prependListener=w,t.prependOnceListener=w,t.listeners=function(E){return[]},t.binding=function(E){throw new Error(\"process.binding is not supported\")},t.cwd=function(){return\"/\"},t.chdir=function(E){throw new Error(\"process.chdir is not supported\")},t.umask=function(){return 0},Ga}var Ga,tg,ii,re,Qa=be(()=>{v();m();_();Ga={},tg=!1,ii=typeof globalThis<\"u\"?globalThis:typeof self<\"u\"?self:__webpack_require__.g;re=sE();re.platform=\"browser\";re.addListener;re.argv;re.binding;re.browser;re.chdir;re.cwd;re.emit;re.env;re.listeners;re.nextTick;re.off;re.on;re.once;re.prependListener;re.prependOnceListener;re.removeAllListeners;re.removeListener;re.title;re.umask;re.version;re.versions});function oE(){if(rg)return Ya;rg=!0;var t=re;function e(o){if(typeof o!=\"string\")throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(o))}function r(o,s){for(var a=\"\",u=0,c=-1,h=0,d,g=0;g<=o.length;++g){if(g<o.length)d=o.charCodeAt(g);else{if(d===47)break;d=47}if(d===47){if(!(c===g-1||h===1))if(c!==g-1&&h===2){if(a.length<2||u!==2||a.charCodeAt(a.length-1)!==46||a.charCodeAt(a.length-2)!==46){if(a.length>2){var y=a.lastIndexOf(\"/\");if(y!==a.length-1){y===-1?(a=\"\",u=0):(a=a.slice(0,y),u=a.length-1-a.lastIndexOf(\"/\")),c=g,h=0;continue}}else if(a.length===2||a.length===1){a=\"\",u=0,c=g,h=0;continue}}s&&(a.length>0?a+=\"/..\":a=\"..\",u=2)}else a.length>0?a+=\"/\"+o.slice(c+1,g):a=o.slice(c+1,g),u=g-c-1;c=g,h=0}else d===46&&h!==-1?++h:h=-1}return a}function i(o,s){var a=s.dir||s.root,u=s.base||(s.name||\"\")+(s.ext||\"\");return a?a===s.root?a+u:a+o+u:u}var n={resolve:function(){for(var s=\"\",a=!1,u,c=arguments.length-1;c>=-1&&!a;c--){var h;c>=0?h=arguments[c]:(u===void 0&&(u=t.cwd()),h=u),e(h),h.length!==0&&(s=h+\"/\"+s,a=h.charCodeAt(0)===47)}return s=r(s,!a),a?s.length>0?\"/\"+s:\"/\":s.length>0?s:\".\"},normalize:function(s){if(e(s),s.length===0)return\".\";var a=s.charCodeAt(0)===47,u=s.charCodeAt(s.length-1)===47;return s=r(s,!a),s.length===0&&!a&&(s=\".\"),s.length>0&&u&&(s+=\"/\"),a?\"/\"+s:s},isAbsolute:function(s){return e(s),s.length>0&&s.charCodeAt(0)===47},join:function(){if(arguments.length===0)return\".\";for(var s,a=0;a<arguments.length;++a){var u=arguments[a];e(u),u.length>0&&(s===void 0?s=u:s+=\"/\"+u)}return s===void 0?\".\":n.normalize(s)},relative:function(s,a){if(e(s),e(a),s===a||(s=n.resolve(s),a=n.resolve(a),s===a))return\"\";for(var u=1;u<s.length&&s.charCodeAt(u)===47;++u);for(var c=s.length,h=c-u,d=1;d<a.length&&a.charCodeAt(d)===47;++d);for(var g=a.length,y=g-d,w=h<y?h:y,E=-1,S=0;S<=w;++S){if(S===w){if(y>w){if(a.charCodeAt(d+S)===47)return a.slice(d+S+1);if(S===0)return a.slice(d+S)}else h>w&&(s.charCodeAt(u+S)===47?E=S:S===0&&(E=0));break}var I=s.charCodeAt(u+S),C=a.charCodeAt(d+S);if(I!==C)break;I===47&&(E=S)}var R=\"\";for(S=u+E+1;S<=c;++S)(S===c||s.charCodeAt(S)===47)&&(R.length===0?R+=\"..\":R+=\"/..\");return R.length>0?R+a.slice(d+E):(d+=E,a.charCodeAt(d)===47&&++d,a.slice(d))},_makeLong:function(s){return s},dirname:function(s){if(e(s),s.length===0)return\".\";for(var a=s.charCodeAt(0),u=a===47,c=-1,h=!0,d=s.length-1;d>=1;--d)if(a=s.charCodeAt(d),a===47){if(!h){c=d;break}}else h=!1;return c===-1?u?\"/\":\".\":u&&c===1?\"//\":s.slice(0,c)},basename:function(s,a){if(a!==void 0&&typeof a!=\"string\")throw new TypeError('\"ext\" argument must be a string');e(s);var u=0,c=-1,h=!0,d;if(a!==void 0&&a.length>0&&a.length<=s.length){if(a.length===s.length&&a===s)return\"\";var g=a.length-1,y=-1;for(d=s.length-1;d>=0;--d){var w=s.charCodeAt(d);if(w===47){if(!h){u=d+1;break}}else y===-1&&(h=!1,y=d+1),g>=0&&(w===a.charCodeAt(g)?--g===-1&&(c=d):(g=-1,c=y))}return u===c?c=y:c===-1&&(c=s.length),s.slice(u,c)}else{for(d=s.length-1;d>=0;--d)if(s.charCodeAt(d)===47){if(!h){u=d+1;break}}else c===-1&&(h=!1,c=d+1);return c===-1?\"\":s.slice(u,c)}},extname:function(s){e(s);for(var a=-1,u=0,c=-1,h=!0,d=0,g=s.length-1;g>=0;--g){var y=s.charCodeAt(g);if(y===47){if(!h){u=g+1;break}continue}c===-1&&(h=!1,c=g+1),y===46?a===-1?a=g:d!==1&&(d=1):a!==-1&&(d=-1)}return a===-1||c===-1||d===0||d===1&&a===c-1&&a===u+1?\"\":s.slice(a,c)},format:function(s){if(s===null||typeof s!=\"object\")throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof s);return i(\"/\",s)},parse:function(s){e(s);var a={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(s.length===0)return a;var u=s.charCodeAt(0),c=u===47,h;c?(a.root=\"/\",h=1):h=0;for(var d=-1,g=0,y=-1,w=!0,E=s.length-1,S=0;E>=h;--E){if(u=s.charCodeAt(E),u===47){if(!w){g=E+1;break}continue}y===-1&&(w=!1,y=E+1),u===46?d===-1?d=E:S!==1&&(S=1):d!==-1&&(S=-1)}return d===-1||y===-1||S===0||S===1&&d===y-1&&d===g+1?y!==-1&&(g===0&&c?a.base=a.name=s.slice(1,y):a.base=a.name=s.slice(g,y)):(g===0&&c?(a.name=s.slice(1,d),a.base=s.slice(1,y)):(a.name=s.slice(g,d),a.base=s.slice(g,y)),a.ext=s.slice(d,y)),g>0?a.dir=s.slice(0,g-1):c&&(a.dir=\"/\"),a},sep:\"/\",delimiter:\":\",win32:null,posix:null};return n.posix=n,Ya=n,Ya}var Ya,rg,Ja,ig=be(()=>{v();m();_();Qa();Ya={},rg=!1;Ja=oE()});var cg={};Qt(cg,{URL:()=>UE,Url:()=>OE,default:()=>X,fileURLToPath:()=>ug,format:()=>kE,parse:()=>LE,pathToFileURL:()=>fg,resolve:()=>xE,resolveObject:()=>ME});function Fe(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}function xi(t,e,r){if(t&&pt.isObject(t)&&t instanceof Fe)return t;var i=new Fe;return i.parse(t,e,r),i}function pE(){if(ag)return el;ag=!0;var t=ne;function e(o){if(typeof o!=\"string\")throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(o))}function r(o,s){for(var a=\"\",u=0,c=-1,h=0,d,g=0;g<=o.length;++g){if(g<o.length)d=o.charCodeAt(g);else{if(d===47)break;d=47}if(d===47){if(!(c===g-1||h===1))if(c!==g-1&&h===2){if(a.length<2||u!==2||a.charCodeAt(a.length-1)!==46||a.charCodeAt(a.length-2)!==46){if(a.length>2){var y=a.lastIndexOf(\"/\");if(y!==a.length-1){y===-1?(a=\"\",u=0):(a=a.slice(0,y),u=a.length-1-a.lastIndexOf(\"/\")),c=g,h=0;continue}}else if(a.length===2||a.length===1){a=\"\",u=0,c=g,h=0;continue}}s&&(a.length>0?a+=\"/..\":a=\"..\",u=2)}else a.length>0?a+=\"/\"+o.slice(c+1,g):a=o.slice(c+1,g),u=g-c-1;c=g,h=0}else d===46&&h!==-1?++h:h=-1}return a}function i(o,s){var a=s.dir||s.root,u=s.base||(s.name||\"\")+(s.ext||\"\");return a?a===s.root?a+u:a+o+u:u}var n={resolve:function(){for(var s=\"\",a=!1,u,c=arguments.length-1;c>=-1&&!a;c--){var h;c>=0?h=arguments[c]:(u===void 0&&(u=t.cwd()),h=u),e(h),h.length!==0&&(s=h+\"/\"+s,a=h.charCodeAt(0)===47)}return s=r(s,!a),a?s.length>0?\"/\"+s:\"/\":s.length>0?s:\".\"},normalize:function(s){if(e(s),s.length===0)return\".\";var a=s.charCodeAt(0)===47,u=s.charCodeAt(s.length-1)===47;return s=r(s,!a),s.length===0&&!a&&(s=\".\"),s.length>0&&u&&(s+=\"/\"),a?\"/\"+s:s},isAbsolute:function(s){return e(s),s.length>0&&s.charCodeAt(0)===47},join:function(){if(arguments.length===0)return\".\";for(var s,a=0;a<arguments.length;++a){var u=arguments[a];e(u),u.length>0&&(s===void 0?s=u:s+=\"/\"+u)}return s===void 0?\".\":n.normalize(s)},relative:function(s,a){if(e(s),e(a),s===a||(s=n.resolve(s),a=n.resolve(a),s===a))return\"\";for(var u=1;u<s.length&&s.charCodeAt(u)===47;++u);for(var c=s.length,h=c-u,d=1;d<a.length&&a.charCodeAt(d)===47;++d);for(var g=a.length,y=g-d,w=h<y?h:y,E=-1,S=0;S<=w;++S){if(S===w){if(y>w){if(a.charCodeAt(d+S)===47)return a.slice(d+S+1);if(S===0)return a.slice(d+S)}else h>w&&(s.charCodeAt(u+S)===47?E=S:S===0&&(E=0));break}var I=s.charCodeAt(u+S),C=a.charCodeAt(d+S);if(I!==C)break;I===47&&(E=S)}var R=\"\";for(S=u+E+1;S<=c;++S)(S===c||s.charCodeAt(S)===47)&&(R.length===0?R+=\"..\":R+=\"/..\");return R.length>0?R+a.slice(d+E):(d+=E,a.charCodeAt(d)===47&&++d,a.slice(d))},_makeLong:function(s){return s},dirname:function(s){if(e(s),s.length===0)return\".\";for(var a=s.charCodeAt(0),u=a===47,c=-1,h=!0,d=s.length-1;d>=1;--d)if(a=s.charCodeAt(d),a===47){if(!h){c=d;break}}else h=!1;return c===-1?u?\"/\":\".\":u&&c===1?\"//\":s.slice(0,c)},basename:function(s,a){if(a!==void 0&&typeof a!=\"string\")throw new TypeError('\"ext\" argument must be a string');e(s);var u=0,c=-1,h=!0,d;if(a!==void 0&&a.length>0&&a.length<=s.length){if(a.length===s.length&&a===s)return\"\";var g=a.length-1,y=-1;for(d=s.length-1;d>=0;--d){var w=s.charCodeAt(d);if(w===47){if(!h){u=d+1;break}}else y===-1&&(h=!1,y=d+1),g>=0&&(w===a.charCodeAt(g)?--g===-1&&(c=d):(g=-1,c=y))}return u===c?c=y:c===-1&&(c=s.length),s.slice(u,c)}else{for(d=s.length-1;d>=0;--d)if(s.charCodeAt(d)===47){if(!h){u=d+1;break}}else c===-1&&(h=!1,c=d+1);return c===-1?\"\":s.slice(u,c)}},extname:function(s){e(s);for(var a=-1,u=0,c=-1,h=!0,d=0,g=s.length-1;g>=0;--g){var y=s.charCodeAt(g);if(y===47){if(!h){u=g+1;break}continue}c===-1&&(h=!1,c=g+1),y===46?a===-1?a=g:d!==1&&(d=1):a!==-1&&(d=-1)}return a===-1||c===-1||d===0||d===1&&a===c-1&&a===u+1?\"\":s.slice(a,c)},format:function(s){if(s===null||typeof s!=\"object\")throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof s);return i(\"/\",s)},parse:function(s){e(s);var a={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(s.length===0)return a;var u=s.charCodeAt(0),c=u===47,h;c?(a.root=\"/\",h=1):h=0;for(var d=-1,g=0,y=-1,w=!0,E=s.length-1,S=0;E>=h;--E){if(u=s.charCodeAt(E),u===47){if(!w){g=E+1;break}continue}y===-1&&(w=!1,y=E+1),u===46?d===-1?d=E:S!==1&&(S=1):d!==-1&&(S=-1)}return d===-1||y===-1||S===0||S===1&&d===y-1&&d===g+1?y!==-1&&(g===0&&c?a.base=a.name=s.slice(1,y):a.base=a.name=s.slice(g,y)):(g===0&&c?(a.name=s.slice(1,d),a.base=s.slice(1,y)):(a.name=s.slice(g,d),a.base=s.slice(g,y)),a.ext=s.slice(d,y)),g>0?a.dir=s.slice(0,g-1):c&&(a.dir=\"/\"),a},sep:\"/\",delimiter:\":\",win32:null,posix:null};return n.posix=n,el=n,el}function TE(t){if(typeof t==\"string\")t=new URL(t);else if(!(t instanceof URL))throw new Deno.errors.InvalidData(\"invalid argument path , must be a string or URL\");if(t.protocol!==\"file:\")throw new Deno.errors.InvalidData(\"invalid url scheme\");return rl?RE(t):CE(t)}function RE(t){let e=t.hostname,r=t.pathname;for(let i=0;i<r.length;i++)if(r[i]===\"%\"){let n=r.codePointAt(i+2)||32;if(r[i+1]===\"2\"&&n===102||r[i+1]===\"5\"&&n===99)throw new Deno.errors.InvalidData(\"must not include encoded \\\\ or / characters\")}if(r=r.replace(mE,\"\\\\\"),r=decodeURIComponent(r),e!==\"\")return`\\\\\\\\${e}${r}`;{let i=r.codePointAt(1)|32,n=r[2];if(i<wE||i>_E||n!==\":\")throw new Deno.errors.InvalidData(\"file url path must be absolute\");return r.slice(1)}}function CE(t){if(t.hostname!==\"\")throw new Deno.errors.InvalidData(\"invalid file url hostname\");let e=t.pathname;for(let r=0;r<e.length;r++)if(e[r]===\"%\"){let i=e.codePointAt(r+2)||32;if(e[r+1]===\"2\"&&i===102)throw new Deno.errors.InvalidData(\"must not include encoded / characters\")}return decodeURIComponent(e)}function BE(t){let e=lg.resolve(t),r=t.charCodeAt(t.length-1);(r===bE||rl&&r===yE)&&e[e.length-1]!==lg.sep&&(e+=\"/\");let i=new URL(\"file://\");return e.includes(\"%\")&&(e=e.replace(vE,\"%25\")),!rl&&e.includes(\"\\\\\")&&(e=e.replace(EE,\"%5C\")),e.includes(`\n`)&&(e=e.replace(SE,\"%0A\")),e.includes(\"\\r\")&&(e=e.replace(AE,\"%0D\")),e.includes(\"\t\")&&(e=e.replace(IE,\"%09\")),i.pathname=e,i}function ug(t){if(typeof t==\"string\")t=new URL(t);else if(!(t instanceof URL))throw new Deno.errors.InvalidData(\"invalid argument path , must be a string or URL\");if(t.protocol!==\"file:\")throw new Deno.errors.InvalidData(\"invalid url scheme\");return il?KE(t):GE(t)}function KE(t){let e=t.hostname,r=t.pathname;for(let i=0;i<r.length;i++)if(r[i]===\"%\"){let n=r.codePointAt(i+2)||32;if(r[i+1]===\"2\"&&n===102||r[i+1]===\"5\"&&n===99)throw new Deno.errors.InvalidData(\"must not include encoded \\\\ or / characters\")}if(r=r.replace(FE,\"\\\\\"),r=decodeURIComponent(r),e!==\"\")return`\\\\\\\\${e}${r}`;{let i=r.codePointAt(1)|32,n=r[2];if(i<DE||i>jE||n!==\":\")throw new Deno.errors.InvalidData(\"file url path must be absolute\");return r.slice(1)}}function GE(t){if(t.hostname!==\"\")throw new Deno.errors.InvalidData(\"invalid file url hostname\");let e=t.pathname;for(let r=0;r<e.length;r++)if(e[r]===\"%\"){let i=e.codePointAt(r+2)||32;if(e[r+1]===\"2\"&&i===102)throw new Deno.errors.InvalidData(\"must not include encoded / characters\")}return decodeURIComponent(e)}function fg(t){let e=Ja.resolve(t),r=t.charCodeAt(t.length-1);(r===qE||il&&r===NE)&&e[e.length-1]!==Ja.sep&&(e+=\"/\");let i=new URL(\"file://\");return e.includes(\"%\")&&(e=e.replace(WE,\"%25\")),!il&&e.includes(\"\\\\\")&&(e=e.replace($E,\"%5C\")),e.includes(`\n`)&&(e=e.replace(HE,\"%0A\")),e.includes(\"\\r\")&&(e=e.replace(VE,\"%0D\")),e.includes(\"\t\")&&(e=e.replace(zE,\"%09\")),i.pathname=e,i}var X,aE,pt,lE,uE,fE,cE,tl,ng,sg,og,hE,dE,Xa,ni,Za,el,ag,lg,gE,yE,bE,wE,_E,rl,mE,vE,EE,SE,AE,IE,PE,OE,kE,xE,ME,LE,UE,NE,qE,DE,jE,il,FE,WE,$E,HE,VE,zE,hg=be(()=>{v();m();_();Gp();Qp();eg();ig();Qa();X={},aE=zt,pt={isString:function(t){return typeof t==\"string\"},isObject:function(t){return typeof t==\"object\"&&t!==null},isNull:function(t){return t===null},isNullOrUndefined:function(t){return t==null}};X.parse=xi,X.resolve=function(t,e){return xi(t,!1,!0).resolve(e)},X.resolveObject=function(t,e){return t?xi(t,!1,!0).resolveObject(e):e},X.format=function(t){return pt.isString(t)&&(t=xi(t)),t instanceof Fe?t.format():Fe.prototype.format.call(t)},X.Url=Fe;lE=/^([a-z0-9.+-]+:)/i,uE=/:[0-9]*$/,fE=/^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,cE=[\"{\",\"}\",\"|\",\"\\\\\",\"^\",\"`\"].concat([\"<\",\">\",'\"',\"`\",\" \",\"\\r\",`\n`,\"\t\"]),tl=[\"'\"].concat(cE),ng=[\"%\",\"/\",\"?\",\";\",\"#\"].concat(tl),sg=[\"/\",\"?\",\"#\"],og=/^[+a-z0-9A-Z_-]{0,63}$/,hE=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,dE={javascript:!0,\"javascript:\":!0},Xa={javascript:!0,\"javascript:\":!0},ni={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,\"http:\":!0,\"https:\":!0,\"ftp:\":!0,\"gopher:\":!0,\"file:\":!0},Za=dt;Fe.prototype.parse=function(t,e,r){if(!pt.isString(t))throw new TypeError(\"Parameter 'url' must be a string, not \"+typeof t);var i=t.indexOf(\"?\"),n=i!==-1&&i<t.indexOf(\"#\")?\"?\":\"#\",o=t.split(n);o[0]=o[0].replace(/\\\\/g,\"/\");var s=t=o.join(n);if(s=s.trim(),!r&&t.split(\"#\").length===1){var a=fE.exec(s);if(a)return this.path=s,this.href=s,this.pathname=a[1],a[2]?(this.search=a[2],this.query=e?Za.parse(this.search.substr(1)):this.search.substr(1)):e&&(this.search=\"\",this.query={}),this}var u=lE.exec(s);if(u){var c=(u=u[0]).toLowerCase();this.protocol=c,s=s.substr(u.length)}if(r||u||s.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)){var h=s.substr(0,2)===\"//\";!h||u&&Xa[u]||(s=s.substr(2),this.slashes=!0)}if(!Xa[u]&&(h||u&&!ni[u])){for(var d,g,y=-1,w=0;w<sg.length;w++)(E=s.indexOf(sg[w]))!==-1&&(y===-1||E<y)&&(y=E);for((g=y===-1?s.lastIndexOf(\"@\"):s.lastIndexOf(\"@\",y))!==-1&&(d=s.slice(0,g),s=s.slice(g+1),this.auth=decodeURIComponent(d)),y=-1,w=0;w<ng.length;w++){var E;(E=s.indexOf(ng[w]))!==-1&&(y===-1||E<y)&&(y=E)}y===-1&&(y=s.length),this.host=s.slice(0,y),s=s.slice(y),this.parseHost(),this.hostname=this.hostname||\"\";var S=this.hostname[0]===\"[\"&&this.hostname[this.hostname.length-1]===\"]\";if(!S)for(var I=this.hostname.split(/\\./),C=(w=0,I.length);w<C;w++){var R=I[w];if(R&&!R.match(og)){for(var U=\"\",N=0,W=R.length;N<W;N++)R.charCodeAt(N)>127?U+=\"x\":U+=R[N];if(!U.match(og)){var K=I.slice(0,w),z=I.slice(w+1),Q=R.match(hE);Q&&(K.push(Q[1]),z.unshift(Q[2])),z.length&&(s=\"/\"+z.join(\".\")+s),this.hostname=K.join(\".\");break}}}this.hostname.length>255?this.hostname=\"\":this.hostname=this.hostname.toLowerCase(),S||(this.hostname=aE.toASCII(this.hostname));var de=this.port?\":\"+this.port:\"\",Gt=this.hostname||\"\";this.host=Gt+de,this.href+=this.host,S&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),s[0]!==\"/\"&&(s=\"/\"+s))}if(!dE[c])for(w=0,C=tl.length;w<C;w++){var pe=tl[w];if(s.indexOf(pe)!==-1){var Rr=encodeURIComponent(pe);Rr===pe&&(Rr=escape(pe)),s=s.split(pe).join(Rr)}}var Cr=s.indexOf(\"#\");Cr!==-1&&(this.hash=s.substr(Cr),s=s.slice(0,Cr));var Br=s.indexOf(\"?\");if(Br!==-1?(this.search=s.substr(Br),this.query=s.substr(Br+1),e&&(this.query=Za.parse(this.query)),s=s.slice(0,Br)):e&&(this.search=\"\",this.query={}),s&&(this.pathname=s),ni[c]&&this.hostname&&!this.pathname&&(this.pathname=\"/\"),this.pathname||this.search){de=this.pathname||\"\";var us=this.search||\"\";this.path=de+us}return this.href=this.format(),this},Fe.prototype.format=function(){var t=this.auth||\"\";t&&(t=(t=encodeURIComponent(t)).replace(/%3A/i,\":\"),t+=\"@\");var e=this.protocol||\"\",r=this.pathname||\"\",i=this.hash||\"\",n=!1,o=\"\";this.host?n=t+this.host:this.hostname&&(n=t+(this.hostname.indexOf(\":\")===-1?this.hostname:\"[\"+this.hostname+\"]\"),this.port&&(n+=\":\"+this.port)),this.query&&pt.isObject(this.query)&&Object.keys(this.query).length&&(o=Za.stringify(this.query));var s=this.search||o&&\"?\"+o||\"\";return e&&e.substr(-1)!==\":\"&&(e+=\":\"),this.slashes||(!e||ni[e])&&n!==!1?(n=\"//\"+(n||\"\"),r&&r.charAt(0)!==\"/\"&&(r=\"/\"+r)):n||(n=\"\"),i&&i.charAt(0)!==\"#\"&&(i=\"#\"+i),s&&s.charAt(0)!==\"?\"&&(s=\"?\"+s),e+n+(r=r.replace(/[?#]/g,function(a){return encodeURIComponent(a)}))+(s=s.replace(\"#\",\"%23\"))+i},Fe.prototype.resolve=function(t){return this.resolveObject(xi(t,!1,!0)).format()},Fe.prototype.resolveObject=function(t){if(pt.isString(t)){var e=new Fe;e.parse(t,!1,!0),t=e}for(var r=new Fe,i=Object.keys(this),n=0;n<i.length;n++){var o=i[n];r[o]=this[o]}if(r.hash=t.hash,t.href===\"\")return r.href=r.format(),r;if(t.slashes&&!t.protocol){for(var s=Object.keys(t),a=0;a<s.length;a++){var u=s[a];u!==\"protocol\"&&(r[u]=t[u])}return ni[r.protocol]&&r.hostname&&!r.pathname&&(r.path=r.pathname=\"/\"),r.href=r.format(),r}if(t.protocol&&t.protocol!==r.protocol){if(!ni[t.protocol]){for(var c=Object.keys(t),h=0;h<c.length;h++){var d=c[h];r[d]=t[d]}return r.href=r.format(),r}if(r.protocol=t.protocol,t.host||Xa[t.protocol])r.pathname=t.pathname;else{for(var g=(t.pathname||\"\").split(\"/\");g.length&&!(t.host=g.shift()););t.host||(t.host=\"\"),t.hostname||(t.hostname=\"\"),g[0]!==\"\"&&g.unshift(\"\"),g.length<2&&g.unshift(\"\"),r.pathname=g.join(\"/\")}if(r.search=t.search,r.query=t.query,r.host=t.host||\"\",r.auth=t.auth,r.hostname=t.hostname||t.host,r.port=t.port,r.pathname||r.search){var y=r.pathname||\"\",w=r.search||\"\";r.path=y+w}return r.slashes=r.slashes||t.slashes,r.href=r.format(),r}var E=r.pathname&&r.pathname.charAt(0)===\"/\",S=t.host||t.pathname&&t.pathname.charAt(0)===\"/\",I=S||E||r.host&&t.pathname,C=I,R=r.pathname&&r.pathname.split(\"/\")||[],U=(g=t.pathname&&t.pathname.split(\"/\")||[],r.protocol&&!ni[r.protocol]);if(U&&(r.hostname=\"\",r.port=null,r.host&&(R[0]===\"\"?R[0]=r.host:R.unshift(r.host)),r.host=\"\",t.protocol&&(t.hostname=null,t.port=null,t.host&&(g[0]===\"\"?g[0]=t.host:g.unshift(t.host)),t.host=null),I=I&&(g[0]===\"\"||R[0]===\"\")),S)r.host=t.host||t.host===\"\"?t.host:r.host,r.hostname=t.hostname||t.hostname===\"\"?t.hostname:r.hostname,r.search=t.search,r.query=t.query,R=g;else if(g.length)R||(R=[]),R.pop(),R=R.concat(g),r.search=t.search,r.query=t.query;else if(!pt.isNullOrUndefined(t.search))return U&&(r.hostname=r.host=R.shift(),(Q=!!(r.host&&r.host.indexOf(\"@\")>0)&&r.host.split(\"@\"))&&(r.auth=Q.shift(),r.host=r.hostname=Q.shift())),r.search=t.search,r.query=t.query,pt.isNull(r.pathname)&&pt.isNull(r.search)||(r.path=(r.pathname?r.pathname:\"\")+(r.search?r.search:\"\")),r.href=r.format(),r;if(!R.length)return r.pathname=null,r.search?r.path=\"/\"+r.search:r.path=null,r.href=r.format(),r;for(var N=R.slice(-1)[0],W=(r.host||t.host||R.length>1)&&(N===\".\"||N===\"..\")||N===\"\",K=0,z=R.length;z>=0;z--)(N=R[z])===\".\"?R.splice(z,1):N===\"..\"?(R.splice(z,1),K++):K&&(R.splice(z,1),K--);if(!I&&!C)for(;K--;K)R.unshift(\"..\");!I||R[0]===\"\"||R[0]&&R[0].charAt(0)===\"/\"||R.unshift(\"\"),W&&R.join(\"/\").substr(-1)!==\"/\"&&R.push(\"\");var Q,de=R[0]===\"\"||R[0]&&R[0].charAt(0)===\"/\";return U&&(r.hostname=r.host=de?\"\":R.length?R.shift():\"\",(Q=!!(r.host&&r.host.indexOf(\"@\")>0)&&r.host.split(\"@\"))&&(r.auth=Q.shift(),r.host=r.hostname=Q.shift())),(I=I||r.host&&R.length)&&!de&&R.unshift(\"\"),R.length?r.pathname=R.join(\"/\"):(r.pathname=null,r.path=null),pt.isNull(r.pathname)&&pt.isNull(r.search)||(r.path=(r.pathname?r.pathname:\"\")+(r.search?r.search:\"\")),r.auth=t.auth||r.auth,r.slashes=r.slashes||t.slashes,r.href=r.format(),r},Fe.prototype.parseHost=function(){var t=this.host,e=uE.exec(t);e&&((e=e[0])!==\":\"&&(this.port=e.substr(1)),t=t.substr(0,t.length-e.length)),t&&(this.hostname=t)};X.Url;X.format;X.resolve;X.resolveObject;el={},ag=!1;lg=pE(),gE=typeof Deno<\"u\"?Deno.build.os===\"windows\"?\"win32\":Deno.build.os:void 0;X.URL=typeof URL<\"u\"?URL:null;X.pathToFileURL=BE;X.fileURLToPath=TE;X.Url;X.format;X.resolve;X.resolveObject;X.URL;yE=92,bE=47,wE=97,_E=122,rl=gE===\"win32\",mE=/\\//g,vE=/%/g,EE=/\\\\/g,SE=/\\n/g,AE=/\\r/g,IE=/\\t/g;PE=typeof Deno<\"u\"?Deno.build.os===\"windows\"?\"win32\":Deno.build.os:void 0;X.URL=typeof URL<\"u\"?URL:null;X.pathToFileURL=fg;X.fileURLToPath=ug;OE=X.Url,kE=X.format,xE=X.resolve,ME=X.resolveObject,LE=X.parse,UE=X.URL,NE=92,qE=47,DE=97,jE=122,il=PE===\"win32\",FE=/\\//g,WE=/%/g,$E=/\\\\/g,HE=/\\n/g,VE=/\\r/g,zE=/\\t/g});var nl={};Qt(nl,{Server:()=>Me,Socket:()=>Me,Stream:()=>Me,_createServerHandle:()=>Me,_normalizeArgs:()=>Me,_setSimultaneousAccepts:()=>Me,connect:()=>Me,createConnection:()=>Me,createServer:()=>Me,default:()=>QE,isIP:()=>Me,isIPv4:()=>Me,isIPv6:()=>Me});function Me(){throw new Error(\"Node.js net module is not supported by JSPM core outside of Node.js\")}var QE,sl=be(()=>{v();m();_();QE={_createServerHandle:Me,_normalizeArgs:Me,_setSimultaneousAccepts:Me,connect:Me,createConnection:Me,createServer:Me,isIP:Me,isIPv4:Me,isIPv6:Me,Server:Me,Socket:Me,Stream:Me}});var ol=M(Mi=>{\"use strict\";v();m();_();var dg=Mi&&Mi.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Mi,\"__esModule\",{value:!0});var YE=dg((sl(),Z(nl))),JE=dg(ot()),XE=(0,JE.default)(\"mqttjs:tcp\"),ZE=(t,e)=>{e.port=e.port||1883,e.hostname=e.hostname||e.host||\"localhost\";let{port:r}=e,i=e.hostname;return XE(\"port %d and host %s\",r,i),YE.default.createConnection(r,i)};Mi.default=ZE});var pg={};Qt(pg,{default:()=>eS});var eS,gg=be(()=>{v();m();_();eS={}});var ll=M(Li=>{\"use strict\";v();m();_();var al=Li&&Li.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Li,\"__esModule\",{value:!0});var tS=al((gg(),Z(pg))),rS=al((sl(),Z(nl))),iS=al(ot()),nS=(0,iS.default)(\"mqttjs:tls\"),sS=(t,e)=>{e.port=e.port||8883,e.host=e.hostname||e.host||\"localhost\",rS.default.isIP(e.host)===0&&(e.servername=e.host),e.rejectUnauthorized=e.rejectUnauthorized!==!1,delete e.path,nS(\"port %d host %s rejectUnauthorized %b\",e.port,e.host,e.rejectUnauthorized);let r=tS.default.connect(e);r.on(\"secureConnect\",()=>{e.rejectUnauthorized&&!r.authorized?r.emit(\"error\",new Error(\"TLS not authorized\")):r.removeListener(\"error\",i)});function i(n){e.rejectUnauthorized&&t.emit(\"error\",n),r.end()}return r.on(\"error\",i),r};Li.default=sS});var os=M(si=>{\"use strict\";v();m();_();Object.defineProperty(si,\"__esModule\",{value:!0});si.BufferedDuplex=si.writev=void 0;var oS=Dt();function yg(t,e){let r=new Array(t.length);for(let i=0;i<t.length;i++)typeof t[i].chunk==\"string\"?r[i]=k.from(t[i].chunk,\"utf8\"):r[i]=t[i].chunk;this._write(k.concat(r),\"binary\",e)}si.writev=yg;var ul=class extends oS.Duplex{constructor(e,r,i){super({objectMode:!0}),this.proxy=r,this.socket=i,this.writeQueue=[],e.objectMode||(this._writev=yg.bind(this)),this.isSocketOpen=!1,this.proxy.on(\"data\",n=>{this.push(n)})}_read(e){this.proxy.read(e)}_write(e,r,i){this.isSocketOpen?this.writeToProxy(e,r,i):this.writeQueue.push({chunk:e,encoding:r,cb:i})}_final(e){this.writeQueue=[],this.proxy.end(e)}socketReady(){this.emit(\"connect\"),this.isSocketOpen=!0,this.processWriteQueue()}writeToProxy(e,r,i){this.proxy.write(e,r)===!1?this.proxy.once(\"drain\",i):i()}processWriteQueue(){for(;this.writeQueue.length>0;){let{chunk:e,encoding:r,cb:i}=this.writeQueue.shift();this.writeToProxy(e,r,i)}}};si.BufferedDuplex=ul});var hl=M(cl=>{\"use strict\";v();m();_();Object.defineProperty(cl,\"__esModule\",{value:!0});var bg=(we(),Z(ve)),aS=Dt(),lS=os(),gt,fl,Le;function uS(){let t=new aS.Transform;return t._write=(e,r,i)=>{gt.send({data:e.buffer,success(){i()},fail(n){i(new Error(n))}})},t._flush=e=>{gt.close({success(){e()}})},t}function fS(t){t.hostname||(t.hostname=\"localhost\"),t.path||(t.path=\"/\"),t.wsOptions||(t.wsOptions={})}function cS(t,e){let r=t.protocol===\"wxs\"?\"wss\":\"ws\",i=`${r}://${t.hostname}${t.path}`;return t.port&&t.port!==80&&t.port!==443&&(i=`${r}://${t.hostname}:${t.port}${t.path}`),typeof t.transformWsUrl==\"function\"&&(i=t.transformWsUrl(i,t,e)),i}function hS(){gt.onOpen(()=>{Le.socketReady()}),gt.onMessage(t=>{let{data:e}=t;e instanceof ArrayBuffer?e=bg.Buffer.from(e):e=bg.Buffer.from(e,\"utf8\"),fl.push(e)}),gt.onClose(()=>{Le.emit(\"close\"),Le.end(),Le.destroy()}),gt.onError(t=>{let e=new Error(t.errMsg);Le.destroy(e)})}var dS=(t,e)=>{if(e.hostname=e.hostname||e.host,!e.hostname)throw new Error(\"Could not determine host. Specify host manually.\");let r=e.protocolId===\"MQIsdp\"&&e.protocolVersion===3?\"mqttv3.1\":\"mqtt\";fS(e);let i=cS(e,t);gt=wx.connectSocket({url:i,protocols:[r]}),fl=uS(),Le=new lS.BufferedDuplex(e,fl,gt),Le._destroy=(o,s)=>{gt.close({success(){s&&s(o)}})};let n=Le.destroy;return Le.destroy=(o,s)=>(Le.destroy=n,setTimeout(()=>{gt.close({fail(){Le._destroy(o,s)}})},0),Le),hS(),Le};cl.default=dS});var gl=M(pl=>{\"use strict\";v();m();_();Object.defineProperty(pl,\"__esModule\",{value:!0});var dl=(we(),Z(ve)),pS=Dt(),gS=os(),kt,as,oi,wg=!1;function yS(){let t=new pS.Transform;return t._write=(e,r,i)=>{kt.sendSocketMessage({data:e.buffer,success(){i()},fail(){i(new Error)}})},t._flush=e=>{kt.closeSocket({success(){e()}})},t}function bS(t){t.hostname||(t.hostname=\"localhost\"),t.path||(t.path=\"/\"),t.wsOptions||(t.wsOptions={})}function wS(t,e){let r=t.protocol===\"alis\"?\"wss\":\"ws\",i=`${r}://${t.hostname}${t.path}`;return t.port&&t.port!==80&&t.port!==443&&(i=`${r}://${t.hostname}:${t.port}${t.path}`),typeof t.transformWsUrl==\"function\"&&(i=t.transformWsUrl(i,t,e)),i}function _S(){wg||(wg=!0,kt.onSocketOpen(()=>{oi.socketReady()}),kt.onSocketMessage(t=>{if(typeof t.data==\"string\"){let e=dl.Buffer.from(t.data,\"base64\");as.push(e)}else{let e=new FileReader;e.addEventListener(\"load\",()=>{let r=e.result;r instanceof ArrayBuffer?r=dl.Buffer.from(r):r=dl.Buffer.from(r,\"utf8\"),as.push(r)}),e.readAsArrayBuffer(t.data)}}),kt.onSocketClose(()=>{oi.end(),oi.destroy()}),kt.onSocketError(t=>{oi.destroy(t)}))}var mS=(t,e)=>{if(e.hostname=e.hostname||e.host,!e.hostname)throw new Error(\"Could not determine host. Specify host manually.\");let r=e.protocolId===\"MQIsdp\"&&e.protocolVersion===3?\"mqttv3.1\":\"mqtt\";bS(e);let i=wS(e,t);return kt=e.my,kt.connectSocket({url:i,protocols:r}),as=yS(),oi=new gS.BufferedDuplex(e,as,kt),_S(),oi};pl.default=mS});var mg=M((RD,_g)=>{\"use strict\";v();m();_();_g.exports=function(){throw new Error(\"ws does not work in the browser. Browser clients must use the native WebSocket object\")}});var _l=M(Ui=>{\"use strict\";v();m();_();var wl=Ui&&Ui.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Ui,\"__esModule\",{value:!0});var yl=(we(),Z(ve)),vg=wl(mg()),vS=wl(ot()),ES=Dt(),Eg=wl(Pi()),bl=os(),Kt=(0,vS.default)(\"mqttjs:ws\"),SS=[\"rejectUnauthorized\",\"ca\",\"cert\",\"key\",\"pfx\",\"passphrase\"];function Sg(t,e){let r=`${t.protocol}://${t.hostname}:${t.port}${t.path}`;return typeof t.transformWsUrl==\"function\"&&(r=t.transformWsUrl(r,t,e)),r}function Ag(t){let e=t;return t.hostname||(e.hostname=\"localhost\"),t.port||(t.protocol===\"wss\"?e.port=443:e.port=80),t.path||(e.path=\"/\"),t.wsOptions||(e.wsOptions={}),!Eg.default&&t.protocol===\"wss\"&&SS.forEach(r=>{Object.prototype.hasOwnProperty.call(t,r)&&!Object.prototype.hasOwnProperty.call(t.wsOptions,r)&&(e.wsOptions[r]=t[r])}),e}function AS(t){let e=Ag(t);if(e.hostname||(e.hostname=e.host),!e.hostname){if(typeof document>\"u\")throw new Error(\"Could not determine host. Specify host manually.\");let r=new URL(document.URL);e.hostname=r.hostname,e.port||(e.port=Number(r.port))}return e.objectMode===void 0&&(e.objectMode=!(e.binary===!0||e.binary===void 0)),e}function IS(t,e,r){Kt(\"createWebSocket\"),Kt(`protocol: ${r.protocolId} ${r.protocolVersion}`);let i=r.protocolId===\"MQIsdp\"&&r.protocolVersion===3?\"mqttv3.1\":\"mqtt\";Kt(`creating new Websocket for url: ${e} and protocol: ${i}`);let n;return r.createWebsocket?n=r.createWebsocket(e,[i],r):n=new vg.default(e,[i],r.wsOptions),n}function TS(t,e){let r=e.protocolId===\"MQIsdp\"&&e.protocolVersion===3?\"mqttv3.1\":\"mqtt\",i=Sg(e,t),n;return e.createWebsocket?n=e.createWebsocket(i,[r],e):n=new WebSocket(i,[r]),n.binaryType=\"arraybuffer\",n}var RS=(t,e)=>{Kt(\"streamBuilder\");let r=Ag(e),i=Sg(r,t),n=IS(t,i,r),o=vg.default.createWebSocketStream(n,r.wsOptions);return o.url=i,n.on(\"close\",()=>{o.destroy()}),o},CS=(t,e)=>{Kt(\"browserStreamBuilder\");let r,n=AS(e).browserBufferSize||1024*512,o=e.browserBufferTimeout||1e3,s=!e.objectMode,a=TS(t,e),u=h(e,E,S);e.objectMode||(u._writev=bl.writev.bind(u)),u.on(\"close\",()=>{a.close()});let c=typeof a.addEventListener<\"u\";a.readyState===a.OPEN?(r=u,r.socket=a):(r=new bl.BufferedDuplex(e,u,a),c?a.addEventListener(\"open\",d):a.onopen=d),c?(a.addEventListener(\"close\",g),a.addEventListener(\"error\",y),a.addEventListener(\"message\",w)):(a.onclose=g,a.onerror=y,a.onmessage=w);function h(I,C,R){let U=new ES.Transform({objectMode:I.objectMode});return U._write=C,U._flush=R,U}function d(){Kt(\"WebSocket onOpen\"),r instanceof bl.BufferedDuplex&&r.socketReady()}function g(I){Kt(\"WebSocket onClose\",I),r.end(),r.destroy()}function y(I){Kt(\"WebSocket onError\",I);let C=new Error(\"WebSocket error\");C.event=I,r.destroy(C)}function w(I){let{data:C}=I;C instanceof ArrayBuffer?C=yl.Buffer.from(C):C=yl.Buffer.from(C,\"utf8\"),u.push(C)}function E(I,C,R){if(a.bufferedAmount>n){setTimeout(E,o,I,C,R);return}s&&typeof I==\"string\"&&(I=yl.Buffer.from(I,\"utf8\"));try{a.send(I)}catch(U){return R(U)}R()}function S(I){a.close(),I()}return r};Ui.default=Eg.default?CS:RS});var Rg=M(Tr=>{\"use strict\";v();m();_();var ls=Tr&&Tr.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Tr,\"__esModule\",{value:!0});Tr.connectAsync=void 0;var BS=ls(ot()),PS=ls((hg(),Z(cg))),OS=ls(ns()),kS=ls(Pi()),Ig=(0,BS.default)(\"mqttjs\"),Re={};kS.default?(Re.wx=hl().default,Re.wxs=hl().default,Re.ali=gl().default,Re.alis=gl().default):(Re.mqtt=ol().default,Re.tcp=ol().default,Re.ssl=ll().default,Re.tls=Re.ssl,Re.mqtts=ll().default);Re.ws=_l().default;Re.wss=_l().default;function xS(t){let e;t.auth&&(e=t.auth.match(/^(.+):(.+)$/),e?(t.username=e[1],t.password=e[2]):t.username=t.auth)}function Tg(t,e){if(Ig(\"connecting to an MQTT broker...\"),typeof t==\"object\"&&!e&&(e=t,t=\"\"),e=e||{},t&&typeof t==\"string\"){let n=PS.default.parse(t,!0);if(n.port!=null&&(n.port=Number(n.port)),e=Object.assign(Object.assign({},n),e),e.protocol===null)throw new Error(\"Missing protocol\");e.protocol=e.protocol.replace(/:$/,\"\")}if(xS(e),e.query&&typeof e.query.clientId==\"string\"&&(e.clientId=e.query.clientId),e.cert&&e.key)if(e.protocol){if([\"mqtts\",\"wss\",\"wxs\",\"alis\"].indexOf(e.protocol)===-1)switch(e.protocol){case\"mqtt\":e.protocol=\"mqtts\";break;case\"ws\":e.protocol=\"wss\";break;case\"wx\":e.protocol=\"wxs\";break;case\"ali\":e.protocol=\"alis\";break;default:throw new Error(`Unknown protocol for secure connection: \"${e.protocol}\"!`)}}else throw new Error(\"Missing secure protocol key\");if(!Re[e.protocol]){let n=[\"mqtts\",\"wss\"].indexOf(e.protocol)!==-1;e.protocol=[\"mqtt\",\"mqtts\",\"ws\",\"wss\",\"wx\",\"wxs\",\"ali\",\"alis\"].filter((o,s)=>n&&s%2===0?!1:typeof Re[o]==\"function\")[0]}if(e.clean===!1&&!e.clientId)throw new Error(\"Missing clientId for unclean clients\");e.protocol&&(e.defaultProtocol=e.protocol);function r(n){return e.servers&&((!n._reconnectCount||n._reconnectCount===e.servers.length)&&(n._reconnectCount=0),e.host=e.servers[n._reconnectCount].host,e.port=e.servers[n._reconnectCount].port,e.protocol=e.servers[n._reconnectCount].protocol?e.servers[n._reconnectCount].protocol:e.defaultProtocol,e.hostname=e.host,n._reconnectCount++),Ig(\"calling streambuilder for\",e.protocol),Re[e.protocol](n,e)}let i=new OS.default(r,e);return i.on(\"error\",()=>{}),i}function MS(t,e,r=!0){return new Promise((i,n)=>{let o=Tg(t,e),s={connect:u=>{a(),i(o)},end:()=>{a(),i(o)},error:u=>{a(),o.end(),n(u)}};r===!1&&(s.close=()=>{s.error(new Error(\"Couldn't connect to server\"))});function a(){Object.keys(s).forEach(u=>{o.off(u,s[u])})}Object.keys(s).forEach(u=>{o.on(u,s[u])})})}Tr.connectAsync=MS;Tr.default=Tg});var ml=M(G=>{\"use strict\";v();m();_();var Cg=G&&G.__createBinding||(Object.create?function(t,e,r,i){i===void 0&&(i=r);var n=Object.getOwnPropertyDescriptor(e,r);(!n||(\"get\"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,i,n)}:function(t,e,r,i){i===void 0&&(i=r),t[i]=e[r]}),LS=G&&G.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),US=G&&G.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(t!=null)for(var r in t)r!==\"default\"&&Object.prototype.hasOwnProperty.call(t,r)&&Cg(e,t,r);return LS(e,t),e},Bg=G&&G.__exportStar||function(t,e){for(var r in t)r!==\"default\"&&!Object.prototype.hasOwnProperty.call(e,r)&&Cg(e,t,r)},Ni=G&&G.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(G,\"__esModule\",{value:!0});G.ReasonCodes=G.PingTimer=G.UniqueMessageIdProvider=G.DefaultMessageIdProvider=G.Store=G.MqttClient=G.connectAsync=G.connect=G.Client=void 0;var Pg=Ni(ns());G.MqttClient=Pg.default;var NS=Ni(Yo());G.DefaultMessageIdProvider=NS.default;var qS=Ni(Fp());G.UniqueMessageIdProvider=qS.default;var DS=Ni(Zo());G.Store=DS.default;var Og=US(Rg());G.connect=Og.default;Object.defineProperty(G,\"connectAsync\",{enumerable:!0,get:function(){return Og.connectAsync}});var jS=Ni(qa());G.PingTimer=jS.default;G.Client=Pg.default;Bg(ns(),G);Bg(Yr(),G);var FS=Si();Object.defineProperty(G,\"ReasonCodes\",{enumerable:!0,get:function(){return FS.ReasonCodes}})});var zS=M(We=>{v();m();_();var kg=We&&We.__createBinding||(Object.create?function(t,e,r,i){i===void 0&&(i=r);var n=Object.getOwnPropertyDescriptor(e,r);(!n||(\"get\"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,i,n)}:function(t,e,r,i){i===void 0&&(i=r),t[i]=e[r]}),WS=We&&We.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),$S=We&&We.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(t!=null)for(var r in t)r!==\"default\"&&Object.prototype.hasOwnProperty.call(t,r)&&kg(e,t,r);return WS(e,t),e},HS=We&&We.__exportStar||function(t,e){for(var r in t)r!==\"default\"&&!Object.prototype.hasOwnProperty.call(e,r)&&kg(e,t,r)};Object.defineProperty(We,\"__esModule\",{value:!0});var VS=$S(ml());We.default=VS;HS(ml(),We)});/* harmony default export */ __webpack_exports__[\"default\"] = (zS());\n/*! Bundled license information:\n\n@jspm/core/nodelibs/browser/buffer.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n*/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbXF0dC9kaXN0L21xdHQuZXNtLmpzIiwibWFwcGluZ3MiOiI7QUFBQSw2QkFBNkIsdUNBQXVDLGtDQUFrQyx1Q0FBdUMsb0NBQW9DLDJCQUEyQixXQUFXLG1DQUFtQyx1QkFBdUIsdUJBQXVCLEVBQUUsZ0JBQWdCLGdHQUFnRyxtREFBbUQsRUFBRSxVQUFVLGlCQUFpQixlQUFlLFNBQVMsS0FBSyxnQkFBZ0IsR0FBRyx1REFBdUQsRUFBRSxTQUFTLE1BQU0saXZDQUFpdkMsRUFBRSxlQUFlLDBGQUEwRixjQUFjLG1FQUFtRSxjQUFjLFFBQVEsdUJBQXVCLE1BQU0sb0JBQW9CLEVBQUUsRUFBRSxnQkFBZ0IsT0FBTyxrQkFBa0Isa0JBQWtCLCtCQUErQixlQUFlLG9DQUFvQyxrQ0FBa0MsbUJBQW1CLHdCQUF3QiwwREFBMEQsaUJBQWlCLHdCQUF3QixlQUFlLGVBQWUscUJBQXFCLGVBQWUsYUFBYSxjQUFjLFNBQVMsY0FBYyxTQUFTLGlCQUFpQiw0Q0FBNEMsY0FBYyxTQUFTLGNBQWMsb0JBQW9CLGVBQWUscUdBQXFHLHFEQUFxRCxjQUFjLFVBQVUsZUFBZSxTQUFTLHFOQUFxTixJQUFJLElBQUksSUFBSSxrQkFBa0IsNEJBQTRCLGlDQUFpQyx1Q0FBdUMseUVBQXlFLDhDQUE4QyxrQkFBa0IsOEJBQThCLGdCQUFnQixjQUFjLGdCQUFnQixTQUFTLGVBQWUsVUFBVSxpQkFBaUIsS0FBSyxrREFBa0QsWUFBWSxLQUFLLGFBQWEsMEJBQTBCLFNBQVMscUNBQXFDLElBQUksaUdBQWlHLGFBQWEsaUlBQWlJLDZIQUE2SCwrSEFBK0gsT0FBTyxzQkFBc0IsWUFBWSxvRUFBb0UsV0FBVyxNQUFNLGdEQUFnRCxJQUFJLCs4QkFBKzhCLEVBQUUsY0FBYyxLQUFLLEVBQUUsVUFBVSxPQUFPLHVFQUF1RSxFQUFFLGNBQWMsZ0JBQWdCLDBEQUEwRCwrSUFBK0ksSUFBSSxtQ0FBbUMsZ0RBQWdELGNBQWMsZUFBZSwy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ZV9tb2R1bGVzL21xdHQvZGlzdC9tcXR0LmVzbS5qcz82YWIyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkcz1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyICRnPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIEhnPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBWZz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBiZT0odCxlKT0+KCk9Pih0JiYoZT10KHQ9MCkpLGUpO3ZhciBNPSh0LGUpPT4oKT0+KGV8fHQoKGU9e2V4cG9ydHM6e319KS5leHBvcnRzLGUpLGUuZXhwb3J0cyksUXQ9KHQsZSk9Pntmb3IodmFyIHIgaW4gZSlkcyh0LHIse2dldDplW3JdLGVudW1lcmFibGU6ITB9KX0semc9KHQsZSxyLGkpPT57aWYoZSYmdHlwZW9mIGU9PVwib2JqZWN0XCJ8fHR5cGVvZiBlPT1cImZ1bmN0aW9uXCIpZm9yKGxldCBuIG9mIEhnKGUpKSFWZy5jYWxsKHQsbikmJm4hPT1yJiZkcyh0LG4se2dldDooKT0+ZVtuXSxlbnVtZXJhYmxlOiEoaT0kZyhlLG4pKXx8aS5lbnVtZXJhYmxlfSk7cmV0dXJuIHR9O3ZhciBaPXQ9PnpnKGRzKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQpO3ZhciBCLF89YmUoKCk9PntCPXtkZXZpY2VNZW1vcnk6OCxoYXJkd2FyZUNvbmN1cnJlbmN5OjgsbGFuZ3VhZ2U6XCJlbi1VU1wifX0pO3ZhciBQPXt9O1F0KFAse19kZWJ1Z0VuZDooKT0+eXUsX2RlYnVnUHJvY2VzczooKT0+Z3UsX2V2ZW50czooKT0+a3UsX2V2ZW50c0NvdW50OigpPT54dSxfZXhpdGluZzooKT0+WWwsX2ZhdGFsRXhjZXB0aW9uczooKT0+Y3UsX2dldEFjdGl2ZUhhbmRsZXM6KCk9PmV1LF9nZXRBY3RpdmVSZXF1ZXN0czooKT0+WmwsX2tpbGw6KCk9PnJ1LF9saW5rZWRCaW5kaW5nOigpPT5HbCxfbWF4TGlzdGVuZXJzOigpPT5PdSxfcHJlbG9hZF9tb2R1bGVzOigpPT5DdSxfcmF3RGVidWc6KCk9PnpsLF9zdGFydFByb2ZpbGVySWRsZU5vdGlmaWVyOigpPT5idSxfc3RvcFByb2ZpbGVySWRsZU5vdGlmaWVyOigpPT53dSxfdGlja0NhbGxiYWNrOigpPT5wdSxhYm9ydDooKT0+RXUsYWRkTGlzdGVuZXI6KCk9Pk11LGFsbG93ZWROb2RlRW52aXJvbm1lbnRGbGFnczooKT0+bHUsYXJjaDooKT0+eGwsYXJndjooKT0+VWwsYXJndjA6KCk9PlJ1LGFzc2VydDooKT0+dXUsYmluZGluZzooKT0+RmwsY2hkaXI6KCk9PkhsLGNvbmZpZzooKT0+SmwsY3B1VXNhZ2U6KCk9PkZpLGN3ZDooKT0+JGwsZGVidWdQb3J0OigpPT5UdSxkZWZhdWx0OigpPT4kdSxkbG9wZW46KCk9PlhsLGRvbWFpbjooKT0+UWwsZW1pdDooKT0+RHUsZW1pdFdhcm5pbmc6KCk9PmpsLGVudjooKT0+TGwsZXhlY0FyZ3Y6KCk9Pk5sLGV4ZWNQYXRoOigpPT5JdSxleGl0OigpPT5vdSxmZWF0dXJlczooKT0+ZnUsaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2s6KCk9PmR1LGhydGltZTooKT0+amksa2lsbDooKT0+c3UsbGlzdGVuZXJzOigpPT5XdSxtZW1vcnlVc2FnZTooKT0+bnUsbW9kdWxlTG9hZExpc3Q6KCk9PktsLG5leHRUaWNrOigpPT5QbCxvZmY6KCk9PlV1LG9uOigpPT5idCxvbmNlOigpPT5MdSxvcGVuU3RkaW46KCk9PmF1LHBpZDooKT0+U3UscGxhdGZvcm06KCk9Pk1sLHBwaWQ6KCk9PkF1LHByZXBlbmRMaXN0ZW5lcjooKT0+anUscHJlcGVuZE9uY2VMaXN0ZW5lcjooKT0+RnUscmVhbGx5RXhpdDooKT0+dHUscmVsZWFzZTooKT0+VmwscmVtb3ZlQWxsTGlzdGVuZXJzOigpPT5xdSxyZW1vdmVMaXN0ZW5lcjooKT0+TnUscmVzb3VyY2VVc2FnZTooKT0+aXUsc2V0U291cmNlTWFwc0VuYWJsZWQ6KCk9PkJ1LHNldFVuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrOigpPT5odSxzdGRlcnI6KCk9Pm11LHN0ZGluOigpPT52dSxzdGRvdXQ6KCk9Pl91LHRpdGxlOigpPT5rbCx1bWFzazooKT0+V2wsdXB0aW1lOigpPT5QdSx2ZXJzaW9uOigpPT5xbCx2ZXJzaW9uczooKT0+RGx9KTtmdW5jdGlvbiB5cyh0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb2RlLmpzIHByb2Nlc3MgXCIrdCtcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IEpTUE0gY29yZSBvdXRzaWRlIG9mIE5vZGUuanNcIil9ZnVuY3Rpb24gS2coKXsha3J8fCFZdHx8KGtyPSExLFl0Lmxlbmd0aD95dD1ZdC5jb25jYXQoeXQpOkRpPS0xLHl0Lmxlbmd0aCYmQmwoKSl9ZnVuY3Rpb24gQmwoKXtpZigha3Ipe3ZhciB0PXNldFRpbWVvdXQoS2csMCk7a3I9ITA7Zm9yKHZhciBlPXl0Lmxlbmd0aDtlOyl7Zm9yKFl0PXl0LHl0PVtdOysrRGk8ZTspWXQmJll0W0RpXS5ydW4oKTtEaT0tMSxlPXl0Lmxlbmd0aH1ZdD1udWxsLGtyPSExLGNsZWFyVGltZW91dCh0KX19ZnVuY3Rpb24gUGwodCl7dmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspZVtyLTFdPWFyZ3VtZW50c1tyXTt5dC5wdXNoKG5ldyBPbCh0LGUpKSx5dC5sZW5ndGg9PT0xJiYha3ImJnNldFRpbWVvdXQoQmwsMCl9ZnVuY3Rpb24gT2wodCxlKXt0aGlzLmZ1bj10LHRoaXMuYXJyYXk9ZX1mdW5jdGlvbiBtZSgpe31mdW5jdGlvbiBHbCh0KXt5cyhcIl9saW5rZWRCaW5kaW5nXCIpfWZ1bmN0aW9uIFhsKHQpe3lzKFwiZGxvcGVuXCIpfWZ1bmN0aW9uIFpsKCl7cmV0dXJuW119ZnVuY3Rpb24gZXUoKXtyZXR1cm5bXX1mdW5jdGlvbiB1dSh0LGUpe2lmKCF0KXRocm93IG5ldyBFcnJvcihlfHxcImFzc2VydGlvbiBlcnJvclwiKX1mdW5jdGlvbiBkdSgpe3JldHVybiExfWZ1bmN0aW9uIFB1KCl7cmV0dXJuIE10Lm5vdygpLzFlM31mdW5jdGlvbiBqaSh0KXt2YXIgZT1NYXRoLmZsb29yKChEYXRlLm5vdygpLU10Lm5vdygpKSouMDAxKSxyPU10Lm5vdygpKi4wMDEsaT1NYXRoLmZsb29yKHIpK2Usbj1NYXRoLmZsb29yKHIlMSoxZTkpO3JldHVybiB0JiYoaT1pLXRbMF0sbj1uLXRbMV0sbjwwJiYoaS0tLG4rPWdzKSksW2ksbl19ZnVuY3Rpb24gYnQoKXtyZXR1cm4gJHV9ZnVuY3Rpb24gV3UodCl7cmV0dXJuW119dmFyIHl0LGtyLFl0LERpLGtsLHhsLE1sLExsLFVsLE5sLHFsLERsLGpsLEZsLFdsLCRsLEhsLFZsLHpsLEtsLFFsLFlsLEpsLHR1LHJ1LEZpLGl1LG51LHN1LG91LGF1LGx1LGZ1LGN1LGh1LHB1LGd1LHl1LGJ1LHd1LF91LG11LHZ1LEV1LFN1LEF1LEl1LFR1LFJ1LEN1LEJ1LE10LHBzLGdzLE91LGt1LHh1LE11LEx1LFV1LE51LHF1LER1LGp1LEZ1LCR1LEh1PWJlKCgpPT57digpO20oKTtfKCk7eXQ9W10sa3I9ITEsRGk9LTE7T2wucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O2tsPVwiYnJvd3NlclwiLHhsPVwieDY0XCIsTWw9XCJicm93c2VyXCIsTGw9e1BBVEg6XCIvdXNyL2JpblwiLExBTkc6Qi5sYW5ndWFnZStcIi5VVEYtOFwiLFBXRDpcIi9cIixIT01FOlwiL2hvbWVcIixUTVA6XCIvdG1wXCJ9LFVsPVtcIi91c3IvYmluL25vZGVcIl0sTmw9W10scWw9XCJ2MTYuOC4wXCIsRGw9e30samw9ZnVuY3Rpb24odCxlKXtjb25zb2xlLndhcm4oKGU/ZStcIjogXCI6XCJcIikrdCl9LEZsPWZ1bmN0aW9uKHQpe3lzKFwiYmluZGluZ1wiKX0sV2w9ZnVuY3Rpb24odCl7cmV0dXJuIDB9LCRsPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9LEhsPWZ1bmN0aW9uKHQpe30sVmw9e25hbWU6XCJub2RlXCIsc291cmNlVXJsOlwiXCIsaGVhZGVyc1VybDpcIlwiLGxpYlVybDpcIlwifTt6bD1tZSxLbD1bXTtRbD17fSxZbD0hMSxKbD17fTt0dT1tZSxydT1tZSxGaT1mdW5jdGlvbigpe3JldHVybnt9fSxpdT1GaSxudT1GaSxzdT1tZSxvdT1tZSxhdT1tZSxsdT17fTtmdT17aW5zcGVjdG9yOiExLGRlYnVnOiExLHV2OiExLGlwdjY6ITEsdGxzX2FscG46ITEsdGxzX3NuaTohMSx0bHNfb2NzcDohMSx0bHM6ITEsY2FjaGVkX2J1aWx0aW5zOiEwfSxjdT1tZSxodT1tZTtwdT1tZSxndT1tZSx5dT1tZSxidT1tZSx3dT1tZSxfdT12b2lkIDAsbXU9dm9pZCAwLHZ1PXZvaWQgMCxFdT1tZSxTdT0yLEF1PTEsSXU9XCIvYmluL3Vzci9ub2RlXCIsVHU9OTIyOSxSdT1cIm5vZGVcIixDdT1bXSxCdT1tZSxNdD17bm93OnR5cGVvZiBwZXJmb3JtYW5jZTxcInVcIj9wZXJmb3JtYW5jZS5ub3cuYmluZChwZXJmb3JtYW5jZSk6dm9pZCAwLHRpbWluZzp0eXBlb2YgcGVyZm9ybWFuY2U8XCJ1XCI/cGVyZm9ybWFuY2UudGltaW5nOnZvaWQgMH07TXQubm93PT09dm9pZCAwJiYocHM9RGF0ZS5ub3coKSxNdC50aW1pbmcmJk10LnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQmJihwcz1NdC50aW1pbmcubmF2aWdhdGlvblN0YXJ0KSxNdC5ub3c9KCk9PkRhdGUubm93KCktcHMpO2dzPTFlOTtqaS5iaWdpbnQ9ZnVuY3Rpb24odCl7dmFyIGU9amkodCk7cmV0dXJuIHR5cGVvZiBCaWdJbnQ+XCJ1XCI/ZVswXSpncytlWzFdOkJpZ0ludChlWzBdKmdzKStCaWdJbnQoZVsxXSl9O091PTEwLGt1PXt9LHh1PTA7TXU9YnQsTHU9YnQsVXU9YnQsTnU9YnQscXU9YnQsRHU9bWUsanU9YnQsRnU9YnQ7JHU9e3ZlcnNpb246cWwsdmVyc2lvbnM6RGwsYXJjaDp4bCxwbGF0Zm9ybTpNbCxyZWxlYXNlOlZsLF9yYXdEZWJ1Zzp6bCxtb2R1bGVMb2FkTGlzdDpLbCxiaW5kaW5nOkZsLF9saW5rZWRCaW5kaW5nOkdsLF9ldmVudHM6a3UsX2V2ZW50c0NvdW50Onh1LF9tYXhMaXN0ZW5lcnM6T3Usb246YnQsYWRkTGlzdGVuZXI6TXUsb25jZTpMdSxvZmY6VXUscmVtb3ZlTGlzdGVuZXI6TnUscmVtb3ZlQWxsTGlzdGVuZXJzOnF1LGVtaXQ6RHUscHJlcGVuZExpc3RlbmVyOmp1LHByZXBlbmRPbmNlTGlzdGVuZXI6RnUsbGlzdGVuZXJzOld1LGRvbWFpbjpRbCxfZXhpdGluZzpZbCxjb25maWc6SmwsZGxvcGVuOlhsLHVwdGltZTpQdSxfZ2V0QWN0aXZlUmVxdWVzdHM6WmwsX2dldEFjdGl2ZUhhbmRsZXM6ZXUscmVhbGx5RXhpdDp0dSxfa2lsbDpydSxjcHVVc2FnZTpGaSxyZXNvdXJjZVVzYWdlOml1LG1lbW9yeVVzYWdlOm51LGtpbGw6c3UsZXhpdDpvdSxvcGVuU3RkaW46YXUsYWxsb3dlZE5vZGVFbnZpcm9ubWVudEZsYWdzOmx1LGFzc2VydDp1dSxmZWF0dXJlczpmdSxfZmF0YWxFeGNlcHRpb25zOmN1LHNldFVuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrOmh1LGhhc1VuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrOmR1LGVtaXRXYXJuaW5nOmpsLG5leHRUaWNrOlBsLF90aWNrQ2FsbGJhY2s6cHUsX2RlYnVnUHJvY2VzczpndSxfZGVidWdFbmQ6eXUsX3N0YXJ0UHJvZmlsZXJJZGxlTm90aWZpZXI6YnUsX3N0b3BQcm9maWxlcklkbGVOb3RpZmllcjp3dSxzdGRvdXQ6X3Usc3RkaW46dnUsc3RkZXJyOm11LGFib3J0OkV1LHVtYXNrOldsLGNoZGlyOkhsLGN3ZDokbCxlbnY6TGwsdGl0bGU6a2wsYXJndjpVbCxleGVjQXJndjpObCxwaWQ6U3UscHBpZDpBdSxleGVjUGF0aDpJdSxkZWJ1Z1BvcnQ6VHUsaHJ0aW1lOmppLGFyZ3YwOlJ1LF9wcmVsb2FkX21vZHVsZXM6Q3Usc2V0U291cmNlTWFwc0VuYWJsZWQ6QnV9fSk7dmFyIG09YmUoKCk9PntIdSgpfSk7dmFyIHZlPXt9O1F0KHZlLHtCdWZmZXI6KCk9PmssSU5TUEVDVF9NQVhfQllURVM6KCk9PkpnLGRlZmF1bHQ6KCk9Pkx0LGtNYXhMZW5ndGg6KCk9PlhnfSk7ZnVuY3Rpb24gR2coKXtpZihWdSlyZXR1cm4gbGk7VnU9ITAsbGkuYnl0ZUxlbmd0aD1hLGxpLnRvQnl0ZUFycmF5PWMsbGkuZnJvbUJ5dGVBcnJheT1nO2Zvcih2YXIgdD1bXSxlPVtdLHI9dHlwZW9mIFVpbnQ4QXJyYXk8XCJ1XCI/VWludDhBcnJheTpBcnJheSxpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLG49MCxvPWkubGVuZ3RoO248bzsrK24pdFtuXT1pW25dLGVbaS5jaGFyQ29kZUF0KG4pXT1uO2VbXCItXCIuY2hhckNvZGVBdCgwKV09NjIsZVtcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBzKHkpe3ZhciB3PXkubGVuZ3RoO2lmKHclND4wKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIik7dmFyIEU9eS5pbmRleE9mKFwiPVwiKTtFPT09LTEmJihFPXcpO3ZhciBTPUU9PT13PzA6NC1FJTQ7cmV0dXJuW0UsU119ZnVuY3Rpb24gYSh5KXt2YXIgdz1zKHkpLEU9d1swXSxTPXdbMV07cmV0dXJuKEUrUykqMy80LVN9ZnVuY3Rpb24gdSh5LHcsRSl7cmV0dXJuKHcrRSkqMy80LUV9ZnVuY3Rpb24gYyh5KXt2YXIgdyxFPXMoeSksUz1FWzBdLEk9RVsxXSxDPW5ldyByKHUoeSxTLEkpKSxSPTAsVT1JPjA/Uy00OlMsTjtmb3IoTj0wO048VTtOKz00KXc9ZVt5LmNoYXJDb2RlQXQoTildPDwxOHxlW3kuY2hhckNvZGVBdChOKzEpXTw8MTJ8ZVt5LmNoYXJDb2RlQXQoTisyKV08PDZ8ZVt5LmNoYXJDb2RlQXQoTiszKV0sQ1tSKytdPXc+PjE2JjI1NSxDW1IrK109dz4+OCYyNTUsQ1tSKytdPXcmMjU1O3JldHVybiBJPT09MiYmKHc9ZVt5LmNoYXJDb2RlQXQoTildPDwyfGVbeS5jaGFyQ29kZUF0KE4rMSldPj40LENbUisrXT13JjI1NSksST09PTEmJih3PWVbeS5jaGFyQ29kZUF0KE4pXTw8MTB8ZVt5LmNoYXJDb2RlQXQoTisxKV08PDR8ZVt5LmNoYXJDb2RlQXQoTisyKV0+PjIsQ1tSKytdPXc+PjgmMjU1LENbUisrXT13JjI1NSksQ31mdW5jdGlvbiBoKHkpe3JldHVybiB0W3k+PjE4JjYzXSt0W3k+PjEyJjYzXSt0W3k+PjYmNjNdK3RbeSY2M119ZnVuY3Rpb24gZCh5LHcsRSl7Zm9yKHZhciBTLEk9W10sQz13O0M8RTtDKz0zKVM9KHlbQ108PDE2JjE2NzExNjgwKSsoeVtDKzFdPDw4JjY1MjgwKSsoeVtDKzJdJjI1NSksSS5wdXNoKGgoUykpO3JldHVybiBJLmpvaW4oXCJcIil9ZnVuY3Rpb24gZyh5KXtmb3IodmFyIHcsRT15Lmxlbmd0aCxTPUUlMyxJPVtdLEM9MTYzODMsUj0wLFU9RS1TO1I8VTtSKz1DKUkucHVzaChkKHksUixSK0M+VT9VOlIrQykpO3JldHVybiBTPT09MT8odz15W0UtMV0sSS5wdXNoKHRbdz4+Ml0rdFt3PDw0JjYzXStcIj09XCIpKTpTPT09MiYmKHc9KHlbRS0yXTw8OCkreVtFLTFdLEkucHVzaCh0W3c+PjEwXSt0W3c+PjQmNjNdK3Rbdzw8MiY2M10rXCI9XCIpKSxJLmpvaW4oXCJcIil9cmV0dXJuIGxpfWZ1bmN0aW9uIFFnKCl7aWYoenUpcmV0dXJuIFdpO3p1PSEwO3JldHVybiBXaS5yZWFkPWZ1bmN0aW9uKHQsZSxyLGksbil7dmFyIG8scyxhPW4qOC1pLTEsdT0oMTw8YSktMSxjPXU+PjEsaD0tNyxkPXI/bi0xOjAsZz1yPy0xOjEseT10W2UrZF07Zm9yKGQrPWcsbz15JigxPDwtaCktMSx5Pj49LWgsaCs9YTtoPjA7bz1vKjI1Nit0W2UrZF0sZCs9ZyxoLT04KTtmb3Iocz1vJigxPDwtaCktMSxvPj49LWgsaCs9aTtoPjA7cz1zKjI1Nit0W2UrZF0sZCs9ZyxoLT04KTtpZihvPT09MClvPTEtYztlbHNle2lmKG89PT11KXJldHVybiBzP05hTjooeT8tMToxKSooMS8wKTtzPXMrTWF0aC5wb3coMixpKSxvPW8tY31yZXR1cm4oeT8tMToxKSpzKk1hdGgucG93KDIsby1pKX0sV2kud3JpdGU9ZnVuY3Rpb24odCxlLHIsaSxuLG8pe3ZhciBzLGEsdSxjPW8qOC1uLTEsaD0oMTw8YyktMSxkPWg+PjEsZz1uPT09MjM/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowLHk9aT8wOm8tMSx3PWk/MTotMSxFPWU8MHx8ZT09PTAmJjEvZTwwPzE6MDtmb3IoZT1NYXRoLmFicyhlKSxpc05hTihlKXx8ZT09PTEvMD8oYT1pc05hTihlKT8xOjAscz1oKToocz1NYXRoLmZsb29yKE1hdGgubG9nKGUpL01hdGguTE4yKSxlKih1PU1hdGgucG93KDIsLXMpKTwxJiYocy0tLHUqPTIpLHMrZD49MT9lKz1nL3U6ZSs9ZypNYXRoLnBvdygyLDEtZCksZSp1Pj0yJiYocysrLHUvPTIpLHMrZD49aD8oYT0wLHM9aCk6cytkPj0xPyhhPShlKnUtMSkqTWF0aC5wb3coMixuKSxzPXMrZCk6KGE9ZSpNYXRoLnBvdygyLGQtMSkqTWF0aC5wb3coMixuKSxzPTApKTtuPj04O3Rbcit5XT1hJjI1NSx5Kz13LGEvPTI1NixuLT04KTtmb3Iocz1zPDxufGEsYys9bjtjPjA7dFtyK3ldPXMmMjU1LHkrPXcscy89MjU2LGMtPTgpO3Rbcit5LXddfD1FKjEyOH0sV2l9ZnVuY3Rpb24gWWcoKXtpZihLdSlyZXR1cm4gSnQ7S3U9ITA7bGV0IHQ9R2coKSxlPVFnKCkscj10eXBlb2YgU3ltYm9sPT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuZm9yPT1cImZ1bmN0aW9uXCI/U3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpOm51bGw7SnQuQnVmZmVyPXMsSnQuU2xvd0J1ZmZlcj1JLEp0LklOU1BFQ1RfTUFYX0JZVEVTPTUwO2xldCBpPTIxNDc0ODM2NDc7SnQua01heExlbmd0aD1pLHMuVFlQRURfQVJSQVlfU1VQUE9SVD1uKCksIXMuVFlQRURfQVJSQVlfU1VQUE9SVCYmdHlwZW9mIGNvbnNvbGU8XCJ1XCImJnR5cGVvZiBjb25zb2xlLmVycm9yPT1cImZ1bmN0aW9uXCImJmNvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC5cIik7ZnVuY3Rpb24gbigpe3RyeXtsZXQgcD1uZXcgVWludDhBcnJheSgxKSxsPXtmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fTtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKGwsVWludDhBcnJheS5wcm90b3R5cGUpLE9iamVjdC5zZXRQcm90b3R5cGVPZihwLGwpLHAuZm9vKCk9PT00Mn1jYXRjaHtyZXR1cm4hMX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHMucHJvdG90eXBlLFwicGFyZW50XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7aWYocy5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdGhpcy5idWZmZXJ9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHMucHJvdG90eXBlLFwib2Zmc2V0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7aWYocy5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdGhpcy5ieXRlT2Zmc2V0fX0pO2Z1bmN0aW9uIG8ocCl7aWYocD5pKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK3ArJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpO2xldCBsPW5ldyBVaW50OEFycmF5KHApO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YobCxzLnByb3RvdHlwZSksbH1mdW5jdGlvbiBzKHAsbCxmKXtpZih0eXBlb2YgcD09XCJudW1iZXJcIil7aWYodHlwZW9mIGw9PVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTtyZXR1cm4gaChwKX1yZXR1cm4gYShwLGwsZil9cy5wb29sU2l6ZT04MTkyO2Z1bmN0aW9uIGEocCxsLGYpe2lmKHR5cGVvZiBwPT1cInN0cmluZ1wiKXJldHVybiBkKHAsbCk7aWYoQXJyYXlCdWZmZXIuaXNWaWV3KHApKXJldHVybiB5KHApO2lmKHA9PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBwKTtpZihZZShwLEFycmF5QnVmZmVyKXx8cCYmWWUocC5idWZmZXIsQXJyYXlCdWZmZXIpfHx0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI8XCJ1XCImJihZZShwLFNoYXJlZEFycmF5QnVmZmVyKXx8cCYmWWUocC5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSlyZXR1cm4gdyhwLGwsZik7aWYodHlwZW9mIHA9PVwibnVtYmVyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTtsZXQgYj1wLnZhbHVlT2YmJnAudmFsdWVPZigpO2lmKGIhPW51bGwmJmIhPT1wKXJldHVybiBzLmZyb20oYixsLGYpO2xldCBBPUUocCk7aWYoQSlyZXR1cm4gQTtpZih0eXBlb2YgU3ltYm9sPFwidVwiJiZTeW1ib2wudG9QcmltaXRpdmUhPW51bGwmJnR5cGVvZiBwW1N5bWJvbC50b1ByaW1pdGl2ZV09PVwiZnVuY3Rpb25cIilyZXR1cm4gcy5mcm9tKHBbU3ltYm9sLnRvUHJpbWl0aXZlXShcInN0cmluZ1wiKSxsLGYpO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgcCl9cy5mcm9tPWZ1bmN0aW9uKHAsbCxmKXtyZXR1cm4gYShwLGwsZil9LE9iamVjdC5zZXRQcm90b3R5cGVPZihzLnByb3RvdHlwZSxVaW50OEFycmF5LnByb3RvdHlwZSksT2JqZWN0LnNldFByb3RvdHlwZU9mKHMsVWludDhBcnJheSk7ZnVuY3Rpb24gdShwKXtpZih0eXBlb2YgcCE9XCJudW1iZXJcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyk7aWYocDwwKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK3ArJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfWZ1bmN0aW9uIGMocCxsLGYpe3JldHVybiB1KHApLHA8PTA/byhwKTpsIT09dm9pZCAwP3R5cGVvZiBmPT1cInN0cmluZ1wiP28ocCkuZmlsbChsLGYpOm8ocCkuZmlsbChsKTpvKHApfXMuYWxsb2M9ZnVuY3Rpb24ocCxsLGYpe3JldHVybiBjKHAsbCxmKX07ZnVuY3Rpb24gaChwKXtyZXR1cm4gdShwKSxvKHA8MD8wOlMocCl8MCl9cy5hbGxvY1Vuc2FmZT1mdW5jdGlvbihwKXtyZXR1cm4gaChwKX0scy5hbGxvY1Vuc2FmZVNsb3c9ZnVuY3Rpb24ocCl7cmV0dXJuIGgocCl9O2Z1bmN0aW9uIGQocCxsKXtpZigodHlwZW9mIGwhPVwic3RyaW5nXCJ8fGw9PT1cIlwiKSYmKGw9XCJ1dGY4XCIpLCFzLmlzRW5jb2RpbmcobCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2wpO2xldCBmPUMocCxsKXwwLGI9byhmKSxBPWIud3JpdGUocCxsKTtyZXR1cm4gQSE9PWYmJihiPWIuc2xpY2UoMCxBKSksYn1mdW5jdGlvbiBnKHApe2xldCBsPXAubGVuZ3RoPDA/MDpTKHAubGVuZ3RoKXwwLGY9byhsKTtmb3IobGV0IGI9MDtiPGw7Yis9MSlmW2JdPXBbYl0mMjU1O3JldHVybiBmfWZ1bmN0aW9uIHkocCl7aWYoWWUocCxVaW50OEFycmF5KSl7bGV0IGw9bmV3IFVpbnQ4QXJyYXkocCk7cmV0dXJuIHcobC5idWZmZXIsbC5ieXRlT2Zmc2V0LGwuYnl0ZUxlbmd0aCl9cmV0dXJuIGcocCl9ZnVuY3Rpb24gdyhwLGwsZil7aWYobDwwfHxwLmJ5dGVMZW5ndGg8bCl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTtpZihwLmJ5dGVMZW5ndGg8bCsoZnx8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7bGV0IGI7cmV0dXJuIGw9PT12b2lkIDAmJmY9PT12b2lkIDA/Yj1uZXcgVWludDhBcnJheShwKTpmPT09dm9pZCAwP2I9bmV3IFVpbnQ4QXJyYXkocCxsKTpiPW5ldyBVaW50OEFycmF5KHAsbCxmKSxPYmplY3Quc2V0UHJvdG90eXBlT2YoYixzLnByb3RvdHlwZSksYn1mdW5jdGlvbiBFKHApe2lmKHMuaXNCdWZmZXIocCkpe2xldCBsPVMocC5sZW5ndGgpfDAsZj1vKGwpO3JldHVybiBmLmxlbmd0aD09PTB8fHAuY29weShmLDAsMCxsKSxmfWlmKHAubGVuZ3RoIT09dm9pZCAwKXJldHVybiB0eXBlb2YgcC5sZW5ndGghPVwibnVtYmVyXCJ8fGhzKHAubGVuZ3RoKT9vKDApOmcocCk7aWYocC50eXBlPT09XCJCdWZmZXJcIiYmQXJyYXkuaXNBcnJheShwLmRhdGEpKXJldHVybiBnKHAuZGF0YSl9ZnVuY3Rpb24gUyhwKXtpZihwPj1pKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweFwiK2kudG9TdHJpbmcoMTYpK1wiIGJ5dGVzXCIpO3JldHVybiBwfDB9ZnVuY3Rpb24gSShwKXtyZXR1cm4rcCE9cCYmKHA9MCkscy5hbGxvYygrcCl9cy5pc0J1ZmZlcj1mdW5jdGlvbihsKXtyZXR1cm4gbCE9bnVsbCYmbC5faXNCdWZmZXI9PT0hMCYmbCE9PXMucHJvdG90eXBlfSxzLmNvbXBhcmU9ZnVuY3Rpb24obCxmKXtpZihZZShsLFVpbnQ4QXJyYXkpJiYobD1zLmZyb20obCxsLm9mZnNldCxsLmJ5dGVMZW5ndGgpKSxZZShmLFVpbnQ4QXJyYXkpJiYoZj1zLmZyb20oZixmLm9mZnNldCxmLmJ5dGVMZW5ndGgpKSwhcy5pc0J1ZmZlcihsKXx8IXMuaXNCdWZmZXIoZikpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpO2lmKGw9PT1mKXJldHVybiAwO2xldCBiPWwubGVuZ3RoLEE9Zi5sZW5ndGg7Zm9yKGxldCBUPTAsTz1NYXRoLm1pbihiLEEpO1Q8TzsrK1QpaWYobFtUXSE9PWZbVF0pe2I9bFtUXSxBPWZbVF07YnJlYWt9cmV0dXJuIGI8QT8tMTpBPGI/MTowfSxzLmlzRW5jb2Rpbmc9ZnVuY3Rpb24obCl7c3dpdGNoKFN0cmluZyhsKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fSxzLmNvbmNhdD1mdW5jdGlvbihsLGYpe2lmKCFBcnJheS5pc0FycmF5KGwpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO2lmKGwubGVuZ3RoPT09MClyZXR1cm4gcy5hbGxvYygwKTtsZXQgYjtpZihmPT09dm9pZCAwKWZvcihmPTAsYj0wO2I8bC5sZW5ndGg7KytiKWYrPWxbYl0ubGVuZ3RoO2xldCBBPXMuYWxsb2NVbnNhZmUoZiksVD0wO2ZvcihiPTA7YjxsLmxlbmd0aDsrK2Ipe2xldCBPPWxbYl07aWYoWWUoTyxVaW50OEFycmF5KSlUK08ubGVuZ3RoPkEubGVuZ3RoPyhzLmlzQnVmZmVyKE8pfHwoTz1zLmZyb20oTykpLE8uY29weShBLFQpKTpVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChBLE8sVCk7ZWxzZSBpZihzLmlzQnVmZmVyKE8pKU8uY29weShBLFQpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7VCs9Ty5sZW5ndGh9cmV0dXJuIEF9O2Z1bmN0aW9uIEMocCxsKXtpZihzLmlzQnVmZmVyKHApKXJldHVybiBwLmxlbmd0aDtpZihBcnJheUJ1ZmZlci5pc1ZpZXcocCl8fFllKHAsQXJyYXlCdWZmZXIpKXJldHVybiBwLmJ5dGVMZW5ndGg7aWYodHlwZW9mIHAhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgcCk7bGV0IGY9cC5sZW5ndGgsYj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXT09PSEwO2lmKCFiJiZmPT09MClyZXR1cm4gMDtsZXQgQT0hMTtmb3IoOzspc3dpdGNoKGwpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIGY7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIGNzKHApLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gZioyO2Nhc2VcImhleFwiOnJldHVybiBmPj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gQ2wocCkubGVuZ3RoO2RlZmF1bHQ6aWYoQSlyZXR1cm4gYj8tMTpjcyhwKS5sZW5ndGg7bD0oXCJcIitsKS50b0xvd2VyQ2FzZSgpLEE9ITB9fXMuYnl0ZUxlbmd0aD1DO2Z1bmN0aW9uIFIocCxsLGYpe2xldCBiPSExO2lmKChsPT09dm9pZCAwfHxsPDApJiYobD0wKSxsPnRoaXMubGVuZ3RofHwoKGY9PT12b2lkIDB8fGY+dGhpcy5sZW5ndGgpJiYoZj10aGlzLmxlbmd0aCksZjw9MCl8fChmPj4+PTAsbD4+Pj0wLGY8PWwpKXJldHVyblwiXCI7Zm9yKHB8fChwPVwidXRmOFwiKTs7KXN3aXRjaChwKXtjYXNlXCJoZXhcIjpyZXR1cm4gTWcodGhpcyxsLGYpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBScih0aGlzLGwsZik7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gdXModGhpcyxsLGYpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiB4Zyh0aGlzLGwsZik7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIHBlKHRoaXMsbCxmKTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gTGcodGhpcyxsLGYpO2RlZmF1bHQ6aWYoYil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcCk7cD0ocCtcIlwiKS50b0xvd2VyQ2FzZSgpLGI9ITB9fXMucHJvdG90eXBlLl9pc0J1ZmZlcj0hMDtmdW5jdGlvbiBVKHAsbCxmKXtsZXQgYj1wW2xdO3BbbF09cFtmXSxwW2ZdPWJ9cy5wcm90b3R5cGUuc3dhcDE2PWZ1bmN0aW9uKCl7bGV0IGw9dGhpcy5sZW5ndGg7aWYobCUyIT09MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpO2ZvcihsZXQgZj0wO2Y8bDtmKz0yKVUodGhpcyxmLGYrMSk7cmV0dXJuIHRoaXN9LHMucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbigpe2xldCBsPXRoaXMubGVuZ3RoO2lmKGwlNCE9PTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0c1wiKTtmb3IobGV0IGY9MDtmPGw7Zis9NClVKHRoaXMsZixmKzMpLFUodGhpcyxmKzEsZisyKTtyZXR1cm4gdGhpc30scy5wcm90b3R5cGUuc3dhcDY0PWZ1bmN0aW9uKCl7bGV0IGw9dGhpcy5sZW5ndGg7aWYobCU4IT09MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzXCIpO2ZvcihsZXQgZj0wO2Y8bDtmKz04KVUodGhpcyxmLGYrNyksVSh0aGlzLGYrMSxmKzYpLFUodGhpcyxmKzIsZis1KSxVKHRoaXMsZiszLGYrNCk7cmV0dXJuIHRoaXN9LHMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7bGV0IGw9dGhpcy5sZW5ndGg7cmV0dXJuIGw9PT0wP1wiXCI6YXJndW1lbnRzLmxlbmd0aD09PTA/UnIodGhpcywwLGwpOlIuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxzLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZz1zLnByb3RvdHlwZS50b1N0cmluZyxzLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24obCl7aWYoIXMuaXNCdWZmZXIobCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7cmV0dXJuIHRoaXM9PT1sPyEwOnMuY29tcGFyZSh0aGlzLGwpPT09MH0scy5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe2xldCBsPVwiXCIsZj1KdC5JTlNQRUNUX01BWF9CWVRFUztyZXR1cm4gbD10aGlzLnRvU3RyaW5nKFwiaGV4XCIsMCxmKS5yZXBsYWNlKC8oLnsyfSkvZyxcIiQxIFwiKS50cmltKCksdGhpcy5sZW5ndGg+ZiYmKGwrPVwiIC4uLiBcIiksXCI8QnVmZmVyIFwiK2wrXCI+XCJ9LHImJihzLnByb3RvdHlwZVtyXT1zLnByb3RvdHlwZS5pbnNwZWN0KSxzLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uKGwsZixiLEEsVCl7aWYoWWUobCxVaW50OEFycmF5KSYmKGw9cy5mcm9tKGwsbC5vZmZzZXQsbC5ieXRlTGVuZ3RoKSksIXMuaXNCdWZmZXIobCkpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiBsKTtpZihmPT09dm9pZCAwJiYoZj0wKSxiPT09dm9pZCAwJiYoYj1sP2wubGVuZ3RoOjApLEE9PT12b2lkIDAmJihBPTApLFQ9PT12b2lkIDAmJihUPXRoaXMubGVuZ3RoKSxmPDB8fGI+bC5sZW5ndGh8fEE8MHx8VD50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtpZihBPj1UJiZmPj1iKXJldHVybiAwO2lmKEE+PVQpcmV0dXJuLTE7aWYoZj49YilyZXR1cm4gMTtpZihmPj4+PTAsYj4+Pj0wLEE+Pj49MCxUPj4+PTAsdGhpcz09PWwpcmV0dXJuIDA7bGV0IE89VC1BLCQ9Yi1mLHNlPU1hdGgubWluKE8sJCksdGU9dGhpcy5zbGljZShBLFQpLG9lPWwuc2xpY2UoZixiKTtmb3IobGV0IEo9MDtKPHNlOysrSilpZih0ZVtKXSE9PW9lW0pdKXtPPXRlW0pdLCQ9b2VbSl07YnJlYWt9cmV0dXJuIE88JD8tMTokPE8/MTowfTtmdW5jdGlvbiBOKHAsbCxmLGIsQSl7aWYocC5sZW5ndGg9PT0wKXJldHVybi0xO2lmKHR5cGVvZiBmPT1cInN0cmluZ1wiPyhiPWYsZj0wKTpmPjIxNDc0ODM2NDc/Zj0yMTQ3NDgzNjQ3OmY8LTIxNDc0ODM2NDgmJihmPS0yMTQ3NDgzNjQ4KSxmPStmLGhzKGYpJiYoZj1BPzA6cC5sZW5ndGgtMSksZjwwJiYoZj1wLmxlbmd0aCtmKSxmPj1wLmxlbmd0aCl7aWYoQSlyZXR1cm4tMTtmPXAubGVuZ3RoLTF9ZWxzZSBpZihmPDApaWYoQSlmPTA7ZWxzZSByZXR1cm4tMTtpZih0eXBlb2YgbD09XCJzdHJpbmdcIiYmKGw9cy5mcm9tKGwsYikpLHMuaXNCdWZmZXIobCkpcmV0dXJuIGwubGVuZ3RoPT09MD8tMTpXKHAsbCxmLGIsQSk7aWYodHlwZW9mIGw9PVwibnVtYmVyXCIpcmV0dXJuIGw9bCYyNTUsdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y9PVwiZnVuY3Rpb25cIj9BP1VpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChwLGwsZik6VWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChwLGwsZik6VyhwLFtsXSxmLGIsQSk7dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiBXKHAsbCxmLGIsQSl7bGV0IFQ9MSxPPXAubGVuZ3RoLCQ9bC5sZW5ndGg7aWYoYiE9PXZvaWQgMCYmKGI9U3RyaW5nKGIpLnRvTG93ZXJDYXNlKCksYj09PVwidWNzMlwifHxiPT09XCJ1Y3MtMlwifHxiPT09XCJ1dGYxNmxlXCJ8fGI9PT1cInV0Zi0xNmxlXCIpKXtpZihwLmxlbmd0aDwyfHxsLmxlbmd0aDwyKXJldHVybi0xO1Q9MixPLz0yLCQvPTIsZi89Mn1mdW5jdGlvbiBzZShvZSxKKXtyZXR1cm4gVD09PTE/b2VbSl06b2UucmVhZFVJbnQxNkJFKEoqVCl9bGV0IHRlO2lmKEEpe2xldCBvZT0tMTtmb3IodGU9Zjt0ZTxPO3RlKyspaWYoc2UocCx0ZSk9PT1zZShsLG9lPT09LTE/MDp0ZS1vZSkpe2lmKG9lPT09LTEmJihvZT10ZSksdGUtb2UrMT09PSQpcmV0dXJuIG9lKlR9ZWxzZSBvZSE9PS0xJiYodGUtPXRlLW9lKSxvZT0tMX1lbHNlIGZvcihmKyQ+TyYmKGY9Ty0kKSx0ZT1mO3RlPj0wO3RlLS0pe2xldCBvZT0hMDtmb3IobGV0IEo9MDtKPCQ7SisrKWlmKHNlKHAsdGUrSikhPT1zZShsLEopKXtvZT0hMTticmVha31pZihvZSlyZXR1cm4gdGV9cmV0dXJuLTF9cy5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24obCxmLGIpe3JldHVybiB0aGlzLmluZGV4T2YobCxmLGIpIT09LTF9LHMucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24obCxmLGIpe3JldHVybiBOKHRoaXMsbCxmLGIsITApfSxzLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbihsLGYsYil7cmV0dXJuIE4odGhpcyxsLGYsYiwhMSl9O2Z1bmN0aW9uIEsocCxsLGYsYil7Zj1OdW1iZXIoZil8fDA7bGV0IEE9cC5sZW5ndGgtZjtiPyhiPU51bWJlcihiKSxiPkEmJihiPUEpKTpiPUE7bGV0IFQ9bC5sZW5ndGg7Yj5ULzImJihiPVQvMik7bGV0IE87Zm9yKE89MDtPPGI7KytPKXtsZXQgJD1wYXJzZUludChsLnN1YnN0cihPKjIsMiksMTYpO2lmKGhzKCQpKXJldHVybiBPO3BbZitPXT0kfXJldHVybiBPfWZ1bmN0aW9uIHoocCxsLGYsYil7cmV0dXJuIHFpKGNzKGwscC5sZW5ndGgtZikscCxmLGIpfWZ1bmN0aW9uIFEocCxsLGYsYil7cmV0dXJuIHFpKERnKGwpLHAsZixiKX1mdW5jdGlvbiBkZShwLGwsZixiKXtyZXR1cm4gcWkoQ2wobCkscCxmLGIpfWZ1bmN0aW9uIEd0KHAsbCxmLGIpe3JldHVybiBxaShqZyhsLHAubGVuZ3RoLWYpLHAsZixiKX1zLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihsLGYsYixBKXtpZihmPT09dm9pZCAwKUE9XCJ1dGY4XCIsYj10aGlzLmxlbmd0aCxmPTA7ZWxzZSBpZihiPT09dm9pZCAwJiZ0eXBlb2YgZj09XCJzdHJpbmdcIilBPWYsYj10aGlzLmxlbmd0aCxmPTA7ZWxzZSBpZihpc0Zpbml0ZShmKSlmPWY+Pj4wLGlzRmluaXRlKGIpPyhiPWI+Pj4wLEE9PT12b2lkIDAmJihBPVwidXRmOFwiKSk6KEE9YixiPXZvaWQgMCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtsZXQgVD10aGlzLmxlbmd0aC1mO2lmKChiPT09dm9pZCAwfHxiPlQpJiYoYj1UKSxsLmxlbmd0aD4wJiYoYjwwfHxmPDApfHxmPnRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIik7QXx8KEE9XCJ1dGY4XCIpO2xldCBPPSExO2Zvcig7Oylzd2l0Y2goQSl7Y2FzZVwiaGV4XCI6cmV0dXJuIEsodGhpcyxsLGYsYik7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHoodGhpcyxsLGYsYik7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gUSh0aGlzLGwsZixiKTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gZGUodGhpcyxsLGYsYik7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIEd0KHRoaXMsbCxmLGIpO2RlZmF1bHQ6aWYoTyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrQSk7QT0oXCJcIitBKS50b0xvd2VyQ2FzZSgpLE89ITB9fSxzLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcIkJ1ZmZlclwiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07ZnVuY3Rpb24gcGUocCxsLGYpe3JldHVybiBsPT09MCYmZj09PXAubGVuZ3RoP3QuZnJvbUJ5dGVBcnJheShwKTp0LmZyb21CeXRlQXJyYXkocC5zbGljZShsLGYpKX1mdW5jdGlvbiBScihwLGwsZil7Zj1NYXRoLm1pbihwLmxlbmd0aCxmKTtsZXQgYj1bXSxBPWw7Zm9yKDtBPGY7KXtsZXQgVD1wW0FdLE89bnVsbCwkPVQ+MjM5PzQ6VD4yMjM/MzpUPjE5MT8yOjE7aWYoQSskPD1mKXtsZXQgc2UsdGUsb2UsSjtzd2l0Y2goJCl7Y2FzZSAxOlQ8MTI4JiYoTz1UKTticmVhaztjYXNlIDI6c2U9cFtBKzFdLChzZSYxOTIpPT09MTI4JiYoSj0oVCYzMSk8PDZ8c2UmNjMsSj4xMjcmJihPPUopKTticmVhaztjYXNlIDM6c2U9cFtBKzFdLHRlPXBbQSsyXSwoc2UmMTkyKT09PTEyOCYmKHRlJjE5Mik9PT0xMjgmJihKPShUJjE1KTw8MTJ8KHNlJjYzKTw8Nnx0ZSY2MyxKPjIwNDcmJihKPDU1Mjk2fHxKPjU3MzQzKSYmKE89SikpO2JyZWFrO2Nhc2UgNDpzZT1wW0ErMV0sdGU9cFtBKzJdLG9lPXBbQSszXSwoc2UmMTkyKT09PTEyOCYmKHRlJjE5Mik9PT0xMjgmJihvZSYxOTIpPT09MTI4JiYoSj0oVCYxNSk8PDE4fChzZSY2Myk8PDEyfCh0ZSY2Myk8PDZ8b2UmNjMsSj42NTUzNSYmSjwxMTE0MTEyJiYoTz1KKSl9fU89PT1udWxsPyhPPTY1NTMzLCQ9MSk6Tz42NTUzNSYmKE8tPTY1NTM2LGIucHVzaChPPj4+MTAmMTAyM3w1NTI5NiksTz01NjMyMHxPJjEwMjMpLGIucHVzaChPKSxBKz0kfXJldHVybiBCcihiKX1sZXQgQ3I9NDA5NjtmdW5jdGlvbiBCcihwKXtsZXQgbD1wLmxlbmd0aDtpZihsPD1DcilyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcscCk7bGV0IGY9XCJcIixiPTA7Zm9yKDtiPGw7KWYrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLHAuc2xpY2UoYixiKz1DcikpO3JldHVybiBmfWZ1bmN0aW9uIHVzKHAsbCxmKXtsZXQgYj1cIlwiO2Y9TWF0aC5taW4ocC5sZW5ndGgsZik7Zm9yKGxldCBBPWw7QTxmOysrQSliKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHBbQV0mMTI3KTtyZXR1cm4gYn1mdW5jdGlvbiB4ZyhwLGwsZil7bGV0IGI9XCJcIjtmPU1hdGgubWluKHAubGVuZ3RoLGYpO2ZvcihsZXQgQT1sO0E8ZjsrK0EpYis9U3RyaW5nLmZyb21DaGFyQ29kZShwW0FdKTtyZXR1cm4gYn1mdW5jdGlvbiBNZyhwLGwsZil7bGV0IGI9cC5sZW5ndGg7KCFsfHxsPDApJiYobD0wKSwoIWZ8fGY8MHx8Zj5iKSYmKGY9Yik7bGV0IEE9XCJcIjtmb3IobGV0IFQ9bDtUPGY7KytUKUErPUZnW3BbVF1dO3JldHVybiBBfWZ1bmN0aW9uIExnKHAsbCxmKXtsZXQgYj1wLnNsaWNlKGwsZiksQT1cIlwiO2ZvcihsZXQgVD0wO1Q8Yi5sZW5ndGgtMTtUKz0yKUErPVN0cmluZy5mcm9tQ2hhckNvZGUoYltUXStiW1QrMV0qMjU2KTtyZXR1cm4gQX1zLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihsLGYpe2xldCBiPXRoaXMubGVuZ3RoO2w9fn5sLGY9Zj09PXZvaWQgMD9iOn5+ZixsPDA/KGwrPWIsbDwwJiYobD0wKSk6bD5iJiYobD1iKSxmPDA/KGYrPWIsZjwwJiYoZj0wKSk6Zj5iJiYoZj1iKSxmPGwmJihmPWwpO2xldCBBPXRoaXMuc3ViYXJyYXkobCxmKTtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKEEscy5wcm90b3R5cGUpLEF9O2Z1bmN0aW9uIGdlKHAsbCxmKXtpZihwJTEhPT0wfHxwPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7aWYocCtsPmYpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfXMucHJvdG90eXBlLnJlYWRVaW50TEU9cy5wcm90b3R5cGUucmVhZFVJbnRMRT1mdW5jdGlvbihsLGYsYil7bD1sPj4+MCxmPWY+Pj4wLGJ8fGdlKGwsZix0aGlzLmxlbmd0aCk7bGV0IEE9dGhpc1tsXSxUPTEsTz0wO2Zvcig7KytPPGYmJihUKj0yNTYpOylBKz10aGlzW2wrT10qVDtyZXR1cm4gQX0scy5wcm90b3R5cGUucmVhZFVpbnRCRT1zLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKGwsZixiKXtsPWw+Pj4wLGY9Zj4+PjAsYnx8Z2UobCxmLHRoaXMubGVuZ3RoKTtsZXQgQT10aGlzW2wrLS1mXSxUPTE7Zm9yKDtmPjAmJihUKj0yNTYpOylBKz10aGlzW2wrLS1mXSpUO3JldHVybiBBfSxzLnByb3RvdHlwZS5yZWFkVWludDg9cy5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uKGwsZil7cmV0dXJuIGw9bD4+PjAsZnx8Z2UobCwxLHRoaXMubGVuZ3RoKSx0aGlzW2xdfSxzLnByb3RvdHlwZS5yZWFkVWludDE2TEU9cy5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uKGwsZil7cmV0dXJuIGw9bD4+PjAsZnx8Z2UobCwyLHRoaXMubGVuZ3RoKSx0aGlzW2xdfHRoaXNbbCsxXTw8OH0scy5wcm90b3R5cGUucmVhZFVpbnQxNkJFPXMucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbihsLGYpe3JldHVybiBsPWw+Pj4wLGZ8fGdlKGwsMix0aGlzLmxlbmd0aCksdGhpc1tsXTw8OHx0aGlzW2wrMV19LHMucHJvdG90eXBlLnJlYWRVaW50MzJMRT1zLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24obCxmKXtyZXR1cm4gbD1sPj4+MCxmfHxnZShsLDQsdGhpcy5sZW5ndGgpLCh0aGlzW2xdfHRoaXNbbCsxXTw8OHx0aGlzW2wrMl08PDE2KSt0aGlzW2wrM10qMTY3NzcyMTZ9LHMucHJvdG90eXBlLnJlYWRVaW50MzJCRT1zLnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24obCxmKXtyZXR1cm4gbD1sPj4+MCxmfHxnZShsLDQsdGhpcy5sZW5ndGgpLHRoaXNbbF0qMTY3NzcyMTYrKHRoaXNbbCsxXTw8MTZ8dGhpc1tsKzJdPDw4fHRoaXNbbCszXSl9LHMucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRT14dChmdW5jdGlvbihsKXtsPWw+Pj4wLE9yKGwsXCJvZmZzZXRcIik7bGV0IGY9dGhpc1tsXSxiPXRoaXNbbCs3XTsoZj09PXZvaWQgMHx8Yj09PXZvaWQgMCkmJmFpKGwsdGhpcy5sZW5ndGgtOCk7bGV0IEE9Zit0aGlzWysrbF0qMioqOCt0aGlzWysrbF0qMioqMTYrdGhpc1srK2xdKjIqKjI0LFQ9dGhpc1srK2xdK3RoaXNbKytsXSoyKio4K3RoaXNbKytsXSoyKioxNitiKjIqKjI0O3JldHVybiBCaWdJbnQoQSkrKEJpZ0ludChUKTw8QmlnSW50KDMyKSl9KSxzLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkU9eHQoZnVuY3Rpb24obCl7bD1sPj4+MCxPcihsLFwib2Zmc2V0XCIpO2xldCBmPXRoaXNbbF0sYj10aGlzW2wrN107KGY9PT12b2lkIDB8fGI9PT12b2lkIDApJiZhaShsLHRoaXMubGVuZ3RoLTgpO2xldCBBPWYqMioqMjQrdGhpc1srK2xdKjIqKjE2K3RoaXNbKytsXSoyKio4K3RoaXNbKytsXSxUPXRoaXNbKytsXSoyKioyNCt0aGlzWysrbF0qMioqMTYrdGhpc1srK2xdKjIqKjgrYjtyZXR1cm4oQmlnSW50KEEpPDxCaWdJbnQoMzIpKStCaWdJbnQoVCl9KSxzLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24obCxmLGIpe2w9bD4+PjAsZj1mPj4+MCxifHxnZShsLGYsdGhpcy5sZW5ndGgpO2xldCBBPXRoaXNbbF0sVD0xLE89MDtmb3IoOysrTzxmJiYoVCo9MjU2KTspQSs9dGhpc1tsK09dKlQ7cmV0dXJuIFQqPTEyOCxBPj1UJiYoQS09TWF0aC5wb3coMiw4KmYpKSxBfSxzLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24obCxmLGIpe2w9bD4+PjAsZj1mPj4+MCxifHxnZShsLGYsdGhpcy5sZW5ndGgpO2xldCBBPWYsVD0xLE89dGhpc1tsKy0tQV07Zm9yKDtBPjAmJihUKj0yNTYpOylPKz10aGlzW2wrLS1BXSpUO3JldHVybiBUKj0xMjgsTz49VCYmKE8tPU1hdGgucG93KDIsOCpmKSksT30scy5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24obCxmKXtyZXR1cm4gbD1sPj4+MCxmfHxnZShsLDEsdGhpcy5sZW5ndGgpLHRoaXNbbF0mMTI4PygyNTUtdGhpc1tsXSsxKSotMTp0aGlzW2xdfSxzLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbihsLGYpe2w9bD4+PjAsZnx8Z2UobCwyLHRoaXMubGVuZ3RoKTtsZXQgYj10aGlzW2xdfHRoaXNbbCsxXTw8ODtyZXR1cm4gYiYzMjc2OD9ifDQyOTQ5MDE3NjA6Yn0scy5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24obCxmKXtsPWw+Pj4wLGZ8fGdlKGwsMix0aGlzLmxlbmd0aCk7bGV0IGI9dGhpc1tsKzFdfHRoaXNbbF08PDg7cmV0dXJuIGImMzI3Njg/Ynw0Mjk0OTAxNzYwOmJ9LHMucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uKGwsZil7cmV0dXJuIGw9bD4+PjAsZnx8Z2UobCw0LHRoaXMubGVuZ3RoKSx0aGlzW2xdfHRoaXNbbCsxXTw8OHx0aGlzW2wrMl08PDE2fHRoaXNbbCszXTw8MjR9LHMucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKGwsZil7cmV0dXJuIGw9bD4+PjAsZnx8Z2UobCw0LHRoaXMubGVuZ3RoKSx0aGlzW2xdPDwyNHx0aGlzW2wrMV08PDE2fHRoaXNbbCsyXTw8OHx0aGlzW2wrM119LHMucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFPXh0KGZ1bmN0aW9uKGwpe2w9bD4+PjAsT3IobCxcIm9mZnNldFwiKTtsZXQgZj10aGlzW2xdLGI9dGhpc1tsKzddOyhmPT09dm9pZCAwfHxiPT09dm9pZCAwKSYmYWkobCx0aGlzLmxlbmd0aC04KTtsZXQgQT10aGlzW2wrNF0rdGhpc1tsKzVdKjIqKjgrdGhpc1tsKzZdKjIqKjE2KyhiPDwyNCk7cmV0dXJuKEJpZ0ludChBKTw8QmlnSW50KDMyKSkrQmlnSW50KGYrdGhpc1srK2xdKjIqKjgrdGhpc1srK2xdKjIqKjE2K3RoaXNbKytsXSoyKioyNCl9KSxzLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRT14dChmdW5jdGlvbihsKXtsPWw+Pj4wLE9yKGwsXCJvZmZzZXRcIik7bGV0IGY9dGhpc1tsXSxiPXRoaXNbbCs3XTsoZj09PXZvaWQgMHx8Yj09PXZvaWQgMCkmJmFpKGwsdGhpcy5sZW5ndGgtOCk7bGV0IEE9KGY8PDI0KSt0aGlzWysrbF0qMioqMTYrdGhpc1srK2xdKjIqKjgrdGhpc1srK2xdO3JldHVybihCaWdJbnQoQSk8PEJpZ0ludCgzMikpK0JpZ0ludCh0aGlzWysrbF0qMioqMjQrdGhpc1srK2xdKjIqKjE2K3RoaXNbKytsXSoyKio4K2IpfSkscy5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24obCxmKXtyZXR1cm4gbD1sPj4+MCxmfHxnZShsLDQsdGhpcy5sZW5ndGgpLGUucmVhZCh0aGlzLGwsITAsMjMsNCl9LHMucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uKGwsZil7cmV0dXJuIGw9bD4+PjAsZnx8Z2UobCw0LHRoaXMubGVuZ3RoKSxlLnJlYWQodGhpcyxsLCExLDIzLDQpfSxzLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24obCxmKXtyZXR1cm4gbD1sPj4+MCxmfHxnZShsLDgsdGhpcy5sZW5ndGgpLGUucmVhZCh0aGlzLGwsITAsNTIsOCl9LHMucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbihsLGYpe3JldHVybiBsPWw+Pj4wLGZ8fGdlKGwsOCx0aGlzLmxlbmd0aCksZS5yZWFkKHRoaXMsbCwhMSw1Miw4KX07ZnVuY3Rpb24gQ2UocCxsLGYsYixBLFQpe2lmKCFzLmlzQnVmZmVyKHApKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKGw+QXx8bDxUKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKGYrYj5wLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1zLnByb3RvdHlwZS53cml0ZVVpbnRMRT1zLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbihsLGYsYixBKXtpZihsPStsLGY9Zj4+PjAsYj1iPj4+MCwhQSl7bGV0ICQ9TWF0aC5wb3coMiw4KmIpLTE7Q2UodGhpcyxsLGYsYiwkLDApfWxldCBUPTEsTz0wO2Zvcih0aGlzW2ZdPWwmMjU1OysrTzxiJiYoVCo9MjU2KTspdGhpc1tmK09dPWwvVCYyNTU7cmV0dXJuIGYrYn0scy5wcm90b3R5cGUud3JpdGVVaW50QkU9cy5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24obCxmLGIsQSl7aWYobD0rbCxmPWY+Pj4wLGI9Yj4+PjAsIUEpe2xldCAkPU1hdGgucG93KDIsOCpiKS0xO0NlKHRoaXMsbCxmLGIsJCwwKX1sZXQgVD1iLTEsTz0xO2Zvcih0aGlzW2YrVF09bCYyNTU7LS1UPj0wJiYoTyo9MjU2KTspdGhpc1tmK1RdPWwvTyYyNTU7cmV0dXJuIGYrYn0scy5wcm90b3R5cGUud3JpdGVVaW50OD1zLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uKGwsZixiKXtyZXR1cm4gbD0rbCxmPWY+Pj4wLGJ8fENlKHRoaXMsbCxmLDEsMjU1LDApLHRoaXNbZl09bCYyNTUsZisxfSxzLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFPXMucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24obCxmLGIpe3JldHVybiBsPStsLGY9Zj4+PjAsYnx8Q2UodGhpcyxsLGYsMiw2NTUzNSwwKSx0aGlzW2ZdPWwmMjU1LHRoaXNbZisxXT1sPj4+OCxmKzJ9LHMucHJvdG90eXBlLndyaXRlVWludDE2QkU9cy5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbihsLGYsYil7cmV0dXJuIGw9K2wsZj1mPj4+MCxifHxDZSh0aGlzLGwsZiwyLDY1NTM1LDApLHRoaXNbZl09bD4+PjgsdGhpc1tmKzFdPWwmMjU1LGYrMn0scy5wcm90b3R5cGUud3JpdGVVaW50MzJMRT1zLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uKGwsZixiKXtyZXR1cm4gbD0rbCxmPWY+Pj4wLGJ8fENlKHRoaXMsbCxmLDQsNDI5NDk2NzI5NSwwKSx0aGlzW2YrM109bD4+PjI0LHRoaXNbZisyXT1sPj4+MTYsdGhpc1tmKzFdPWw+Pj44LHRoaXNbZl09bCYyNTUsZis0fSxzLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFPXMucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24obCxmLGIpe3JldHVybiBsPStsLGY9Zj4+PjAsYnx8Q2UodGhpcyxsLGYsNCw0Mjk0OTY3Mjk1LDApLHRoaXNbZl09bD4+PjI0LHRoaXNbZisxXT1sPj4+MTYsdGhpc1tmKzJdPWw+Pj44LHRoaXNbZiszXT1sJjI1NSxmKzR9O2Z1bmN0aW9uIHZsKHAsbCxmLGIsQSl7UmwobCxiLEEscCxmLDcpO2xldCBUPU51bWJlcihsJkJpZ0ludCg0Mjk0OTY3Mjk1KSk7cFtmKytdPVQsVD1UPj44LHBbZisrXT1ULFQ9VD4+OCxwW2YrK109VCxUPVQ+PjgscFtmKytdPVQ7bGV0IE89TnVtYmVyKGw+PkJpZ0ludCgzMikmQmlnSW50KDQyOTQ5NjcyOTUpKTtyZXR1cm4gcFtmKytdPU8sTz1PPj44LHBbZisrXT1PLE89Tz4+OCxwW2YrK109TyxPPU8+PjgscFtmKytdPU8sZn1mdW5jdGlvbiBFbChwLGwsZixiLEEpe1JsKGwsYixBLHAsZiw3KTtsZXQgVD1OdW1iZXIobCZCaWdJbnQoNDI5NDk2NzI5NSkpO3BbZis3XT1ULFQ9VD4+OCxwW2YrNl09VCxUPVQ+PjgscFtmKzVdPVQsVD1UPj44LHBbZis0XT1UO2xldCBPPU51bWJlcihsPj5CaWdJbnQoMzIpJkJpZ0ludCg0Mjk0OTY3Mjk1KSk7cmV0dXJuIHBbZiszXT1PLE89Tz4+OCxwW2YrMl09TyxPPU8+PjgscFtmKzFdPU8sTz1PPj44LHBbZl09TyxmKzh9cy5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRT14dChmdW5jdGlvbihsLGY9MCl7cmV0dXJuIHZsKHRoaXMsbCxmLEJpZ0ludCgwKSxCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZcIikpfSkscy5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRT14dChmdW5jdGlvbihsLGY9MCl7cmV0dXJuIEVsKHRoaXMsbCxmLEJpZ0ludCgwKSxCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZcIikpfSkscy5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbihsLGYsYixBKXtpZihsPStsLGY9Zj4+PjAsIUEpe2xldCBzZT1NYXRoLnBvdygyLDgqYi0xKTtDZSh0aGlzLGwsZixiLHNlLTEsLXNlKX1sZXQgVD0wLE89MSwkPTA7Zm9yKHRoaXNbZl09bCYyNTU7KytUPGImJihPKj0yNTYpOylsPDAmJiQ9PT0wJiZ0aGlzW2YrVC0xXSE9PTAmJigkPTEpLHRoaXNbZitUXT0obC9PPj4wKS0kJjI1NTtyZXR1cm4gZitifSxzLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uKGwsZixiLEEpe2lmKGw9K2wsZj1mPj4+MCwhQSl7bGV0IHNlPU1hdGgucG93KDIsOCpiLTEpO0NlKHRoaXMsbCxmLGIsc2UtMSwtc2UpfWxldCBUPWItMSxPPTEsJD0wO2Zvcih0aGlzW2YrVF09bCYyNTU7LS1UPj0wJiYoTyo9MjU2KTspbDwwJiYkPT09MCYmdGhpc1tmK1QrMV0hPT0wJiYoJD0xKSx0aGlzW2YrVF09KGwvTz4+MCktJCYyNTU7cmV0dXJuIGYrYn0scy5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKGwsZixiKXtyZXR1cm4gbD0rbCxmPWY+Pj4wLGJ8fENlKHRoaXMsbCxmLDEsMTI3LC0xMjgpLGw8MCYmKGw9MjU1K2wrMSksdGhpc1tmXT1sJjI1NSxmKzF9LHMucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbihsLGYsYil7cmV0dXJuIGw9K2wsZj1mPj4+MCxifHxDZSh0aGlzLGwsZiwyLDMyNzY3LC0zMjc2OCksdGhpc1tmXT1sJjI1NSx0aGlzW2YrMV09bD4+PjgsZisyfSxzLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24obCxmLGIpe3JldHVybiBsPStsLGY9Zj4+PjAsYnx8Q2UodGhpcyxsLGYsMiwzMjc2NywtMzI3NjgpLHRoaXNbZl09bD4+PjgsdGhpc1tmKzFdPWwmMjU1LGYrMn0scy5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uKGwsZixiKXtyZXR1cm4gbD0rbCxmPWY+Pj4wLGJ8fENlKHRoaXMsbCxmLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksdGhpc1tmXT1sJjI1NSx0aGlzW2YrMV09bD4+PjgsdGhpc1tmKzJdPWw+Pj4xNix0aGlzW2YrM109bD4+PjI0LGYrNH0scy5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uKGwsZixiKXtyZXR1cm4gbD0rbCxmPWY+Pj4wLGJ8fENlKHRoaXMsbCxmLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksbDwwJiYobD00Mjk0OTY3Mjk1K2wrMSksdGhpc1tmXT1sPj4+MjQsdGhpc1tmKzFdPWw+Pj4xNix0aGlzW2YrMl09bD4+PjgsdGhpc1tmKzNdPWwmMjU1LGYrNH0scy5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFPXh0KGZ1bmN0aW9uKGwsZj0wKXtyZXR1cm4gdmwodGhpcyxsLGYsLUJpZ0ludChcIjB4ODAwMDAwMDAwMDAwMDAwMFwiKSxCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZcIikpfSkscy5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFPXh0KGZ1bmN0aW9uKGwsZj0wKXtyZXR1cm4gRWwodGhpcyxsLGYsLUJpZ0ludChcIjB4ODAwMDAwMDAwMDAwMDAwMFwiKSxCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZcIikpfSk7ZnVuY3Rpb24gU2wocCxsLGYsYixBLFQpe2lmKGYrYj5wLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZihmPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gQWwocCxsLGYsYixBKXtyZXR1cm4gbD0rbCxmPWY+Pj4wLEF8fFNsKHAsbCxmLDQpLGUud3JpdGUocCxsLGYsYiwyMyw0KSxmKzR9cy5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uKGwsZixiKXtyZXR1cm4gQWwodGhpcyxsLGYsITAsYil9LHMucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbihsLGYsYil7cmV0dXJuIEFsKHRoaXMsbCxmLCExLGIpfTtmdW5jdGlvbiBJbChwLGwsZixiLEEpe3JldHVybiBsPStsLGY9Zj4+PjAsQXx8U2wocCxsLGYsOCksZS53cml0ZShwLGwsZixiLDUyLDgpLGYrOH1zLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uKGwsZixiKXtyZXR1cm4gSWwodGhpcyxsLGYsITAsYil9LHMucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24obCxmLGIpe3JldHVybiBJbCh0aGlzLGwsZiwhMSxiKX0scy5wcm90b3R5cGUuY29weT1mdW5jdGlvbihsLGYsYixBKXtpZighcy5pc0J1ZmZlcihsKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyXCIpO2lmKGJ8fChiPTApLCFBJiZBIT09MCYmKEE9dGhpcy5sZW5ndGgpLGY+PWwubGVuZ3RoJiYoZj1sLmxlbmd0aCksZnx8KGY9MCksQT4wJiZBPGImJihBPWIpLEE9PT1ifHxsLmxlbmd0aD09PTB8fHRoaXMubGVuZ3RoPT09MClyZXR1cm4gMDtpZihmPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpO2lmKGI8MHx8Yj49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoQTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7QT50aGlzLmxlbmd0aCYmKEE9dGhpcy5sZW5ndGgpLGwubGVuZ3RoLWY8QS1iJiYoQT1sLmxlbmd0aC1mK2IpO2xldCBUPUEtYjtyZXR1cm4gdGhpcz09PWwmJnR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluPT1cImZ1bmN0aW9uXCI/dGhpcy5jb3B5V2l0aGluKGYsYixBKTpVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChsLHRoaXMuc3ViYXJyYXkoYixBKSxmKSxUfSxzLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKGwsZixiLEEpe2lmKHR5cGVvZiBsPT1cInN0cmluZ1wiKXtpZih0eXBlb2YgZj09XCJzdHJpbmdcIj8oQT1mLGY9MCxiPXRoaXMubGVuZ3RoKTp0eXBlb2YgYj09XCJzdHJpbmdcIiYmKEE9YixiPXRoaXMubGVuZ3RoKSxBIT09dm9pZCAwJiZ0eXBlb2YgQSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZih0eXBlb2YgQT09XCJzdHJpbmdcIiYmIXMuaXNFbmNvZGluZyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrQSk7aWYobC5sZW5ndGg9PT0xKXtsZXQgTz1sLmNoYXJDb2RlQXQoMCk7KEE9PT1cInV0ZjhcIiYmTzwxMjh8fEE9PT1cImxhdGluMVwiKSYmKGw9Tyl9fWVsc2UgdHlwZW9mIGw9PVwibnVtYmVyXCI/bD1sJjI1NTp0eXBlb2YgbD09XCJib29sZWFuXCImJihsPU51bWJlcihsKSk7aWYoZjwwfHx0aGlzLmxlbmd0aDxmfHx0aGlzLmxlbmd0aDxiKXRocm93IG5ldyBSYW5nZUVycm9yKFwiT3V0IG9mIHJhbmdlIGluZGV4XCIpO2lmKGI8PWYpcmV0dXJuIHRoaXM7Zj1mPj4+MCxiPWI9PT12b2lkIDA/dGhpcy5sZW5ndGg6Yj4+PjAsbHx8KGw9MCk7bGV0IFQ7aWYodHlwZW9mIGw9PVwibnVtYmVyXCIpZm9yKFQ9ZjtUPGI7KytUKXRoaXNbVF09bDtlbHNle2xldCBPPXMuaXNCdWZmZXIobCk/bDpzLmZyb20obCxBKSwkPU8ubGVuZ3RoO2lmKCQ9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrbCsnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJyk7Zm9yKFQ9MDtUPGItZjsrK1QpdGhpc1tUK2ZdPU9bVCUkXX1yZXR1cm4gdGhpc307bGV0IFByPXt9O2Z1bmN0aW9uIGZzKHAsbCxmKXtQcltwXT1jbGFzcyBleHRlbmRzIGZ7Y29uc3RydWN0b3IoKXtzdXBlcigpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwibWVzc2FnZVwiLHt2YWx1ZTpsLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0aGlzLm5hbWU9YCR7dGhpcy5uYW1lfSBbJHtwfV1gLHRoaXMuc3RhY2ssZGVsZXRlIHRoaXMubmFtZX1nZXQgY29kZSgpe3JldHVybiBwfXNldCBjb2RlKEEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwiY29kZVwiLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTpBLHdyaXRhYmxlOiEwfSl9dG9TdHJpbmcoKXtyZXR1cm5gJHt0aGlzLm5hbWV9IFske3B9XTogJHt0aGlzLm1lc3NhZ2V9YH19fWZzKFwiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTXCIsZnVuY3Rpb24ocCl7cmV0dXJuIHA/YCR7cH0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYDpcIkF0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIn0sUmFuZ2VFcnJvciksZnMoXCJFUlJfSU5WQUxJRF9BUkdfVFlQRVwiLGZ1bmN0aW9uKHAsbCl7cmV0dXJuYFRoZSBcIiR7cH1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGx9YH0sVHlwZUVycm9yKSxmcyhcIkVSUl9PVVRfT0ZfUkFOR0VcIixmdW5jdGlvbihwLGwsZil7bGV0IGI9YFRoZSB2YWx1ZSBvZiBcIiR7cH1cIiBpcyBvdXQgb2YgcmFuZ2UuYCxBPWY7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZikmJk1hdGguYWJzKGYpPjIqKjMyP0E9VGwoU3RyaW5nKGYpKTp0eXBlb2YgZj09XCJiaWdpbnRcIiYmKEE9U3RyaW5nKGYpLChmPkJpZ0ludCgyKSoqQmlnSW50KDMyKXx8ZjwtKEJpZ0ludCgyKSoqQmlnSW50KDMyKSkpJiYoQT1UbChBKSksQSs9XCJuXCIpLGIrPWAgSXQgbXVzdCBiZSAke2x9LiBSZWNlaXZlZCAke0F9YCxifSxSYW5nZUVycm9yKTtmdW5jdGlvbiBUbChwKXtsZXQgbD1cIlwiLGY9cC5sZW5ndGgsYj1wWzBdPT09XCItXCI/MTowO2Zvcig7Zj49Yis0O2YtPTMpbD1gXyR7cC5zbGljZShmLTMsZil9JHtsfWA7cmV0dXJuYCR7cC5zbGljZSgwLGYpfSR7bH1gfWZ1bmN0aW9uIFVnKHAsbCxmKXtPcihsLFwib2Zmc2V0XCIpLChwW2xdPT09dm9pZCAwfHxwW2wrZl09PT12b2lkIDApJiZhaShsLHAubGVuZ3RoLShmKzEpKX1mdW5jdGlvbiBSbChwLGwsZixiLEEsVCl7aWYocD5mfHxwPGwpe2xldCBPPXR5cGVvZiBsPT1cImJpZ2ludFwiP1wiblwiOlwiXCIsJDt0aHJvdyBUPjM/bD09PTB8fGw9PT1CaWdJbnQoMCk/JD1gPj0gMCR7T30gYW5kIDwgMiR7T30gKiogJHsoVCsxKSo4fSR7T31gOiQ9YD49IC0oMiR7T30gKiogJHsoVCsxKSo4LTF9JHtPfSkgYW5kIDwgMiAqKiAkeyhUKzEpKjgtMX0ke099YDokPWA+PSAke2x9JHtPfSBhbmQgPD0gJHtmfSR7T31gLG5ldyBQci5FUlJfT1VUX09GX1JBTkdFKFwidmFsdWVcIiwkLHApfVVnKGIsQSxUKX1mdW5jdGlvbiBPcihwLGwpe2lmKHR5cGVvZiBwIT1cIm51bWJlclwiKXRocm93IG5ldyBQci5FUlJfSU5WQUxJRF9BUkdfVFlQRShsLFwibnVtYmVyXCIscCl9ZnVuY3Rpb24gYWkocCxsLGYpe3Rocm93IE1hdGguZmxvb3IocCkhPT1wPyhPcihwLGYpLG5ldyBQci5FUlJfT1VUX09GX1JBTkdFKGZ8fFwib2Zmc2V0XCIsXCJhbiBpbnRlZ2VyXCIscCkpOmw8MD9uZXcgUHIuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTOm5ldyBQci5FUlJfT1VUX09GX1JBTkdFKGZ8fFwib2Zmc2V0XCIsYD49ICR7Zj8xOjB9IGFuZCA8PSAke2x9YCxwKX1sZXQgTmc9L1teKy8wLTlBLVphLXotX10vZztmdW5jdGlvbiBxZyhwKXtpZihwPXAuc3BsaXQoXCI9XCIpWzBdLHA9cC50cmltKCkucmVwbGFjZShOZyxcIlwiKSxwLmxlbmd0aDwyKXJldHVyblwiXCI7Zm9yKDtwLmxlbmd0aCU0IT09MDspcD1wK1wiPVwiO3JldHVybiBwfWZ1bmN0aW9uIGNzKHAsbCl7bD1sfHwxLzA7bGV0IGYsYj1wLmxlbmd0aCxBPW51bGwsVD1bXTtmb3IobGV0IE89MDtPPGI7KytPKXtpZihmPXAuY2hhckNvZGVBdChPKSxmPjU1Mjk1JiZmPDU3MzQ0KXtpZighQSl7aWYoZj41NjMxOSl7KGwtPTMpPi0xJiZULnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWVsc2UgaWYoTysxPT09Yil7KGwtPTMpPi0xJiZULnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfUE9Zjtjb250aW51ZX1pZihmPDU2MzIwKXsobC09Myk+LTEmJlQucHVzaCgyMzksMTkxLDE4OSksQT1mO2NvbnRpbnVlfWY9KEEtNTUyOTY8PDEwfGYtNTYzMjApKzY1NTM2fWVsc2UgQSYmKGwtPTMpPi0xJiZULnB1c2goMjM5LDE5MSwxODkpO2lmKEE9bnVsbCxmPDEyOCl7aWYoKGwtPTEpPDApYnJlYWs7VC5wdXNoKGYpfWVsc2UgaWYoZjwyMDQ4KXtpZigobC09Mik8MClicmVhaztULnB1c2goZj4+NnwxOTIsZiY2M3wxMjgpfWVsc2UgaWYoZjw2NTUzNil7aWYoKGwtPTMpPDApYnJlYWs7VC5wdXNoKGY+PjEyfDIyNCxmPj42JjYzfDEyOCxmJjYzfDEyOCl9ZWxzZSBpZihmPDExMTQxMTIpe2lmKChsLT00KTwwKWJyZWFrO1QucHVzaChmPj4xOHwyNDAsZj4+MTImNjN8MTI4LGY+PjYmNjN8MTI4LGYmNjN8MTI4KX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKX1yZXR1cm4gVH1mdW5jdGlvbiBEZyhwKXtsZXQgbD1bXTtmb3IobGV0IGY9MDtmPHAubGVuZ3RoOysrZilsLnB1c2gocC5jaGFyQ29kZUF0KGYpJjI1NSk7cmV0dXJuIGx9ZnVuY3Rpb24gamcocCxsKXtsZXQgZixiLEEsVD1bXTtmb3IobGV0IE89MDtPPHAubGVuZ3RoJiYhKChsLT0yKTwwKTsrK08pZj1wLmNoYXJDb2RlQXQoTyksYj1mPj44LEE9ZiUyNTYsVC5wdXNoKEEpLFQucHVzaChiKTtyZXR1cm4gVH1mdW5jdGlvbiBDbChwKXtyZXR1cm4gdC50b0J5dGVBcnJheShxZyhwKSl9ZnVuY3Rpb24gcWkocCxsLGYsYil7bGV0IEE7Zm9yKEE9MDtBPGImJiEoQStmPj1sLmxlbmd0aHx8QT49cC5sZW5ndGgpOysrQSlsW0ErZl09cFtBXTtyZXR1cm4gQX1mdW5jdGlvbiBZZShwLGwpe3JldHVybiBwIGluc3RhbmNlb2YgbHx8cCE9bnVsbCYmcC5jb25zdHJ1Y3RvciE9bnVsbCYmcC5jb25zdHJ1Y3Rvci5uYW1lIT1udWxsJiZwLmNvbnN0cnVjdG9yLm5hbWU9PT1sLm5hbWV9ZnVuY3Rpb24gaHMocCl7cmV0dXJuIHAhPT1wfWxldCBGZz1mdW5jdGlvbigpe2xldCBwPVwiMDEyMzQ1Njc4OWFiY2RlZlwiLGw9bmV3IEFycmF5KDI1Nik7Zm9yKGxldCBmPTA7ZjwxNjsrK2Ype2xldCBiPWYqMTY7Zm9yKGxldCBBPTA7QTwxNjsrK0EpbFtiK0FdPXBbZl0rcFtBXX1yZXR1cm4gbH0oKTtmdW5jdGlvbiB4dChwKXtyZXR1cm4gdHlwZW9mIEJpZ0ludD5cInVcIj9XZzpwfWZ1bmN0aW9uIFdnKCl7dGhyb3cgbmV3IEVycm9yKFwiQmlnSW50IG5vdCBzdXBwb3J0ZWRcIil9cmV0dXJuIEp0fXZhciBsaSxWdSxXaSx6dSxKdCxLdSxMdCxrLEpnLFhnLHdlPWJlKCgpPT57digpO20oKTtfKCk7bGk9e30sVnU9ITE7V2k9e30senU9ITE7SnQ9e30sS3U9ITE7THQ9WWcoKTtMdC5CdWZmZXI7THQuU2xvd0J1ZmZlcjtMdC5JTlNQRUNUX01BWF9CWVRFUztMdC5rTWF4TGVuZ3RoO2s9THQuQnVmZmVyLEpnPUx0LklOU1BFQ1RfTUFYX0JZVEVTLFhnPUx0LmtNYXhMZW5ndGh9KTt2YXIgdj1iZSgoKT0+e3dlKCl9KTt2YXIgR3U9TSh3cz0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYnM9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5hbGlhc1RvVG9waWM9e30sdGhpcy5tYXg9ZX1wdXQoZSxyKXtyZXR1cm4gcj09PTB8fHI+dGhpcy5tYXg/ITE6KHRoaXMuYWxpYXNUb1RvcGljW3JdPWUsdGhpcy5sZW5ndGg9T2JqZWN0LmtleXModGhpcy5hbGlhc1RvVG9waWMpLmxlbmd0aCwhMCl9Z2V0VG9waWNCeUFsaWFzKGUpe3JldHVybiB0aGlzLmFsaWFzVG9Ub3BpY1tlXX1jbGVhcigpe3RoaXMuYWxpYXNUb1RvcGljPXt9fX07d3MuZGVmYXVsdD1ic30pO3ZhciBjZT1NKChSQSxRdSk9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtRdS5leHBvcnRzPXtBcnJheUlzQXJyYXkodCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCl9LEFycmF5UHJvdG90eXBlSW5jbHVkZXModCxlKXtyZXR1cm4gdC5pbmNsdWRlcyhlKX0sQXJyYXlQcm90b3R5cGVJbmRleE9mKHQsZSl7cmV0dXJuIHQuaW5kZXhPZihlKX0sQXJyYXlQcm90b3R5cGVKb2luKHQsZSl7cmV0dXJuIHQuam9pbihlKX0sQXJyYXlQcm90b3R5cGVNYXAodCxlKXtyZXR1cm4gdC5tYXAoZSl9LEFycmF5UHJvdG90eXBlUG9wKHQsZSl7cmV0dXJuIHQucG9wKGUpfSxBcnJheVByb3RvdHlwZVB1c2godCxlKXtyZXR1cm4gdC5wdXNoKGUpfSxBcnJheVByb3RvdHlwZVNsaWNlKHQsZSxyKXtyZXR1cm4gdC5zbGljZShlLHIpfSxFcnJvcixGdW5jdGlvblByb3RvdHlwZUNhbGwodCxlLC4uLnIpe3JldHVybiB0LmNhbGwoZSwuLi5yKX0sRnVuY3Rpb25Qcm90b3R5cGVTeW1ib2xIYXNJbnN0YW5jZSh0LGUpe3JldHVybiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXS5jYWxsKHQsZSl9LE1hdGhGbG9vcjpNYXRoLmZsb29yLE51bWJlcixOdW1iZXJJc0ludGVnZXI6TnVtYmVyLmlzSW50ZWdlcixOdW1iZXJJc05hTjpOdW1iZXIuaXNOYU4sTnVtYmVyTUFYX1NBRkVfSU5URUdFUjpOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixOdW1iZXJNSU5fU0FGRV9JTlRFR0VSOk51bWJlci5NSU5fU0FGRV9JTlRFR0VSLE51bWJlclBhcnNlSW50Ok51bWJlci5wYXJzZUludCxPYmplY3REZWZpbmVQcm9wZXJ0aWVzKHQsZSl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsZSl9LE9iamVjdERlZmluZVByb3BlcnR5KHQsZSxyKXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxyKX0sT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxlKX0sT2JqZWN0S2V5cyh0KXtyZXR1cm4gT2JqZWN0LmtleXModCl9LE9iamVjdFNldFByb3RvdHlwZU9mKHQsZSl7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpfSxQcm9taXNlLFByb21pc2VQcm90b3R5cGVDYXRjaCh0LGUpe3JldHVybiB0LmNhdGNoKGUpfSxQcm9taXNlUHJvdG90eXBlVGhlbih0LGUscil7cmV0dXJuIHQudGhlbihlLHIpfSxQcm9taXNlUmVqZWN0KHQpe3JldHVybiBQcm9taXNlLnJlamVjdCh0KX0sUmVmbGVjdEFwcGx5OlJlZmxlY3QuYXBwbHksUmVnRXhwUHJvdG90eXBlVGVzdCh0LGUpe3JldHVybiB0LnRlc3QoZSl9LFNhZmVTZXQ6U2V0LFN0cmluZyxTdHJpbmdQcm90b3R5cGVTbGljZSh0LGUscil7cmV0dXJuIHQuc2xpY2UoZSxyKX0sU3RyaW5nUHJvdG90eXBlVG9Mb3dlckNhc2UodCl7cmV0dXJuIHQudG9Mb3dlckNhc2UoKX0sU3RyaW5nUHJvdG90eXBlVG9VcHBlckNhc2UodCl7cmV0dXJuIHQudG9VcHBlckNhc2UoKX0sU3RyaW5nUHJvdG90eXBlVHJpbSh0KXtyZXR1cm4gdC50cmltKCl9LFN5bWJvbCxTeW1ib2xGb3I6U3ltYm9sLmZvcixTeW1ib2xBc3luY0l0ZXJhdG9yOlN5bWJvbC5hc3luY0l0ZXJhdG9yLFN5bWJvbEhhc0luc3RhbmNlOlN5bWJvbC5oYXNJbnN0YW5jZSxTeW1ib2xJdGVyYXRvcjpTeW1ib2wuaXRlcmF0b3IsVHlwZWRBcnJheVByb3RvdHlwZVNldCh0LGUscil7cmV0dXJuIHQuc2V0KGUscil9LFVpbnQ4QXJyYXl9fSk7dmFyIEplPU0oKE5BLG1zKT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhciBaZz0od2UoKSxaKHZlKSksZXk9T2JqZWN0LmdldFByb3RvdHlwZU9mKGFzeW5jIGZ1bmN0aW9uKCl7fSkuY29uc3RydWN0b3IsWXU9Z2xvYmFsVGhpcy5CbG9ifHxaZy5CbG9iLHR5PXR5cGVvZiBZdTxcInVcIj9mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFl1fTpmdW5jdGlvbihlKXtyZXR1cm4hMX0sX3M9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihlKXtpZighQXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnB1dCB0byBiZSBhbiBBcnJheSwgZ290ICR7dHlwZW9mIGV9YCk7bGV0IHI9XCJcIjtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKylyKz1gICAgICR7ZVtpXS5zdGFja31cbmA7c3VwZXIociksdGhpcy5uYW1lPVwiQWdncmVnYXRlRXJyb3JcIix0aGlzLmVycm9ycz1lfX07bXMuZXhwb3J0cz17QWdncmVnYXRlRXJyb3I6X3Msa0VtcHR5T2JqZWN0Ok9iamVjdC5mcmVlemUoe30pLG9uY2UodCl7bGV0IGU9ITE7cmV0dXJuIGZ1bmN0aW9uKC4uLnIpe2V8fChlPSEwLHQuYXBwbHkodGhpcyxyKSl9fSxjcmVhdGVEZWZlcnJlZFByb21pc2U6ZnVuY3Rpb24oKXtsZXQgdCxlO3JldHVybntwcm9taXNlOm5ldyBQcm9taXNlKChpLG4pPT57dD1pLGU9bn0pLHJlc29sdmU6dCxyZWplY3Q6ZX19LHByb21pc2lmeSh0KXtyZXR1cm4gbmV3IFByb21pc2UoKGUscik9Pnt0KChpLC4uLm4pPT5pP3IoaSk6ZSguLi5uKSl9KX0sZGVidWdsb2coKXtyZXR1cm4gZnVuY3Rpb24oKXt9fSxmb3JtYXQodCwuLi5lKXtyZXR1cm4gdC5yZXBsYWNlKC8lKFtzZGlmal0pL2csZnVuY3Rpb24oLi4uW3IsaV0pe2xldCBuPWUuc2hpZnQoKTtyZXR1cm4gaT09PVwiZlwiP24udG9GaXhlZCg2KTppPT09XCJqXCI/SlNPTi5zdHJpbmdpZnkobik6aT09PVwic1wiJiZ0eXBlb2Ygbj09XCJvYmplY3RcIj9gJHtuLmNvbnN0cnVjdG9yIT09T2JqZWN0P24uY29uc3RydWN0b3IubmFtZTpcIlwifSB7fWAudHJpbSgpOm4udG9TdHJpbmcoKX0pfSxpbnNwZWN0KHQpe3N3aXRjaCh0eXBlb2YgdCl7Y2FzZVwic3RyaW5nXCI6aWYodC5pbmNsdWRlcyhcIidcIikpaWYodC5pbmNsdWRlcygnXCInKSl7aWYoIXQuaW5jbHVkZXMoXCJgXCIpJiYhdC5pbmNsdWRlcyhcIiR7XCIpKXJldHVybmBcXGAke3R9XFxgYH1lbHNlIHJldHVybmBcIiR7dH1cImA7cmV0dXJuYCcke3R9J2A7Y2FzZVwibnVtYmVyXCI6cmV0dXJuIGlzTmFOKHQpP1wiTmFOXCI6T2JqZWN0LmlzKHQsLTApP1N0cmluZyh0KTp0O2Nhc2VcImJpZ2ludFwiOnJldHVybmAke1N0cmluZyh0KX1uYDtjYXNlXCJib29sZWFuXCI6Y2FzZVwidW5kZWZpbmVkXCI6cmV0dXJuIFN0cmluZyh0KTtjYXNlXCJvYmplY3RcIjpyZXR1cm5cInt9XCJ9fSx0eXBlczp7aXNBc3luY0Z1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZXl9LGlzQXJyYXlCdWZmZXJWaWV3KHQpe3JldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodCl9fSxpc0Jsb2I6dHl9O21zLmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbT1TeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiKX0pO3ZhciBIaT1NKChLQSwkaSk9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTt2YXJ7QWJvcnRDb250cm9sbGVyOkp1LEFib3J0U2lnbmFsOnJ5fT10eXBlb2Ygc2VsZjxcInVcIj9zZWxmOnR5cGVvZiB3aW5kb3c8XCJ1XCI/d2luZG93OnZvaWQgMDskaS5leHBvcnRzPUp1OyRpLmV4cG9ydHMuQWJvcnRTaWduYWw9cnk7JGkuZXhwb3J0cy5kZWZhdWx0PUp1fSk7dmFyIFNlPU0oKGlJLGVmKT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3Zhcntmb3JtYXQ6aXksaW5zcGVjdDpWaSxBZ2dyZWdhdGVFcnJvcjpueX09SmUoKSxzeT1nbG9iYWxUaGlzLkFnZ3JlZ2F0ZUVycm9yfHxueSxveT1TeW1ib2woXCJrSXNOb2RlRXJyb3JcIiksYXk9W1wic3RyaW5nXCIsXCJmdW5jdGlvblwiLFwibnVtYmVyXCIsXCJvYmplY3RcIixcIkZ1bmN0aW9uXCIsXCJPYmplY3RcIixcImJvb2xlYW5cIixcImJpZ2ludFwiLFwic3ltYm9sXCJdLGx5PS9eKFtBLVpdW2EtejAtOV0qKSskLyx1eT1cIl9fbm9kZV9pbnRlcm5hbF9cIix6aT17fTtmdW5jdGlvbiBYdCh0LGUpe2lmKCF0KXRocm93IG5ldyB6aS5FUlJfSU5URVJOQUxfQVNTRVJUSU9OKGUpfWZ1bmN0aW9uIFh1KHQpe2xldCBlPVwiXCIscj10Lmxlbmd0aCxpPXRbMF09PT1cIi1cIj8xOjA7Zm9yKDtyPj1pKzQ7ci09MyllPWBfJHt0LnNsaWNlKHItMyxyKX0ke2V9YDtyZXR1cm5gJHt0LnNsaWNlKDAscil9JHtlfWB9ZnVuY3Rpb24gZnkodCxlLHIpe2lmKHR5cGVvZiBlPT1cImZ1bmN0aW9uXCIpcmV0dXJuIFh0KGUubGVuZ3RoPD1yLmxlbmd0aCxgQ29kZTogJHt0fTsgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBsZW5ndGggKCR7ci5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZWQgb25lcyAoJHtlLmxlbmd0aH0pLmApLGUoLi4ucik7bGV0IGk9KGUubWF0Y2goLyVbZGZpam9Pc10vZyl8fFtdKS5sZW5ndGg7cmV0dXJuIFh0KGk9PT1yLmxlbmd0aCxgQ29kZTogJHt0fTsgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBsZW5ndGggKCR7ci5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZWQgb25lcyAoJHtpfSkuYCksci5sZW5ndGg9PT0wP2U6aXkoZSwuLi5yKX1mdW5jdGlvbiBfZSh0LGUscil7cnx8KHI9RXJyb3IpO2NsYXNzIGkgZXh0ZW5kcyBye2NvbnN0cnVjdG9yKC4uLm8pe3N1cGVyKGZ5KHQsZSxvKSl9dG9TdHJpbmcoKXtyZXR1cm5gJHt0aGlzLm5hbWV9IFske3R9XTogJHt0aGlzLm1lc3NhZ2V9YH19T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaS5wcm90b3R5cGUse25hbWU6e3ZhbHVlOnIubmFtZSx3cml0YWJsZTohMCxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0sdG9TdHJpbmc6e3ZhbHVlKCl7cmV0dXJuYCR7dGhpcy5uYW1lfSBbJHt0fV06ICR7dGhpcy5tZXNzYWdlfWB9LHdyaXRhYmxlOiEwLGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfX0pLGkucHJvdG90eXBlLmNvZGU9dCxpLnByb3RvdHlwZVtveV09ITAsemlbdF09aX1mdW5jdGlvbiBadSh0KXtsZXQgZT11eSt0Lm5hbWU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwibmFtZVwiLHt2YWx1ZTplfSksdH1mdW5jdGlvbiBjeSh0LGUpe2lmKHQmJmUmJnQhPT1lKXtpZihBcnJheS5pc0FycmF5KGUuZXJyb3JzKSlyZXR1cm4gZS5lcnJvcnMucHVzaCh0KSxlO2xldCByPW5ldyBzeShbZSx0XSxlLm1lc3NhZ2UpO3JldHVybiByLmNvZGU9ZS5jb2RlLHJ9cmV0dXJuIHR8fGV9dmFyIHZzPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoZT1cIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWRcIixyPXZvaWQgMCl7aWYociE9PXZvaWQgMCYmdHlwZW9mIHIhPVwib2JqZWN0XCIpdGhyb3cgbmV3IHppLkVSUl9JTlZBTElEX0FSR19UWVBFKFwib3B0aW9uc1wiLFwiT2JqZWN0XCIscik7c3VwZXIoZSxyKSx0aGlzLmNvZGU9XCJBQk9SVF9FUlJcIix0aGlzLm5hbWU9XCJBYm9ydEVycm9yXCJ9fTtfZShcIkVSUl9BU1NFUlRJT05cIixcIiVzXCIsRXJyb3IpO19lKFwiRVJSX0lOVkFMSURfQVJHX1RZUEVcIiwodCxlLHIpPT57WHQodHlwZW9mIHQ9PVwic3RyaW5nXCIsXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKSxBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pO2xldCBpPVwiVGhlIFwiO3QuZW5kc1dpdGgoXCIgYXJndW1lbnRcIik/aSs9YCR7dH0gYDppKz1gXCIke3R9XCIgJHt0LmluY2x1ZGVzKFwiLlwiKT9cInByb3BlcnR5XCI6XCJhcmd1bWVudFwifSBgLGkrPVwibXVzdCBiZSBcIjtsZXQgbj1bXSxvPVtdLHM9W107Zm9yKGxldCB1IG9mIGUpWHQodHlwZW9mIHU9PVwic3RyaW5nXCIsXCJBbGwgZXhwZWN0ZWQgZW50cmllcyBoYXZlIHRvIGJlIG9mIHR5cGUgc3RyaW5nXCIpLGF5LmluY2x1ZGVzKHUpP24ucHVzaCh1LnRvTG93ZXJDYXNlKCkpOmx5LnRlc3QodSk/by5wdXNoKHUpOihYdCh1IT09XCJvYmplY3RcIiwnVGhlIHZhbHVlIFwib2JqZWN0XCIgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgXCJPYmplY3RcIicpLHMucHVzaCh1KSk7aWYoby5sZW5ndGg+MCl7bGV0IHU9bi5pbmRleE9mKFwib2JqZWN0XCIpO3UhPT0tMSYmKG4uc3BsaWNlKG4sdSwxKSxvLnB1c2goXCJPYmplY3RcIikpfWlmKG4ubGVuZ3RoPjApe3N3aXRjaChuLmxlbmd0aCl7Y2FzZSAxOmkrPWBvZiB0eXBlICR7blswXX1gO2JyZWFrO2Nhc2UgMjppKz1gb25lIG9mIHR5cGUgJHtuWzBdfSBvciAke25bMV19YDticmVhaztkZWZhdWx0OntsZXQgdT1uLnBvcCgpO2krPWBvbmUgb2YgdHlwZSAke24uam9pbihcIiwgXCIpfSwgb3IgJHt1fWB9fShvLmxlbmd0aD4wfHxzLmxlbmd0aD4wKSYmKGkrPVwiIG9yIFwiKX1pZihvLmxlbmd0aD4wKXtzd2l0Y2goby5sZW5ndGgpe2Nhc2UgMTppKz1gYW4gaW5zdGFuY2Ugb2YgJHtvWzBdfWA7YnJlYWs7Y2FzZSAyOmkrPWBhbiBpbnN0YW5jZSBvZiAke29bMF19IG9yICR7b1sxXX1gO2JyZWFrO2RlZmF1bHQ6e2xldCB1PW8ucG9wKCk7aSs9YGFuIGluc3RhbmNlIG9mICR7by5qb2luKFwiLCBcIil9LCBvciAke3V9YH19cy5sZW5ndGg+MCYmKGkrPVwiIG9yIFwiKX1zd2l0Y2gocy5sZW5ndGgpe2Nhc2UgMDpicmVhaztjYXNlIDE6c1swXS50b0xvd2VyQ2FzZSgpIT09c1swXSYmKGkrPVwiYW4gXCIpLGkrPWAke3NbMF19YDticmVhaztjYXNlIDI6aSs9YG9uZSBvZiAke3NbMF19IG9yICR7c1sxXX1gO2JyZWFrO2RlZmF1bHQ6e2xldCB1PXMucG9wKCk7aSs9YG9uZSBvZiAke3Muam9pbihcIiwgXCIpfSwgb3IgJHt1fWB9fWlmKHI9PW51bGwpaSs9YC4gUmVjZWl2ZWQgJHtyfWA7ZWxzZSBpZih0eXBlb2Ygcj09XCJmdW5jdGlvblwiJiZyLm5hbWUpaSs9YC4gUmVjZWl2ZWQgZnVuY3Rpb24gJHtyLm5hbWV9YDtlbHNlIGlmKHR5cGVvZiByPT1cIm9iamVjdFwiKXt2YXIgYTtpZigoYT1yLmNvbnN0cnVjdG9yKSE9PW51bGwmJmEhPT12b2lkIDAmJmEubmFtZSlpKz1gLiBSZWNlaXZlZCBhbiBpbnN0YW5jZSBvZiAke3IuY29uc3RydWN0b3IubmFtZX1gO2Vsc2V7bGV0IHU9Vmkocix7ZGVwdGg6LTF9KTtpKz1gLiBSZWNlaXZlZCAke3V9YH19ZWxzZXtsZXQgdT1WaShyLHtjb2xvcnM6ITF9KTt1Lmxlbmd0aD4yNSYmKHU9YCR7dS5zbGljZSgwLDI1KX0uLi5gKSxpKz1gLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIHJ9ICgke3V9KWB9cmV0dXJuIGl9LFR5cGVFcnJvcik7X2UoXCJFUlJfSU5WQUxJRF9BUkdfVkFMVUVcIiwodCxlLHI9XCJpcyBpbnZhbGlkXCIpPT57bGV0IGk9VmkoZSk7cmV0dXJuIGkubGVuZ3RoPjEyOCYmKGk9aS5zbGljZSgwLDEyOCkrXCIuLi5cIiksYFRoZSAke3QuaW5jbHVkZXMoXCIuXCIpP1wicHJvcGVydHlcIjpcImFyZ3VtZW50XCJ9ICcke3R9JyAke3J9LiBSZWNlaXZlZCAke2l9YH0sVHlwZUVycm9yKTtfZShcIkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRVwiLCh0LGUscik9Pnt2YXIgaTtsZXQgbj1yIT1udWxsJiYoaT1yLmNvbnN0cnVjdG9yKSE9PW51bGwmJmkhPT12b2lkIDAmJmkubmFtZT9gaW5zdGFuY2Ugb2YgJHtyLmNvbnN0cnVjdG9yLm5hbWV9YDpgdHlwZSAke3R5cGVvZiByfWA7cmV0dXJuYEV4cGVjdGVkICR7dH0gdG8gYmUgcmV0dXJuZWQgZnJvbSB0aGUgXCIke2V9XCIgZnVuY3Rpb24gYnV0IGdvdCAke259LmB9LFR5cGVFcnJvcik7X2UoXCJFUlJfTUlTU0lOR19BUkdTXCIsKC4uLnQpPT57WHQodC5sZW5ndGg+MCxcIkF0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkXCIpO2xldCBlLHI9dC5sZW5ndGg7c3dpdGNoKHQ9KEFycmF5LmlzQXJyYXkodCk/dDpbdF0pLm1hcChpPT5gXCIke2l9XCJgKS5qb2luKFwiIG9yIFwiKSxyKXtjYXNlIDE6ZSs9YFRoZSAke3RbMF19IGFyZ3VtZW50YDticmVhaztjYXNlIDI6ZSs9YFRoZSAke3RbMF19IGFuZCAke3RbMV19IGFyZ3VtZW50c2A7YnJlYWs7ZGVmYXVsdDp7bGV0IGk9dC5wb3AoKTtlKz1gVGhlICR7dC5qb2luKFwiLCBcIil9LCBhbmQgJHtpfSBhcmd1bWVudHNgfWJyZWFrfXJldHVybmAke2V9IG11c3QgYmUgc3BlY2lmaWVkYH0sVHlwZUVycm9yKTtfZShcIkVSUl9PVVRfT0ZfUkFOR0VcIiwodCxlLHIpPT57WHQoZSwnTWlzc2luZyBcInJhbmdlXCIgYXJndW1lbnQnKTtsZXQgaTtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihyKSYmTWF0aC5hYnMocik+MioqMzI/aT1YdShTdHJpbmcocikpOnR5cGVvZiByPT1cImJpZ2ludFwiPyhpPVN0cmluZyhyKSwocj4ybioqMzJufHxyPC0oMm4qKjMybikpJiYoaT1YdShpKSksaSs9XCJuXCIpOmk9VmkociksYFRoZSB2YWx1ZSBvZiBcIiR7dH1cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgJHtlfS4gUmVjZWl2ZWQgJHtpfWB9LFJhbmdlRXJyb3IpO19lKFwiRVJSX01VTFRJUExFX0NBTExCQUNLXCIsXCJDYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXNcIixFcnJvcik7X2UoXCJFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRFwiLFwiVGhlICVzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWRcIixFcnJvcik7X2UoXCJFUlJfU1RSRUFNX0FMUkVBRFlfRklOSVNIRURcIixcIkNhbm5vdCBjYWxsICVzIGFmdGVyIGEgc3RyZWFtIHdhcyBmaW5pc2hlZFwiLEVycm9yKTtfZShcIkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEVcIixcIkNhbm5vdCBwaXBlLCBub3QgcmVhZGFibGVcIixFcnJvcik7X2UoXCJFUlJfU1RSRUFNX0RFU1RST1lFRFwiLFwiQ2Fubm90IGNhbGwgJXMgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZFwiLEVycm9yKTtfZShcIkVSUl9TVFJFQU1fTlVMTF9WQUxVRVNcIixcIk1heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtXCIsVHlwZUVycm9yKTtfZShcIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFXCIsXCJQcmVtYXR1cmUgY2xvc2VcIixFcnJvcik7X2UoXCJFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GXCIsXCJzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRlwiLEVycm9yKTtfZShcIkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlRcIixcInN0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50XCIsRXJyb3IpO19lKFwiRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkRcIixcIndyaXRlIGFmdGVyIGVuZFwiLEVycm9yKTtfZShcIkVSUl9VTktOT1dOX0VOQ09ESU5HXCIsXCJVbmtub3duIGVuY29kaW5nOiAlc1wiLFR5cGVFcnJvcik7ZWYuZXhwb3J0cz17QWJvcnRFcnJvcjp2cyxhZ2dyZWdhdGVUd29FcnJvcnM6WnUoY3kpLGhpZGVTdGFja0ZyYW1lczpadSxjb2Rlczp6aX19KTt2YXIgdWk9TSgoZEksZmYpPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7dmFye0FycmF5SXNBcnJheTpTcyxBcnJheVByb3RvdHlwZUluY2x1ZGVzOnNmLEFycmF5UHJvdG90eXBlSm9pbjpvZixBcnJheVByb3RvdHlwZU1hcDpoeSxOdW1iZXJJc0ludGVnZXI6QXMsTnVtYmVySXNOYU46ZHksTnVtYmVyTUFYX1NBRkVfSU5URUdFUjpweSxOdW1iZXJNSU5fU0FGRV9JTlRFR0VSOmd5LE51bWJlclBhcnNlSW50Onl5LE9iamVjdFByb3RvdHlwZUhhc093blByb3BlcnR5OmJ5LFJlZ0V4cFByb3RvdHlwZUV4ZWM6YWYsU3RyaW5nOnd5LFN0cmluZ1Byb3RvdHlwZVRvVXBwZXJDYXNlOl95LFN0cmluZ1Byb3RvdHlwZVRyaW06bXl9PWNlKCkse2hpZGVTdGFja0ZyYW1lczpVZSxjb2Rlczp7RVJSX1NPQ0tFVF9CQURfUE9SVDp2eSxFUlJfSU5WQUxJRF9BUkdfVFlQRTpBZSxFUlJfSU5WQUxJRF9BUkdfVkFMVUU6eHIsRVJSX09VVF9PRl9SQU5HRTpadCxFUlJfVU5LTk9XTl9TSUdOQUw6dGZ9fT1TZSgpLHtub3JtYWxpemVFbmNvZGluZzpFeX09SmUoKSx7aXNBc3luY0Z1bmN0aW9uOlN5LGlzQXJyYXlCdWZmZXJWaWV3OkF5fT1KZSgpLnR5cGVzLHJmPXt9O2Z1bmN0aW9uIEl5KHQpe3JldHVybiB0PT09KHR8MCl9ZnVuY3Rpb24gVHkodCl7cmV0dXJuIHQ9PT10Pj4+MH12YXIgUnk9L15bMC03XSskLyxDeT1cIm11c3QgYmUgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciBvciBhbiBvY3RhbCBzdHJpbmdcIjtmdW5jdGlvbiBCeSh0LGUscil7aWYodHlwZW9mIHQ+XCJ1XCImJih0PXIpLHR5cGVvZiB0PT1cInN0cmluZ1wiKXtpZihhZihSeSx0KT09PW51bGwpdGhyb3cgbmV3IHhyKGUsdCxDeSk7dD15eSh0LDgpfXJldHVybiBsZih0LGUpLHR9dmFyIFB5PVVlKCh0LGUscj1neSxpPXB5KT0+e2lmKHR5cGVvZiB0IT1cIm51bWJlclwiKXRocm93IG5ldyBBZShlLFwibnVtYmVyXCIsdCk7aWYoIUFzKHQpKXRocm93IG5ldyBadChlLFwiYW4gaW50ZWdlclwiLHQpO2lmKHQ8cnx8dD5pKXRocm93IG5ldyBadChlLGA+PSAke3J9ICYmIDw9ICR7aX1gLHQpfSksT3k9VWUoKHQsZSxyPS0yMTQ3NDgzNjQ4LGk9MjE0NzQ4MzY0Nyk9PntpZih0eXBlb2YgdCE9XCJudW1iZXJcIil0aHJvdyBuZXcgQWUoZSxcIm51bWJlclwiLHQpO2lmKCFBcyh0KSl0aHJvdyBuZXcgWnQoZSxcImFuIGludGVnZXJcIix0KTtpZih0PHJ8fHQ+aSl0aHJvdyBuZXcgWnQoZSxgPj0gJHtyfSAmJiA8PSAke2l9YCx0KX0pLGxmPVVlKCh0LGUscj0hMSk9PntpZih0eXBlb2YgdCE9XCJudW1iZXJcIil0aHJvdyBuZXcgQWUoZSxcIm51bWJlclwiLHQpO2lmKCFBcyh0KSl0aHJvdyBuZXcgWnQoZSxcImFuIGludGVnZXJcIix0KTtsZXQgaT1yPzE6MCxuPTQyOTQ5NjcyOTU7aWYodDxpfHx0Pm4pdGhyb3cgbmV3IFp0KGUsYD49ICR7aX0gJiYgPD0gJHtufWAsdCl9KTtmdW5jdGlvbiBJcyh0LGUpe2lmKHR5cGVvZiB0IT1cInN0cmluZ1wiKXRocm93IG5ldyBBZShlLFwic3RyaW5nXCIsdCl9ZnVuY3Rpb24ga3kodCxlLHI9dm9pZCAwLGkpe2lmKHR5cGVvZiB0IT1cIm51bWJlclwiKXRocm93IG5ldyBBZShlLFwibnVtYmVyXCIsdCk7aWYociE9bnVsbCYmdDxyfHxpIT1udWxsJiZ0Pml8fChyIT1udWxsfHxpIT1udWxsKSYmZHkodCkpdGhyb3cgbmV3IFp0KGUsYCR7ciE9bnVsbD9gPj0gJHtyfWA6XCJcIn0ke3IhPW51bGwmJmkhPW51bGw/XCIgJiYgXCI6XCJcIn0ke2khPW51bGw/YDw9ICR7aX1gOlwiXCJ9YCx0KX12YXIgeHk9VWUoKHQsZSxyKT0+e2lmKCFzZihyLHQpKXtsZXQgbj1cIm11c3QgYmUgb25lIG9mOiBcIitvZihoeShyLG89PnR5cGVvZiBvPT1cInN0cmluZ1wiP2AnJHtvfSdgOnd5KG8pKSxcIiwgXCIpO3Rocm93IG5ldyB4cihlLHQsbil9fSk7ZnVuY3Rpb24gdWYodCxlKXtpZih0eXBlb2YgdCE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEFlKGUsXCJib29sZWFuXCIsdCl9ZnVuY3Rpb24gRXModCxlLHIpe3JldHVybiB0PT1udWxsfHwhYnkodCxlKT9yOnRbZV19dmFyIE15PVVlKCh0LGUscj1udWxsKT0+e2xldCBpPUVzKHIsXCJhbGxvd0FycmF5XCIsITEpLG49RXMocixcImFsbG93RnVuY3Rpb25cIiwhMSk7aWYoIUVzKHIsXCJudWxsYWJsZVwiLCExKSYmdD09PW51bGx8fCFpJiZTcyh0KXx8dHlwZW9mIHQhPVwib2JqZWN0XCImJighbnx8dHlwZW9mIHQhPVwiZnVuY3Rpb25cIikpdGhyb3cgbmV3IEFlKGUsXCJPYmplY3RcIix0KX0pLEx5PVVlKCh0LGUpPT57aWYodCE9bnVsbCYmdHlwZW9mIHQhPVwib2JqZWN0XCImJnR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEFlKGUsXCJhIGRpY3Rpb25hcnlcIix0KX0pLFRzPVVlKCh0LGUscj0wKT0+e2lmKCFTcyh0KSl0aHJvdyBuZXcgQWUoZSxcIkFycmF5XCIsdCk7aWYodC5sZW5ndGg8cil7bGV0IGk9YG11c3QgYmUgbG9uZ2VyIHRoYW4gJHtyfWA7dGhyb3cgbmV3IHhyKGUsdCxpKX19KTtmdW5jdGlvbiBVeSh0LGUpe1RzKHQsZSk7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspSXModFtyXSxgJHtlfVske3J9XWApfWZ1bmN0aW9uIE55KHQsZSl7VHModCxlKTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl1Zih0W3JdLGAke2V9WyR7cn1dYCl9ZnVuY3Rpb24gcXkodCxlPVwic2lnbmFsXCIpe2lmKElzKHQsZSkscmZbdF09PT12b2lkIDApdGhyb3cgcmZbX3kodCldIT09dm9pZCAwP25ldyB0Zih0K1wiIChzaWduYWxzIG11c3QgdXNlIGFsbCBjYXBpdGFsIGxldHRlcnMpXCIpOm5ldyB0Zih0KX12YXIgRHk9VWUoKHQsZT1cImJ1ZmZlclwiKT0+e2lmKCFBeSh0KSl0aHJvdyBuZXcgQWUoZSxbXCJCdWZmZXJcIixcIlR5cGVkQXJyYXlcIixcIkRhdGFWaWV3XCJdLHQpfSk7ZnVuY3Rpb24gankodCxlKXtsZXQgcj1FeShlKSxpPXQubGVuZ3RoO2lmKHI9PT1cImhleFwiJiZpJTIhPT0wKXRocm93IG5ldyB4cihcImVuY29kaW5nXCIsZSxgaXMgaW52YWxpZCBmb3IgZGF0YSBvZiBsZW5ndGggJHtpfWApfWZ1bmN0aW9uIEZ5KHQsZT1cIlBvcnRcIixyPSEwKXtpZih0eXBlb2YgdCE9XCJudW1iZXJcIiYmdHlwZW9mIHQhPVwic3RyaW5nXCJ8fHR5cGVvZiB0PT1cInN0cmluZ1wiJiZteSh0KS5sZW5ndGg9PT0wfHwrdCE9PSt0Pj4+MHx8dD42NTUzNXx8dD09PTAmJiFyKXRocm93IG5ldyB2eShlLHQscik7cmV0dXJuIHR8MH12YXIgV3k9VWUoKHQsZSk9PntpZih0IT09dm9pZCAwJiYodD09PW51bGx8fHR5cGVvZiB0IT1cIm9iamVjdFwifHwhKFwiYWJvcnRlZFwiaW4gdCkpKXRocm93IG5ldyBBZShlLFwiQWJvcnRTaWduYWxcIix0KX0pLCR5PVVlKCh0LGUpPT57aWYodHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgQWUoZSxcIkZ1bmN0aW9uXCIsdCl9KSxIeT1VZSgodCxlKT0+e2lmKHR5cGVvZiB0IT1cImZ1bmN0aW9uXCJ8fFN5KHQpKXRocm93IG5ldyBBZShlLFwiRnVuY3Rpb25cIix0KX0pLFZ5PVVlKCh0LGUpPT57aWYodCE9PXZvaWQgMCl0aHJvdyBuZXcgQWUoZSxcInVuZGVmaW5lZFwiLHQpfSk7ZnVuY3Rpb24genkodCxlLHIpe2lmKCFzZihyLHQpKXRocm93IG5ldyBBZShlLGAoJyR7b2YocixcInxcIil9JylgLHQpfXZhciBLeT0vXig/OjxbXj5dKj4pKD86XFxzKjtcXHMqW147XCJcXHNdKyg/Oj0oXCIpP1teO1wiXFxzXSpcXDEpPykqJC87ZnVuY3Rpb24gbmYodCxlKXtpZih0eXBlb2YgdD5cInVcInx8IWFmKEt5LHQpKXRocm93IG5ldyB4cihlLHQsJ211c3QgYmUgYW4gYXJyYXkgb3Igc3RyaW5nIG9mIGZvcm1hdCBcIjwvc3R5bGVzLmNzcz47IHJlbD1wcmVsb2FkOyBhcz1zdHlsZVwiJyl9ZnVuY3Rpb24gR3kodCl7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpcmV0dXJuIG5mKHQsXCJoaW50c1wiKSx0O2lmKFNzKHQpKXtsZXQgZT10Lmxlbmd0aCxyPVwiXCI7aWYoZT09PTApcmV0dXJuIHI7Zm9yKGxldCBpPTA7aTxlO2krKyl7bGV0IG49dFtpXTtuZihuLFwiaGludHNcIikscis9bixpIT09ZS0xJiYocis9XCIsIFwiKX1yZXR1cm4gcn10aHJvdyBuZXcgeHIoXCJoaW50c1wiLHQsJ211c3QgYmUgYW4gYXJyYXkgb3Igc3RyaW5nIG9mIGZvcm1hdCBcIjwvc3R5bGVzLmNzcz47IHJlbD1wcmVsb2FkOyBhcz1zdHlsZVwiJyl9ZmYuZXhwb3J0cz17aXNJbnQzMjpJeSxpc1VpbnQzMjpUeSxwYXJzZUZpbGVNb2RlOkJ5LHZhbGlkYXRlQXJyYXk6VHMsdmFsaWRhdGVTdHJpbmdBcnJheTpVeSx2YWxpZGF0ZUJvb2xlYW5BcnJheTpOeSx2YWxpZGF0ZUJvb2xlYW46dWYsdmFsaWRhdGVCdWZmZXI6RHksdmFsaWRhdGVEaWN0aW9uYXJ5Okx5LHZhbGlkYXRlRW5jb2Rpbmc6anksdmFsaWRhdGVGdW5jdGlvbjokeSx2YWxpZGF0ZUludDMyOk95LHZhbGlkYXRlSW50ZWdlcjpQeSx2YWxpZGF0ZU51bWJlcjpreSx2YWxpZGF0ZU9iamVjdDpNeSx2YWxpZGF0ZU9uZU9mOnh5LHZhbGlkYXRlUGxhaW5GdW5jdGlvbjpIeSx2YWxpZGF0ZVBvcnQ6RnksdmFsaWRhdGVTaWduYWxOYW1lOnF5LHZhbGlkYXRlU3RyaW5nOklzLHZhbGlkYXRlVWludDMyOmxmLHZhbGlkYXRlVW5kZWZpbmVkOlZ5LHZhbGlkYXRlVW5pb246enksdmFsaWRhdGVBYm9ydFNpZ25hbDpXeSx2YWxpZGF0ZUxpbmtIZWFkZXJWYWx1ZTpHeX19KTt2YXIgVXQ9TSgoU0kscGYpPT57digpO20oKTtfKCk7dmFyIGFlPXBmLmV4cG9ydHM9e30sWGUsWmU7ZnVuY3Rpb24gUnMoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIENzKCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXt0eXBlb2Ygc2V0VGltZW91dD09XCJmdW5jdGlvblwiP1hlPXNldFRpbWVvdXQ6WGU9UnN9Y2F0Y2h7WGU9UnN9dHJ5e3R5cGVvZiBjbGVhclRpbWVvdXQ9PVwiZnVuY3Rpb25cIj9aZT1jbGVhclRpbWVvdXQ6WmU9Q3N9Y2F0Y2h7WmU9Q3N9fSkoKTtmdW5jdGlvbiBjZih0KXtpZihYZT09PXNldFRpbWVvdXQpcmV0dXJuIHNldFRpbWVvdXQodCwwKTtpZigoWGU9PT1Sc3x8IVhlKSYmc2V0VGltZW91dClyZXR1cm4gWGU9c2V0VGltZW91dCxzZXRUaW1lb3V0KHQsMCk7dHJ5e3JldHVybiBYZSh0LDApfWNhdGNoe3RyeXtyZXR1cm4gWGUuY2FsbChudWxsLHQsMCl9Y2F0Y2h7cmV0dXJuIFhlLmNhbGwodGhpcyx0LDApfX19ZnVuY3Rpb24gUXkodCl7aWYoWmU9PT1jbGVhclRpbWVvdXQpcmV0dXJuIGNsZWFyVGltZW91dCh0KTtpZigoWmU9PT1Dc3x8IVplKSYmY2xlYXJUaW1lb3V0KXJldHVybiBaZT1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KHQpO3RyeXtyZXR1cm4gWmUodCl9Y2F0Y2h7dHJ5e3JldHVybiBaZS5jYWxsKG51bGwsdCl9Y2F0Y2h7cmV0dXJuIFplLmNhbGwodGhpcyx0KX19fXZhciB3dD1bXSxNcj0hMSxlcixLaT0tMTtmdW5jdGlvbiBZeSgpeyFNcnx8IWVyfHwoTXI9ITEsZXIubGVuZ3RoP3d0PWVyLmNvbmNhdCh3dCk6S2k9LTEsd3QubGVuZ3RoJiZoZigpKX1mdW5jdGlvbiBoZigpe2lmKCFNcil7dmFyIHQ9Y2YoWXkpO01yPSEwO2Zvcih2YXIgZT13dC5sZW5ndGg7ZTspe2Zvcihlcj13dCx3dD1bXTsrK0tpPGU7KWVyJiZlcltLaV0ucnVuKCk7S2k9LTEsZT13dC5sZW5ndGh9ZXI9bnVsbCxNcj0hMSxReSh0KX19YWUubmV4dFRpY2s9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspZVtyLTFdPWFyZ3VtZW50c1tyXTt3dC5wdXNoKG5ldyBkZih0LGUpKSx3dC5sZW5ndGg9PT0xJiYhTXImJmNmKGhmKX07ZnVuY3Rpb24gZGYodCxlKXt0aGlzLmZ1bj10LHRoaXMuYXJyYXk9ZX1kZi5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07YWUudGl0bGU9XCJicm93c2VyXCI7YWUuYnJvd3Nlcj0hMDthZS5lbnY9e307YWUuYXJndj1bXTthZS52ZXJzaW9uPVwiXCI7YWUudmVyc2lvbnM9e307ZnVuY3Rpb24gX3QoKXt9YWUub249X3Q7YWUuYWRkTGlzdGVuZXI9X3Q7YWUub25jZT1fdDthZS5vZmY9X3Q7YWUucmVtb3ZlTGlzdGVuZXI9X3Q7YWUucmVtb3ZlQWxsTGlzdGVuZXJzPV90O2FlLmVtaXQ9X3Q7YWUucHJlcGVuZExpc3RlbmVyPV90O2FlLnByZXBlbmRPbmNlTGlzdGVuZXI9X3Q7YWUubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybltdfTthZS5iaW5kaW5nPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTthZS5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07YWUuY2hkaXI9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTthZS51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0pO3ZhciB0dD1NKCh4SSxQZik9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTt2YXJ7U3ltYm9sOkdpLFN5bWJvbEFzeW5jSXRlcmF0b3I6Z2YsU3ltYm9sSXRlcmF0b3I6eWYsU3ltYm9sRm9yOmJmfT1jZSgpLHdmPUdpKFwia0Rlc3Ryb3llZFwiKSxfZj1HaShcImtJc0Vycm9yZWRcIiksQnM9R2koXCJrSXNSZWFkYWJsZVwiKSxtZj1HaShcImtJc0Rpc3R1cmJlZFwiKSxKeT1iZihcIm5vZGVqcy53ZWJzdHJlYW0uaXNDbG9zZWRQcm9taXNlXCIpLFh5PWJmKFwibm9kZWpzLndlYnN0cmVhbS5jb250cm9sbGVyRXJyb3JGdW5jdGlvblwiKTtmdW5jdGlvbiBRaSh0LGU9ITEpe3ZhciByO3JldHVybiEhKHQmJnR5cGVvZiB0LnBpcGU9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHQub249PVwiZnVuY3Rpb25cIiYmKCFlfHx0eXBlb2YgdC5wYXVzZT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgdC5yZXN1bWU9PVwiZnVuY3Rpb25cIikmJighdC5fd3JpdGFibGVTdGF0ZXx8KChyPXQuX3JlYWRhYmxlU3RhdGUpPT09bnVsbHx8cj09PXZvaWQgMD92b2lkIDA6ci5yZWFkYWJsZSkhPT0hMSkmJighdC5fd3JpdGFibGVTdGF0ZXx8dC5fcmVhZGFibGVTdGF0ZSkpfWZ1bmN0aW9uIFlpKHQpe3ZhciBlO3JldHVybiEhKHQmJnR5cGVvZiB0LndyaXRlPT1cImZ1bmN0aW9uXCImJnR5cGVvZiB0Lm9uPT1cImZ1bmN0aW9uXCImJighdC5fcmVhZGFibGVTdGF0ZXx8KChlPXQuX3dyaXRhYmxlU3RhdGUpPT09bnVsbHx8ZT09PXZvaWQgMD92b2lkIDA6ZS53cml0YWJsZSkhPT0hMSkpfWZ1bmN0aW9uIFp5KHQpe3JldHVybiEhKHQmJnR5cGVvZiB0LnBpcGU9PVwiZnVuY3Rpb25cIiYmdC5fcmVhZGFibGVTdGF0ZSYmdHlwZW9mIHQub249PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHQud3JpdGU9PVwiZnVuY3Rpb25cIil9ZnVuY3Rpb24gZXQodCl7cmV0dXJuIHQmJih0Ll9yZWFkYWJsZVN0YXRlfHx0Ll93cml0YWJsZVN0YXRlfHx0eXBlb2YgdC53cml0ZT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgdC5vbj09XCJmdW5jdGlvblwifHx0eXBlb2YgdC5waXBlPT1cImZ1bmN0aW9uXCImJnR5cGVvZiB0Lm9uPT1cImZ1bmN0aW9uXCIpfWZ1bmN0aW9uIHZmKHQpe3JldHVybiEhKHQmJiFldCh0KSYmdHlwZW9mIHQucGlwZVRocm91Z2g9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHQuZ2V0UmVhZGVyPT1cImZ1bmN0aW9uXCImJnR5cGVvZiB0LmNhbmNlbD09XCJmdW5jdGlvblwiKX1mdW5jdGlvbiBFZih0KXtyZXR1cm4hISh0JiYhZXQodCkmJnR5cGVvZiB0LmdldFdyaXRlcj09XCJmdW5jdGlvblwiJiZ0eXBlb2YgdC5hYm9ydD09XCJmdW5jdGlvblwiKX1mdW5jdGlvbiBTZih0KXtyZXR1cm4hISh0JiYhZXQodCkmJnR5cGVvZiB0LnJlYWRhYmxlPT1cIm9iamVjdFwiJiZ0eXBlb2YgdC53cml0YWJsZT09XCJvYmplY3RcIil9ZnVuY3Rpb24gZWIodCl7cmV0dXJuIHZmKHQpfHxFZih0KXx8U2YodCl9ZnVuY3Rpb24gdGIodCxlKXtyZXR1cm4gdD09bnVsbD8hMTplPT09ITA/dHlwZW9mIHRbZ2ZdPT1cImZ1bmN0aW9uXCI6ZT09PSExP3R5cGVvZiB0W3lmXT09XCJmdW5jdGlvblwiOnR5cGVvZiB0W2dmXT09XCJmdW5jdGlvblwifHx0eXBlb2YgdFt5Zl09PVwiZnVuY3Rpb25cIn1mdW5jdGlvbiBKaSh0KXtpZighZXQodCkpcmV0dXJuIG51bGw7bGV0IGU9dC5fd3JpdGFibGVTdGF0ZSxyPXQuX3JlYWRhYmxlU3RhdGUsaT1lfHxyO3JldHVybiEhKHQuZGVzdHJveWVkfHx0W3dmXXx8aSE9bnVsbCYmaS5kZXN0cm95ZWQpfWZ1bmN0aW9uIEFmKHQpe2lmKCFZaSh0KSlyZXR1cm4gbnVsbDtpZih0LndyaXRhYmxlRW5kZWQ9PT0hMClyZXR1cm4hMDtsZXQgZT10Ll93cml0YWJsZVN0YXRlO3JldHVybiBlIT1udWxsJiZlLmVycm9yZWQ/ITE6dHlwZW9mIGU/LmVuZGVkIT1cImJvb2xlYW5cIj9udWxsOmUuZW5kZWR9ZnVuY3Rpb24gcmIodCxlKXtpZighWWkodCkpcmV0dXJuIG51bGw7aWYodC53cml0YWJsZUZpbmlzaGVkPT09ITApcmV0dXJuITA7bGV0IHI9dC5fd3JpdGFibGVTdGF0ZTtyZXR1cm4gciE9bnVsbCYmci5lcnJvcmVkPyExOnR5cGVvZiByPy5maW5pc2hlZCE9XCJib29sZWFuXCI/bnVsbDohIShyLmZpbmlzaGVkfHxlPT09ITEmJnIuZW5kZWQ9PT0hMCYmci5sZW5ndGg9PT0wKX1mdW5jdGlvbiBpYih0KXtpZighUWkodCkpcmV0dXJuIG51bGw7aWYodC5yZWFkYWJsZUVuZGVkPT09ITApcmV0dXJuITA7bGV0IGU9dC5fcmVhZGFibGVTdGF0ZTtyZXR1cm4hZXx8ZS5lcnJvcmVkPyExOnR5cGVvZiBlPy5lbmRlZCE9XCJib29sZWFuXCI/bnVsbDplLmVuZGVkfWZ1bmN0aW9uIElmKHQsZSl7aWYoIVFpKHQpKXJldHVybiBudWxsO2xldCByPXQuX3JlYWRhYmxlU3RhdGU7cmV0dXJuIHIhPW51bGwmJnIuZXJyb3JlZD8hMTp0eXBlb2Ygcj8uZW5kRW1pdHRlZCE9XCJib29sZWFuXCI/bnVsbDohIShyLmVuZEVtaXR0ZWR8fGU9PT0hMSYmci5lbmRlZD09PSEwJiZyLmxlbmd0aD09PTApfWZ1bmN0aW9uIFRmKHQpe3JldHVybiB0JiZ0W0JzXSE9bnVsbD90W0JzXTp0eXBlb2YgdD8ucmVhZGFibGUhPVwiYm9vbGVhblwiP251bGw6SmkodCk/ITE6UWkodCkmJnQucmVhZGFibGUmJiFJZih0KX1mdW5jdGlvbiBSZih0KXtyZXR1cm4gdHlwZW9mIHQ/LndyaXRhYmxlIT1cImJvb2xlYW5cIj9udWxsOkppKHQpPyExOllpKHQpJiZ0LndyaXRhYmxlJiYhQWYodCl9ZnVuY3Rpb24gbmIodCxlKXtyZXR1cm4gZXQodCk/SmkodCk/ITA6IShlPy5yZWFkYWJsZSE9PSExJiZUZih0KXx8ZT8ud3JpdGFibGUhPT0hMSYmUmYodCkpOm51bGx9ZnVuY3Rpb24gc2IodCl7dmFyIGUscjtyZXR1cm4gZXQodCk/dC53cml0YWJsZUVycm9yZWQ/dC53cml0YWJsZUVycm9yZWQ6KGU9KHI9dC5fd3JpdGFibGVTdGF0ZSk9PT1udWxsfHxyPT09dm9pZCAwP3ZvaWQgMDpyLmVycm9yZWQpIT09bnVsbCYmZSE9PXZvaWQgMD9lOm51bGw6bnVsbH1mdW5jdGlvbiBvYih0KXt2YXIgZSxyO3JldHVybiBldCh0KT90LnJlYWRhYmxlRXJyb3JlZD90LnJlYWRhYmxlRXJyb3JlZDooZT0ocj10Ll9yZWFkYWJsZVN0YXRlKT09PW51bGx8fHI9PT12b2lkIDA/dm9pZCAwOnIuZXJyb3JlZCkhPT1udWxsJiZlIT09dm9pZCAwP2U6bnVsbDpudWxsfWZ1bmN0aW9uIGFiKHQpe2lmKCFldCh0KSlyZXR1cm4gbnVsbDtpZih0eXBlb2YgdC5jbG9zZWQ9PVwiYm9vbGVhblwiKXJldHVybiB0LmNsb3NlZDtsZXQgZT10Ll93cml0YWJsZVN0YXRlLHI9dC5fcmVhZGFibGVTdGF0ZTtyZXR1cm4gdHlwZW9mIGU/LmNsb3NlZD09XCJib29sZWFuXCJ8fHR5cGVvZiByPy5jbG9zZWQ9PVwiYm9vbGVhblwiP2U/LmNsb3NlZHx8cj8uY2xvc2VkOnR5cGVvZiB0Ll9jbG9zZWQ9PVwiYm9vbGVhblwiJiZDZih0KT90Ll9jbG9zZWQ6bnVsbH1mdW5jdGlvbiBDZih0KXtyZXR1cm4gdHlwZW9mIHQuX2Nsb3NlZD09XCJib29sZWFuXCImJnR5cGVvZiB0Ll9kZWZhdWx0S2VlcEFsaXZlPT1cImJvb2xlYW5cIiYmdHlwZW9mIHQuX3JlbW92ZWRDb25uZWN0aW9uPT1cImJvb2xlYW5cIiYmdHlwZW9mIHQuX3JlbW92ZWRDb250TGVuPT1cImJvb2xlYW5cIn1mdW5jdGlvbiBCZih0KXtyZXR1cm4gdHlwZW9mIHQuX3NlbnQxMDA9PVwiYm9vbGVhblwiJiZDZih0KX1mdW5jdGlvbiBsYih0KXt2YXIgZTtyZXR1cm4gdHlwZW9mIHQuX2NvbnN1bWluZz09XCJib29sZWFuXCImJnR5cGVvZiB0Ll9kdW1wZWQ9PVwiYm9vbGVhblwiJiYoKGU9dC5yZXEpPT09bnVsbHx8ZT09PXZvaWQgMD92b2lkIDA6ZS51cGdyYWRlT3JDb25uZWN0KT09PXZvaWQgMH1mdW5jdGlvbiB1Yih0KXtpZighZXQodCkpcmV0dXJuIG51bGw7bGV0IGU9dC5fd3JpdGFibGVTdGF0ZSxyPXQuX3JlYWRhYmxlU3RhdGUsaT1lfHxyO3JldHVybiFpJiZCZih0KXx8ISEoaSYmaS5hdXRvRGVzdHJveSYmaS5lbWl0Q2xvc2UmJmkuY2xvc2VkPT09ITEpfWZ1bmN0aW9uIGZiKHQpe3ZhciBlO3JldHVybiEhKHQmJigoZT10W21mXSkhPT1udWxsJiZlIT09dm9pZCAwP2U6dC5yZWFkYWJsZURpZFJlYWR8fHQucmVhZGFibGVBYm9ydGVkKSl9ZnVuY3Rpb24gY2IodCl7dmFyIGUscixpLG4sbyxzLGEsdSxjLGg7cmV0dXJuISEodCYmKChlPShyPShpPShuPShvPShzPXRbX2ZdKSE9PW51bGwmJnMhPT12b2lkIDA/czp0LnJlYWRhYmxlRXJyb3JlZCkhPT1udWxsJiZvIT09dm9pZCAwP286dC53cml0YWJsZUVycm9yZWQpIT09bnVsbCYmbiE9PXZvaWQgMD9uOihhPXQuX3JlYWRhYmxlU3RhdGUpPT09bnVsbHx8YT09PXZvaWQgMD92b2lkIDA6YS5lcnJvckVtaXR0ZWQpIT09bnVsbCYmaSE9PXZvaWQgMD9pOih1PXQuX3dyaXRhYmxlU3RhdGUpPT09bnVsbHx8dT09PXZvaWQgMD92b2lkIDA6dS5lcnJvckVtaXR0ZWQpIT09bnVsbCYmciE9PXZvaWQgMD9yOihjPXQuX3JlYWRhYmxlU3RhdGUpPT09bnVsbHx8Yz09PXZvaWQgMD92b2lkIDA6Yy5lcnJvcmVkKSE9PW51bGwmJmUhPT12b2lkIDA/ZTohKChoPXQuX3dyaXRhYmxlU3RhdGUpPT09bnVsbHx8aD09PXZvaWQgMCkmJmguZXJyb3JlZCkpfVBmLmV4cG9ydHM9e2tEZXN0cm95ZWQ6d2YsaXNEaXN0dXJiZWQ6ZmIsa0lzRGlzdHVyYmVkOm1mLGlzRXJyb3JlZDpjYixrSXNFcnJvcmVkOl9mLGlzUmVhZGFibGU6VGYsa0lzUmVhZGFibGU6QnMsa0lzQ2xvc2VkUHJvbWlzZTpKeSxrQ29udHJvbGxlckVycm9yRnVuY3Rpb246WHksaXNDbG9zZWQ6YWIsaXNEZXN0cm95ZWQ6SmksaXNEdXBsZXhOb2RlU3RyZWFtOlp5LGlzRmluaXNoZWQ6bmIsaXNJdGVyYWJsZTp0Yixpc1JlYWRhYmxlTm9kZVN0cmVhbTpRaSxpc1JlYWRhYmxlU3RyZWFtOnZmLGlzUmVhZGFibGVFbmRlZDppYixpc1JlYWRhYmxlRmluaXNoZWQ6SWYsaXNSZWFkYWJsZUVycm9yZWQ6b2IsaXNOb2RlU3RyZWFtOmV0LGlzV2ViU3RyZWFtOmViLGlzV3JpdGFibGU6UmYsaXNXcml0YWJsZU5vZGVTdHJlYW06WWksaXNXcml0YWJsZVN0cmVhbTpFZixpc1dyaXRhYmxlRW5kZWQ6QWYsaXNXcml0YWJsZUZpbmlzaGVkOnJiLGlzV3JpdGFibGVFcnJvcmVkOnNiLGlzU2VydmVyUmVxdWVzdDpsYixpc1NlcnZlclJlc3BvbnNlOkJmLHdpbGxFbWl0Q2xvc2U6dWIsaXNUcmFuc2Zvcm1TdHJlYW06U2Z9fSk7dmFyIG10PU0oKCRJLE1zKT0+e3YoKTttKCk7XygpO3ZhciBOdD1VdCgpLHtBYm9ydEVycm9yOkRmLGNvZGVzOmhifT1TZSgpLHtFUlJfSU5WQUxJRF9BUkdfVFlQRTpkYixFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTpPZn09aGIse2tFbXB0eU9iamVjdDpPcyxvbmNlOmtzfT1KZSgpLHt2YWxpZGF0ZUFib3J0U2lnbmFsOnBiLHZhbGlkYXRlRnVuY3Rpb246Z2IsdmFsaWRhdGVPYmplY3Q6eWIsdmFsaWRhdGVCb29sZWFuOmJifT11aSgpLHtQcm9taXNlOndiLFByb21pc2VQcm90b3R5cGVUaGVuOl9ifT1jZSgpLHtpc0Nsb3NlZDptYixpc1JlYWRhYmxlOmtmLGlzUmVhZGFibGVOb2RlU3RyZWFtOlBzLGlzUmVhZGFibGVTdHJlYW06dmIsaXNSZWFkYWJsZUZpbmlzaGVkOnhmLGlzUmVhZGFibGVFcnJvcmVkOk1mLGlzV3JpdGFibGU6TGYsaXNXcml0YWJsZU5vZGVTdHJlYW06VWYsaXNXcml0YWJsZVN0cmVhbTpFYixpc1dyaXRhYmxlRmluaXNoZWQ6TmYsaXNXcml0YWJsZUVycm9yZWQ6cWYsaXNOb2RlU3RyZWFtOlNiLHdpbGxFbWl0Q2xvc2U6QWIsa0lzQ2xvc2VkUHJvbWlzZTpJYn09dHQoKTtmdW5jdGlvbiBUYih0KXtyZXR1cm4gdC5zZXRIZWFkZXImJnR5cGVvZiB0LmFib3J0PT1cImZ1bmN0aW9uXCJ9dmFyIHhzPSgpPT57fTtmdW5jdGlvbiBqZih0LGUscil7dmFyIGksbjtpZihhcmd1bWVudHMubGVuZ3RoPT09Mj8ocj1lLGU9T3MpOmU9PW51bGw/ZT1Pczp5YihlLFwib3B0aW9uc1wiKSxnYihyLFwiY2FsbGJhY2tcIikscGIoZS5zaWduYWwsXCJvcHRpb25zLnNpZ25hbFwiKSxyPWtzKHIpLHZiKHQpfHxFYih0KSlyZXR1cm4gUmIodCxlLHIpO2lmKCFTYih0KSl0aHJvdyBuZXcgZGIoXCJzdHJlYW1cIixbXCJSZWFkYWJsZVN0cmVhbVwiLFwiV3JpdGFibGVTdHJlYW1cIixcIlN0cmVhbVwiXSx0KTtsZXQgbz0oaT1lLnJlYWRhYmxlKSE9PW51bGwmJmkhPT12b2lkIDA/aTpQcyh0KSxzPShuPWUud3JpdGFibGUpIT09bnVsbCYmbiE9PXZvaWQgMD9uOlVmKHQpLGE9dC5fd3JpdGFibGVTdGF0ZSx1PXQuX3JlYWRhYmxlU3RhdGUsYz0oKT0+e3Qud3JpdGFibGV8fGcoKX0saD1BYih0KSYmUHModCk9PT1vJiZVZih0KT09PXMsZD1OZih0LCExKSxnPSgpPT57ZD0hMCx0LmRlc3Ryb3llZCYmKGg9ITEpLCEoaCYmKCF0LnJlYWRhYmxlfHxvKSkmJighb3x8eSkmJnIuY2FsbCh0KX0seT14Zih0LCExKSx3PSgpPT57eT0hMCx0LmRlc3Ryb3llZCYmKGg9ITEpLCEoaCYmKCF0LndyaXRhYmxlfHxzKSkmJighc3x8ZCkmJnIuY2FsbCh0KX0sRT1OPT57ci5jYWxsKHQsTil9LFM9bWIodCksST0oKT0+e1M9ITA7bGV0IE49cWYodCl8fE1mKHQpO2lmKE4mJnR5cGVvZiBOIT1cImJvb2xlYW5cIilyZXR1cm4gci5jYWxsKHQsTik7aWYobyYmIXkmJlBzKHQsITApJiYheGYodCwhMSkpcmV0dXJuIHIuY2FsbCh0LG5ldyBPZik7aWYocyYmIWQmJiFOZih0LCExKSlyZXR1cm4gci5jYWxsKHQsbmV3IE9mKTtyLmNhbGwodCl9LEM9KCk9PntTPSEwO2xldCBOPXFmKHQpfHxNZih0KTtpZihOJiZ0eXBlb2YgTiE9XCJib29sZWFuXCIpcmV0dXJuIHIuY2FsbCh0LE4pO3IuY2FsbCh0KX0sUj0oKT0+e3QucmVxLm9uKFwiZmluaXNoXCIsZyl9O1RiKHQpPyh0Lm9uKFwiY29tcGxldGVcIixnKSxofHx0Lm9uKFwiYWJvcnRcIixJKSx0LnJlcT9SKCk6dC5vbihcInJlcXVlc3RcIixSKSk6cyYmIWEmJih0Lm9uKFwiZW5kXCIsYyksdC5vbihcImNsb3NlXCIsYykpLCFoJiZ0eXBlb2YgdC5hYm9ydGVkPT1cImJvb2xlYW5cIiYmdC5vbihcImFib3J0ZWRcIixJKSx0Lm9uKFwiZW5kXCIsdyksdC5vbihcImZpbmlzaFwiLGcpLGUuZXJyb3IhPT0hMSYmdC5vbihcImVycm9yXCIsRSksdC5vbihcImNsb3NlXCIsSSksUz9OdC5uZXh0VGljayhJKTphIT1udWxsJiZhLmVycm9yRW1pdHRlZHx8dSE9bnVsbCYmdS5lcnJvckVtaXR0ZWQ/aHx8TnQubmV4dFRpY2soQyk6KCFvJiYoIWh8fGtmKHQpKSYmKGR8fExmKHQpPT09ITEpfHwhcyYmKCFofHxMZih0KSkmJih5fHxrZih0KT09PSExKXx8dSYmdC5yZXEmJnQuYWJvcnRlZCkmJk50Lm5leHRUaWNrKEMpO2xldCBVPSgpPT57cj14cyx0LnJlbW92ZUxpc3RlbmVyKFwiYWJvcnRlZFwiLEkpLHQucmVtb3ZlTGlzdGVuZXIoXCJjb21wbGV0ZVwiLGcpLHQucmVtb3ZlTGlzdGVuZXIoXCJhYm9ydFwiLEkpLHQucmVtb3ZlTGlzdGVuZXIoXCJyZXF1ZXN0XCIsUiksdC5yZXEmJnQucmVxLnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsZyksdC5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLGMpLHQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGMpLHQucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIixnKSx0LnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsdyksdC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsRSksdC5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsSSl9O2lmKGUuc2lnbmFsJiYhUyl7bGV0IE49KCk9PntsZXQgVz1yO1UoKSxXLmNhbGwodCxuZXcgRGYodm9pZCAwLHtjYXVzZTplLnNpZ25hbC5yZWFzb259KSl9O2lmKGUuc2lnbmFsLmFib3J0ZWQpTnQubmV4dFRpY2soTik7ZWxzZXtsZXQgVz1yO3I9a3MoKC4uLkspPT57ZS5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsTiksVy5hcHBseSh0LEspfSksZS5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsTil9fXJldHVybiBVfWZ1bmN0aW9uIFJiKHQsZSxyKXtsZXQgaT0hMSxuPXhzO2lmKGUuc2lnbmFsKWlmKG49KCk9PntpPSEwLHIuY2FsbCh0LG5ldyBEZih2b2lkIDAse2NhdXNlOmUuc2lnbmFsLnJlYXNvbn0pKX0sZS5zaWduYWwuYWJvcnRlZClOdC5uZXh0VGljayhuKTtlbHNle2xldCBzPXI7cj1rcygoLi4uYSk9PntlLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIixuKSxzLmFwcGx5KHQsYSl9KSxlLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIixuKX1sZXQgbz0oLi4ucyk9PntpfHxOdC5uZXh0VGljaygoKT0+ci5hcHBseSh0LHMpKX07cmV0dXJuIF9iKHRbSWJdLnByb21pc2UsbyxvKSx4c31mdW5jdGlvbiBDYih0LGUpe3ZhciByO2xldCBpPSExO3JldHVybiBlPT09bnVsbCYmKGU9T3MpLChyPWUpIT09bnVsbCYmciE9PXZvaWQgMCYmci5jbGVhbnVwJiYoYmIoZS5jbGVhbnVwLFwiY2xlYW51cFwiKSxpPWUuY2xlYW51cCksbmV3IHdiKChuLG8pPT57bGV0IHM9amYodCxlLGE9PntpJiZzKCksYT9vKGEpOm4oKX0pfSl9TXMuZXhwb3J0cz1qZjtNcy5leHBvcnRzLmZpbmlzaGVkPUNifSk7dmFyIHRyPU0oKFpJLEdmKT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhciBydD1VdCgpLHthZ2dyZWdhdGVUd29FcnJvcnM6QmIsY29kZXM6e0VSUl9NVUxUSVBMRV9DQUxMQkFDSzpQYn0sQWJvcnRFcnJvcjpPYn09U2UoKSx7U3ltYm9sOiRmfT1jZSgpLHtrRGVzdHJveWVkOmtiLGlzRGVzdHJveWVkOnhiLGlzRmluaXNoZWQ6TWIsaXNTZXJ2ZXJSZXF1ZXN0OkxifT10dCgpLEhmPSRmKFwia0Rlc3Ryb3lcIiksTHM9JGYoXCJrQ29uc3RydWN0XCIpO2Z1bmN0aW9uIFZmKHQsZSxyKXt0JiYodC5zdGFjayxlJiYhZS5lcnJvcmVkJiYoZS5lcnJvcmVkPXQpLHImJiFyLmVycm9yZWQmJihyLmVycm9yZWQ9dCkpfWZ1bmN0aW9uIFViKHQsZSl7bGV0IHI9dGhpcy5fcmVhZGFibGVTdGF0ZSxpPXRoaXMuX3dyaXRhYmxlU3RhdGUsbj1pfHxyO3JldHVybiBpIT1udWxsJiZpLmRlc3Ryb3llZHx8ciE9bnVsbCYmci5kZXN0cm95ZWQ/KHR5cGVvZiBlPT1cImZ1bmN0aW9uXCImJmUoKSx0aGlzKTooVmYodCxpLHIpLGkmJihpLmRlc3Ryb3llZD0hMCksciYmKHIuZGVzdHJveWVkPSEwKSxuLmNvbnN0cnVjdGVkP0ZmKHRoaXMsdCxlKTp0aGlzLm9uY2UoSGYsZnVuY3Rpb24obyl7RmYodGhpcyxCYihvLHQpLGUpfSksdGhpcyl9ZnVuY3Rpb24gRmYodCxlLHIpe2xldCBpPSExO2Z1bmN0aW9uIG4obyl7aWYoaSlyZXR1cm47aT0hMDtsZXQgcz10Ll9yZWFkYWJsZVN0YXRlLGE9dC5fd3JpdGFibGVTdGF0ZTtWZihvLGEscyksYSYmKGEuY2xvc2VkPSEwKSxzJiYocy5jbG9zZWQ9ITApLHR5cGVvZiByPT1cImZ1bmN0aW9uXCImJnIobyksbz9ydC5uZXh0VGljayhOYix0LG8pOnJ0Lm5leHRUaWNrKHpmLHQpfXRyeXt0Ll9kZXN0cm95KGV8fG51bGwsbil9Y2F0Y2gobyl7bihvKX19ZnVuY3Rpb24gTmIodCxlKXtVcyh0LGUpLHpmKHQpfWZ1bmN0aW9uIHpmKHQpe2xldCBlPXQuX3JlYWRhYmxlU3RhdGUscj10Ll93cml0YWJsZVN0YXRlO3ImJihyLmNsb3NlRW1pdHRlZD0hMCksZSYmKGUuY2xvc2VFbWl0dGVkPSEwKSwociE9bnVsbCYmci5lbWl0Q2xvc2V8fGUhPW51bGwmJmUuZW1pdENsb3NlKSYmdC5lbWl0KFwiY2xvc2VcIil9ZnVuY3Rpb24gVXModCxlKXtsZXQgcj10Ll9yZWFkYWJsZVN0YXRlLGk9dC5fd3JpdGFibGVTdGF0ZTtpIT1udWxsJiZpLmVycm9yRW1pdHRlZHx8ciE9bnVsbCYmci5lcnJvckVtaXR0ZWR8fChpJiYoaS5lcnJvckVtaXR0ZWQ9ITApLHImJihyLmVycm9yRW1pdHRlZD0hMCksdC5lbWl0KFwiZXJyb3JcIixlKSl9ZnVuY3Rpb24gcWIoKXtsZXQgdD10aGlzLl9yZWFkYWJsZVN0YXRlLGU9dGhpcy5fd3JpdGFibGVTdGF0ZTt0JiYodC5jb25zdHJ1Y3RlZD0hMCx0LmNsb3NlZD0hMSx0LmNsb3NlRW1pdHRlZD0hMSx0LmRlc3Ryb3llZD0hMSx0LmVycm9yZWQ9bnVsbCx0LmVycm9yRW1pdHRlZD0hMSx0LnJlYWRpbmc9ITEsdC5lbmRlZD10LnJlYWRhYmxlPT09ITEsdC5lbmRFbWl0dGVkPXQucmVhZGFibGU9PT0hMSksZSYmKGUuY29uc3RydWN0ZWQ9ITAsZS5kZXN0cm95ZWQ9ITEsZS5jbG9zZWQ9ITEsZS5jbG9zZUVtaXR0ZWQ9ITEsZS5lcnJvcmVkPW51bGwsZS5lcnJvckVtaXR0ZWQ9ITEsZS5maW5hbENhbGxlZD0hMSxlLnByZWZpbmlzaGVkPSExLGUuZW5kZWQ9ZS53cml0YWJsZT09PSExLGUuZW5kaW5nPWUud3JpdGFibGU9PT0hMSxlLmZpbmlzaGVkPWUud3JpdGFibGU9PT0hMSl9ZnVuY3Rpb24gTnModCxlLHIpe2xldCBpPXQuX3JlYWRhYmxlU3RhdGUsbj10Ll93cml0YWJsZVN0YXRlO2lmKG4hPW51bGwmJm4uZGVzdHJveWVkfHxpIT1udWxsJiZpLmRlc3Ryb3llZClyZXR1cm4gdGhpcztpIT1udWxsJiZpLmF1dG9EZXN0cm95fHxuIT1udWxsJiZuLmF1dG9EZXN0cm95P3QuZGVzdHJveShlKTplJiYoZS5zdGFjayxuJiYhbi5lcnJvcmVkJiYobi5lcnJvcmVkPWUpLGkmJiFpLmVycm9yZWQmJihpLmVycm9yZWQ9ZSkscj9ydC5uZXh0VGljayhVcyx0LGUpOlVzKHQsZSkpfWZ1bmN0aW9uIERiKHQsZSl7aWYodHlwZW9mIHQuX2NvbnN0cnVjdCE9XCJmdW5jdGlvblwiKXJldHVybjtsZXQgcj10Ll9yZWFkYWJsZVN0YXRlLGk9dC5fd3JpdGFibGVTdGF0ZTtyJiYoci5jb25zdHJ1Y3RlZD0hMSksaSYmKGkuY29uc3RydWN0ZWQ9ITEpLHQub25jZShMcyxlKSwhKHQubGlzdGVuZXJDb3VudChMcyk+MSkmJnJ0Lm5leHRUaWNrKGpiLHQpfWZ1bmN0aW9uIGpiKHQpe2xldCBlPSExO2Z1bmN0aW9uIHIoaSl7aWYoZSl7TnModCxpPz9uZXcgUGIpO3JldHVybn1lPSEwO2xldCBuPXQuX3JlYWRhYmxlU3RhdGUsbz10Ll93cml0YWJsZVN0YXRlLHM9b3x8bjtuJiYobi5jb25zdHJ1Y3RlZD0hMCksbyYmKG8uY29uc3RydWN0ZWQ9ITApLHMuZGVzdHJveWVkP3QuZW1pdChIZixpKTppP05zKHQsaSwhMCk6cnQubmV4dFRpY2soRmIsdCl9dHJ5e3QuX2NvbnN0cnVjdChpPT57cnQubmV4dFRpY2socixpKX0pfWNhdGNoKGkpe3J0Lm5leHRUaWNrKHIsaSl9fWZ1bmN0aW9uIEZiKHQpe3QuZW1pdChMcyl9ZnVuY3Rpb24gV2YodCl7cmV0dXJuIHQ/LnNldEhlYWRlciYmdHlwZW9mIHQuYWJvcnQ9PVwiZnVuY3Rpb25cIn1mdW5jdGlvbiBLZih0KXt0LmVtaXQoXCJjbG9zZVwiKX1mdW5jdGlvbiBXYih0LGUpe3QuZW1pdChcImVycm9yXCIsZSkscnQubmV4dFRpY2soS2YsdCl9ZnVuY3Rpb24gJGIodCxlKXshdHx8eGIodCl8fCghZSYmIU1iKHQpJiYoZT1uZXcgT2IpLExiKHQpPyh0LnNvY2tldD1udWxsLHQuZGVzdHJveShlKSk6V2YodCk/dC5hYm9ydCgpOldmKHQucmVxKT90LnJlcS5hYm9ydCgpOnR5cGVvZiB0LmRlc3Ryb3k9PVwiZnVuY3Rpb25cIj90LmRlc3Ryb3koZSk6dHlwZW9mIHQuY2xvc2U9PVwiZnVuY3Rpb25cIj90LmNsb3NlKCk6ZT9ydC5uZXh0VGljayhXYix0LGUpOnJ0Lm5leHRUaWNrKEtmLHQpLHQuZGVzdHJveWVkfHwodFtrYl09ITApKX1HZi5leHBvcnRzPXtjb25zdHJ1Y3Q6RGIsZGVzdHJveWVyOiRiLGRlc3Ryb3k6VWIsdW5kZXN0cm95OnFiLGVycm9yT3JEZXN0cm95Ok5zfX0pO2Z1bmN0aW9uIFkoKXtZLmluaXQuY2FsbCh0aGlzKX1mdW5jdGlvbiBYaSh0KXtpZih0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIHQpfWZ1bmN0aW9uIG5jKHQpe3JldHVybiB0Ll9tYXhMaXN0ZW5lcnM9PT12b2lkIDA/WS5kZWZhdWx0TWF4TGlzdGVuZXJzOnQuX21heExpc3RlbmVyc31mdW5jdGlvbiBYZih0LGUscixpKXt2YXIgbixvLHMsYTtpZihYaShyKSwobz10Ll9ldmVudHMpPT09dm9pZCAwPyhvPXQuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpLHQuX2V2ZW50c0NvdW50PTApOihvLm5ld0xpc3RlbmVyIT09dm9pZCAwJiYodC5lbWl0KFwibmV3TGlzdGVuZXJcIixlLHIubGlzdGVuZXI/ci5saXN0ZW5lcjpyKSxvPXQuX2V2ZW50cykscz1vW2VdKSxzPT09dm9pZCAwKXM9b1tlXT1yLCsrdC5fZXZlbnRzQ291bnQ7ZWxzZSBpZih0eXBlb2Ygcz09XCJmdW5jdGlvblwiP3M9b1tlXT1pP1tyLHNdOltzLHJdOmk/cy51bnNoaWZ0KHIpOnMucHVzaChyKSwobj1uYyh0KSk+MCYmcy5sZW5ndGg+biYmIXMud2FybmVkKXtzLndhcm5lZD0hMDt2YXIgdT1uZXcgRXJyb3IoXCJQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuIFwiK3MubGVuZ3RoK1wiIFwiK1N0cmluZyhlKStcIiBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0XCIpO3UubmFtZT1cIk1heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZ1wiLHUuZW1pdHRlcj10LHUudHlwZT1lLHUuY291bnQ9cy5sZW5ndGgsYT11LGNvbnNvbGUmJmNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKGEpfXJldHVybiB0fWZ1bmN0aW9uIEhiKCl7aWYoIXRoaXMuZmlyZWQpcmV0dXJuIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSx0aGlzLndyYXBGbiksdGhpcy5maXJlZD0hMCxhcmd1bWVudHMubGVuZ3RoPT09MD90aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpOnRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsYXJndW1lbnRzKX1mdW5jdGlvbiBaZih0LGUscil7dmFyIGk9e2ZpcmVkOiExLHdyYXBGbjp2b2lkIDAsdGFyZ2V0OnQsdHlwZTplLGxpc3RlbmVyOnJ9LG49SGIuYmluZChpKTtyZXR1cm4gbi5saXN0ZW5lcj1yLGkud3JhcEZuPW4sbn1mdW5jdGlvbiBlYyh0LGUscil7dmFyIGk9dC5fZXZlbnRzO2lmKGk9PT12b2lkIDApcmV0dXJuW107dmFyIG49aVtlXTtyZXR1cm4gbj09PXZvaWQgMD9bXTp0eXBlb2Ygbj09XCJmdW5jdGlvblwiP3I/W24ubGlzdGVuZXJ8fG5dOltuXTpyP2Z1bmN0aW9uKG8pe2Zvcih2YXIgcz1uZXcgQXJyYXkoby5sZW5ndGgpLGE9MDthPHMubGVuZ3RoOysrYSlzW2FdPW9bYV0ubGlzdGVuZXJ8fG9bYV07cmV0dXJuIHN9KG4pOnNjKG4sbi5sZW5ndGgpfWZ1bmN0aW9uIHRjKHQpe3ZhciBlPXRoaXMuX2V2ZW50cztpZihlIT09dm9pZCAwKXt2YXIgcj1lW3RdO2lmKHR5cGVvZiByPT1cImZ1bmN0aW9uXCIpcmV0dXJuIDE7aWYociE9PXZvaWQgMClyZXR1cm4gci5sZW5ndGh9cmV0dXJuIDB9ZnVuY3Rpb24gc2ModCxlKXtmb3IodmFyIHI9bmV3IEFycmF5KGUpLGk9MDtpPGU7KytpKXJbaV09dFtpXTtyZXR1cm4gcn12YXIgcmMsaWMsTHIsUWYsWWYsSmYsQmUscXM9YmUoKCk9Pnt2KCk7bSgpO18oKTtMcj10eXBlb2YgUmVmbGVjdD09XCJvYmplY3RcIj9SZWZsZWN0Om51bGwsUWY9THImJnR5cGVvZiBMci5hcHBseT09XCJmdW5jdGlvblwiP0xyLmFwcGx5OmZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodCxlLHIpfTtpYz1MciYmdHlwZW9mIExyLm93bktleXM9PVwiZnVuY3Rpb25cIj9Mci5vd25LZXlzOk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM/ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpKX06ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpfTtZZj1OdW1iZXIuaXNOYU58fGZ1bmN0aW9uKHQpe3JldHVybiB0IT10fTtyYz1ZLFkuRXZlbnRFbWl0dGVyPVksWS5wcm90b3R5cGUuX2V2ZW50cz12b2lkIDAsWS5wcm90b3R5cGUuX2V2ZW50c0NvdW50PTAsWS5wcm90b3R5cGUuX21heExpc3RlbmVycz12b2lkIDA7SmY9MTA7T2JqZWN0LmRlZmluZVByb3BlcnR5KFksXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEpmfSxzZXQ6ZnVuY3Rpb24odCl7aWYodHlwZW9mIHQhPVwibnVtYmVyXCJ8fHQ8MHx8WWYodCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnK3QrXCIuXCIpO0pmPXR9fSksWS5pbml0PWZ1bmN0aW9uKCl7dGhpcy5fZXZlbnRzIT09dm9pZCAwJiZ0aGlzLl9ldmVudHMhPT1PYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50c3x8KHRoaXMuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX2V2ZW50c0NvdW50PTApLHRoaXMuX21heExpc3RlbmVycz10aGlzLl9tYXhMaXN0ZW5lcnN8fHZvaWQgMH0sWS5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uKHQpe2lmKHR5cGVvZiB0IT1cIm51bWJlclwifHx0PDB8fFlmKHQpKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyt0K1wiLlwiKTtyZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzPXQsdGhpc30sWS5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIG5jKHRoaXMpfSxZLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyllLnB1c2goYXJndW1lbnRzW3JdKTt2YXIgaT10PT09XCJlcnJvclwiLG49dGhpcy5fZXZlbnRzO2lmKG4hPT12b2lkIDApaT1pJiZuLmVycm9yPT09dm9pZCAwO2Vsc2UgaWYoIWkpcmV0dXJuITE7aWYoaSl7dmFyIG87aWYoZS5sZW5ndGg+MCYmKG89ZVswXSksbyBpbnN0YW5jZW9mIEVycm9yKXRocm93IG87dmFyIHM9bmV3IEVycm9yKFwiVW5oYW5kbGVkIGVycm9yLlwiKyhvP1wiIChcIitvLm1lc3NhZ2UrXCIpXCI6XCJcIikpO3Rocm93IHMuY29udGV4dD1vLHN9dmFyIGE9blt0XTtpZihhPT09dm9pZCAwKXJldHVybiExO2lmKHR5cGVvZiBhPT1cImZ1bmN0aW9uXCIpUWYoYSx0aGlzLGUpO2Vsc2V7dmFyIHU9YS5sZW5ndGgsYz1zYyhhLHUpO2ZvcihyPTA7cjx1OysrcilRZihjW3JdLHRoaXMsZSl9cmV0dXJuITB9LFkucHJvdG90eXBlLmFkZExpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFhmKHRoaXMsdCxlLCExKX0sWS5wcm90b3R5cGUub249WS5wcm90b3R5cGUuYWRkTGlzdGVuZXIsWS5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFhmKHRoaXMsdCxlLCEwKX0sWS5wcm90b3R5cGUub25jZT1mdW5jdGlvbih0LGUpe3JldHVybiBYaShlKSx0aGlzLm9uKHQsWmYodGhpcyx0LGUpKSx0aGlzfSxZLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFhpKGUpLHRoaXMucHJlcGVuZExpc3RlbmVyKHQsWmYodGhpcyx0LGUpKSx0aGlzfSxZLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe3ZhciByLGksbixvLHM7aWYoWGkoZSksKGk9dGhpcy5fZXZlbnRzKT09PXZvaWQgMClyZXR1cm4gdGhpcztpZigocj1pW3RdKT09PXZvaWQgMClyZXR1cm4gdGhpcztpZihyPT09ZXx8ci5saXN0ZW5lcj09PWUpLS10aGlzLl9ldmVudHNDb3VudD09MD90aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKTooZGVsZXRlIGlbdF0saS5yZW1vdmVMaXN0ZW5lciYmdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIix0LHIubGlzdGVuZXJ8fGUpKTtlbHNlIGlmKHR5cGVvZiByIT1cImZ1bmN0aW9uXCIpe2ZvcihuPS0xLG89ci5sZW5ndGgtMTtvPj0wO28tLSlpZihyW29dPT09ZXx8cltvXS5saXN0ZW5lcj09PWUpe3M9cltvXS5saXN0ZW5lcixuPW87YnJlYWt9aWYobjwwKXJldHVybiB0aGlzO249PT0wP3Iuc2hpZnQoKTpmdW5jdGlvbihhLHUpe2Zvcig7dSsxPGEubGVuZ3RoO3UrKylhW3VdPWFbdSsxXTthLnBvcCgpfShyLG4pLHIubGVuZ3RoPT09MSYmKGlbdF09clswXSksaS5yZW1vdmVMaXN0ZW5lciE9PXZvaWQgMCYmdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIix0LHN8fGUpfXJldHVybiB0aGlzfSxZLnByb3RvdHlwZS5vZmY9WS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIsWS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3ZhciBlLHIsaTtpZigocj10aGlzLl9ldmVudHMpPT09dm9pZCAwKXJldHVybiB0aGlzO2lmKHIucmVtb3ZlTGlzdGVuZXI9PT12b2lkIDApcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg9PT0wPyh0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wKTpyW3RdIT09dm9pZCAwJiYoLS10aGlzLl9ldmVudHNDb3VudD09MD90aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKTpkZWxldGUgclt0XSksdGhpcztpZihhcmd1bWVudHMubGVuZ3RoPT09MCl7dmFyIG4sbz1PYmplY3Qua2V5cyhyKTtmb3IoaT0wO2k8by5sZW5ndGg7KytpKShuPW9baV0pIT09XCJyZW1vdmVMaXN0ZW5lclwiJiZ0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhuKTtyZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJyZW1vdmVMaXN0ZW5lclwiKSx0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wLHRoaXN9aWYodHlwZW9mKGU9clt0XSk9PVwiZnVuY3Rpb25cIil0aGlzLnJlbW92ZUxpc3RlbmVyKHQsZSk7ZWxzZSBpZihlIT09dm9pZCAwKWZvcihpPWUubGVuZ3RoLTE7aT49MDtpLS0pdGhpcy5yZW1vdmVMaXN0ZW5lcih0LGVbaV0pO3JldHVybiB0aGlzfSxZLnByb3RvdHlwZS5saXN0ZW5lcnM9ZnVuY3Rpb24odCl7cmV0dXJuIGVjKHRoaXMsdCwhMCl9LFkucHJvdG90eXBlLnJhd0xpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm4gZWModGhpcyx0LCExKX0sWS5saXN0ZW5lckNvdW50PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHR5cGVvZiB0Lmxpc3RlbmVyQ291bnQ9PVwiZnVuY3Rpb25cIj90Lmxpc3RlbmVyQ291bnQoZSk6dGMuY2FsbCh0LGUpfSxZLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PXRjLFkucHJvdG90eXBlLmV2ZW50TmFtZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQ+MD9pYyh0aGlzLl9ldmVudHMpOltdfTtCZT1yYztCZS5FdmVudEVtaXR0ZXI7QmUuZGVmYXVsdE1heExpc3RlbmVycztCZS5pbml0O0JlLmxpc3RlbmVyQ291bnQ7QmUuRXZlbnRFbWl0dGVyO0JlLmRlZmF1bHRNYXhMaXN0ZW5lcnM7QmUuaW5pdDtCZS5saXN0ZW5lckNvdW50fSk7dmFyIHJyPXt9O1F0KHJyLHtFdmVudEVtaXR0ZXI6KCk9PlZiLGRlZmF1bHQ6KCk9PkJlLGRlZmF1bHRNYXhMaXN0ZW5lcnM6KCk9PnpiLGluaXQ6KCk9PktiLGxpc3RlbmVyQ291bnQ6KCk9PkdiLG9uOigpPT5RYixvbmNlOigpPT5ZYn0pO3ZhciBWYix6YixLYixHYixRYixZYixpcj1iZSgoKT0+e3YoKTttKCk7XygpO3FzKCk7cXMoKTtCZS5vbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBQcm9taXNlKChyLGkpPT57ZnVuY3Rpb24gbiguLi5zKXtvIT09dm9pZCAwJiZ0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIixvKSxyKHMpfWxldCBvO2UhPT1cImVycm9yXCImJihvPXM9Pnt0LnJlbW92ZUxpc3RlbmVyKG5hbWUsbiksaShzKX0sdC5vbmNlKFwiZXJyb3JcIixvKSksdC5vbmNlKGUsbil9KX07QmUub249ZnVuY3Rpb24odCxlKXtsZXQgcj1bXSxpPVtdLG49bnVsbCxvPSExLHM9e2FzeW5jIG5leHQoKXtsZXQgYz1yLnNoaWZ0KCk7aWYoYylyZXR1cm4gY3JlYXRlSXRlclJlc3VsdChjLCExKTtpZihuKXtsZXQgaD1Qcm9taXNlLnJlamVjdChuKTtyZXR1cm4gbj1udWxsLGh9cmV0dXJuIG8/Y3JlYXRlSXRlclJlc3VsdCh2b2lkIDAsITApOm5ldyBQcm9taXNlKChoLGQpPT5pLnB1c2goe3Jlc29sdmU6aCxyZWplY3Q6ZH0pKX0sYXN5bmMgcmV0dXJuKCl7dC5yZW1vdmVMaXN0ZW5lcihlLGEpLHQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLHUpLG89ITA7Zm9yKGxldCBjIG9mIGkpYy5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodm9pZCAwLCEwKSk7cmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHQodm9pZCAwLCEwKX0sdGhyb3coYyl7bj1jLHQucmVtb3ZlTGlzdGVuZXIoZSxhKSx0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIix1KX0sW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpe3JldHVybiB0aGlzfX07cmV0dXJuIHQub24oZSxhKSx0Lm9uKFwiZXJyb3JcIix1KSxzO2Z1bmN0aW9uIGEoLi4uYyl7bGV0IGg9aS5zaGlmdCgpO2g/aC5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoYywhMSkpOnIucHVzaChjKX1mdW5jdGlvbiB1KGMpe289ITA7bGV0IGg9aS5zaGlmdCgpO2g/aC5yZWplY3QoYyk6bj1jLHMucmV0dXJuKCl9fTsoe0V2ZW50RW1pdHRlcjpWYixkZWZhdWx0TWF4TGlzdGVuZXJzOnpiLGluaXQ6S2IsbGlzdGVuZXJDb3VudDpHYixvbjpRYixvbmNlOllifT1CZSl9KTt2YXIgdG49TSgoUFQsYWMpPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7dmFye0FycmF5SXNBcnJheTpKYixPYmplY3RTZXRQcm90b3R5cGVPZjpvY309Y2UoKSx7RXZlbnRFbWl0dGVyOlppfT0oaXIoKSxaKHJyKSk7ZnVuY3Rpb24gZW4odCl7WmkuY2FsbCh0aGlzLHQpfW9jKGVuLnByb3RvdHlwZSxaaS5wcm90b3R5cGUpO29jKGVuLFppKTtlbi5wcm90b3R5cGUucGlwZT1mdW5jdGlvbih0LGUpe2xldCByPXRoaXM7ZnVuY3Rpb24gaShoKXt0LndyaXRhYmxlJiZ0LndyaXRlKGgpPT09ITEmJnIucGF1c2UmJnIucGF1c2UoKX1yLm9uKFwiZGF0YVwiLGkpO2Z1bmN0aW9uIG4oKXtyLnJlYWRhYmxlJiZyLnJlc3VtZSYmci5yZXN1bWUoKX10Lm9uKFwiZHJhaW5cIixuKSwhdC5faXNTdGRpbyYmKCFlfHxlLmVuZCE9PSExKSYmKHIub24oXCJlbmRcIixzKSxyLm9uKFwiY2xvc2VcIixhKSk7bGV0IG89ITE7ZnVuY3Rpb24gcygpe298fChvPSEwLHQuZW5kKCkpfWZ1bmN0aW9uIGEoKXtvfHwobz0hMCx0eXBlb2YgdC5kZXN0cm95PT1cImZ1bmN0aW9uXCImJnQuZGVzdHJveSgpKX1mdW5jdGlvbiB1KGgpe2MoKSxaaS5saXN0ZW5lckNvdW50KHRoaXMsXCJlcnJvclwiKT09PTAmJnRoaXMuZW1pdChcImVycm9yXCIsaCl9RHMocixcImVycm9yXCIsdSksRHModCxcImVycm9yXCIsdSk7ZnVuY3Rpb24gYygpe3IucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsaSksdC5yZW1vdmVMaXN0ZW5lcihcImRyYWluXCIsbiksci5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLHMpLHIucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGEpLHIucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLHUpLHQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLHUpLHIucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixjKSxyLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixjKSx0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixjKX1yZXR1cm4gci5vbihcImVuZFwiLGMpLHIub24oXCJjbG9zZVwiLGMpLHQub24oXCJjbG9zZVwiLGMpLHQuZW1pdChcInBpcGVcIixyKSx0fTtmdW5jdGlvbiBEcyh0LGUscil7aWYodHlwZW9mIHQucHJlcGVuZExpc3RlbmVyPT1cImZ1bmN0aW9uXCIpcmV0dXJuIHQucHJlcGVuZExpc3RlbmVyKGUscik7IXQuX2V2ZW50c3x8IXQuX2V2ZW50c1tlXT90Lm9uKGUscik6SmIodC5fZXZlbnRzW2VdKT90Ll9ldmVudHNbZV0udW5zaGlmdChyKTp0Ll9ldmVudHNbZV09W3IsdC5fZXZlbnRzW2VdXX1hYy5leHBvcnRzPXtTdHJlYW06ZW4scHJlcGVuZExpc3RlbmVyOkRzfX0pO3ZhciBmaT1NKChqVCxybik9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTt2YXJ7QWJvcnRFcnJvcjpsYyxjb2RlczpYYn09U2UoKSx7aXNOb2RlU3RyZWFtOnVjLGlzV2ViU3RyZWFtOlpiLGtDb250cm9sbGVyRXJyb3JGdW5jdGlvbjpld309dHQoKSx0dz1tdCgpLHtFUlJfSU5WQUxJRF9BUkdfVFlQRTpmY309WGIscnc9KHQsZSk9PntpZih0eXBlb2YgdCE9XCJvYmplY3RcInx8IShcImFib3J0ZWRcImluIHQpKXRocm93IG5ldyBmYyhlLFwiQWJvcnRTaWduYWxcIix0KX07cm4uZXhwb3J0cy5hZGRBYm9ydFNpZ25hbD1mdW5jdGlvbihlLHIpe2lmKHJ3KGUsXCJzaWduYWxcIiksIXVjKHIpJiYhWmIocikpdGhyb3cgbmV3IGZjKFwic3RyZWFtXCIsW1wiUmVhZGFibGVTdHJlYW1cIixcIldyaXRhYmxlU3RyZWFtXCIsXCJTdHJlYW1cIl0scik7cmV0dXJuIHJuLmV4cG9ydHMuYWRkQWJvcnRTaWduYWxOb1ZhbGlkYXRlKGUscil9O3JuLmV4cG9ydHMuYWRkQWJvcnRTaWduYWxOb1ZhbGlkYXRlPWZ1bmN0aW9uKHQsZSl7aWYodHlwZW9mIHQhPVwib2JqZWN0XCJ8fCEoXCJhYm9ydGVkXCJpbiB0KSlyZXR1cm4gZTtsZXQgcj11YyhlKT8oKT0+e2UuZGVzdHJveShuZXcgbGModm9pZCAwLHtjYXVzZTp0LnJlYXNvbn0pKX06KCk9PntlW2V3XShuZXcgbGModm9pZCAwLHtjYXVzZTp0LnJlYXNvbn0pKX07cmV0dXJuIHQuYWJvcnRlZD9yKCk6KHQuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsciksdHcoZSwoKT0+dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIixyKSkpLGV9fSk7dmFyIGRjPU0oKEpULGhjKT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhcntTdHJpbmdQcm90b3R5cGVTbGljZTpjYyxTeW1ib2xJdGVyYXRvcjppdyxUeXBlZEFycmF5UHJvdG90eXBlU2V0Om5uLFVpbnQ4QXJyYXk6bnd9PWNlKCkse0J1ZmZlcjpqc309KHdlKCksWih2ZSkpLHtpbnNwZWN0OnN3fT1KZSgpO2hjLmV4cG9ydHM9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmhlYWQ9bnVsbCx0aGlzLnRhaWw9bnVsbCx0aGlzLmxlbmd0aD0wfXB1c2goZSl7bGV0IHI9e2RhdGE6ZSxuZXh0Om51bGx9O3RoaXMubGVuZ3RoPjA/dGhpcy50YWlsLm5leHQ9cjp0aGlzLmhlYWQ9cix0aGlzLnRhaWw9ciwrK3RoaXMubGVuZ3RofXVuc2hpZnQoZSl7bGV0IHI9e2RhdGE6ZSxuZXh0OnRoaXMuaGVhZH07dGhpcy5sZW5ndGg9PT0wJiYodGhpcy50YWlsPXIpLHRoaXMuaGVhZD1yLCsrdGhpcy5sZW5ndGh9c2hpZnQoKXtpZih0aGlzLmxlbmd0aD09PTApcmV0dXJuO2xldCBlPXRoaXMuaGVhZC5kYXRhO3JldHVybiB0aGlzLmxlbmd0aD09PTE/dGhpcy5oZWFkPXRoaXMudGFpbD1udWxsOnRoaXMuaGVhZD10aGlzLmhlYWQubmV4dCwtLXRoaXMubGVuZ3RoLGV9Y2xlYXIoKXt0aGlzLmhlYWQ9dGhpcy50YWlsPW51bGwsdGhpcy5sZW5ndGg9MH1qb2luKGUpe2lmKHRoaXMubGVuZ3RoPT09MClyZXR1cm5cIlwiO2xldCByPXRoaXMuaGVhZCxpPVwiXCIrci5kYXRhO2Zvcig7KHI9ci5uZXh0KSE9PW51bGw7KWkrPWUrci5kYXRhO3JldHVybiBpfWNvbmNhdChlKXtpZih0aGlzLmxlbmd0aD09PTApcmV0dXJuIGpzLmFsbG9jKDApO2xldCByPWpzLmFsbG9jVW5zYWZlKGU+Pj4wKSxpPXRoaXMuaGVhZCxuPTA7Zm9yKDtpOylubihyLGkuZGF0YSxuKSxuKz1pLmRhdGEubGVuZ3RoLGk9aS5uZXh0O3JldHVybiByfWNvbnN1bWUoZSxyKXtsZXQgaT10aGlzLmhlYWQuZGF0YTtpZihlPGkubGVuZ3RoKXtsZXQgbj1pLnNsaWNlKDAsZSk7cmV0dXJuIHRoaXMuaGVhZC5kYXRhPWkuc2xpY2UoZSksbn1yZXR1cm4gZT09PWkubGVuZ3RoP3RoaXMuc2hpZnQoKTpyP3RoaXMuX2dldFN0cmluZyhlKTp0aGlzLl9nZXRCdWZmZXIoZSl9Zmlyc3QoKXtyZXR1cm4gdGhpcy5oZWFkLmRhdGF9Kltpd10oKXtmb3IobGV0IGU9dGhpcy5oZWFkO2U7ZT1lLm5leHQpeWllbGQgZS5kYXRhfV9nZXRTdHJpbmcoZSl7bGV0IHI9XCJcIixpPXRoaXMuaGVhZCxuPTA7ZG97bGV0IG89aS5kYXRhO2lmKGU+by5sZW5ndGgpcis9byxlLT1vLmxlbmd0aDtlbHNle2U9PT1vLmxlbmd0aD8ocis9bywrK24saS5uZXh0P3RoaXMuaGVhZD1pLm5leHQ6dGhpcy5oZWFkPXRoaXMudGFpbD1udWxsKToocis9Y2MobywwLGUpLHRoaXMuaGVhZD1pLGkuZGF0YT1jYyhvLGUpKTticmVha30rK259d2hpbGUoKGk9aS5uZXh0KSE9PW51bGwpO3JldHVybiB0aGlzLmxlbmd0aC09bixyfV9nZXRCdWZmZXIoZSl7bGV0IHI9anMuYWxsb2NVbnNhZmUoZSksaT1lLG49dGhpcy5oZWFkLG89MDtkb3tsZXQgcz1uLmRhdGE7aWYoZT5zLmxlbmd0aClubihyLHMsaS1lKSxlLT1zLmxlbmd0aDtlbHNle2U9PT1zLmxlbmd0aD8obm4ocixzLGktZSksKytvLG4ubmV4dD90aGlzLmhlYWQ9bi5uZXh0OnRoaXMuaGVhZD10aGlzLnRhaWw9bnVsbCk6KG5uKHIsbmV3IG53KHMuYnVmZmVyLHMuYnl0ZU9mZnNldCxlKSxpLWUpLHRoaXMuaGVhZD1uLG4uZGF0YT1zLnNsaWNlKGUpKTticmVha30rK299d2hpbGUoKG49bi5uZXh0KSE9PW51bGwpO3JldHVybiB0aGlzLmxlbmd0aC09byxyfVtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKGUscil7cmV0dXJuIHN3KHRoaXMsey4uLnIsZGVwdGg6MCxjdXN0b21JbnNwZWN0OiExfSl9fX0pO3ZhciBzbj1NKChhMixnYyk9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTt2YXJ7TWF0aEZsb29yOm93LE51bWJlcklzSW50ZWdlcjphd309Y2UoKSx7RVJSX0lOVkFMSURfQVJHX1ZBTFVFOmx3fT1TZSgpLmNvZGVzO2Z1bmN0aW9uIHV3KHQsZSxyKXtyZXR1cm4gdC5oaWdoV2F0ZXJNYXJrIT1udWxsP3QuaGlnaFdhdGVyTWFyazplP3Rbcl06bnVsbH1mdW5jdGlvbiBwYyh0KXtyZXR1cm4gdD8xNjoxNioxMDI0fWZ1bmN0aW9uIGZ3KHQsZSxyLGkpe2xldCBuPXV3KGUsaSxyKTtpZihuIT1udWxsKXtpZighYXcobil8fG48MCl7bGV0IG89aT9gb3B0aW9ucy4ke3J9YDpcIm9wdGlvbnMuaGlnaFdhdGVyTWFya1wiO3Rocm93IG5ldyBsdyhvLG4pfXJldHVybiBvdyhuKX1yZXR1cm4gcGModC5vYmplY3RNb2RlKX1nYy5leHBvcnRzPXtnZXRIaWdoV2F0ZXJNYXJrOmZ3LGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrOnBjfX0pO2Z1bmN0aW9uIHdjKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGUlND4wKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIik7dmFyIHI9dC5pbmRleE9mKFwiPVwiKTtyZXR1cm4gcj09PS0xJiYocj1lKSxbcixyPT09ZT8wOjQtciU0XX1mdW5jdGlvbiBjdyh0LGUscil7Zm9yKHZhciBpLG4sbz1bXSxzPWU7czxyO3MrPTMpaT0odFtzXTw8MTYmMTY3MTE2ODApKyh0W3MrMV08PDgmNjUyODApKygyNTUmdFtzKzJdKSxvLnB1c2goJGVbKG49aSk+PjE4JjYzXSskZVtuPj4xMiY2M10rJGVbbj4+NiY2M10rJGVbNjMmbl0pO3JldHVybiBvLmpvaW4oXCJcIil9ZnVuY3Rpb24gdnQodCl7aWYodD4yMTQ3NDgzNjQ3KXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK3QrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpO3ZhciBlPW5ldyBVaW50OEFycmF5KHQpO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSx4LnByb3RvdHlwZSksZX1mdW5jdGlvbiB4KHQsZSxyKXtpZih0eXBlb2YgdD09XCJudW1iZXJcIil7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTtyZXR1cm4gSHModCl9cmV0dXJuIENjKHQsZSxyKX1mdW5jdGlvbiBDYyh0LGUscil7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpcmV0dXJuIGZ1bmN0aW9uKG8scyl7aWYodHlwZW9mIHM9PVwic3RyaW5nXCImJnMhPT1cIlwifHwocz1cInV0ZjhcIiksIXguaXNFbmNvZGluZyhzKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcyk7dmFyIGE9MHxQYyhvLHMpLHU9dnQoYSksYz11LndyaXRlKG8scyk7cmV0dXJuIGMhPT1hJiYodT11LnNsaWNlKDAsYykpLHV9KHQsZSk7aWYoQXJyYXlCdWZmZXIuaXNWaWV3KHQpKXJldHVybiBGcyh0KTtpZih0PT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgdCk7aWYoRXQodCxBcnJheUJ1ZmZlcil8fHQmJkV0KHQuYnVmZmVyLEFycmF5QnVmZmVyKXx8dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPFwidVwiJiYoRXQodCxTaGFyZWRBcnJheUJ1ZmZlcil8fHQmJkV0KHQuYnVmZmVyLFNoYXJlZEFycmF5QnVmZmVyKSkpcmV0dXJuIG1jKHQsZSxyKTtpZih0eXBlb2YgdD09XCJudW1iZXJcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpO3ZhciBpPXQudmFsdWVPZiYmdC52YWx1ZU9mKCk7aWYoaSE9bnVsbCYmaSE9PXQpcmV0dXJuIHguZnJvbShpLGUscik7dmFyIG49ZnVuY3Rpb24obyl7aWYoeC5pc0J1ZmZlcihvKSl7dmFyIHM9MHxLcyhvLmxlbmd0aCksYT12dChzKTtyZXR1cm4gYS5sZW5ndGg9PT0wfHxvLmNvcHkoYSwwLDAscyksYX1pZihvLmxlbmd0aCE9PXZvaWQgMClyZXR1cm4gdHlwZW9mIG8ubGVuZ3RoIT1cIm51bWJlclwifHxHcyhvLmxlbmd0aCk/dnQoMCk6RnMobyk7aWYoby50eXBlPT09XCJCdWZmZXJcIiYmQXJyYXkuaXNBcnJheShvLmRhdGEpKXJldHVybiBGcyhvLmRhdGEpfSh0KTtpZihuKXJldHVybiBuO2lmKHR5cGVvZiBTeW1ib2w8XCJ1XCImJlN5bWJvbC50b1ByaW1pdGl2ZSE9bnVsbCYmdHlwZW9mIHRbU3ltYm9sLnRvUHJpbWl0aXZlXT09XCJmdW5jdGlvblwiKXJldHVybiB4LmZyb20odFtTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLGUscik7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiB0KX1mdW5jdGlvbiBCYyh0KXtpZih0eXBlb2YgdCE9XCJudW1iZXJcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyk7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK3QrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfWZ1bmN0aW9uIEhzKHQpe3JldHVybiBCYyh0KSx2dCh0PDA/MDowfEtzKHQpKX1mdW5jdGlvbiBGcyh0KXtmb3IodmFyIGU9dC5sZW5ndGg8MD8wOjB8S3ModC5sZW5ndGgpLHI9dnQoZSksaT0wO2k8ZTtpKz0xKXJbaV09MjU1JnRbaV07cmV0dXJuIHJ9ZnVuY3Rpb24gbWModCxlLHIpe2lmKGU8MHx8dC5ieXRlTGVuZ3RoPGUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7aWYodC5ieXRlTGVuZ3RoPGUrKHJ8fDApKXRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpO3ZhciBpO3JldHVybiBpPWU9PT12b2lkIDAmJnI9PT12b2lkIDA/bmV3IFVpbnQ4QXJyYXkodCk6cj09PXZvaWQgMD9uZXcgVWludDhBcnJheSh0LGUpOm5ldyBVaW50OEFycmF5KHQsZSxyKSxPYmplY3Quc2V0UHJvdG90eXBlT2YoaSx4LnByb3RvdHlwZSksaX1mdW5jdGlvbiBLcyh0KXtpZih0Pj0yMTQ3NDgzNjQ3KXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweFwiKzIxNDc0ODM2NDcgLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKTtyZXR1cm4gMHx0fWZ1bmN0aW9uIFBjKHQsZSl7aWYoeC5pc0J1ZmZlcih0KSlyZXR1cm4gdC5sZW5ndGg7aWYoQXJyYXlCdWZmZXIuaXNWaWV3KHQpfHxFdCh0LEFycmF5QnVmZmVyKSlyZXR1cm4gdC5ieXRlTGVuZ3RoO2lmKHR5cGVvZiB0IT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIHQpO3ZhciByPXQubGVuZ3RoLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl09PT0hMDtpZighaSYmcj09PTApcmV0dXJuIDA7Zm9yKHZhciBuPSExOzspc3dpdGNoKGUpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHI7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIFZzKHQpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gMipyO2Nhc2VcImhleFwiOnJldHVybiByPj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gTWModCkubGVuZ3RoO2RlZmF1bHQ6aWYobilyZXR1cm4gaT8tMTpWcyh0KS5sZW5ndGg7ZT0oXCJcIitlKS50b0xvd2VyQ2FzZSgpLG49ITB9fWZ1bmN0aW9uIGR3KHQsZSxyKXt2YXIgaT0hMTtpZigoZT09PXZvaWQgMHx8ZTwwKSYmKGU9MCksZT50aGlzLmxlbmd0aHx8KChyPT09dm9pZCAwfHxyPnRoaXMubGVuZ3RoKSYmKHI9dGhpcy5sZW5ndGgpLHI8PTApfHwocj4+Pj0wKTw9KGU+Pj49MCkpcmV0dXJuXCJcIjtmb3IodHx8KHQ9XCJ1dGY4XCIpOzspc3dpdGNoKHQpe2Nhc2VcImhleFwiOnJldHVybiBFdyh0aGlzLGUscik7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIGtjKHRoaXMsZSxyKTtjYXNlXCJhc2NpaVwiOnJldHVybiBtdyh0aGlzLGUscik7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHZ3KHRoaXMsZSxyKTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gX3codGhpcyxlLHIpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiBTdyh0aGlzLGUscik7ZGVmYXVsdDppZihpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIit0KTt0PSh0K1wiXCIpLnRvTG93ZXJDYXNlKCksaT0hMH19ZnVuY3Rpb24gc3IodCxlLHIpe3ZhciBpPXRbZV07dFtlXT10W3JdLHRbcl09aX1mdW5jdGlvbiB2Yyh0LGUscixpLG4pe2lmKHQubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2Ygcj09XCJzdHJpbmdcIj8oaT1yLHI9MCk6cj4yMTQ3NDgzNjQ3P3I9MjE0NzQ4MzY0NzpyPC0yMTQ3NDgzNjQ4JiYocj0tMjE0NzQ4MzY0OCksR3Mocj0rcikmJihyPW4/MDp0Lmxlbmd0aC0xKSxyPDAmJihyPXQubGVuZ3RoK3IpLHI+PXQubGVuZ3RoKXtpZihuKXJldHVybi0xO3I9dC5sZW5ndGgtMX1lbHNlIGlmKHI8MCl7aWYoIW4pcmV0dXJuLTE7cj0wfWlmKHR5cGVvZiBlPT1cInN0cmluZ1wiJiYoZT14LmZyb20oZSxpKSkseC5pc0J1ZmZlcihlKSlyZXR1cm4gZS5sZW5ndGg9PT0wPy0xOkVjKHQsZSxyLGksbik7aWYodHlwZW9mIGU9PVwibnVtYmVyXCIpcmV0dXJuIGUmPTI1NSx0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj09XCJmdW5jdGlvblwiP24/VWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHQsZSxyKTpVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKHQsZSxyKTpFYyh0LFtlXSxyLGksbik7dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiBFYyh0LGUscixpLG4pe3ZhciBvLHM9MSxhPXQubGVuZ3RoLHU9ZS5sZW5ndGg7aWYoaSE9PXZvaWQgMCYmKChpPVN0cmluZyhpKS50b0xvd2VyQ2FzZSgpKT09PVwidWNzMlwifHxpPT09XCJ1Y3MtMlwifHxpPT09XCJ1dGYxNmxlXCJ8fGk9PT1cInV0Zi0xNmxlXCIpKXtpZih0Lmxlbmd0aDwyfHxlLmxlbmd0aDwyKXJldHVybi0xO3M9MixhLz0yLHUvPTIsci89Mn1mdW5jdGlvbiBjKHksdyl7cmV0dXJuIHM9PT0xP3lbd106eS5yZWFkVUludDE2QkUodypzKX1pZihuKXt2YXIgaD0tMTtmb3Iobz1yO288YTtvKyspaWYoYyh0LG8pPT09YyhlLGg9PT0tMT8wOm8taCkpe2lmKGg9PT0tMSYmKGg9byksby1oKzE9PT11KXJldHVybiBoKnN9ZWxzZSBoIT09LTEmJihvLT1vLWgpLGg9LTF9ZWxzZSBmb3Iocit1PmEmJihyPWEtdSksbz1yO28+PTA7by0tKXtmb3IodmFyIGQ9ITAsZz0wO2c8dTtnKyspaWYoYyh0LG8rZykhPT1jKGUsZykpe2Q9ITE7YnJlYWt9aWYoZClyZXR1cm4gb31yZXR1cm4tMX1mdW5jdGlvbiBwdyh0LGUscixpKXtyPU51bWJlcihyKXx8MDt2YXIgbj10Lmxlbmd0aC1yO2k/KGk9TnVtYmVyKGkpKT5uJiYoaT1uKTppPW47dmFyIG89ZS5sZW5ndGg7aT5vLzImJihpPW8vMik7Zm9yKHZhciBzPTA7czxpOysrcyl7dmFyIGE9cGFyc2VJbnQoZS5zdWJzdHIoMipzLDIpLDE2KTtpZihHcyhhKSlyZXR1cm4gczt0W3Irc109YX1yZXR1cm4gc31mdW5jdGlvbiBndyh0LGUscixpKXtyZXR1cm4gdW4oVnMoZSx0Lmxlbmd0aC1yKSx0LHIsaSl9ZnVuY3Rpb24gT2ModCxlLHIsaSl7cmV0dXJuIHVuKGZ1bmN0aW9uKG4pe2Zvcih2YXIgbz1bXSxzPTA7czxuLmxlbmd0aDsrK3Mpby5wdXNoKDI1NSZuLmNoYXJDb2RlQXQocykpO3JldHVybiBvfShlKSx0LHIsaSl9ZnVuY3Rpb24geXcodCxlLHIsaSl7cmV0dXJuIE9jKHQsZSxyLGkpfWZ1bmN0aW9uIGJ3KHQsZSxyLGkpe3JldHVybiB1bihNYyhlKSx0LHIsaSl9ZnVuY3Rpb24gd3codCxlLHIsaSl7cmV0dXJuIHVuKGZ1bmN0aW9uKG4sbyl7Zm9yKHZhciBzLGEsdSxjPVtdLGg9MDtoPG4ubGVuZ3RoJiYhKChvLT0yKTwwKTsrK2gpcz1uLmNoYXJDb2RlQXQoaCksYT1zPj44LHU9cyUyNTYsYy5wdXNoKHUpLGMucHVzaChhKTtyZXR1cm4gY30oZSx0Lmxlbmd0aC1yKSx0LHIsaSl9ZnVuY3Rpb24gX3codCxlLHIpe3JldHVybiBlPT09MCYmcj09PXQubGVuZ3RoPyRzLmZyb21CeXRlQXJyYXkodCk6JHMuZnJvbUJ5dGVBcnJheSh0LnNsaWNlKGUscikpfWZ1bmN0aW9uIGtjKHQsZSxyKXtyPU1hdGgubWluKHQubGVuZ3RoLHIpO2Zvcih2YXIgaT1bXSxuPWU7bjxyOyl7dmFyIG8scyxhLHUsYz10W25dLGg9bnVsbCxkPWM+MjM5PzQ6Yz4yMjM/MzpjPjE5MT8yOjE7aWYobitkPD1yKXN3aXRjaChkKXtjYXNlIDE6YzwxMjgmJihoPWMpO2JyZWFrO2Nhc2UgMjooMTkyJihvPXRbbisxXSkpPT0xMjgmJih1PSgzMSZjKTw8Nnw2MyZvKT4xMjcmJihoPXUpO2JyZWFrO2Nhc2UgMzpvPXRbbisxXSxzPXRbbisyXSwoMTkyJm8pPT0xMjgmJigxOTImcyk9PTEyOCYmKHU9KDE1JmMpPDwxMnwoNjMmbyk8PDZ8NjMmcyk+MjA0NyYmKHU8NTUyOTZ8fHU+NTczNDMpJiYoaD11KTticmVhaztjYXNlIDQ6bz10W24rMV0scz10W24rMl0sYT10W24rM10sKDE5MiZvKT09MTI4JiYoMTkyJnMpPT0xMjgmJigxOTImYSk9PTEyOCYmKHU9KDE1JmMpPDwxOHwoNjMmbyk8PDEyfCg2MyZzKTw8Nnw2MyZhKT42NTUzNSYmdTwxMTE0MTEyJiYoaD11KX1oPT09bnVsbD8oaD02NTUzMyxkPTEpOmg+NjU1MzUmJihoLT02NTUzNixpLnB1c2goaD4+PjEwJjEwMjN8NTUyOTYpLGg9NTYzMjB8MTAyMyZoKSxpLnB1c2goaCksbis9ZH1yZXR1cm4gZnVuY3Rpb24oZyl7dmFyIHk9Zy5sZW5ndGg7aWYoeTw9NDA5NilyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZyk7Zm9yKHZhciB3PVwiXCIsRT0wO0U8eTspdys9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZy5zbGljZShFLEUrPTQwOTYpKTtyZXR1cm4gd30oaSl9ZnVuY3Rpb24gbXcodCxlLHIpe3ZhciBpPVwiXCI7cj1NYXRoLm1pbih0Lmxlbmd0aCxyKTtmb3IodmFyIG49ZTtuPHI7KytuKWkrPVN0cmluZy5mcm9tQ2hhckNvZGUoMTI3JnRbbl0pO3JldHVybiBpfWZ1bmN0aW9uIHZ3KHQsZSxyKXt2YXIgaT1cIlwiO3I9TWF0aC5taW4odC5sZW5ndGgscik7Zm9yKHZhciBuPWU7bjxyOysrbilpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbbl0pO3JldHVybiBpfWZ1bmN0aW9uIEV3KHQsZSxyKXt2YXIgaT10Lmxlbmd0aDsoIWV8fGU8MCkmJihlPTApLCghcnx8cjwwfHxyPmkpJiYocj1pKTtmb3IodmFyIG49XCJcIixvPWU7bzxyOysrbyluKz1Jd1t0W29dXTtyZXR1cm4gbn1mdW5jdGlvbiBTdyh0LGUscil7Zm9yKHZhciBpPXQuc2xpY2UoZSxyKSxuPVwiXCIsbz0wO288aS5sZW5ndGg7bys9MiluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGlbb10rMjU2KmlbbysxXSk7cmV0dXJuIG59ZnVuY3Rpb24geWUodCxlLHIpe2lmKHQlMSE9MHx8dDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKHQrZT5yKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1mdW5jdGlvbiBQZSh0LGUscixpLG4sbyl7aWYoIXguaXNCdWZmZXIodCkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7aWYoZT5ufHxlPG8pdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7aWYocitpPnQubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIHhjKHQsZSxyLGksbixvKXtpZihyK2k+dC5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYocjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIFNjKHQsZSxyLGksbil7cmV0dXJuIGU9K2Uscj4+Pj0wLG58fHhjKHQsMCxyLDQpLFVyLndyaXRlKHQsZSxyLGksMjMsNCkscis0fWZ1bmN0aW9uIEFjKHQsZSxyLGksbil7cmV0dXJuIGU9K2Uscj4+Pj0wLG58fHhjKHQsMCxyLDgpLFVyLndyaXRlKHQsZSxyLGksNTIsOCkscis4fWZ1bmN0aW9uIFZzKHQsZSl7dmFyIHI7ZT1lfHwxLzA7Zm9yKHZhciBpPXQubGVuZ3RoLG49bnVsbCxvPVtdLHM9MDtzPGk7KytzKXtpZigocj10LmNoYXJDb2RlQXQocykpPjU1Mjk1JiZyPDU3MzQ0KXtpZighbil7aWYocj41NjMxOSl7KGUtPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWlmKHMrMT09PWkpeyhlLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1uPXI7Y29udGludWV9aWYocjw1NjMyMCl7KGUtPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpLG49cjtjb250aW51ZX1yPTY1NTM2KyhuLTU1Mjk2PDwxMHxyLTU2MzIwKX1lbHNlIG4mJihlLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KTtpZihuPW51bGwscjwxMjgpe2lmKChlLT0xKTwwKWJyZWFrO28ucHVzaChyKX1lbHNlIGlmKHI8MjA0OCl7aWYoKGUtPTIpPDApYnJlYWs7by5wdXNoKHI+PjZ8MTkyLDYzJnJ8MTI4KX1lbHNlIGlmKHI8NjU1MzYpe2lmKChlLT0zKTwwKWJyZWFrO28ucHVzaChyPj4xMnwyMjQscj4+NiY2M3wxMjgsNjMmcnwxMjgpfWVsc2V7aWYoIShyPDExMTQxMTIpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKTtpZigoZS09NCk8MClicmVhaztvLnB1c2gocj4+MTh8MjQwLHI+PjEyJjYzfDEyOCxyPj42JjYzfDEyOCw2MyZyfDEyOCl9fXJldHVybiBvfWZ1bmN0aW9uIE1jKHQpe3JldHVybiAkcy50b0J5dGVBcnJheShmdW5jdGlvbihlKXtpZigoZT0oZT1lLnNwbGl0KFwiPVwiKVswXSkudHJpbSgpLnJlcGxhY2UoQXcsXCJcIikpLmxlbmd0aDwyKXJldHVyblwiXCI7Zm9yKDtlLmxlbmd0aCU0IT0wOyllKz1cIj1cIjtyZXR1cm4gZX0odCkpfWZ1bmN0aW9uIHVuKHQsZSxyLGkpe2Zvcih2YXIgbj0wO248aSYmIShuK3I+PWUubGVuZ3RofHxuPj10Lmxlbmd0aCk7KytuKWVbbityXT10W25dO3JldHVybiBufWZ1bmN0aW9uIEV0KHQsZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBlfHx0IT1udWxsJiZ0LmNvbnN0cnVjdG9yIT1udWxsJiZ0LmNvbnN0cnVjdG9yLm5hbWUhPW51bGwmJnQuY29uc3RydWN0b3IubmFtZT09PWUubmFtZX1mdW5jdGlvbiBHcyh0KXtyZXR1cm4gdCE9dH1mdW5jdGlvbiBJYyh0LGUpe2Zvcih2YXIgciBpbiB0KWVbcl09dFtyXX1mdW5jdGlvbiBvcih0LGUscil7cmV0dXJuIGl0KHQsZSxyKX1mdW5jdGlvbiBjaSh0KXt2YXIgZTtzd2l0Y2godGhpcy5lbmNvZGluZz1mdW5jdGlvbihyKXt2YXIgaT1mdW5jdGlvbihuKXtpZighbilyZXR1cm5cInV0ZjhcIjtmb3IodmFyIG87Oylzd2l0Y2gobil7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuXCJ1dGY4XCI7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuXCJ1dGYxNmxlXCI7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuXCJsYXRpbjFcIjtjYXNlXCJiYXNlNjRcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImhleFwiOnJldHVybiBuO2RlZmF1bHQ6aWYobylyZXR1cm47bj0oXCJcIituKS50b0xvd2VyQ2FzZSgpLG89ITB9fShyKTtpZih0eXBlb2YgaSE9XCJzdHJpbmdcIiYmKHpzLmlzRW5jb2Rpbmc9PT1UY3x8IVRjKHIpKSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIityKTtyZXR1cm4gaXx8cn0odCksdGhpcy5lbmNvZGluZyl7Y2FzZVwidXRmMTZsZVwiOnRoaXMudGV4dD1Ddyx0aGlzLmVuZD1CdyxlPTQ7YnJlYWs7Y2FzZVwidXRmOFwiOnRoaXMuZmlsbExhc3Q9UncsZT00O2JyZWFrO2Nhc2VcImJhc2U2NFwiOnRoaXMudGV4dD1Qdyx0aGlzLmVuZD1PdyxlPTM7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gdGhpcy53cml0ZT1rdyx0aGlzLmVuZD14dyx2b2lkIDB9dGhpcy5sYXN0TmVlZD0wLHRoaXMubGFzdFRvdGFsPTAsdGhpcy5sYXN0Q2hhcj16cy5hbGxvY1Vuc2FmZShlKX1mdW5jdGlvbiBXcyh0KXtyZXR1cm4gdDw9MTI3PzA6dD4+NT09Nj8yOnQ+PjQ9PTE0PzM6dD4+Mz09MzA/NDp0Pj42PT0yPy0xOi0yfWZ1bmN0aW9uIFJ3KHQpe3ZhciBlPXRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQscj1mdW5jdGlvbihpLG4sbyl7aWYoKDE5MiZuWzBdKSE9MTI4KXJldHVybiBpLmxhc3ROZWVkPTAsXCJcXHVGRkZEXCI7aWYoaS5sYXN0TmVlZD4xJiZuLmxlbmd0aD4xKXtpZigoMTkyJm5bMV0pIT0xMjgpcmV0dXJuIGkubGFzdE5lZWQ9MSxcIlxcdUZGRkRcIjtpZihpLmxhc3ROZWVkPjImJm4ubGVuZ3RoPjImJigxOTImblsyXSkhPTEyOClyZXR1cm4gaS5sYXN0TmVlZD0yLFwiXFx1RkZGRFwifX0odGhpcyx0KTtyZXR1cm4gciE9PXZvaWQgMD9yOnRoaXMubGFzdE5lZWQ8PXQubGVuZ3RoPyh0LmNvcHkodGhpcy5sYXN0Q2hhcixlLDAsdGhpcy5sYXN0TmVlZCksdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLDAsdGhpcy5sYXN0VG90YWwpKToodC5jb3B5KHRoaXMubGFzdENoYXIsZSwwLHQubGVuZ3RoKSx0aGlzLmxhc3ROZWVkLT10Lmxlbmd0aCx2b2lkIDApfWZ1bmN0aW9uIEN3KHQsZSl7aWYoKHQubGVuZ3RoLWUpJTI9PTApe3ZhciByPXQudG9TdHJpbmcoXCJ1dGYxNmxlXCIsZSk7aWYocil7dmFyIGk9ci5jaGFyQ29kZUF0KHIubGVuZ3RoLTEpO2lmKGk+PTU1Mjk2JiZpPD01NjMxOSlyZXR1cm4gdGhpcy5sYXN0TmVlZD0yLHRoaXMubGFzdFRvdGFsPTQsdGhpcy5sYXN0Q2hhclswXT10W3QubGVuZ3RoLTJdLHRoaXMubGFzdENoYXJbMV09dFt0Lmxlbmd0aC0xXSxyLnNsaWNlKDAsLTEpfXJldHVybiByfXJldHVybiB0aGlzLmxhc3ROZWVkPTEsdGhpcy5sYXN0VG90YWw9Mix0aGlzLmxhc3RDaGFyWzBdPXRbdC5sZW5ndGgtMV0sdC50b1N0cmluZyhcInV0ZjE2bGVcIixlLHQubGVuZ3RoLTEpfWZ1bmN0aW9uIEJ3KHQpe3ZhciBlPXQmJnQubGVuZ3RoP3RoaXMud3JpdGUodCk6XCJcIjtpZih0aGlzLmxhc3ROZWVkKXt2YXIgcj10aGlzLmxhc3RUb3RhbC10aGlzLmxhc3ROZWVkO3JldHVybiBlK3RoaXMubGFzdENoYXIudG9TdHJpbmcoXCJ1dGYxNmxlXCIsMCxyKX1yZXR1cm4gZX1mdW5jdGlvbiBQdyh0LGUpe3ZhciByPSh0Lmxlbmd0aC1lKSUzO3JldHVybiByPT09MD90LnRvU3RyaW5nKFwiYmFzZTY0XCIsZSk6KHRoaXMubGFzdE5lZWQ9My1yLHRoaXMubGFzdFRvdGFsPTMscj09PTE/dGhpcy5sYXN0Q2hhclswXT10W3QubGVuZ3RoLTFdOih0aGlzLmxhc3RDaGFyWzBdPXRbdC5sZW5ndGgtMl0sdGhpcy5sYXN0Q2hhclsxXT10W3QubGVuZ3RoLTFdKSx0LnRvU3RyaW5nKFwiYmFzZTY0XCIsZSx0Lmxlbmd0aC1yKSl9ZnVuY3Rpb24gT3codCl7dmFyIGU9dCYmdC5sZW5ndGg/dGhpcy53cml0ZSh0KTpcIlwiO3JldHVybiB0aGlzLmxhc3ROZWVkP2UrdGhpcy5sYXN0Q2hhci50b1N0cmluZyhcImJhc2U2NFwiLDAsMy10aGlzLmxhc3ROZWVkKTplfWZ1bmN0aW9uIGt3KHQpe3JldHVybiB0LnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpfWZ1bmN0aW9uIHh3KHQpe3JldHVybiB0JiZ0Lmxlbmd0aD90aGlzLndyaXRlKHQpOlwiXCJ9dmFyIFJjLCRlLGtlLHljLG9uLG5yLGJjLGh3LFN0LCRzLFVyLF9jLEF3LEl3LGFuLGxuLGl0LFR3LGFyLHpzLFRjLFFzPWJlKCgpPT57digpO20oKTtfKCk7Zm9yKFJjPXtieXRlTGVuZ3RoOmZ1bmN0aW9uKHQpe3ZhciBlPXdjKHQpLHI9ZVswXSxpPWVbMV07cmV0dXJuIDMqKHIraSkvNC1pfSx0b0J5dGVBcnJheTpmdW5jdGlvbih0KXt2YXIgZSxyLGk9d2ModCksbj1pWzBdLG89aVsxXSxzPW5ldyB5YyhmdW5jdGlvbihjLGgsZCl7cmV0dXJuIDMqKGgrZCkvNC1kfSgwLG4sbykpLGE9MCx1PW8+MD9uLTQ6bjtmb3Iocj0wO3I8dTtyKz00KWU9a2VbdC5jaGFyQ29kZUF0KHIpXTw8MTh8a2VbdC5jaGFyQ29kZUF0KHIrMSldPDwxMnxrZVt0LmNoYXJDb2RlQXQocisyKV08PDZ8a2VbdC5jaGFyQ29kZUF0KHIrMyldLHNbYSsrXT1lPj4xNiYyNTUsc1thKytdPWU+PjgmMjU1LHNbYSsrXT0yNTUmZTtyZXR1cm4gbz09PTImJihlPWtlW3QuY2hhckNvZGVBdChyKV08PDJ8a2VbdC5jaGFyQ29kZUF0KHIrMSldPj40LHNbYSsrXT0yNTUmZSksbz09PTEmJihlPWtlW3QuY2hhckNvZGVBdChyKV08PDEwfGtlW3QuY2hhckNvZGVBdChyKzEpXTw8NHxrZVt0LmNoYXJDb2RlQXQocisyKV0+PjIsc1thKytdPWU+PjgmMjU1LHNbYSsrXT0yNTUmZSksc30sZnJvbUJ5dGVBcnJheTpmdW5jdGlvbih0KXtmb3IodmFyIGUscj10Lmxlbmd0aCxpPXIlMyxuPVtdLG89MCxzPXItaTtvPHM7bys9MTYzODMpbi5wdXNoKGN3KHQsbyxvKzE2MzgzPnM/czpvKzE2MzgzKSk7cmV0dXJuIGk9PT0xPyhlPXRbci0xXSxuLnB1c2goJGVbZT4+Ml0rJGVbZTw8NCY2M10rXCI9PVwiKSk6aT09PTImJihlPSh0W3ItMl08PDgpK3Rbci0xXSxuLnB1c2goJGVbZT4+MTBdKyRlW2U+PjQmNjNdKyRlW2U8PDImNjNdK1wiPVwiKSksbi5qb2luKFwiXCIpfX0sJGU9W10sa2U9W10seWM9dHlwZW9mIFVpbnQ4QXJyYXk8XCJ1XCI/VWludDhBcnJheTpBcnJheSxvbj1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIixucj0wLGJjPW9uLmxlbmd0aDtucjxiYzsrK25yKSRlW25yXT1vbltucl0sa2Vbb24uY2hhckNvZGVBdChucildPW5yO2tlW1wiLVwiLmNoYXJDb2RlQXQoMCldPTYyLGtlW1wiX1wiLmNoYXJDb2RlQXQoMCldPTYzO2h3PXtyZWFkOmZ1bmN0aW9uKHQsZSxyLGksbil7dmFyIG8scyxhPTgqbi1pLTEsdT0oMTw8YSktMSxjPXU+PjEsaD0tNyxkPXI/bi0xOjAsZz1yPy0xOjEseT10W2UrZF07Zm9yKGQrPWcsbz15JigxPDwtaCktMSx5Pj49LWgsaCs9YTtoPjA7bz0yNTYqbyt0W2UrZF0sZCs9ZyxoLT04KTtmb3Iocz1vJigxPDwtaCktMSxvPj49LWgsaCs9aTtoPjA7cz0yNTYqcyt0W2UrZF0sZCs9ZyxoLT04KTtpZihvPT09MClvPTEtYztlbHNle2lmKG89PT11KXJldHVybiBzP05hTjoxLzAqKHk/LTE6MSk7cys9TWF0aC5wb3coMixpKSxvLT1jfXJldHVybih5Py0xOjEpKnMqTWF0aC5wb3coMixvLWkpfSx3cml0ZTpmdW5jdGlvbih0LGUscixpLG4sbyl7dmFyIHMsYSx1LGM9OCpvLW4tMSxoPSgxPDxjKS0xLGQ9aD4+MSxnPW49PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjAseT1pPzA6by0xLHc9aT8xOi0xLEU9ZTwwfHxlPT09MCYmMS9lPDA/MTowO2ZvcihlPU1hdGguYWJzKGUpLGlzTmFOKGUpfHxlPT09MS8wPyhhPWlzTmFOKGUpPzE6MCxzPWgpOihzPU1hdGguZmxvb3IoTWF0aC5sb2coZSkvTWF0aC5MTjIpLGUqKHU9TWF0aC5wb3coMiwtcykpPDEmJihzLS0sdSo9MiksKGUrPXMrZD49MT9nL3U6ZypNYXRoLnBvdygyLDEtZCkpKnU+PTImJihzKyssdS89MikscytkPj1oPyhhPTAscz1oKTpzK2Q+PTE/KGE9KGUqdS0xKSpNYXRoLnBvdygyLG4pLHMrPWQpOihhPWUqTWF0aC5wb3coMixkLTEpKk1hdGgucG93KDIsbikscz0wKSk7bj49ODt0W3IreV09MjU1JmEseSs9dyxhLz0yNTYsbi09OCk7Zm9yKHM9czw8bnxhLGMrPW47Yz4wO3Rbcit5XT0yNTUmcyx5Kz13LHMvPTI1NixjLT04KTt0W3IreS13XXw9MTI4KkV9fSxTdD17fSwkcz1SYyxVcj1odyxfYz10eXBlb2YgU3ltYm9sPT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuZm9yPT1cImZ1bmN0aW9uXCI/U3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpOm51bGw7U3QuQnVmZmVyPXgsU3QuU2xvd0J1ZmZlcj1mdW5jdGlvbih0KXtyZXR1cm4rdCE9dCYmKHQ9MCkseC5hbGxvYygrdCl9LFN0LklOU1BFQ1RfTUFYX0JZVEVTPTUwO1N0LmtNYXhMZW5ndGg9MjE0NzQ4MzY0Nyx4LlRZUEVEX0FSUkFZX1NVUFBPUlQ9ZnVuY3Rpb24oKXt0cnl7dmFyIHQ9bmV3IFVpbnQ4QXJyYXkoMSksZT17Zm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX07cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihlLFVpbnQ4QXJyYXkucHJvdG90eXBlKSxPYmplY3Quc2V0UHJvdG90eXBlT2YodCxlKSx0LmZvbygpPT09NDJ9Y2F0Y2h7cmV0dXJuITF9fSgpLHguVFlQRURfQVJSQVlfU1VQUE9SVHx8dHlwZW9mIGNvbnNvbGU+XCJ1XCJ8fHR5cGVvZiBjb25zb2xlLmVycm9yIT1cImZ1bmN0aW9uXCJ8fGNvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC5cIiksT2JqZWN0LmRlZmluZVByb3BlcnR5KHgucHJvdG90eXBlLFwicGFyZW50XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7aWYoeC5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdGhpcy5idWZmZXJ9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHgucHJvdG90eXBlLFwib2Zmc2V0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7aWYoeC5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdGhpcy5ieXRlT2Zmc2V0fX0pLHgucG9vbFNpemU9ODE5Mix4LmZyb209ZnVuY3Rpb24odCxlLHIpe3JldHVybiBDYyh0LGUscil9LE9iamVjdC5zZXRQcm90b3R5cGVPZih4LnByb3RvdHlwZSxVaW50OEFycmF5LnByb3RvdHlwZSksT2JqZWN0LnNldFByb3RvdHlwZU9mKHgsVWludDhBcnJheSkseC5hbGxvYz1mdW5jdGlvbih0LGUscil7cmV0dXJuIGZ1bmN0aW9uKGksbixvKXtyZXR1cm4gQmMoaSksaTw9MD92dChpKTpuIT09dm9pZCAwP3R5cGVvZiBvPT1cInN0cmluZ1wiP3Z0KGkpLmZpbGwobixvKTp2dChpKS5maWxsKG4pOnZ0KGkpfSh0LGUscil9LHguYWxsb2NVbnNhZmU9ZnVuY3Rpb24odCl7cmV0dXJuIEhzKHQpfSx4LmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbih0KXtyZXR1cm4gSHModCl9LHguaXNCdWZmZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHQhPW51bGwmJnQuX2lzQnVmZmVyPT09ITAmJnQhPT14LnByb3RvdHlwZX0seC5jb21wYXJlPWZ1bmN0aW9uKHQsZSl7aWYoRXQodCxVaW50OEFycmF5KSYmKHQ9eC5mcm9tKHQsdC5vZmZzZXQsdC5ieXRlTGVuZ3RoKSksRXQoZSxVaW50OEFycmF5KSYmKGU9eC5mcm9tKGUsZS5vZmZzZXQsZS5ieXRlTGVuZ3RoKSksIXguaXNCdWZmZXIodCl8fCF4LmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKTtpZih0PT09ZSlyZXR1cm4gMDtmb3IodmFyIHI9dC5sZW5ndGgsaT1lLmxlbmd0aCxuPTAsbz1NYXRoLm1pbihyLGkpO248bzsrK24paWYodFtuXSE9PWVbbl0pe3I9dFtuXSxpPWVbbl07YnJlYWt9cmV0dXJuIHI8aT8tMTppPHI/MTowfSx4LmlzRW5jb2Rpbmc9ZnVuY3Rpb24odCl7c3dpdGNoKFN0cmluZyh0KS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fSx4LmNvbmNhdD1mdW5jdGlvbih0LGUpe2lmKCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO2lmKHQubGVuZ3RoPT09MClyZXR1cm4geC5hbGxvYygwKTt2YXIgcjtpZihlPT09dm9pZCAwKWZvcihlPTAscj0wO3I8dC5sZW5ndGg7KytyKWUrPXRbcl0ubGVuZ3RoO3ZhciBpPXguYWxsb2NVbnNhZmUoZSksbj0wO2ZvcihyPTA7cjx0Lmxlbmd0aDsrK3Ipe3ZhciBvPXRbcl07aWYoRXQobyxVaW50OEFycmF5KSYmKG89eC5mcm9tKG8pKSwheC5pc0J1ZmZlcihvKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtvLmNvcHkoaSxuKSxuKz1vLmxlbmd0aH1yZXR1cm4gaX0seC5ieXRlTGVuZ3RoPVBjLHgucHJvdG90eXBlLl9pc0J1ZmZlcj0hMCx4LnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxlbmd0aDtpZih0JTIhPTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKTtmb3IodmFyIGU9MDtlPHQ7ZSs9Milzcih0aGlzLGUsZSsxKTtyZXR1cm4gdGhpc30seC5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sZW5ndGg7aWYodCU0IT0wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIik7Zm9yKHZhciBlPTA7ZTx0O2UrPTQpc3IodGhpcyxlLGUrMyksc3IodGhpcyxlKzEsZSsyKTtyZXR1cm4gdGhpc30seC5wcm90b3R5cGUuc3dhcDY0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sZW5ndGg7aWYodCU4IT0wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHNcIik7Zm9yKHZhciBlPTA7ZTx0O2UrPTgpc3IodGhpcyxlLGUrNyksc3IodGhpcyxlKzEsZSs2KSxzcih0aGlzLGUrMixlKzUpLHNyKHRoaXMsZSszLGUrNCk7cmV0dXJuIHRoaXN9LHgucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sZW5ndGg7cmV0dXJuIHQ9PT0wP1wiXCI6YXJndW1lbnRzLmxlbmd0aD09PTA/a2ModGhpcywwLHQpOmR3LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0seC5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc9eC5wcm90b3R5cGUudG9TdHJpbmcseC5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKHQpe2lmKCF4LmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO3JldHVybiB0aGlzPT09dHx8eC5jb21wYXJlKHRoaXMsdCk9PT0wfSx4LnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uKCl7dmFyIHQ9XCJcIixlPVN0LklOU1BFQ1RfTUFYX0JZVEVTO3JldHVybiB0PXRoaXMudG9TdHJpbmcoXCJoZXhcIiwwLGUpLnJlcGxhY2UoLyguezJ9KS9nLFwiJDEgXCIpLnRyaW0oKSx0aGlzLmxlbmd0aD5lJiYodCs9XCIgLi4uIFwiKSxcIjxCdWZmZXIgXCIrdCtcIj5cIn0sX2MmJih4LnByb3RvdHlwZVtfY109eC5wcm90b3R5cGUuaW5zcGVjdCkseC5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbih0LGUscixpLG4pe2lmKEV0KHQsVWludDhBcnJheSkmJih0PXguZnJvbSh0LHQub2Zmc2V0LHQuYnl0ZUxlbmd0aCkpLCF4LmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgdCk7aWYoZT09PXZvaWQgMCYmKGU9MCkscj09PXZvaWQgMCYmKHI9dD90Lmxlbmd0aDowKSxpPT09dm9pZCAwJiYoaT0wKSxuPT09dm9pZCAwJiYobj10aGlzLmxlbmd0aCksZTwwfHxyPnQubGVuZ3RofHxpPDB8fG4+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIik7aWYoaT49biYmZT49cilyZXR1cm4gMDtpZihpPj1uKXJldHVybi0xO2lmKGU+PXIpcmV0dXJuIDE7aWYodGhpcz09PXQpcmV0dXJuIDA7Zm9yKHZhciBvPShuPj4+PTApLShpPj4+PTApLHM9KHI+Pj49MCktKGU+Pj49MCksYT1NYXRoLm1pbihvLHMpLHU9dGhpcy5zbGljZShpLG4pLGM9dC5zbGljZShlLHIpLGg9MDtoPGE7KytoKWlmKHVbaF0hPT1jW2hdKXtvPXVbaF0scz1jW2hdO2JyZWFrfXJldHVybiBvPHM/LTE6czxvPzE6MH0seC5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0aGlzLmluZGV4T2YodCxlLHIpIT09LTF9LHgucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB2Yyh0aGlzLHQsZSxyLCEwKX0seC5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB2Yyh0aGlzLHQsZSxyLCExKX0seC5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlLHIsaSl7aWYoZT09PXZvaWQgMClpPVwidXRmOFwiLHI9dGhpcy5sZW5ndGgsZT0wO2Vsc2UgaWYocj09PXZvaWQgMCYmdHlwZW9mIGU9PVwic3RyaW5nXCIpaT1lLHI9dGhpcy5sZW5ndGgsZT0wO2Vsc2V7aWYoIWlzRmluaXRlKGUpKXRocm93IG5ldyBFcnJvcihcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpO2U+Pj49MCxpc0Zpbml0ZShyKT8ocj4+Pj0wLGk9PT12b2lkIDAmJihpPVwidXRmOFwiKSk6KGk9cixyPXZvaWQgMCl9dmFyIG49dGhpcy5sZW5ndGgtZTtpZigocj09PXZvaWQgMHx8cj5uKSYmKHI9biksdC5sZW5ndGg+MCYmKHI8MHx8ZTwwKXx8ZT50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpO2l8fChpPVwidXRmOFwiKTtmb3IodmFyIG89ITE7Oylzd2l0Y2goaSl7Y2FzZVwiaGV4XCI6cmV0dXJuIHB3KHRoaXMsdCxlLHIpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBndyh0aGlzLHQsZSxyKTtjYXNlXCJhc2NpaVwiOnJldHVybiBPYyh0aGlzLHQsZSxyKTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4geXcodGhpcyx0LGUscik7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJ3KHRoaXMsdCxlLHIpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB3dyh0aGlzLHQsZSxyKTtkZWZhdWx0OmlmKG8pdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2kpO2k9KFwiXCIraSkudG9Mb3dlckNhc2UoKSxvPSEwfX0seC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O3gucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5sZW5ndGg7KHQ9fn50KTwwPyh0Kz1yKTwwJiYodD0wKTp0PnImJih0PXIpLChlPWU9PT12b2lkIDA/cjp+fmUpPDA/KGUrPXIpPDAmJihlPTApOmU+ciYmKGU9ciksZTx0JiYoZT10KTt2YXIgaT10aGlzLnN1YmFycmF5KHQsZSk7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihpLHgucHJvdG90eXBlKSxpfSx4LnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uKHQsZSxyKXt0Pj4+PTAsZT4+Pj0wLHJ8fHllKHQsZSx0aGlzLmxlbmd0aCk7Zm9yKHZhciBpPXRoaXNbdF0sbj0xLG89MDsrK288ZSYmKG4qPTI1Nik7KWkrPXRoaXNbdCtvXSpuO3JldHVybiBpfSx4LnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKHQsZSxyKXt0Pj4+PTAsZT4+Pj0wLHJ8fHllKHQsZSx0aGlzLmxlbmd0aCk7Zm9yKHZhciBpPXRoaXNbdCstLWVdLG49MTtlPjAmJihuKj0yNTYpOylpKz10aGlzW3QrLS1lXSpuO3JldHVybiBpfSx4LnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD4+Pj0wLGV8fHllKHQsMSx0aGlzLmxlbmd0aCksdGhpc1t0XX0seC5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+Pj49MCxlfHx5ZSh0LDIsdGhpcy5sZW5ndGgpLHRoaXNbdF18dGhpc1t0KzFdPDw4fSx4LnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD4+Pj0wLGV8fHllKHQsMix0aGlzLmxlbmd0aCksdGhpc1t0XTw8OHx0aGlzW3QrMV19LHgucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbih0LGUpe3JldHVybiB0Pj4+PTAsZXx8eWUodCw0LHRoaXMubGVuZ3RoKSwodGhpc1t0XXx0aGlzW3QrMV08PDh8dGhpc1t0KzJdPDwxNikrMTY3NzcyMTYqdGhpc1t0KzNdfSx4LnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD4+Pj0wLGV8fHllKHQsNCx0aGlzLmxlbmd0aCksMTY3NzcyMTYqdGhpc1t0XSsodGhpc1t0KzFdPDwxNnx0aGlzW3QrMl08PDh8dGhpc1t0KzNdKX0seC5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uKHQsZSxyKXt0Pj4+PTAsZT4+Pj0wLHJ8fHllKHQsZSx0aGlzLmxlbmd0aCk7Zm9yKHZhciBpPXRoaXNbdF0sbj0xLG89MDsrK288ZSYmKG4qPTI1Nik7KWkrPXRoaXNbdCtvXSpuO3JldHVybiBpPj0obio9MTI4KSYmKGktPU1hdGgucG93KDIsOCplKSksaX0seC5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uKHQsZSxyKXt0Pj4+PTAsZT4+Pj0wLHJ8fHllKHQsZSx0aGlzLmxlbmd0aCk7Zm9yKHZhciBpPWUsbj0xLG89dGhpc1t0Ky0taV07aT4wJiYobio9MjU2KTspbys9dGhpc1t0Ky0taV0qbjtyZXR1cm4gbz49KG4qPTEyOCkmJihvLT1NYXRoLnBvdygyLDgqZSkpLG99LHgucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+Pj49MCxlfHx5ZSh0LDEsdGhpcy5sZW5ndGgpLDEyOCZ0aGlzW3RdPy0xKigyNTUtdGhpc1t0XSsxKTp0aGlzW3RdfSx4LnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbih0LGUpe3Q+Pj49MCxlfHx5ZSh0LDIsdGhpcy5sZW5ndGgpO3ZhciByPXRoaXNbdF18dGhpc1t0KzFdPDw4O3JldHVybiAzMjc2OCZyPzQyOTQ5MDE3NjB8cjpyfSx4LnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbih0LGUpe3Q+Pj49MCxlfHx5ZSh0LDIsdGhpcy5sZW5ndGgpO3ZhciByPXRoaXNbdCsxXXx0aGlzW3RdPDw4O3JldHVybiAzMjc2OCZyPzQyOTQ5MDE3NjB8cjpyfSx4LnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbih0LGUpe3JldHVybiB0Pj4+PTAsZXx8eWUodCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2fHRoaXNbdCszXTw8MjR9LHgucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+Pj49MCxlfHx5ZSh0LDQsdGhpcy5sZW5ndGgpLHRoaXNbdF08PDI0fHRoaXNbdCsxXTw8MTZ8dGhpc1t0KzJdPDw4fHRoaXNbdCszXX0seC5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD4+Pj0wLGV8fHllKHQsNCx0aGlzLmxlbmd0aCksVXIucmVhZCh0aGlzLHQsITAsMjMsNCl9LHgucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+Pj49MCxlfHx5ZSh0LDQsdGhpcy5sZW5ndGgpLFVyLnJlYWQodGhpcyx0LCExLDIzLDQpfSx4LnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD4+Pj0wLGV8fHllKHQsOCx0aGlzLmxlbmd0aCksVXIucmVhZCh0aGlzLHQsITAsNTIsOCl9LHgucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbih0LGUpe3JldHVybiB0Pj4+PTAsZXx8eWUodCw4LHRoaXMubGVuZ3RoKSxVci5yZWFkKHRoaXMsdCwhMSw1Miw4KX0seC5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24odCxlLHIsaSl7dD0rdCxlPj4+PTAscj4+Pj0wLGl8fFBlKHRoaXMsdCxlLHIsTWF0aC5wb3coMiw4KnIpLTEsMCk7dmFyIG49MSxvPTA7Zm9yKHRoaXNbZV09MjU1JnQ7KytvPHImJihuKj0yNTYpOyl0aGlzW2Urb109dC9uJjI1NTtyZXR1cm4gZStyfSx4LnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbih0LGUscixpKXt0PSt0LGU+Pj49MCxyPj4+PTAsaXx8UGUodGhpcyx0LGUscixNYXRoLnBvdygyLDgqciktMSwwKTt2YXIgbj1yLTEsbz0xO2Zvcih0aGlzW2Urbl09MjU1JnQ7LS1uPj0wJiYobyo9MjU2KTspdGhpc1tlK25dPXQvbyYyNTU7cmV0dXJuIGUrcn0seC5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZT4+Pj0wLHJ8fFBlKHRoaXMsdCxlLDEsMjU1LDApLHRoaXNbZV09MjU1JnQsZSsxfSx4LnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlPj4+PTAscnx8UGUodGhpcyx0LGUsMiw2NTUzNSwwKSx0aGlzW2VdPTI1NSZ0LHRoaXNbZSsxXT10Pj4+OCxlKzJ9LHgucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGU+Pj49MCxyfHxQZSh0aGlzLHQsZSwyLDY1NTM1LDApLHRoaXNbZV09dD4+PjgsdGhpc1tlKzFdPTI1NSZ0LGUrMn0seC5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZT4+Pj0wLHJ8fFBlKHRoaXMsdCxlLDQsNDI5NDk2NzI5NSwwKSx0aGlzW2UrM109dD4+PjI0LHRoaXNbZSsyXT10Pj4+MTYsdGhpc1tlKzFdPXQ+Pj44LHRoaXNbZV09MjU1JnQsZSs0fSx4LnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlPj4+PTAscnx8UGUodGhpcyx0LGUsNCw0Mjk0OTY3Mjk1LDApLHRoaXNbZV09dD4+PjI0LHRoaXNbZSsxXT10Pj4+MTYsdGhpc1tlKzJdPXQ+Pj44LHRoaXNbZSszXT0yNTUmdCxlKzR9LHgucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24odCxlLHIsaSl7aWYodD0rdCxlPj4+PTAsIWkpe3ZhciBuPU1hdGgucG93KDIsOCpyLTEpO1BlKHRoaXMsdCxlLHIsbi0xLC1uKX12YXIgbz0wLHM9MSxhPTA7Zm9yKHRoaXNbZV09MjU1JnQ7KytvPHImJihzKj0yNTYpOyl0PDAmJmE9PT0wJiZ0aGlzW2Urby0xXSE9PTAmJihhPTEpLHRoaXNbZStvXT0odC9zPj4wKS1hJjI1NTtyZXR1cm4gZStyfSx4LnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uKHQsZSxyLGkpe2lmKHQ9K3QsZT4+Pj0wLCFpKXt2YXIgbj1NYXRoLnBvdygyLDgqci0xKTtQZSh0aGlzLHQsZSxyLG4tMSwtbil9dmFyIG89ci0xLHM9MSxhPTA7Zm9yKHRoaXNbZStvXT0yNTUmdDstLW8+PTAmJihzKj0yNTYpOyl0PDAmJmE9PT0wJiZ0aGlzW2UrbysxXSE9PTAmJihhPTEpLHRoaXNbZStvXT0odC9zPj4wKS1hJjI1NTtyZXR1cm4gZStyfSx4LnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGU+Pj49MCxyfHxQZSh0aGlzLHQsZSwxLDEyNywtMTI4KSx0PDAmJih0PTI1NSt0KzEpLHRoaXNbZV09MjU1JnQsZSsxfSx4LnByb3RvdHlwZS53cml0ZUludDE2TEU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGU+Pj49MCxyfHxQZSh0aGlzLHQsZSwyLDMyNzY3LC0zMjc2OCksdGhpc1tlXT0yNTUmdCx0aGlzW2UrMV09dD4+PjgsZSsyfSx4LnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGU+Pj49MCxyfHxQZSh0aGlzLHQsZSwyLDMyNzY3LC0zMjc2OCksdGhpc1tlXT10Pj4+OCx0aGlzW2UrMV09MjU1JnQsZSsyfSx4LnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGU+Pj49MCxyfHxQZSh0aGlzLHQsZSw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpLHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44LHRoaXNbZSsyXT10Pj4+MTYsdGhpc1tlKzNdPXQ+Pj4yNCxlKzR9LHgucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZT4+Pj0wLHJ8fFBlKHRoaXMsdCxlLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksdDwwJiYodD00Mjk0OTY3Mjk1K3QrMSksdGhpc1tlXT10Pj4+MjQsdGhpc1tlKzFdPXQ+Pj4xNix0aGlzW2UrMl09dD4+PjgsdGhpc1tlKzNdPTI1NSZ0LGUrNH0seC5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gU2ModGhpcyx0LGUsITAscil9LHgucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIFNjKHRoaXMsdCxlLCExLHIpfSx4LnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gQWModGhpcyx0LGUsITAscil9LHgucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBBYyh0aGlzLHQsZSwhMSxyKX0seC5wcm90b3R5cGUuY29weT1mdW5jdGlvbih0LGUscixpKXtpZigheC5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyXCIpO2lmKHJ8fChyPTApLGl8fGk9PT0wfHwoaT10aGlzLmxlbmd0aCksZT49dC5sZW5ndGgmJihlPXQubGVuZ3RoKSxlfHwoZT0wKSxpPjAmJmk8ciYmKGk9ciksaT09PXJ8fHQubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwO2lmKGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIik7aWYocjwwfHxyPj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZihpPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtpPnRoaXMubGVuZ3RoJiYoaT10aGlzLmxlbmd0aCksdC5sZW5ndGgtZTxpLXImJihpPXQubGVuZ3RoLWUrcik7dmFyIG49aS1yO2lmKHRoaXM9PT10JiZ0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbj09XCJmdW5jdGlvblwiKXRoaXMuY29weVdpdGhpbihlLHIsaSk7ZWxzZSBpZih0aGlzPT09dCYmcjxlJiZlPGkpZm9yKHZhciBvPW4tMTtvPj0wOy0tbyl0W28rZV09dGhpc1tvK3JdO2Vsc2UgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwodCx0aGlzLnN1YmFycmF5KHIsaSksZSk7cmV0dXJuIG59LHgucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCxlLHIsaSl7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpe2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiPyhpPWUsZT0wLHI9dGhpcy5sZW5ndGgpOnR5cGVvZiByPT1cInN0cmluZ1wiJiYoaT1yLHI9dGhpcy5sZW5ndGgpLGkhPT12b2lkIDAmJnR5cGVvZiBpIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpO2lmKHR5cGVvZiBpPT1cInN0cmluZ1wiJiYheC5pc0VuY29kaW5nKGkpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitpKTtpZih0Lmxlbmd0aD09PTEpe3ZhciBuPXQuY2hhckNvZGVBdCgwKTsoaT09PVwidXRmOFwiJiZuPDEyOHx8aT09PVwibGF0aW4xXCIpJiYodD1uKX19ZWxzZSB0eXBlb2YgdD09XCJudW1iZXJcIj90Jj0yNTU6dHlwZW9mIHQ9PVwiYm9vbGVhblwiJiYodD1OdW1iZXIodCkpO2lmKGU8MHx8dGhpcy5sZW5ndGg8ZXx8dGhpcy5sZW5ndGg8cil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKTtpZihyPD1lKXJldHVybiB0aGlzO3ZhciBvO2lmKGU+Pj49MCxyPXI9PT12b2lkIDA/dGhpcy5sZW5ndGg6cj4+PjAsdHx8KHQ9MCksdHlwZW9mIHQ9PVwibnVtYmVyXCIpZm9yKG89ZTtvPHI7KytvKXRoaXNbb109dDtlbHNle3ZhciBzPXguaXNCdWZmZXIodCk/dDp4LmZyb20odCxpKSxhPXMubGVuZ3RoO2lmKGE9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrdCsnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJyk7Zm9yKG89MDtvPHItZTsrK28pdGhpc1tvK2VdPXNbbyVhXX1yZXR1cm4gdGhpc307QXc9L1teKy8wLTlBLVphLXotX10vZztJdz1mdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkoMjU2KSxlPTA7ZTwxNjsrK2UpZm9yKHZhciByPTE2KmUsaT0wO2k8MTY7KytpKXRbcitpXT1cIjAxMjM0NTY3ODlhYmNkZWZcIltlXStcIjAxMjM0NTY3ODlhYmNkZWZcIltpXTtyZXR1cm4gdH0oKTtTdC5CdWZmZXI7U3QuSU5TUEVDVF9NQVhfQllURVM7U3Qua01heExlbmd0aDthbj17fSxsbj1TdCxpdD1sbi5CdWZmZXI7aXQuZnJvbSYmaXQuYWxsb2MmJml0LmFsbG9jVW5zYWZlJiZpdC5hbGxvY1Vuc2FmZVNsb3c/YW49bG46KEljKGxuLGFuKSxhbi5CdWZmZXI9b3IpLG9yLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGl0LnByb3RvdHlwZSksSWMoaXQsb3IpLG9yLmZyb209ZnVuY3Rpb24odCxlLHIpe2lmKHR5cGVvZiB0PT1cIm51bWJlclwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlclwiKTtyZXR1cm4gaXQodCxlLHIpfSxvci5hbGxvYz1mdW5jdGlvbih0LGUscil7aWYodHlwZW9mIHQhPVwibnVtYmVyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIik7dmFyIGk9aXQodCk7cmV0dXJuIGUhPT12b2lkIDA/dHlwZW9mIHI9PVwic3RyaW5nXCI/aS5maWxsKGUscik6aS5maWxsKGUpOmkuZmlsbCgwKSxpfSxvci5hbGxvY1Vuc2FmZT1mdW5jdGlvbih0KXtpZih0eXBlb2YgdCE9XCJudW1iZXJcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKTtyZXR1cm4gaXQodCl9LG9yLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbih0KXtpZih0eXBlb2YgdCE9XCJudW1iZXJcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKTtyZXR1cm4gbG4uU2xvd0J1ZmZlcih0KX07VHc9YW4sYXI9e30senM9VHcuQnVmZmVyLFRjPXpzLmlzRW5jb2Rpbmd8fGZ1bmN0aW9uKHQpe3N3aXRjaCgodD1cIlwiK3QpJiZ0LnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6Y2FzZVwicmF3XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19O2FyLlN0cmluZ0RlY29kZXI9Y2ksY2kucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQpe2lmKHQubGVuZ3RoPT09MClyZXR1cm5cIlwiO3ZhciBlLHI7aWYodGhpcy5sYXN0TmVlZCl7aWYoKGU9dGhpcy5maWxsTGFzdCh0KSk9PT12b2lkIDApcmV0dXJuXCJcIjtyPXRoaXMubGFzdE5lZWQsdGhpcy5sYXN0TmVlZD0wfWVsc2Ugcj0wO3JldHVybiByPHQubGVuZ3RoP2U/ZSt0aGlzLnRleHQodCxyKTp0aGlzLnRleHQodCxyKTplfHxcIlwifSxjaS5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKHQpe3ZhciBlPXQmJnQubGVuZ3RoP3RoaXMud3JpdGUodCk6XCJcIjtyZXR1cm4gdGhpcy5sYXN0TmVlZD9lK1wiXFx1RkZGRFwiOmV9LGNpLnByb3RvdHlwZS50ZXh0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZnVuY3Rpb24obixvLHMpe3ZhciBhPW8ubGVuZ3RoLTE7aWYoYTxzKXJldHVybiAwO3ZhciB1PVdzKG9bYV0pO3JldHVybiB1Pj0wPyh1PjAmJihuLmxhc3ROZWVkPXUtMSksdSk6LS1hPHN8fHU9PT0tMj8wOih1PVdzKG9bYV0pKT49MD8odT4wJiYobi5sYXN0TmVlZD11LTIpLHUpOi0tYTxzfHx1PT09LTI/MDoodT1XcyhvW2FdKSk+PTA/KHU+MCYmKHU9PT0yP3U9MDpuLmxhc3ROZWVkPXUtMyksdSk6MH0odGhpcyx0LGUpO2lmKCF0aGlzLmxhc3ROZWVkKXJldHVybiB0LnRvU3RyaW5nKFwidXRmOFwiLGUpO3RoaXMubGFzdFRvdGFsPXI7dmFyIGk9dC5sZW5ndGgtKHItdGhpcy5sYXN0TmVlZCk7cmV0dXJuIHQuY29weSh0aGlzLmxhc3RDaGFyLDAsaSksdC50b1N0cmluZyhcInV0ZjhcIixlLGkpfSxjaS5wcm90b3R5cGUuZmlsbExhc3Q9ZnVuY3Rpb24odCl7aWYodGhpcy5sYXN0TmVlZDw9dC5sZW5ndGgpcmV0dXJuIHQuY29weSh0aGlzLmxhc3RDaGFyLHRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQsMCx0aGlzLmxhc3ROZWVkKSx0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsMCx0aGlzLmxhc3RUb3RhbCk7dC5jb3B5KHRoaXMubGFzdENoYXIsdGhpcy5sYXN0VG90YWwtdGhpcy5sYXN0TmVlZCwwLHQubGVuZ3RoKSx0aGlzLmxhc3ROZWVkLT10Lmxlbmd0aH07YXIuU3RyaW5nRGVjb2Rlcjthci5TdHJpbmdEZWNvZGVyfSk7dmFyIExjPXt9O1F0KExjLHtTdHJpbmdEZWNvZGVyOigpPT5NdyxkZWZhdWx0OigpPT5hcn0pO3ZhciBNdyxVYz1iZSgoKT0+e3YoKTttKCk7XygpO1FzKCk7UXMoKTtNdz1hci5TdHJpbmdEZWNvZGVyfSk7dmFyIFlzPU0oKHEyLGpjKT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhciBOYz1VdCgpLHtQcm9taXNlUHJvdG90eXBlVGhlbjpMdyxTeW1ib2xBc3luY0l0ZXJhdG9yOnFjLFN5bWJvbEl0ZXJhdG9yOkRjfT1jZSgpLHtCdWZmZXI6VXd9PSh3ZSgpLFoodmUpKSx7RVJSX0lOVkFMSURfQVJHX1RZUEU6TncsRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUzpxd309U2UoKS5jb2RlcztmdW5jdGlvbiBEdyh0LGUscil7bGV0IGk7aWYodHlwZW9mIGU9PVwic3RyaW5nXCJ8fGUgaW5zdGFuY2VvZiBVdylyZXR1cm4gbmV3IHQoe29iamVjdE1vZGU6ITAsLi4ucixyZWFkKCl7dGhpcy5wdXNoKGUpLHRoaXMucHVzaChudWxsKX19KTtsZXQgbjtpZihlJiZlW3FjXSluPSEwLGk9ZVtxY10oKTtlbHNlIGlmKGUmJmVbRGNdKW49ITEsaT1lW0RjXSgpO2Vsc2UgdGhyb3cgbmV3IE53KFwiaXRlcmFibGVcIixbXCJJdGVyYWJsZVwiXSxlKTtsZXQgbz1uZXcgdCh7b2JqZWN0TW9kZTohMCxoaWdoV2F0ZXJNYXJrOjEsLi4ucn0pLHM9ITE7by5fcmVhZD1mdW5jdGlvbigpe3N8fChzPSEwLHUoKSl9LG8uX2Rlc3Ryb3k9ZnVuY3Rpb24oYyxoKXtMdyhhKGMpLCgpPT5OYy5uZXh0VGljayhoLGMpLGQ9Pk5jLm5leHRUaWNrKGgsZHx8YykpfTthc3luYyBmdW5jdGlvbiBhKGMpe2xldCBoPWMhPW51bGwsZD10eXBlb2YgaS50aHJvdz09XCJmdW5jdGlvblwiO2lmKGgmJmQpe2xldHt2YWx1ZTpnLGRvbmU6eX09YXdhaXQgaS50aHJvdyhjKTtpZihhd2FpdCBnLHkpcmV0dXJufWlmKHR5cGVvZiBpLnJldHVybj09XCJmdW5jdGlvblwiKXtsZXR7dmFsdWU6Z309YXdhaXQgaS5yZXR1cm4oKTthd2FpdCBnfX1hc3luYyBmdW5jdGlvbiB1KCl7Zm9yKDs7KXt0cnl7bGV0e3ZhbHVlOmMsZG9uZTpofT1uP2F3YWl0IGkubmV4dCgpOmkubmV4dCgpO2lmKGgpby5wdXNoKG51bGwpO2Vsc2V7bGV0IGQ9YyYmdHlwZW9mIGMudGhlbj09XCJmdW5jdGlvblwiP2F3YWl0IGM6YztpZihkPT09bnVsbCl0aHJvdyBzPSExLG5ldyBxdztpZihvLnB1c2goZCkpY29udGludWU7cz0hMX19Y2F0Y2goYyl7by5kZXN0cm95KGMpfWJyZWFrfX1yZXR1cm4gb31qYy5leHBvcnRzPUR3fSk7dmFyIGhpPU0oKEcyLFpjKT0+e3YoKTttKCk7XygpO3ZhciBIZT1VdCgpLHtBcnJheVByb3RvdHlwZUluZGV4T2Y6ancsTnVtYmVySXNJbnRlZ2VyOkZ3LE51bWJlcklzTmFOOld3LE51bWJlclBhcnNlSW50OiR3LE9iamVjdERlZmluZVByb3BlcnRpZXM6JGMsT2JqZWN0S2V5czpIdyxPYmplY3RTZXRQcm90b3R5cGVPZjpIYyxQcm9taXNlOlZ3LFNhZmVTZXQ6encsU3ltYm9sQXN5bmNJdGVyYXRvcjpLdyxTeW1ib2w6R3d9PWNlKCk7WmMuZXhwb3J0cz1GO0YuUmVhZGFibGVTdGF0ZT1ybzt2YXJ7RXZlbnRFbWl0dGVyOlF3fT0oaXIoKSxaKHJyKSkse1N0cmVhbTpxdCxwcmVwZW5kTGlzdGVuZXI6WXd9PXRuKCkse0J1ZmZlcjpKc309KHdlKCksWih2ZSkpLHthZGRBYm9ydFNpZ25hbDpKd309ZmkoKSxYdz1tdCgpLEg9SmUoKS5kZWJ1Z2xvZyhcInN0cmVhbVwiLHQ9PntIPXR9KSxadz1kYygpLHFyPXRyKCkse2dldEhpZ2hXYXRlck1hcms6ZV8sZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcms6dF99PXNuKCkse2FnZ3JlZ2F0ZVR3b0Vycm9yczpGYyxjb2Rlczp7RVJSX0lOVkFMSURfQVJHX1RZUEU6cl8sRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQ6aV8sRVJSX09VVF9PRl9SQU5HRTpuXyxFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GOnNfLEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ6b199fT1TZSgpLHt2YWxpZGF0ZU9iamVjdDphX309dWkoKSxscj1HdyhcImtQYXVzZWRcIikse1N0cmluZ0RlY29kZXI6VmN9PShVYygpLFooTGMpKSxsXz1ZcygpO0hjKEYucHJvdG90eXBlLHF0LnByb3RvdHlwZSk7SGMoRixxdCk7dmFyIFhzPSgpPT57fSx7ZXJyb3JPckRlc3Ryb3k6TnJ9PXFyO2Z1bmN0aW9uIHJvKHQsZSxyKXt0eXBlb2YgciE9XCJib29sZWFuXCImJihyPWUgaW5zdGFuY2VvZiBudCgpKSx0aGlzLm9iamVjdE1vZGU9ISEodCYmdC5vYmplY3RNb2RlKSxyJiYodGhpcy5vYmplY3RNb2RlPXRoaXMub2JqZWN0TW9kZXx8ISEodCYmdC5yZWFkYWJsZU9iamVjdE1vZGUpKSx0aGlzLmhpZ2hXYXRlck1hcms9dD9lXyh0aGlzLHQsXCJyZWFkYWJsZUhpZ2hXYXRlck1hcmtcIixyKTp0XyghMSksdGhpcy5idWZmZXI9bmV3IFp3LHRoaXMubGVuZ3RoPTAsdGhpcy5waXBlcz1bXSx0aGlzLmZsb3dpbmc9bnVsbCx0aGlzLmVuZGVkPSExLHRoaXMuZW5kRW1pdHRlZD0hMSx0aGlzLnJlYWRpbmc9ITEsdGhpcy5jb25zdHJ1Y3RlZD0hMCx0aGlzLnN5bmM9ITAsdGhpcy5uZWVkUmVhZGFibGU9ITEsdGhpcy5lbWl0dGVkUmVhZGFibGU9ITEsdGhpcy5yZWFkYWJsZUxpc3RlbmluZz0hMSx0aGlzLnJlc3VtZVNjaGVkdWxlZD0hMSx0aGlzW2xyXT1udWxsLHRoaXMuZXJyb3JFbWl0dGVkPSExLHRoaXMuZW1pdENsb3NlPSF0fHx0LmVtaXRDbG9zZSE9PSExLHRoaXMuYXV0b0Rlc3Ryb3k9IXR8fHQuYXV0b0Rlc3Ryb3khPT0hMSx0aGlzLmRlc3Ryb3llZD0hMSx0aGlzLmVycm9yZWQ9bnVsbCx0aGlzLmNsb3NlZD0hMSx0aGlzLmNsb3NlRW1pdHRlZD0hMSx0aGlzLmRlZmF1bHRFbmNvZGluZz10JiZ0LmRlZmF1bHRFbmNvZGluZ3x8XCJ1dGY4XCIsdGhpcy5hd2FpdERyYWluV3JpdGVycz1udWxsLHRoaXMubXVsdGlBd2FpdERyYWluPSExLHRoaXMucmVhZGluZ01vcmU9ITEsdGhpcy5kYXRhRW1pdHRlZD0hMSx0aGlzLmRlY29kZXI9bnVsbCx0aGlzLmVuY29kaW5nPW51bGwsdCYmdC5lbmNvZGluZyYmKHRoaXMuZGVjb2Rlcj1uZXcgVmModC5lbmNvZGluZyksdGhpcy5lbmNvZGluZz10LmVuY29kaW5nKX1mdW5jdGlvbiBGKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIEYpKXJldHVybiBuZXcgRih0KTtsZXQgZT10aGlzIGluc3RhbmNlb2YgbnQoKTt0aGlzLl9yZWFkYWJsZVN0YXRlPW5ldyBybyh0LHRoaXMsZSksdCYmKHR5cGVvZiB0LnJlYWQ9PVwiZnVuY3Rpb25cIiYmKHRoaXMuX3JlYWQ9dC5yZWFkKSx0eXBlb2YgdC5kZXN0cm95PT1cImZ1bmN0aW9uXCImJih0aGlzLl9kZXN0cm95PXQuZGVzdHJveSksdHlwZW9mIHQuY29uc3RydWN0PT1cImZ1bmN0aW9uXCImJih0aGlzLl9jb25zdHJ1Y3Q9dC5jb25zdHJ1Y3QpLHQuc2lnbmFsJiYhZSYmSncodC5zaWduYWwsdGhpcykpLHF0LmNhbGwodGhpcyx0KSxxci5jb25zdHJ1Y3QodGhpcywoKT0+e3RoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlJiZmbih0aGlzLHRoaXMuX3JlYWRhYmxlU3RhdGUpfSl9Ri5wcm90b3R5cGUuZGVzdHJveT1xci5kZXN0cm95O0YucHJvdG90eXBlLl91bmRlc3Ryb3k9cXIudW5kZXN0cm95O0YucHJvdG90eXBlLl9kZXN0cm95PWZ1bmN0aW9uKHQsZSl7ZSh0KX07Ri5wcm90b3R5cGVbUXcuY2FwdHVyZVJlamVjdGlvblN5bWJvbF09ZnVuY3Rpb24odCl7dGhpcy5kZXN0cm95KHQpfTtGLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHpjKHRoaXMsdCxlLCExKX07Ri5wcm90b3R5cGUudW5zaGlmdD1mdW5jdGlvbih0LGUpe3JldHVybiB6Yyh0aGlzLHQsZSwhMCl9O2Z1bmN0aW9uIHpjKHQsZSxyLGkpe0goXCJyZWFkYWJsZUFkZENodW5rXCIsZSk7bGV0IG49dC5fcmVhZGFibGVTdGF0ZSxvO2lmKG4ub2JqZWN0TW9kZXx8KHR5cGVvZiBlPT1cInN0cmluZ1wiPyhyPXJ8fG4uZGVmYXVsdEVuY29kaW5nLG4uZW5jb2RpbmchPT1yJiYoaSYmbi5lbmNvZGluZz9lPUpzLmZyb20oZSxyKS50b1N0cmluZyhuLmVuY29kaW5nKTooZT1Kcy5mcm9tKGUscikscj1cIlwiKSkpOmUgaW5zdGFuY2VvZiBKcz9yPVwiXCI6cXQuX2lzVWludDhBcnJheShlKT8oZT1xdC5fdWludDhBcnJheVRvQnVmZmVyKGUpLHI9XCJcIik6ZSE9bnVsbCYmKG89bmV3IHJfKFwiY2h1bmtcIixbXCJzdHJpbmdcIixcIkJ1ZmZlclwiLFwiVWludDhBcnJheVwiXSxlKSkpLG8pTnIodCxvKTtlbHNlIGlmKGU9PT1udWxsKW4ucmVhZGluZz0hMSxjXyh0LG4pO2Vsc2UgaWYobi5vYmplY3RNb2RlfHxlJiZlLmxlbmd0aD4wKWlmKGkpaWYobi5lbmRFbWl0dGVkKU5yKHQsbmV3IG9fKTtlbHNle2lmKG4uZGVzdHJveWVkfHxuLmVycm9yZWQpcmV0dXJuITE7WnModCxuLGUsITApfWVsc2UgaWYobi5lbmRlZClOcih0LG5ldyBzXyk7ZWxzZXtpZihuLmRlc3Ryb3llZHx8bi5lcnJvcmVkKXJldHVybiExO24ucmVhZGluZz0hMSxuLmRlY29kZXImJiFyPyhlPW4uZGVjb2Rlci53cml0ZShlKSxuLm9iamVjdE1vZGV8fGUubGVuZ3RoIT09MD9acyh0LG4sZSwhMSk6Zm4odCxuKSk6WnModCxuLGUsITEpfWVsc2UgaXx8KG4ucmVhZGluZz0hMSxmbih0LG4pKTtyZXR1cm4hbi5lbmRlZCYmKG4ubGVuZ3RoPG4uaGlnaFdhdGVyTWFya3x8bi5sZW5ndGg9PT0wKX1mdW5jdGlvbiBacyh0LGUscixpKXtlLmZsb3dpbmcmJmUubGVuZ3RoPT09MCYmIWUuc3luYyYmdC5saXN0ZW5lckNvdW50KFwiZGF0YVwiKT4wPyhlLm11bHRpQXdhaXREcmFpbj9lLmF3YWl0RHJhaW5Xcml0ZXJzLmNsZWFyKCk6ZS5hd2FpdERyYWluV3JpdGVycz1udWxsLGUuZGF0YUVtaXR0ZWQ9ITAsdC5lbWl0KFwiZGF0YVwiLHIpKTooZS5sZW5ndGgrPWUub2JqZWN0TW9kZT8xOnIubGVuZ3RoLGk/ZS5idWZmZXIudW5zaGlmdChyKTplLmJ1ZmZlci5wdXNoKHIpLGUubmVlZFJlYWRhYmxlJiZjbih0KSksZm4odCxlKX1GLnByb3RvdHlwZS5pc1BhdXNlZD1mdW5jdGlvbigpe2xldCB0PXRoaXMuX3JlYWRhYmxlU3RhdGU7cmV0dXJuIHRbbHJdPT09ITB8fHQuZmxvd2luZz09PSExfTtGLnByb3RvdHlwZS5zZXRFbmNvZGluZz1mdW5jdGlvbih0KXtsZXQgZT1uZXcgVmModCk7dGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyPWUsdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZz10aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7bGV0IHI9dGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIsaT1cIlwiO2ZvcihsZXQgbiBvZiByKWkrPWUud3JpdGUobik7cmV0dXJuIHIuY2xlYXIoKSxpIT09XCJcIiYmci5wdXNoKGkpLHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoPWkubGVuZ3RoLHRoaXN9O3ZhciB1Xz0xMDczNzQxODI0O2Z1bmN0aW9uIGZfKHQpe2lmKHQ+dV8pdGhyb3cgbmV3IG5fKFwic2l6ZVwiLFwiPD0gMUdpQlwiLHQpO3JldHVybiB0LS0sdHw9dD4+PjEsdHw9dD4+PjIsdHw9dD4+PjQsdHw9dD4+PjgsdHw9dD4+PjE2LHQrKyx0fWZ1bmN0aW9uIFdjKHQsZSl7cmV0dXJuIHQ8PTB8fGUubGVuZ3RoPT09MCYmZS5lbmRlZD8wOmUub2JqZWN0TW9kZT8xOld3KHQpP2UuZmxvd2luZyYmZS5sZW5ndGg/ZS5idWZmZXIuZmlyc3QoKS5sZW5ndGg6ZS5sZW5ndGg6dDw9ZS5sZW5ndGg/dDplLmVuZGVkP2UubGVuZ3RoOjB9Ri5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtIKFwicmVhZFwiLHQpLHQ9PT12b2lkIDA/dD1OYU46RncodCl8fCh0PSR3KHQsMTApKTtsZXQgZT10aGlzLl9yZWFkYWJsZVN0YXRlLHI9dDtpZih0PmUuaGlnaFdhdGVyTWFyayYmKGUuaGlnaFdhdGVyTWFyaz1mXyh0KSksdCE9PTAmJihlLmVtaXR0ZWRSZWFkYWJsZT0hMSksdD09PTAmJmUubmVlZFJlYWRhYmxlJiYoKGUuaGlnaFdhdGVyTWFyayE9PTA/ZS5sZW5ndGg+PWUuaGlnaFdhdGVyTWFyazplLmxlbmd0aD4wKXx8ZS5lbmRlZCkpcmV0dXJuIEgoXCJyZWFkOiBlbWl0UmVhZGFibGVcIixlLmxlbmd0aCxlLmVuZGVkKSxlLmxlbmd0aD09PTAmJmUuZW5kZWQ/ZW8odGhpcyk6Y24odGhpcyksbnVsbDtpZih0PVdjKHQsZSksdD09PTAmJmUuZW5kZWQpcmV0dXJuIGUubGVuZ3RoPT09MCYmZW8odGhpcyksbnVsbDtsZXQgaT1lLm5lZWRSZWFkYWJsZTtpZihIKFwibmVlZCByZWFkYWJsZVwiLGkpLChlLmxlbmd0aD09PTB8fGUubGVuZ3RoLXQ8ZS5oaWdoV2F0ZXJNYXJrKSYmKGk9ITAsSChcImxlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrXCIsaSkpLGUuZW5kZWR8fGUucmVhZGluZ3x8ZS5kZXN0cm95ZWR8fGUuZXJyb3JlZHx8IWUuY29uc3RydWN0ZWQpaT0hMSxIKFwicmVhZGluZywgZW5kZWQgb3IgY29uc3RydWN0aW5nXCIsaSk7ZWxzZSBpZihpKXtIKFwiZG8gcmVhZFwiKSxlLnJlYWRpbmc9ITAsZS5zeW5jPSEwLGUubGVuZ3RoPT09MCYmKGUubmVlZFJlYWRhYmxlPSEwKTt0cnl7dGhpcy5fcmVhZChlLmhpZ2hXYXRlck1hcmspfWNhdGNoKG8pe05yKHRoaXMsbyl9ZS5zeW5jPSExLGUucmVhZGluZ3x8KHQ9V2MocixlKSl9bGV0IG47cmV0dXJuIHQ+MD9uPUpjKHQsZSk6bj1udWxsLG49PT1udWxsPyhlLm5lZWRSZWFkYWJsZT1lLmxlbmd0aDw9ZS5oaWdoV2F0ZXJNYXJrLHQ9MCk6KGUubGVuZ3RoLT10LGUubXVsdGlBd2FpdERyYWluP2UuYXdhaXREcmFpbldyaXRlcnMuY2xlYXIoKTplLmF3YWl0RHJhaW5Xcml0ZXJzPW51bGwpLGUubGVuZ3RoPT09MCYmKGUuZW5kZWR8fChlLm5lZWRSZWFkYWJsZT0hMCksciE9PXQmJmUuZW5kZWQmJmVvKHRoaXMpKSxuIT09bnVsbCYmIWUuZXJyb3JFbWl0dGVkJiYhZS5jbG9zZUVtaXR0ZWQmJihlLmRhdGFFbWl0dGVkPSEwLHRoaXMuZW1pdChcImRhdGFcIixuKSksbn07ZnVuY3Rpb24gY18odCxlKXtpZihIKFwib25Fb2ZDaHVua1wiKSwhZS5lbmRlZCl7aWYoZS5kZWNvZGVyKXtsZXQgcj1lLmRlY29kZXIuZW5kKCk7ciYmci5sZW5ndGgmJihlLmJ1ZmZlci5wdXNoKHIpLGUubGVuZ3RoKz1lLm9iamVjdE1vZGU/MTpyLmxlbmd0aCl9ZS5lbmRlZD0hMCxlLnN5bmM/Y24odCk6KGUubmVlZFJlYWRhYmxlPSExLGUuZW1pdHRlZFJlYWRhYmxlPSEwLEtjKHQpKX19ZnVuY3Rpb24gY24odCl7bGV0IGU9dC5fcmVhZGFibGVTdGF0ZTtIKFwiZW1pdFJlYWRhYmxlXCIsZS5uZWVkUmVhZGFibGUsZS5lbWl0dGVkUmVhZGFibGUpLGUubmVlZFJlYWRhYmxlPSExLGUuZW1pdHRlZFJlYWRhYmxlfHwoSChcImVtaXRSZWFkYWJsZVwiLGUuZmxvd2luZyksZS5lbWl0dGVkUmVhZGFibGU9ITAsSGUubmV4dFRpY2soS2MsdCkpfWZ1bmN0aW9uIEtjKHQpe2xldCBlPXQuX3JlYWRhYmxlU3RhdGU7SChcImVtaXRSZWFkYWJsZV9cIixlLmRlc3Ryb3llZCxlLmxlbmd0aCxlLmVuZGVkKSwhZS5kZXN0cm95ZWQmJiFlLmVycm9yZWQmJihlLmxlbmd0aHx8ZS5lbmRlZCkmJih0LmVtaXQoXCJyZWFkYWJsZVwiKSxlLmVtaXR0ZWRSZWFkYWJsZT0hMSksZS5uZWVkUmVhZGFibGU9IWUuZmxvd2luZyYmIWUuZW5kZWQmJmUubGVuZ3RoPD1lLmhpZ2hXYXRlck1hcmssUWModCl9ZnVuY3Rpb24gZm4odCxlKXshZS5yZWFkaW5nTW9yZSYmZS5jb25zdHJ1Y3RlZCYmKGUucmVhZGluZ01vcmU9ITAsSGUubmV4dFRpY2soaF8sdCxlKSl9ZnVuY3Rpb24gaF8odCxlKXtmb3IoOyFlLnJlYWRpbmcmJiFlLmVuZGVkJiYoZS5sZW5ndGg8ZS5oaWdoV2F0ZXJNYXJrfHxlLmZsb3dpbmcmJmUubGVuZ3RoPT09MCk7KXtsZXQgcj1lLmxlbmd0aDtpZihIKFwibWF5YmVSZWFkTW9yZSByZWFkIDBcIiksdC5yZWFkKDApLHI9PT1lLmxlbmd0aClicmVha31lLnJlYWRpbmdNb3JlPSExfUYucHJvdG90eXBlLl9yZWFkPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBpXyhcIl9yZWFkKClcIil9O0YucHJvdG90eXBlLnBpcGU9ZnVuY3Rpb24odCxlKXtsZXQgcj10aGlzLGk9dGhpcy5fcmVhZGFibGVTdGF0ZTtpLnBpcGVzLmxlbmd0aD09PTEmJihpLm11bHRpQXdhaXREcmFpbnx8KGkubXVsdGlBd2FpdERyYWluPSEwLGkuYXdhaXREcmFpbldyaXRlcnM9bmV3IHp3KGkuYXdhaXREcmFpbldyaXRlcnM/W2kuYXdhaXREcmFpbldyaXRlcnNdOltdKSkpLGkucGlwZXMucHVzaCh0KSxIKFwicGlwZSBjb3VudD0lZCBvcHRzPSVqXCIsaS5waXBlcy5sZW5ndGgsZSk7bGV0IG89KCFlfHxlLmVuZCE9PSExKSYmdCE9PUhlLnN0ZG91dCYmdCE9PUhlLnN0ZGVycj9hOlM7aS5lbmRFbWl0dGVkP0hlLm5leHRUaWNrKG8pOnIub25jZShcImVuZFwiLG8pLHQub24oXCJ1bnBpcGVcIixzKTtmdW5jdGlvbiBzKEksQyl7SChcIm9udW5waXBlXCIpLEk9PT1yJiZDJiZDLmhhc1VucGlwZWQ9PT0hMSYmKEMuaGFzVW5waXBlZD0hMCxoKCkpfWZ1bmN0aW9uIGEoKXtIKFwib25lbmRcIiksdC5lbmQoKX1sZXQgdSxjPSExO2Z1bmN0aW9uIGgoKXtIKFwiY2xlYW51cFwiKSx0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIix3KSx0LnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsRSksdSYmdC5yZW1vdmVMaXN0ZW5lcihcImRyYWluXCIsdSksdC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIseSksdC5yZW1vdmVMaXN0ZW5lcihcInVucGlwZVwiLHMpLHIucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixhKSxyLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsUyksci5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIixnKSxjPSEwLHUmJmkuYXdhaXREcmFpbldyaXRlcnMmJighdC5fd3JpdGFibGVTdGF0ZXx8dC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pJiZ1KCl9ZnVuY3Rpb24gZCgpe2N8fChpLnBpcGVzLmxlbmd0aD09PTEmJmkucGlwZXNbMF09PT10PyhIKFwiZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlXCIsMCksaS5hd2FpdERyYWluV3JpdGVycz10LGkubXVsdGlBd2FpdERyYWluPSExKTppLnBpcGVzLmxlbmd0aD4xJiZpLnBpcGVzLmluY2x1ZGVzKHQpJiYoSChcImZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZVwiLGkuYXdhaXREcmFpbldyaXRlcnMuc2l6ZSksaS5hd2FpdERyYWluV3JpdGVycy5hZGQodCkpLHIucGF1c2UoKSksdXx8KHU9ZF8ocix0KSx0Lm9uKFwiZHJhaW5cIix1KSl9ci5vbihcImRhdGFcIixnKTtmdW5jdGlvbiBnKEkpe0goXCJvbmRhdGFcIik7bGV0IEM9dC53cml0ZShJKTtIKFwiZGVzdC53cml0ZVwiLEMpLEM9PT0hMSYmZCgpfWZ1bmN0aW9uIHkoSSl7aWYoSChcIm9uZXJyb3JcIixJKSxTKCksdC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIseSksdC5saXN0ZW5lckNvdW50KFwiZXJyb3JcIik9PT0wKXtsZXQgQz10Ll93cml0YWJsZVN0YXRlfHx0Ll9yZWFkYWJsZVN0YXRlO0MmJiFDLmVycm9yRW1pdHRlZD9Ocih0LEkpOnQuZW1pdChcImVycm9yXCIsSSl9fVl3KHQsXCJlcnJvclwiLHkpO2Z1bmN0aW9uIHcoKXt0LnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsRSksUygpfXQub25jZShcImNsb3NlXCIsdyk7ZnVuY3Rpb24gRSgpe0goXCJvbmZpbmlzaFwiKSx0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIix3KSxTKCl9dC5vbmNlKFwiZmluaXNoXCIsRSk7ZnVuY3Rpb24gUygpe0goXCJ1bnBpcGVcIiksci51bnBpcGUodCl9cmV0dXJuIHQuZW1pdChcInBpcGVcIixyKSx0LndyaXRhYmxlTmVlZERyYWluPT09ITA/aS5mbG93aW5nJiZkKCk6aS5mbG93aW5nfHwoSChcInBpcGUgcmVzdW1lXCIpLHIucmVzdW1lKCkpLHR9O2Z1bmN0aW9uIGRfKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKCl7bGV0IGk9dC5fcmVhZGFibGVTdGF0ZTtpLmF3YWl0RHJhaW5Xcml0ZXJzPT09ZT8oSChcInBpcGVPbkRyYWluXCIsMSksaS5hd2FpdERyYWluV3JpdGVycz1udWxsKTppLm11bHRpQXdhaXREcmFpbiYmKEgoXCJwaXBlT25EcmFpblwiLGkuYXdhaXREcmFpbldyaXRlcnMuc2l6ZSksaS5hd2FpdERyYWluV3JpdGVycy5kZWxldGUoZSkpLCghaS5hd2FpdERyYWluV3JpdGVyc3x8aS5hd2FpdERyYWluV3JpdGVycy5zaXplPT09MCkmJnQubGlzdGVuZXJDb3VudChcImRhdGFcIikmJnQucmVzdW1lKCl9fUYucHJvdG90eXBlLnVucGlwZT1mdW5jdGlvbih0KXtsZXQgZT10aGlzLl9yZWFkYWJsZVN0YXRlLHI9e2hhc1VucGlwZWQ6ITF9O2lmKGUucGlwZXMubGVuZ3RoPT09MClyZXR1cm4gdGhpcztpZighdCl7bGV0IG49ZS5waXBlcztlLnBpcGVzPVtdLHRoaXMucGF1c2UoKTtmb3IobGV0IG89MDtvPG4ubGVuZ3RoO28rKyluW29dLmVtaXQoXCJ1bnBpcGVcIix0aGlzLHtoYXNVbnBpcGVkOiExfSk7cmV0dXJuIHRoaXN9bGV0IGk9ancoZS5waXBlcyx0KTtyZXR1cm4gaT09PS0xP3RoaXM6KGUucGlwZXMuc3BsaWNlKGksMSksZS5waXBlcy5sZW5ndGg9PT0wJiZ0aGlzLnBhdXNlKCksdC5lbWl0KFwidW5waXBlXCIsdGhpcyxyKSx0aGlzKX07Ri5wcm90b3R5cGUub249ZnVuY3Rpb24odCxlKXtsZXQgcj1xdC5wcm90b3R5cGUub24uY2FsbCh0aGlzLHQsZSksaT10aGlzLl9yZWFkYWJsZVN0YXRlO3JldHVybiB0PT09XCJkYXRhXCI/KGkucmVhZGFibGVMaXN0ZW5pbmc9dGhpcy5saXN0ZW5lckNvdW50KFwicmVhZGFibGVcIik+MCxpLmZsb3dpbmchPT0hMSYmdGhpcy5yZXN1bWUoKSk6dD09PVwicmVhZGFibGVcIiYmIWkuZW5kRW1pdHRlZCYmIWkucmVhZGFibGVMaXN0ZW5pbmcmJihpLnJlYWRhYmxlTGlzdGVuaW5nPWkubmVlZFJlYWRhYmxlPSEwLGkuZmxvd2luZz0hMSxpLmVtaXR0ZWRSZWFkYWJsZT0hMSxIKFwib24gcmVhZGFibGVcIixpLmxlbmd0aCxpLnJlYWRpbmcpLGkubGVuZ3RoP2NuKHRoaXMpOmkucmVhZGluZ3x8SGUubmV4dFRpY2socF8sdGhpcykpLHJ9O0YucHJvdG90eXBlLmFkZExpc3RlbmVyPUYucHJvdG90eXBlLm9uO0YucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7bGV0IHI9cXQucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcyx0LGUpO3JldHVybiB0PT09XCJyZWFkYWJsZVwiJiZIZS5uZXh0VGljayhHYyx0aGlzKSxyfTtGLnByb3RvdHlwZS5vZmY9Ri5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7Ri5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWZ1bmN0aW9uKHQpe2xldCBlPXF0LnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybih0PT09XCJyZWFkYWJsZVwifHx0PT09dm9pZCAwKSYmSGUubmV4dFRpY2soR2MsdGhpcyksZX07ZnVuY3Rpb24gR2ModCl7bGV0IGU9dC5fcmVhZGFibGVTdGF0ZTtlLnJlYWRhYmxlTGlzdGVuaW5nPXQubGlzdGVuZXJDb3VudChcInJlYWRhYmxlXCIpPjAsZS5yZXN1bWVTY2hlZHVsZWQmJmVbbHJdPT09ITE/ZS5mbG93aW5nPSEwOnQubGlzdGVuZXJDb3VudChcImRhdGFcIik+MD90LnJlc3VtZSgpOmUucmVhZGFibGVMaXN0ZW5pbmd8fChlLmZsb3dpbmc9bnVsbCl9ZnVuY3Rpb24gcF8odCl7SChcInJlYWRhYmxlIG5leHR0aWNrIHJlYWQgMFwiKSx0LnJlYWQoMCl9Ri5wcm90b3R5cGUucmVzdW1lPWZ1bmN0aW9uKCl7bGV0IHQ9dGhpcy5fcmVhZGFibGVTdGF0ZTtyZXR1cm4gdC5mbG93aW5nfHwoSChcInJlc3VtZVwiKSx0LmZsb3dpbmc9IXQucmVhZGFibGVMaXN0ZW5pbmcsZ18odGhpcyx0KSksdFtscl09ITEsdGhpc307ZnVuY3Rpb24gZ18odCxlKXtlLnJlc3VtZVNjaGVkdWxlZHx8KGUucmVzdW1lU2NoZWR1bGVkPSEwLEhlLm5leHRUaWNrKHlfLHQsZSkpfWZ1bmN0aW9uIHlfKHQsZSl7SChcInJlc3VtZVwiLGUucmVhZGluZyksZS5yZWFkaW5nfHx0LnJlYWQoMCksZS5yZXN1bWVTY2hlZHVsZWQ9ITEsdC5lbWl0KFwicmVzdW1lXCIpLFFjKHQpLGUuZmxvd2luZyYmIWUucmVhZGluZyYmdC5yZWFkKDApfUYucHJvdG90eXBlLnBhdXNlPWZ1bmN0aW9uKCl7cmV0dXJuIEgoXCJjYWxsIHBhdXNlIGZsb3dpbmc9JWpcIix0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpLHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyE9PSExJiYoSChcInBhdXNlXCIpLHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZz0hMSx0aGlzLmVtaXQoXCJwYXVzZVwiKSksdGhpcy5fcmVhZGFibGVTdGF0ZVtscl09ITAsdGhpc307ZnVuY3Rpb24gUWModCl7bGV0IGU9dC5fcmVhZGFibGVTdGF0ZTtmb3IoSChcImZsb3dcIixlLmZsb3dpbmcpO2UuZmxvd2luZyYmdC5yZWFkKCkhPT1udWxsOyk7fUYucHJvdG90eXBlLndyYXA9ZnVuY3Rpb24odCl7bGV0IGU9ITE7dC5vbihcImRhdGFcIixpPT57IXRoaXMucHVzaChpKSYmdC5wYXVzZSYmKGU9ITAsdC5wYXVzZSgpKX0pLHQub24oXCJlbmRcIiwoKT0+e3RoaXMucHVzaChudWxsKX0pLHQub24oXCJlcnJvclwiLGk9PntOcih0aGlzLGkpfSksdC5vbihcImNsb3NlXCIsKCk9Pnt0aGlzLmRlc3Ryb3koKX0pLHQub24oXCJkZXN0cm95XCIsKCk9Pnt0aGlzLmRlc3Ryb3koKX0pLHRoaXMuX3JlYWQ9KCk9PntlJiZ0LnJlc3VtZSYmKGU9ITEsdC5yZXN1bWUoKSl9O2xldCByPUh3KHQpO2ZvcihsZXQgaT0xO2k8ci5sZW5ndGg7aSsrKXtsZXQgbj1yW2ldO3RoaXNbbl09PT12b2lkIDAmJnR5cGVvZiB0W25dPT1cImZ1bmN0aW9uXCImJih0aGlzW25dPXRbbl0uYmluZCh0KSl9cmV0dXJuIHRoaXN9O0YucHJvdG90eXBlW0t3XT1mdW5jdGlvbigpe3JldHVybiBZYyh0aGlzKX07Ri5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24odCl7cmV0dXJuIHQhPT12b2lkIDAmJmFfKHQsXCJvcHRpb25zXCIpLFljKHRoaXMsdCl9O2Z1bmN0aW9uIFljKHQsZSl7dHlwZW9mIHQucmVhZCE9XCJmdW5jdGlvblwiJiYodD1GLndyYXAodCx7b2JqZWN0TW9kZTohMH0pKTtsZXQgcj1iXyh0LGUpO3JldHVybiByLnN0cmVhbT10LHJ9YXN5bmMgZnVuY3Rpb24qYl8odCxlKXtsZXQgcj1YcztmdW5jdGlvbiBpKHMpe3RoaXM9PT10PyhyKCkscj1Ycyk6cj1zfXQub24oXCJyZWFkYWJsZVwiLGkpO2xldCBuLG89WHcodCx7d3JpdGFibGU6ITF9LHM9PntuPXM/RmMobixzKTpudWxsLHIoKSxyPVhzfSk7dHJ5e2Zvcig7Oyl7bGV0IHM9dC5kZXN0cm95ZWQ/bnVsbDp0LnJlYWQoKTtpZihzIT09bnVsbCl5aWVsZCBzO2Vsc2V7aWYobil0aHJvdyBuO2lmKG49PT1udWxsKXJldHVybjthd2FpdCBuZXcgVncoaSl9fX1jYXRjaChzKXt0aHJvdyBuPUZjKG4scyksbn1maW5hbGx5eyhufHxlPy5kZXN0cm95T25SZXR1cm4hPT0hMSkmJihuPT09dm9pZCAwfHx0Ll9yZWFkYWJsZVN0YXRlLmF1dG9EZXN0cm95KT9xci5kZXN0cm95ZXIodCxudWxsKToodC5vZmYoXCJyZWFkYWJsZVwiLGkpLG8oKSl9fSRjKEYucHJvdG90eXBlLHtyZWFkYWJsZTp7X19wcm90b19fOm51bGwsZ2V0KCl7bGV0IHQ9dGhpcy5fcmVhZGFibGVTdGF0ZTtyZXR1cm4hIXQmJnQucmVhZGFibGUhPT0hMSYmIXQuZGVzdHJveWVkJiYhdC5lcnJvckVtaXR0ZWQmJiF0LmVuZEVtaXR0ZWR9LHNldCh0KXt0aGlzLl9yZWFkYWJsZVN0YXRlJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkYWJsZT0hIXQpfX0scmVhZGFibGVEaWRSZWFkOntfX3Byb3RvX186bnVsbCxlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkfX0scmVhZGFibGVBYm9ydGVkOntfX3Byb3RvX186bnVsbCxlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiEhKHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGFibGUhPT0hMSYmKHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkfHx0aGlzLl9yZWFkYWJsZVN0YXRlLmVycm9yZWQpJiYhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKX19LHJlYWRhYmxlSGlnaFdhdGVyTWFyazp7X19wcm90b19fOm51bGwsZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrfX0scmVhZGFibGVCdWZmZXI6e19fcHJvdG9fXzpudWxsLGVudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyfX0scmVhZGFibGVGbG93aW5nOntfX3Byb3RvX186bnVsbCxlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmd9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9yZWFkYWJsZVN0YXRlJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nPXQpfX0scmVhZGFibGVMZW5ndGg6e19fcHJvdG9fXzpudWxsLGVudW1lcmFibGU6ITEsZ2V0KCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RofX0scmVhZGFibGVPYmplY3RNb2RlOntfX3Byb3RvX186bnVsbCxlbnVtZXJhYmxlOiExLGdldCgpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlP3RoaXMuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZTohMX19LHJlYWRhYmxlRW5jb2Rpbmc6e19fcHJvdG9fXzpudWxsLGVudW1lcmFibGU6ITEsZ2V0KCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGU/dGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZzpudWxsfX0sZXJyb3JlZDp7X19wcm90b19fOm51bGwsZW51bWVyYWJsZTohMSxnZXQoKXtyZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZT90aGlzLl9yZWFkYWJsZVN0YXRlLmVycm9yZWQ6bnVsbH19LGNsb3NlZDp7X19wcm90b19fOm51bGwsZ2V0KCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGU/dGhpcy5fcmVhZGFibGVTdGF0ZS5jbG9zZWQ6ITF9fSxkZXN0cm95ZWQ6e19fcHJvdG9fXzpudWxsLGVudW1lcmFibGU6ITEsZ2V0KCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGU/dGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ6ITF9LHNldCh0KXt0aGlzLl9yZWFkYWJsZVN0YXRlJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9dCl9fSxyZWFkYWJsZUVuZGVkOntfX3Byb3RvX186bnVsbCxlbnVtZXJhYmxlOiExLGdldCgpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlP3RoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDohMX19fSk7JGMocm8ucHJvdG90eXBlLHtwaXBlc0NvdW50OntfX3Byb3RvX186bnVsbCxnZXQoKXtyZXR1cm4gdGhpcy5waXBlcy5sZW5ndGh9fSxwYXVzZWQ6e19fcHJvdG9fXzpudWxsLGdldCgpe3JldHVybiB0aGlzW2xyXSE9PSExfSxzZXQodCl7dGhpc1tscl09ISF0fX19KTtGLl9mcm9tTGlzdD1KYztmdW5jdGlvbiBKYyh0LGUpe2lmKGUubGVuZ3RoPT09MClyZXR1cm4gbnVsbDtsZXQgcjtyZXR1cm4gZS5vYmplY3RNb2RlP3I9ZS5idWZmZXIuc2hpZnQoKTohdHx8dD49ZS5sZW5ndGg/KGUuZGVjb2Rlcj9yPWUuYnVmZmVyLmpvaW4oXCJcIik6ZS5idWZmZXIubGVuZ3RoPT09MT9yPWUuYnVmZmVyLmZpcnN0KCk6cj1lLmJ1ZmZlci5jb25jYXQoZS5sZW5ndGgpLGUuYnVmZmVyLmNsZWFyKCkpOnI9ZS5idWZmZXIuY29uc3VtZSh0LGUuZGVjb2Rlcikscn1mdW5jdGlvbiBlbyh0KXtsZXQgZT10Ll9yZWFkYWJsZVN0YXRlO0goXCJlbmRSZWFkYWJsZVwiLGUuZW5kRW1pdHRlZCksZS5lbmRFbWl0dGVkfHwoZS5lbmRlZD0hMCxIZS5uZXh0VGljayh3XyxlLHQpKX1mdW5jdGlvbiB3Xyh0LGUpe2lmKEgoXCJlbmRSZWFkYWJsZU5UXCIsdC5lbmRFbWl0dGVkLHQubGVuZ3RoKSwhdC5lcnJvcmVkJiYhdC5jbG9zZUVtaXR0ZWQmJiF0LmVuZEVtaXR0ZWQmJnQubGVuZ3RoPT09MCl7aWYodC5lbmRFbWl0dGVkPSEwLGUuZW1pdChcImVuZFwiKSxlLndyaXRhYmxlJiZlLmFsbG93SGFsZk9wZW49PT0hMSlIZS5uZXh0VGljayhfXyxlKTtlbHNlIGlmKHQuYXV0b0Rlc3Ryb3kpe2xldCByPWUuX3dyaXRhYmxlU3RhdGU7KCFyfHxyLmF1dG9EZXN0cm95JiYoci5maW5pc2hlZHx8ci53cml0YWJsZT09PSExKSkmJmUuZGVzdHJveSgpfX19ZnVuY3Rpb24gX18odCl7dC53cml0YWJsZSYmIXQud3JpdGFibGVFbmRlZCYmIXQuZGVzdHJveWVkJiZ0LmVuZCgpfUYuZnJvbT1mdW5jdGlvbih0LGUpe3JldHVybiBsXyhGLHQsZSl9O3ZhciB0bztmdW5jdGlvbiBYYygpe3JldHVybiB0bz09PXZvaWQgMCYmKHRvPXt9KSx0b31GLmZyb21XZWI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gWGMoKS5uZXdTdHJlYW1SZWFkYWJsZUZyb21SZWFkYWJsZVN0cmVhbSh0LGUpfTtGLnRvV2ViPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFhjKCkubmV3UmVhZGFibGVTdHJlYW1Gcm9tU3RyZWFtUmVhZGFibGUodCxlKX07Ri53cmFwPWZ1bmN0aW9uKHQsZSl7dmFyIHIsaTtyZXR1cm4gbmV3IEYoe29iamVjdE1vZGU6KHI9KGk9dC5yZWFkYWJsZU9iamVjdE1vZGUpIT09bnVsbCYmaSE9PXZvaWQgMD9pOnQub2JqZWN0TW9kZSkhPT1udWxsJiZyIT09dm9pZCAwP3I6ITAsLi4uZSxkZXN0cm95KG4sbyl7cXIuZGVzdHJveWVyKHQsbiksbyhuKX19KS53cmFwKHQpfX0pO3ZhciB1bz1NKChuUixjaCk9Pnt2KCk7bSgpO18oKTt2YXIgdXI9VXQoKSx7QXJyYXlQcm90b3R5cGVTbGljZTpyaCxFcnJvcjptXyxGdW5jdGlvblByb3RvdHlwZVN5bWJvbEhhc0luc3RhbmNlOmloLE9iamVjdERlZmluZVByb3BlcnR5Om5oLE9iamVjdERlZmluZVByb3BlcnRpZXM6dl8sT2JqZWN0U2V0UHJvdG90eXBlT2Y6c2gsU3RyaW5nUHJvdG90eXBlVG9Mb3dlckNhc2U6RV8sU3ltYm9sOlNfLFN5bWJvbEhhc0luc3RhbmNlOkFffT1jZSgpO2NoLmV4cG9ydHM9aWU7aWUuV3JpdGFibGVTdGF0ZT1naTt2YXJ7RXZlbnRFbWl0dGVyOklffT0oaXIoKSxaKHJyKSksZGk9dG4oKS5TdHJlYW0se0J1ZmZlcjpobn09KHdlKCksWih2ZSkpLGduPXRyKCkse2FkZEFib3J0U2lnbmFsOlRffT1maSgpLHtnZXRIaWdoV2F0ZXJNYXJrOlJfLGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrOkNffT1zbigpLHtFUlJfSU5WQUxJRF9BUkdfVFlQRTpCXyxFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRDpQXyxFUlJfTVVMVElQTEVfQ0FMTEJBQ0s6b2gsRVJSX1NUUkVBTV9DQU5OT1RfUElQRTpPXyxFUlJfU1RSRUFNX0RFU1RST1lFRDpwaSxFUlJfU1RSRUFNX0FMUkVBRFlfRklOSVNIRUQ6a18sRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUzp4XyxFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORDpNXyxFUlJfVU5LTk9XTl9FTkNPRElORzphaH09U2UoKS5jb2Rlcyx7ZXJyb3JPckRlc3Ryb3k6RHJ9PWduO3NoKGllLnByb3RvdHlwZSxkaS5wcm90b3R5cGUpO3NoKGllLGRpKTtmdW5jdGlvbiBzbygpe312YXIganI9U18oXCJrT25GaW5pc2hlZFwiKTtmdW5jdGlvbiBnaSh0LGUscil7dHlwZW9mIHIhPVwiYm9vbGVhblwiJiYocj1lIGluc3RhbmNlb2YgbnQoKSksdGhpcy5vYmplY3RNb2RlPSEhKHQmJnQub2JqZWN0TW9kZSksciYmKHRoaXMub2JqZWN0TW9kZT10aGlzLm9iamVjdE1vZGV8fCEhKHQmJnQud3JpdGFibGVPYmplY3RNb2RlKSksdGhpcy5oaWdoV2F0ZXJNYXJrPXQ/Ul8odGhpcyx0LFwid3JpdGFibGVIaWdoV2F0ZXJNYXJrXCIscik6Q18oITEpLHRoaXMuZmluYWxDYWxsZWQ9ITEsdGhpcy5uZWVkRHJhaW49ITEsdGhpcy5lbmRpbmc9ITEsdGhpcy5lbmRlZD0hMSx0aGlzLmZpbmlzaGVkPSExLHRoaXMuZGVzdHJveWVkPSExO2xldCBpPSEhKHQmJnQuZGVjb2RlU3RyaW5ncz09PSExKTt0aGlzLmRlY29kZVN0cmluZ3M9IWksdGhpcy5kZWZhdWx0RW5jb2Rpbmc9dCYmdC5kZWZhdWx0RW5jb2Rpbmd8fFwidXRmOFwiLHRoaXMubGVuZ3RoPTAsdGhpcy53cml0aW5nPSExLHRoaXMuY29ya2VkPTAsdGhpcy5zeW5jPSEwLHRoaXMuYnVmZmVyUHJvY2Vzc2luZz0hMSx0aGlzLm9ud3JpdGU9VV8uYmluZCh2b2lkIDAsZSksdGhpcy53cml0ZWNiPW51bGwsdGhpcy53cml0ZWxlbj0wLHRoaXMuYWZ0ZXJXcml0ZVRpY2tJbmZvPW51bGwscG4odGhpcyksdGhpcy5wZW5kaW5nY2I9MCx0aGlzLmNvbnN0cnVjdGVkPSEwLHRoaXMucHJlZmluaXNoZWQ9ITEsdGhpcy5lcnJvckVtaXR0ZWQ9ITEsdGhpcy5lbWl0Q2xvc2U9IXR8fHQuZW1pdENsb3NlIT09ITEsdGhpcy5hdXRvRGVzdHJveT0hdHx8dC5hdXRvRGVzdHJveSE9PSExLHRoaXMuZXJyb3JlZD1udWxsLHRoaXMuY2xvc2VkPSExLHRoaXMuY2xvc2VFbWl0dGVkPSExLHRoaXNbanJdPVtdfWZ1bmN0aW9uIHBuKHQpe3QuYnVmZmVyZWQ9W10sdC5idWZmZXJlZEluZGV4PTAsdC5hbGxCdWZmZXJzPSEwLHQuYWxsTm9vcD0hMH1naS5wcm90b3R5cGUuZ2V0QnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHJoKHRoaXMuYnVmZmVyZWQsdGhpcy5idWZmZXJlZEluZGV4KX07bmgoZ2kucHJvdG90eXBlLFwiYnVmZmVyZWRSZXF1ZXN0Q291bnRcIix7X19wcm90b19fOm51bGwsZ2V0KCl7cmV0dXJuIHRoaXMuYnVmZmVyZWQubGVuZ3RoLXRoaXMuYnVmZmVyZWRJbmRleH19KTtmdW5jdGlvbiBpZSh0KXtsZXQgZT10aGlzIGluc3RhbmNlb2YgbnQoKTtpZighZSYmIWloKGllLHRoaXMpKXJldHVybiBuZXcgaWUodCk7dGhpcy5fd3JpdGFibGVTdGF0ZT1uZXcgZ2kodCx0aGlzLGUpLHQmJih0eXBlb2YgdC53cml0ZT09XCJmdW5jdGlvblwiJiYodGhpcy5fd3JpdGU9dC53cml0ZSksdHlwZW9mIHQud3JpdGV2PT1cImZ1bmN0aW9uXCImJih0aGlzLl93cml0ZXY9dC53cml0ZXYpLHR5cGVvZiB0LmRlc3Ryb3k9PVwiZnVuY3Rpb25cIiYmKHRoaXMuX2Rlc3Ryb3k9dC5kZXN0cm95KSx0eXBlb2YgdC5maW5hbD09XCJmdW5jdGlvblwiJiYodGhpcy5fZmluYWw9dC5maW5hbCksdHlwZW9mIHQuY29uc3RydWN0PT1cImZ1bmN0aW9uXCImJih0aGlzLl9jb25zdHJ1Y3Q9dC5jb25zdHJ1Y3QpLHQuc2lnbmFsJiZUXyh0LnNpZ25hbCx0aGlzKSksZGkuY2FsbCh0aGlzLHQpLGduLmNvbnN0cnVjdCh0aGlzLCgpPT57bGV0IHI9dGhpcy5fd3JpdGFibGVTdGF0ZTtyLndyaXRpbmd8fGFvKHRoaXMsciksbG8odGhpcyxyKX0pfW5oKGllLEFfLHtfX3Byb3RvX186bnVsbCx2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gaWgodGhpcyx0KT8hMDp0aGlzIT09aWU/ITE6dCYmdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIGdpfX0pO2llLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKCl7RHIodGhpcyxuZXcgT18pfTtmdW5jdGlvbiBsaCh0LGUscixpKXtsZXQgbj10Ll93cml0YWJsZVN0YXRlO2lmKHR5cGVvZiByPT1cImZ1bmN0aW9uXCIpaT1yLHI9bi5kZWZhdWx0RW5jb2Rpbmc7ZWxzZXtpZighcilyPW4uZGVmYXVsdEVuY29kaW5nO2Vsc2UgaWYociE9PVwiYnVmZmVyXCImJiFobi5pc0VuY29kaW5nKHIpKXRocm93IG5ldyBhaChyKTt0eXBlb2YgaSE9XCJmdW5jdGlvblwiJiYoaT1zbyl9aWYoZT09PW51bGwpdGhyb3cgbmV3IHhfO2lmKCFuLm9iamVjdE1vZGUpaWYodHlwZW9mIGU9PVwic3RyaW5nXCIpbi5kZWNvZGVTdHJpbmdzIT09ITEmJihlPWhuLmZyb20oZSxyKSxyPVwiYnVmZmVyXCIpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIGhuKXI9XCJidWZmZXJcIjtlbHNlIGlmKGRpLl9pc1VpbnQ4QXJyYXkoZSkpZT1kaS5fdWludDhBcnJheVRvQnVmZmVyKGUpLHI9XCJidWZmZXJcIjtlbHNlIHRocm93IG5ldyBCXyhcImNodW5rXCIsW1wic3RyaW5nXCIsXCJCdWZmZXJcIixcIlVpbnQ4QXJyYXlcIl0sZSk7bGV0IG87cmV0dXJuIG4uZW5kaW5nP289bmV3IE1fOm4uZGVzdHJveWVkJiYobz1uZXcgcGkoXCJ3cml0ZVwiKSksbz8odXIubmV4dFRpY2soaSxvKSxEcih0LG8sITApLG8pOihuLnBlbmRpbmdjYisrLExfKHQsbixlLHIsaSkpfWllLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUscil7cmV0dXJuIGxoKHRoaXMsdCxlLHIpPT09ITB9O2llLnByb3RvdHlwZS5jb3JrPWZ1bmN0aW9uKCl7dGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrK307aWUucHJvdG90eXBlLnVuY29yaz1mdW5jdGlvbigpe2xldCB0PXRoaXMuX3dyaXRhYmxlU3RhdGU7dC5jb3JrZWQmJih0LmNvcmtlZC0tLHQud3JpdGluZ3x8YW8odGhpcyx0KSl9O2llLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2Rpbmc9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGU9PVwic3RyaW5nXCImJihlPUVfKGUpKSwhaG4uaXNFbmNvZGluZyhlKSl0aHJvdyBuZXcgYWgoZSk7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nPWUsdGhpc307ZnVuY3Rpb24gTF8odCxlLHIsaSxuKXtsZXQgbz1lLm9iamVjdE1vZGU/MTpyLmxlbmd0aDtlLmxlbmd0aCs9bztsZXQgcz1lLmxlbmd0aDxlLmhpZ2hXYXRlck1hcms7cmV0dXJuIHN8fChlLm5lZWREcmFpbj0hMCksZS53cml0aW5nfHxlLmNvcmtlZHx8ZS5lcnJvcmVkfHwhZS5jb25zdHJ1Y3RlZD8oZS5idWZmZXJlZC5wdXNoKHtjaHVuazpyLGVuY29kaW5nOmksY2FsbGJhY2s6bn0pLGUuYWxsQnVmZmVycyYmaSE9PVwiYnVmZmVyXCImJihlLmFsbEJ1ZmZlcnM9ITEpLGUuYWxsTm9vcCYmbiE9PXNvJiYoZS5hbGxOb29wPSExKSk6KGUud3JpdGVsZW49byxlLndyaXRlY2I9bixlLndyaXRpbmc9ITAsZS5zeW5jPSEwLHQuX3dyaXRlKHIsaSxlLm9ud3JpdGUpLGUuc3luYz0hMSkscyYmIWUuZXJyb3JlZCYmIWUuZGVzdHJveWVkfWZ1bmN0aW9uIGVoKHQsZSxyLGksbixvLHMpe2Uud3JpdGVsZW49aSxlLndyaXRlY2I9cyxlLndyaXRpbmc9ITAsZS5zeW5jPSEwLGUuZGVzdHJveWVkP2Uub253cml0ZShuZXcgcGkoXCJ3cml0ZVwiKSk6cj90Ll93cml0ZXYobixlLm9ud3JpdGUpOnQuX3dyaXRlKG4sbyxlLm9ud3JpdGUpLGUuc3luYz0hMX1mdW5jdGlvbiB0aCh0LGUscixpKXstLWUucGVuZGluZ2NiLGkociksb28oZSksRHIodCxyKX1mdW5jdGlvbiBVXyh0LGUpe2xldCByPXQuX3dyaXRhYmxlU3RhdGUsaT1yLnN5bmMsbj1yLndyaXRlY2I7aWYodHlwZW9mIG4hPVwiZnVuY3Rpb25cIil7RHIodCxuZXcgb2gpO3JldHVybn1yLndyaXRpbmc9ITEsci53cml0ZWNiPW51bGwsci5sZW5ndGgtPXIud3JpdGVsZW4sci53cml0ZWxlbj0wLGU/KGUuc3RhY2ssci5lcnJvcmVkfHwoci5lcnJvcmVkPWUpLHQuX3JlYWRhYmxlU3RhdGUmJiF0Ll9yZWFkYWJsZVN0YXRlLmVycm9yZWQmJih0Ll9yZWFkYWJsZVN0YXRlLmVycm9yZWQ9ZSksaT91ci5uZXh0VGljayh0aCx0LHIsZSxuKTp0aCh0LHIsZSxuKSk6KHIuYnVmZmVyZWQubGVuZ3RoPnIuYnVmZmVyZWRJbmRleCYmYW8odCxyKSxpP3IuYWZ0ZXJXcml0ZVRpY2tJbmZvIT09bnVsbCYmci5hZnRlcldyaXRlVGlja0luZm8uY2I9PT1uP3IuYWZ0ZXJXcml0ZVRpY2tJbmZvLmNvdW50Kys6KHIuYWZ0ZXJXcml0ZVRpY2tJbmZvPXtjb3VudDoxLGNiOm4sc3RyZWFtOnQsc3RhdGU6cn0sdXIubmV4dFRpY2soTl8sci5hZnRlcldyaXRlVGlja0luZm8pKTp1aCh0LHIsMSxuKSl9ZnVuY3Rpb24gTl8oe3N0cmVhbTp0LHN0YXRlOmUsY291bnQ6cixjYjppfSl7cmV0dXJuIGUuYWZ0ZXJXcml0ZVRpY2tJbmZvPW51bGwsdWgodCxlLHIsaSl9ZnVuY3Rpb24gdWgodCxlLHIsaSl7Zm9yKCFlLmVuZGluZyYmIXQuZGVzdHJveWVkJiZlLmxlbmd0aD09PTAmJmUubmVlZERyYWluJiYoZS5uZWVkRHJhaW49ITEsdC5lbWl0KFwiZHJhaW5cIikpO3ItLSA+MDspZS5wZW5kaW5nY2ItLSxpKCk7ZS5kZXN0cm95ZWQmJm9vKGUpLGxvKHQsZSl9ZnVuY3Rpb24gb28odCl7aWYodC53cml0aW5nKXJldHVybjtmb3IobGV0IG49dC5idWZmZXJlZEluZGV4O248dC5idWZmZXJlZC5sZW5ndGg7KytuKXt2YXIgZTtsZXR7Y2h1bms6byxjYWxsYmFjazpzfT10LmJ1ZmZlcmVkW25dLGE9dC5vYmplY3RNb2RlPzE6by5sZW5ndGg7dC5sZW5ndGgtPWEscygoZT10LmVycm9yZWQpIT09bnVsbCYmZSE9PXZvaWQgMD9lOm5ldyBwaShcIndyaXRlXCIpKX1sZXQgcj10W2pyXS5zcGxpY2UoMCk7Zm9yKGxldCBuPTA7bjxyLmxlbmd0aDtuKyspe3ZhciBpO3Jbbl0oKGk9dC5lcnJvcmVkKSE9PW51bGwmJmkhPT12b2lkIDA/aTpuZXcgcGkoXCJlbmRcIikpfXBuKHQpfWZ1bmN0aW9uIGFvKHQsZSl7aWYoZS5jb3JrZWR8fGUuYnVmZmVyUHJvY2Vzc2luZ3x8ZS5kZXN0cm95ZWR8fCFlLmNvbnN0cnVjdGVkKXJldHVybjtsZXR7YnVmZmVyZWQ6cixidWZmZXJlZEluZGV4Omksb2JqZWN0TW9kZTpufT1lLG89ci5sZW5ndGgtaTtpZighbylyZXR1cm47bGV0IHM9aTtpZihlLmJ1ZmZlclByb2Nlc3Npbmc9ITAsbz4xJiZ0Ll93cml0ZXYpe2UucGVuZGluZ2NiLT1vLTE7bGV0IGE9ZS5hbGxOb29wP3NvOmM9Pntmb3IobGV0IGg9cztoPHIubGVuZ3RoOysraClyW2hdLmNhbGxiYWNrKGMpfSx1PWUuYWxsTm9vcCYmcz09PTA/cjpyaChyLHMpO3UuYWxsQnVmZmVycz1lLmFsbEJ1ZmZlcnMsZWgodCxlLCEwLGUubGVuZ3RoLHUsXCJcIixhKSxwbihlKX1lbHNle2Rve2xldHtjaHVuazphLGVuY29kaW5nOnUsY2FsbGJhY2s6Y309cltzXTtyW3MrK109bnVsbDtsZXQgaD1uPzE6YS5sZW5ndGg7ZWgodCxlLCExLGgsYSx1LGMpfXdoaWxlKHM8ci5sZW5ndGgmJiFlLndyaXRpbmcpO3M9PT1yLmxlbmd0aD9wbihlKTpzPjI1Nj8oci5zcGxpY2UoMCxzKSxlLmJ1ZmZlcmVkSW5kZXg9MCk6ZS5idWZmZXJlZEluZGV4PXN9ZS5idWZmZXJQcm9jZXNzaW5nPSExfWllLnByb3RvdHlwZS5fd3JpdGU9ZnVuY3Rpb24odCxlLHIpe2lmKHRoaXMuX3dyaXRldil0aGlzLl93cml0ZXYoW3tjaHVuazp0LGVuY29kaW5nOmV9XSxyKTtlbHNlIHRocm93IG5ldyBQXyhcIl93cml0ZSgpXCIpfTtpZS5wcm90b3R5cGUuX3dyaXRldj1udWxsO2llLnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24odCxlLHIpe2xldCBpPXRoaXMuX3dyaXRhYmxlU3RhdGU7dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIj8ocj10LHQ9bnVsbCxlPW51bGwpOnR5cGVvZiBlPT1cImZ1bmN0aW9uXCImJihyPWUsZT1udWxsKTtsZXQgbjtpZih0IT1udWxsKXtsZXQgbz1saCh0aGlzLHQsZSk7byBpbnN0YW5jZW9mIG1fJiYobj1vKX1yZXR1cm4gaS5jb3JrZWQmJihpLmNvcmtlZD0xLHRoaXMudW5jb3JrKCkpLG58fCghaS5lcnJvcmVkJiYhaS5lbmRpbmc/KGkuZW5kaW5nPSEwLGxvKHRoaXMsaSwhMCksaS5lbmRlZD0hMCk6aS5maW5pc2hlZD9uPW5ldyBrXyhcImVuZFwiKTppLmRlc3Ryb3llZCYmKG49bmV3IHBpKFwiZW5kXCIpKSksdHlwZW9mIHI9PVwiZnVuY3Rpb25cIiYmKG58fGkuZmluaXNoZWQ/dXIubmV4dFRpY2socixuKTppW2pyXS5wdXNoKHIpKSx0aGlzfTtmdW5jdGlvbiBkbih0KXtyZXR1cm4gdC5lbmRpbmcmJiF0LmRlc3Ryb3llZCYmdC5jb25zdHJ1Y3RlZCYmdC5sZW5ndGg9PT0wJiYhdC5lcnJvcmVkJiZ0LmJ1ZmZlcmVkLmxlbmd0aD09PTAmJiF0LmZpbmlzaGVkJiYhdC53cml0aW5nJiYhdC5lcnJvckVtaXR0ZWQmJiF0LmNsb3NlRW1pdHRlZH1mdW5jdGlvbiBxXyh0LGUpe2xldCByPSExO2Z1bmN0aW9uIGkobil7aWYocil7RHIodCxuPz9vaCgpKTtyZXR1cm59aWYocj0hMCxlLnBlbmRpbmdjYi0tLG4pe2xldCBvPWVbanJdLnNwbGljZSgwKTtmb3IobGV0IHM9MDtzPG8ubGVuZ3RoO3MrKylvW3NdKG4pO0RyKHQsbixlLnN5bmMpfWVsc2UgZG4oZSkmJihlLnByZWZpbmlzaGVkPSEwLHQuZW1pdChcInByZWZpbmlzaFwiKSxlLnBlbmRpbmdjYisrLHVyLm5leHRUaWNrKG5vLHQsZSkpfWUuc3luYz0hMCxlLnBlbmRpbmdjYisrO3RyeXt0Ll9maW5hbChpKX1jYXRjaChuKXtpKG4pfWUuc3luYz0hMX1mdW5jdGlvbiBEXyh0LGUpeyFlLnByZWZpbmlzaGVkJiYhZS5maW5hbENhbGxlZCYmKHR5cGVvZiB0Ll9maW5hbD09XCJmdW5jdGlvblwiJiYhZS5kZXN0cm95ZWQ/KGUuZmluYWxDYWxsZWQ9ITAscV8odCxlKSk6KGUucHJlZmluaXNoZWQ9ITAsdC5lbWl0KFwicHJlZmluaXNoXCIpKSl9ZnVuY3Rpb24gbG8odCxlLHIpe2RuKGUpJiYoRF8odCxlKSxlLnBlbmRpbmdjYj09PTAmJihyPyhlLnBlbmRpbmdjYisrLHVyLm5leHRUaWNrKChpLG4pPT57ZG4obik/bm8oaSxuKTpuLnBlbmRpbmdjYi0tfSx0LGUpKTpkbihlKSYmKGUucGVuZGluZ2NiKyssbm8odCxlKSkpKX1mdW5jdGlvbiBubyh0LGUpe2UucGVuZGluZ2NiLS0sZS5maW5pc2hlZD0hMDtsZXQgcj1lW2pyXS5zcGxpY2UoMCk7Zm9yKGxldCBpPTA7aTxyLmxlbmd0aDtpKyspcltpXSgpO2lmKHQuZW1pdChcImZpbmlzaFwiKSxlLmF1dG9EZXN0cm95KXtsZXQgaT10Ll9yZWFkYWJsZVN0YXRlOyghaXx8aS5hdXRvRGVzdHJveSYmKGkuZW5kRW1pdHRlZHx8aS5yZWFkYWJsZT09PSExKSkmJnQuZGVzdHJveSgpfX12XyhpZS5wcm90b3R5cGUse2Nsb3NlZDp7X19wcm90b19fOm51bGwsZ2V0KCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGU/dGhpcy5fd3JpdGFibGVTdGF0ZS5jbG9zZWQ6ITF9fSxkZXN0cm95ZWQ6e19fcHJvdG9fXzpudWxsLGdldCgpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlP3RoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkOiExfSxzZXQodCl7dGhpcy5fd3JpdGFibGVTdGF0ZSYmKHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkPXQpfX0sd3JpdGFibGU6e19fcHJvdG9fXzpudWxsLGdldCgpe2xldCB0PXRoaXMuX3dyaXRhYmxlU3RhdGU7cmV0dXJuISF0JiZ0LndyaXRhYmxlIT09ITEmJiF0LmRlc3Ryb3llZCYmIXQuZXJyb3JlZCYmIXQuZW5kaW5nJiYhdC5lbmRlZH0sc2V0KHQpe3RoaXMuX3dyaXRhYmxlU3RhdGUmJih0aGlzLl93cml0YWJsZVN0YXRlLndyaXRhYmxlPSEhdCl9fSx3cml0YWJsZUZpbmlzaGVkOntfX3Byb3RvX186bnVsbCxnZXQoKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZT90aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkOiExfX0sd3JpdGFibGVPYmplY3RNb2RlOntfX3Byb3RvX186bnVsbCxnZXQoKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZT90aGlzLl93cml0YWJsZVN0YXRlLm9iamVjdE1vZGU6ITF9fSx3cml0YWJsZUJ1ZmZlcjp7X19wcm90b19fOm51bGwsZ2V0KCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUmJnRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCl9fSx3cml0YWJsZUVuZGVkOntfX3Byb3RvX186bnVsbCxnZXQoKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZT90aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZzohMX19LHdyaXRhYmxlTmVlZERyYWluOntfX3Byb3RvX186bnVsbCxnZXQoKXtsZXQgdD10aGlzLl93cml0YWJsZVN0YXRlO3JldHVybiB0PyF0LmRlc3Ryb3llZCYmIXQuZW5kaW5nJiZ0Lm5lZWREcmFpbjohMX19LHdyaXRhYmxlSGlnaFdhdGVyTWFyazp7X19wcm90b19fOm51bGwsZ2V0KCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUmJnRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319LHdyaXRhYmxlQ29ya2VkOntfX3Byb3RvX186bnVsbCxnZXQoKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZT90aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZDowfX0sd3JpdGFibGVMZW5ndGg6e19fcHJvdG9fXzpudWxsLGdldCgpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlJiZ0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aH19LGVycm9yZWQ6e19fcHJvdG9fXzpudWxsLGVudW1lcmFibGU6ITEsZ2V0KCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGU/dGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvcmVkOm51bGx9fSx3cml0YWJsZUFib3J0ZWQ6e19fcHJvdG9fXzpudWxsLGVudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuISEodGhpcy5fd3JpdGFibGVTdGF0ZS53cml0YWJsZSE9PSExJiYodGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWR8fHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JlZCkmJiF0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKX19fSk7dmFyIGpfPWduLmRlc3Ryb3k7aWUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24odCxlKXtsZXQgcj10aGlzLl93cml0YWJsZVN0YXRlO3JldHVybiFyLmRlc3Ryb3llZCYmKHIuYnVmZmVyZWRJbmRleDxyLmJ1ZmZlcmVkLmxlbmd0aHx8cltqcl0ubGVuZ3RoKSYmdXIubmV4dFRpY2sob28sciksal8uY2FsbCh0aGlzLHQsZSksdGhpc307aWUucHJvdG90eXBlLl91bmRlc3Ryb3k9Z24udW5kZXN0cm95O2llLnByb3RvdHlwZS5fZGVzdHJveT1mdW5jdGlvbih0LGUpe2UodCl9O2llLnByb3RvdHlwZVtJXy5jYXB0dXJlUmVqZWN0aW9uU3ltYm9sXT1mdW5jdGlvbih0KXt0aGlzLmRlc3Ryb3kodCl9O3ZhciBpbztmdW5jdGlvbiBmaCgpe3JldHVybiBpbz09PXZvaWQgMCYmKGlvPXt9KSxpb31pZS5mcm9tV2ViPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZoKCkubmV3U3RyZWFtV3JpdGFibGVGcm9tV3JpdGFibGVTdHJlYW0odCxlKX07aWUudG9XZWI9ZnVuY3Rpb24odCl7cmV0dXJuIGZoKCkubmV3V3JpdGFibGVTdHJlYW1Gcm9tU3RyZWFtV3JpdGFibGUodCl9fSk7dmFyIFNoPU0oKHBSLEVoKT0+e3YoKTttKCk7XygpO3ZhciBmbz1VdCgpLEZfPSh3ZSgpLFoodmUpKSx7aXNSZWFkYWJsZTpXXyxpc1dyaXRhYmxlOiRfLGlzSXRlcmFibGU6aGgsaXNOb2RlU3RyZWFtOkhfLGlzUmVhZGFibGVOb2RlU3RyZWFtOmRoLGlzV3JpdGFibGVOb2RlU3RyZWFtOnBoLGlzRHVwbGV4Tm9kZVN0cmVhbTpWX309dHQoKSxnaD1tdCgpLHtBYm9ydEVycm9yOnZoLGNvZGVzOntFUlJfSU5WQUxJRF9BUkdfVFlQRTp6XyxFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUU6eWh9fT1TZSgpLHtkZXN0cm95ZXI6RnJ9PXRyKCksS189bnQoKSxHXz1oaSgpLHtjcmVhdGVEZWZlcnJlZFByb21pc2U6Ymh9PUplKCksd2g9WXMoKSxfaD1nbG9iYWxUaGlzLkJsb2J8fEZfLkJsb2IsUV89dHlwZW9mIF9oPFwidVwiP2Z1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgX2h9OmZ1bmN0aW9uKGUpe3JldHVybiExfSxZXz1nbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcnx8SGkoKS5BYm9ydENvbnRyb2xsZXIse0Z1bmN0aW9uUHJvdG90eXBlQ2FsbDptaH09Y2UoKSxmcj1jbGFzcyBleHRlbmRzIEtfe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLGU/LnJlYWRhYmxlPT09ITEmJih0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRhYmxlPSExLHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQ9ITAsdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkPSEwKSxlPy53cml0YWJsZT09PSExJiYodGhpcy5fd3JpdGFibGVTdGF0ZS53cml0YWJsZT0hMSx0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZz0hMCx0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkPSEwLHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ9ITApfX07RWguZXhwb3J0cz1mdW5jdGlvbiB0KGUscil7aWYoVl8oZSkpcmV0dXJuIGU7aWYoZGgoZSkpcmV0dXJuIHluKHtyZWFkYWJsZTplfSk7aWYocGgoZSkpcmV0dXJuIHluKHt3cml0YWJsZTplfSk7aWYoSF8oZSkpcmV0dXJuIHluKHt3cml0YWJsZTohMSxyZWFkYWJsZTohMX0pO2lmKHR5cGVvZiBlPT1cImZ1bmN0aW9uXCIpe2xldHt2YWx1ZTpuLHdyaXRlOm8sZmluYWw6cyxkZXN0cm95OmF9PUpfKGUpO2lmKGhoKG4pKXJldHVybiB3aChmcixuLHtvYmplY3RNb2RlOiEwLHdyaXRlOm8sZmluYWw6cyxkZXN0cm95OmF9KTtsZXQgdT1uPy50aGVuO2lmKHR5cGVvZiB1PT1cImZ1bmN0aW9uXCIpe2xldCBjLGg9bWgodSxuLGQ9PntpZihkIT1udWxsKXRocm93IG5ldyB5aChcIm51bGx5XCIsXCJib2R5XCIsZCl9LGQ9PntGcihjLGQpfSk7cmV0dXJuIGM9bmV3IGZyKHtvYmplY3RNb2RlOiEwLHJlYWRhYmxlOiExLHdyaXRlOm8sZmluYWwoZCl7cyhhc3luYygpPT57dHJ5e2F3YWl0IGgsZm8ubmV4dFRpY2soZCxudWxsKX1jYXRjaChnKXtmby5uZXh0VGljayhkLGcpfX0pfSxkZXN0cm95OmF9KX10aHJvdyBuZXcgeWgoXCJJdGVyYWJsZSwgQXN5bmNJdGVyYWJsZSBvciBBc3luY0Z1bmN0aW9uXCIscixuKX1pZihRXyhlKSlyZXR1cm4gdChlLmFycmF5QnVmZmVyKCkpO2lmKGhoKGUpKXJldHVybiB3aChmcixlLHtvYmplY3RNb2RlOiEwLHdyaXRhYmxlOiExfSk7aWYodHlwZW9mIGU/LndyaXRhYmxlPT1cIm9iamVjdFwifHx0eXBlb2YgZT8ucmVhZGFibGU9PVwib2JqZWN0XCIpe2xldCBuPWUhPW51bGwmJmUucmVhZGFibGU/ZGgoZT8ucmVhZGFibGUpP2U/LnJlYWRhYmxlOnQoZS5yZWFkYWJsZSk6dm9pZCAwLG89ZSE9bnVsbCYmZS53cml0YWJsZT9waChlPy53cml0YWJsZSk/ZT8ud3JpdGFibGU6dChlLndyaXRhYmxlKTp2b2lkIDA7cmV0dXJuIHluKHtyZWFkYWJsZTpuLHdyaXRhYmxlOm99KX1sZXQgaT1lPy50aGVuO2lmKHR5cGVvZiBpPT1cImZ1bmN0aW9uXCIpe2xldCBuO3JldHVybiBtaChpLGUsbz0+e28hPW51bGwmJm4ucHVzaChvKSxuLnB1c2gobnVsbCl9LG89PntGcihuLG8pfSksbj1uZXcgZnIoe29iamVjdE1vZGU6ITAsd3JpdGFibGU6ITEscmVhZCgpe319KX10aHJvdyBuZXcgel8ocixbXCJCbG9iXCIsXCJSZWFkYWJsZVN0cmVhbVwiLFwiV3JpdGFibGVTdHJlYW1cIixcIlN0cmVhbVwiLFwiSXRlcmFibGVcIixcIkFzeW5jSXRlcmFibGVcIixcIkZ1bmN0aW9uXCIsXCJ7IHJlYWRhYmxlLCB3cml0YWJsZSB9IHBhaXJcIixcIlByb21pc2VcIl0sZSl9O2Z1bmN0aW9uIEpfKHQpe2xldHtwcm9taXNlOmUscmVzb2x2ZTpyfT1iaCgpLGk9bmV3IFlfLG49aS5zaWduYWw7cmV0dXJue3ZhbHVlOnQoYXN5bmMgZnVuY3Rpb24qKCl7Zm9yKDs7KXtsZXQgcz1lO2U9bnVsbDtsZXR7Y2h1bms6YSxkb25lOnUsY2I6Y309YXdhaXQgcztpZihmby5uZXh0VGljayhjKSx1KXJldHVybjtpZihuLmFib3J0ZWQpdGhyb3cgbmV3IHZoKHZvaWQgMCx7Y2F1c2U6bi5yZWFzb259KTsoe3Byb21pc2U6ZSxyZXNvbHZlOnJ9PWJoKCkpLHlpZWxkIGF9fSgpLHtzaWduYWw6bn0pLHdyaXRlKHMsYSx1KXtsZXQgYz1yO3I9bnVsbCxjKHtjaHVuazpzLGRvbmU6ITEsY2I6dX0pfSxmaW5hbChzKXtsZXQgYT1yO3I9bnVsbCxhKHtkb25lOiEwLGNiOnN9KX0sZGVzdHJveShzLGEpe2kuYWJvcnQoKSxhKHMpfX19ZnVuY3Rpb24geW4odCl7bGV0IGU9dC5yZWFkYWJsZSYmdHlwZW9mIHQucmVhZGFibGUucmVhZCE9XCJmdW5jdGlvblwiP0dfLndyYXAodC5yZWFkYWJsZSk6dC5yZWFkYWJsZSxyPXQud3JpdGFibGUsaT0hIVdfKGUpLG49ISEkXyhyKSxvLHMsYSx1LGM7ZnVuY3Rpb24gaChkKXtsZXQgZz11O3U9bnVsbCxnP2coZCk6ZCYmYy5kZXN0cm95KGQpfXJldHVybiBjPW5ldyBmcih7cmVhZGFibGVPYmplY3RNb2RlOiEhKGUhPW51bGwmJmUucmVhZGFibGVPYmplY3RNb2RlKSx3cml0YWJsZU9iamVjdE1vZGU6ISEociE9bnVsbCYmci53cml0YWJsZU9iamVjdE1vZGUpLHJlYWRhYmxlOmksd3JpdGFibGU6bn0pLG4mJihnaChyLGQ9PntuPSExLGQmJkZyKGUsZCksaChkKX0pLGMuX3dyaXRlPWZ1bmN0aW9uKGQsZyx5KXtyLndyaXRlKGQsZyk/eSgpOm89eX0sYy5fZmluYWw9ZnVuY3Rpb24oZCl7ci5lbmQoKSxzPWR9LHIub24oXCJkcmFpblwiLGZ1bmN0aW9uKCl7aWYobyl7bGV0IGQ9bztvPW51bGwsZCgpfX0pLHIub24oXCJmaW5pc2hcIixmdW5jdGlvbigpe2lmKHMpe2xldCBkPXM7cz1udWxsLGQoKX19KSksaSYmKGdoKGUsZD0+e2k9ITEsZCYmRnIoZSxkKSxoKGQpfSksZS5vbihcInJlYWRhYmxlXCIsZnVuY3Rpb24oKXtpZihhKXtsZXQgZD1hO2E9bnVsbCxkKCl9fSksZS5vbihcImVuZFwiLGZ1bmN0aW9uKCl7Yy5wdXNoKG51bGwpfSksYy5fcmVhZD1mdW5jdGlvbigpe2Zvcig7Oyl7bGV0IGQ9ZS5yZWFkKCk7aWYoZD09PW51bGwpe2E9Yy5fcmVhZDtyZXR1cm59aWYoIWMucHVzaChkKSlyZXR1cm59fSksYy5fZGVzdHJveT1mdW5jdGlvbihkLGcpeyFkJiZ1IT09bnVsbCYmKGQ9bmV3IHZoKSxhPW51bGwsbz1udWxsLHM9bnVsbCx1PT09bnVsbD9nKGQpOih1PWcsRnIocixkKSxGcihlLGQpKX0sY319KTt2YXIgbnQ9TSgoQVIsVGgpPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7dmFye09iamVjdERlZmluZVByb3BlcnRpZXM6WF8sT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOkF0LE9iamVjdEtleXM6Wl8sT2JqZWN0U2V0UHJvdG90eXBlT2Y6QWh9PWNlKCk7VGguZXhwb3J0cz1WZTt2YXIgcG89aGkoKSxOZT11bygpO0FoKFZlLnByb3RvdHlwZSxwby5wcm90b3R5cGUpO0FoKFZlLHBvKTt7bGV0IHQ9Wl8oTmUucHJvdG90eXBlKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7bGV0IHI9dFtlXTtWZS5wcm90b3R5cGVbcl18fChWZS5wcm90b3R5cGVbcl09TmUucHJvdG90eXBlW3JdKX19ZnVuY3Rpb24gVmUodCl7aWYoISh0aGlzIGluc3RhbmNlb2YgVmUpKXJldHVybiBuZXcgVmUodCk7cG8uY2FsbCh0aGlzLHQpLE5lLmNhbGwodGhpcyx0KSx0Pyh0aGlzLmFsbG93SGFsZk9wZW49dC5hbGxvd0hhbGZPcGVuIT09ITEsdC5yZWFkYWJsZT09PSExJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkYWJsZT0hMSx0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkPSEwLHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZD0hMCksdC53cml0YWJsZT09PSExJiYodGhpcy5fd3JpdGFibGVTdGF0ZS53cml0YWJsZT0hMSx0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZz0hMCx0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkPSEwLHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ9ITApKTp0aGlzLmFsbG93SGFsZk9wZW49ITB9WF8oVmUucHJvdG90eXBlLHt3cml0YWJsZTp7X19wcm90b19fOm51bGwsLi4uQXQoTmUucHJvdG90eXBlLFwid3JpdGFibGVcIil9LHdyaXRhYmxlSGlnaFdhdGVyTWFyazp7X19wcm90b19fOm51bGwsLi4uQXQoTmUucHJvdG90eXBlLFwid3JpdGFibGVIaWdoV2F0ZXJNYXJrXCIpfSx3cml0YWJsZU9iamVjdE1vZGU6e19fcHJvdG9fXzpudWxsLC4uLkF0KE5lLnByb3RvdHlwZSxcIndyaXRhYmxlT2JqZWN0TW9kZVwiKX0sd3JpdGFibGVCdWZmZXI6e19fcHJvdG9fXzpudWxsLC4uLkF0KE5lLnByb3RvdHlwZSxcIndyaXRhYmxlQnVmZmVyXCIpfSx3cml0YWJsZUxlbmd0aDp7X19wcm90b19fOm51bGwsLi4uQXQoTmUucHJvdG90eXBlLFwid3JpdGFibGVMZW5ndGhcIil9LHdyaXRhYmxlRmluaXNoZWQ6e19fcHJvdG9fXzpudWxsLC4uLkF0KE5lLnByb3RvdHlwZSxcIndyaXRhYmxlRmluaXNoZWRcIil9LHdyaXRhYmxlQ29ya2VkOntfX3Byb3RvX186bnVsbCwuLi5BdChOZS5wcm90b3R5cGUsXCJ3cml0YWJsZUNvcmtlZFwiKX0sd3JpdGFibGVFbmRlZDp7X19wcm90b19fOm51bGwsLi4uQXQoTmUucHJvdG90eXBlLFwid3JpdGFibGVFbmRlZFwiKX0sd3JpdGFibGVOZWVkRHJhaW46e19fcHJvdG9fXzpudWxsLC4uLkF0KE5lLnByb3RvdHlwZSxcIndyaXRhYmxlTmVlZERyYWluXCIpfSxkZXN0cm95ZWQ6e19fcHJvdG9fXzpudWxsLGdldCgpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlPT09dm9pZCAwfHx0aGlzLl93cml0YWJsZVN0YXRlPT09dm9pZCAwPyExOnRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkJiZ0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZH0sc2V0KHQpe3RoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3dyaXRhYmxlU3RhdGUmJih0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZD10LHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkPXQpfX19KTt2YXIgY287ZnVuY3Rpb24gSWgoKXtyZXR1cm4gY289PT12b2lkIDAmJihjbz17fSksY299VmUuZnJvbVdlYj1mdW5jdGlvbih0LGUpe3JldHVybiBJaCgpLm5ld1N0cmVhbUR1cGxleEZyb21SZWFkYWJsZVdyaXRhYmxlUGFpcih0LGUpfTtWZS50b1dlYj1mdW5jdGlvbih0KXtyZXR1cm4gSWgoKS5uZXdSZWFkYWJsZVdyaXRhYmxlUGFpckZyb21EdXBsZXgodCl9O3ZhciBobztWZS5mcm9tPWZ1bmN0aW9uKHQpe3JldHVybiBob3x8KGhvPVNoKCkpLGhvKHQsXCJib2R5XCIpfX0pO3ZhciBibz1NKChNUixDaCk9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTt2YXJ7T2JqZWN0U2V0UHJvdG90eXBlT2Y6UmgsU3ltYm9sOmUwfT1jZSgpO0NoLmV4cG9ydHM9SXQ7dmFye0VSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEOnQwfT1TZSgpLmNvZGVzLHlvPW50KCkse2dldEhpZ2hXYXRlck1hcms6cjB9PXNuKCk7UmgoSXQucHJvdG90eXBlLHlvLnByb3RvdHlwZSk7UmgoSXQseW8pO3ZhciB5aT1lMChcImtDYWxsYmFja1wiKTtmdW5jdGlvbiBJdCh0KXtpZighKHRoaXMgaW5zdGFuY2VvZiBJdCkpcmV0dXJuIG5ldyBJdCh0KTtsZXQgZT10P3IwKHRoaXMsdCxcInJlYWRhYmxlSGlnaFdhdGVyTWFya1wiLCEwKTpudWxsO2U9PT0wJiYodD17Li4udCxoaWdoV2F0ZXJNYXJrOm51bGwscmVhZGFibGVIaWdoV2F0ZXJNYXJrOmUsd3JpdGFibGVIaWdoV2F0ZXJNYXJrOnQud3JpdGFibGVIaWdoV2F0ZXJNYXJrfHwwfSkseW8uY2FsbCh0aGlzLHQpLHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYz0hMSx0aGlzW3lpXT1udWxsLHQmJih0eXBlb2YgdC50cmFuc2Zvcm09PVwiZnVuY3Rpb25cIiYmKHRoaXMuX3RyYW5zZm9ybT10LnRyYW5zZm9ybSksdHlwZW9mIHQuZmx1c2g9PVwiZnVuY3Rpb25cIiYmKHRoaXMuX2ZsdXNoPXQuZmx1c2gpKSx0aGlzLm9uKFwicHJlZmluaXNoXCIsaTApfWZ1bmN0aW9uIGdvKHQpe3R5cGVvZiB0aGlzLl9mbHVzaD09XCJmdW5jdGlvblwiJiYhdGhpcy5kZXN0cm95ZWQ/dGhpcy5fZmx1c2goKGUscik9PntpZihlKXt0P3QoZSk6dGhpcy5kZXN0cm95KGUpO3JldHVybn1yIT1udWxsJiZ0aGlzLnB1c2gociksdGhpcy5wdXNoKG51bGwpLHQmJnQoKX0pOih0aGlzLnB1c2gobnVsbCksdCYmdCgpKX1mdW5jdGlvbiBpMCgpe3RoaXMuX2ZpbmFsIT09Z28mJmdvLmNhbGwodGhpcyl9SXQucHJvdG90eXBlLl9maW5hbD1nbztJdC5wcm90b3R5cGUuX3RyYW5zZm9ybT1mdW5jdGlvbih0LGUscil7dGhyb3cgbmV3IHQwKFwiX3RyYW5zZm9ybSgpXCIpfTtJdC5wcm90b3R5cGUuX3dyaXRlPWZ1bmN0aW9uKHQsZSxyKXtsZXQgaT10aGlzLl9yZWFkYWJsZVN0YXRlLG49dGhpcy5fd3JpdGFibGVTdGF0ZSxvPWkubGVuZ3RoO3RoaXMuX3RyYW5zZm9ybSh0LGUsKHMsYSk9PntpZihzKXtyKHMpO3JldHVybn1hIT1udWxsJiZ0aGlzLnB1c2goYSksbi5lbmRlZHx8bz09PWkubGVuZ3RofHxpLmxlbmd0aDxpLmhpZ2hXYXRlck1hcms/cigpOnRoaXNbeWldPXJ9KX07SXQucHJvdG90eXBlLl9yZWFkPWZ1bmN0aW9uKCl7aWYodGhpc1t5aV0pe2xldCB0PXRoaXNbeWldO3RoaXNbeWldPW51bGwsdCgpfX19KTt2YXIgX289TSgoSFIsUGgpPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7dmFye09iamVjdFNldFByb3RvdHlwZU9mOkJofT1jZSgpO1BoLmV4cG9ydHM9V3I7dmFyIHdvPWJvKCk7QmgoV3IucHJvdG90eXBlLHdvLnByb3RvdHlwZSk7QmgoV3Isd28pO2Z1bmN0aW9uIFdyKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFdyKSlyZXR1cm4gbmV3IFdyKHQpO3dvLmNhbGwodGhpcyx0KX1Xci5wcm90b3R5cGUuX3RyYW5zZm9ybT1mdW5jdGlvbih0LGUscil7cihudWxsLHQpfX0pO3ZhciBtbj1NKChlQyxMaCk9Pnt2KCk7bSgpO18oKTt2YXIgYmk9VXQoKSx7QXJyYXlJc0FycmF5Om4wLFByb21pc2U6czAsU3ltYm9sQXN5bmNJdGVyYXRvcjpvMH09Y2UoKSxfbj1tdCgpLHtvbmNlOmEwfT1KZSgpLGwwPXRyKCksT2g9bnQoKSx7YWdncmVnYXRlVHdvRXJyb3JzOnUwLGNvZGVzOntFUlJfSU5WQUxJRF9BUkdfVFlQRTpSbyxFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUU6bW8sRVJSX01JU1NJTkdfQVJHUzpmMCxFUlJfU1RSRUFNX0RFU1RST1lFRDpjMCxFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTpoMH0sQWJvcnRFcnJvcjpkMH09U2UoKSx7dmFsaWRhdGVGdW5jdGlvbjpwMCx2YWxpZGF0ZUFib3J0U2lnbmFsOmcwfT11aSgpLHtpc0l0ZXJhYmxlOmNyLGlzUmVhZGFibGU6dm8saXNSZWFkYWJsZU5vZGVTdHJlYW06d24saXNOb2RlU3RyZWFtOmtoLGlzVHJhbnNmb3JtU3RyZWFtOiRyLGlzV2ViU3RyZWFtOnkwLGlzUmVhZGFibGVTdHJlYW06RW8saXNSZWFkYWJsZUVuZGVkOmIwfT10dCgpLHcwPWdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyfHxIaSgpLkFib3J0Q29udHJvbGxlcixTbyxBbztmdW5jdGlvbiB4aCh0LGUscil7bGV0IGk9ITE7dC5vbihcImNsb3NlXCIsKCk9PntpPSEwfSk7bGV0IG49X24odCx7cmVhZGFibGU6ZSx3cml0YWJsZTpyfSxvPT57aT0hb30pO3JldHVybntkZXN0cm95Om89PntpfHwoaT0hMCxsMC5kZXN0cm95ZXIodCxvfHxuZXcgYzAoXCJwaXBlXCIpKSl9LGNsZWFudXA6bn19ZnVuY3Rpb24gXzAodCl7cmV0dXJuIHAwKHRbdC5sZW5ndGgtMV0sXCJzdHJlYW1zW3N0cmVhbS5sZW5ndGggLSAxXVwiKSx0LnBvcCgpfWZ1bmN0aW9uIElvKHQpe2lmKGNyKHQpKXJldHVybiB0O2lmKHduKHQpKXJldHVybiBtMCh0KTt0aHJvdyBuZXcgUm8oXCJ2YWxcIixbXCJSZWFkYWJsZVwiLFwiSXRlcmFibGVcIixcIkFzeW5jSXRlcmFibGVcIl0sdCl9YXN5bmMgZnVuY3Rpb24qbTAodCl7QW98fChBbz1oaSgpKSx5aWVsZCpBby5wcm90b3R5cGVbbzBdLmNhbGwodCl9YXN5bmMgZnVuY3Rpb24gYm4odCxlLHIse2VuZDppfSl7bGV0IG4sbz1udWxsLHM9Yz0+e2lmKGMmJihuPWMpLG8pe2xldCBoPW87bz1udWxsLGgoKX19LGE9KCk9Pm5ldyBzMCgoYyxoKT0+e24/aChuKTpvPSgpPT57bj9oKG4pOmMoKX19KTtlLm9uKFwiZHJhaW5cIixzKTtsZXQgdT1fbihlLHtyZWFkYWJsZTohMX0scyk7dHJ5e2Uud3JpdGFibGVOZWVkRHJhaW4mJmF3YWl0IGEoKTtmb3IgYXdhaXQobGV0IGMgb2YgdCllLndyaXRlKGMpfHxhd2FpdCBhKCk7aSYmZS5lbmQoKSxhd2FpdCBhKCkscigpfWNhdGNoKGMpe3IobiE9PWM/dTAobixjKTpjKX1maW5hbGx5e3UoKSxlLm9mZihcImRyYWluXCIscyl9fWFzeW5jIGZ1bmN0aW9uIFRvKHQsZSxyLHtlbmQ6aX0peyRyKGUpJiYoZT1lLndyaXRhYmxlKTtsZXQgbj1lLmdldFdyaXRlcigpO3RyeXtmb3IgYXdhaXQobGV0IG8gb2YgdClhd2FpdCBuLnJlYWR5LG4ud3JpdGUobykuY2F0Y2goKCk9Pnt9KTthd2FpdCBuLnJlYWR5LGkmJmF3YWl0IG4uY2xvc2UoKSxyKCl9Y2F0Y2gobyl7dHJ5e2F3YWl0IG4uYWJvcnQobykscihvKX1jYXRjaChzKXtyKHMpfX19ZnVuY3Rpb24gdjAoLi4udCl7cmV0dXJuIE1oKHQsYTAoXzAodCkpKX1mdW5jdGlvbiBNaCh0LGUscil7aWYodC5sZW5ndGg9PT0xJiZuMCh0WzBdKSYmKHQ9dFswXSksdC5sZW5ndGg8Mil0aHJvdyBuZXcgZjAoXCJzdHJlYW1zXCIpO2xldCBpPW5ldyB3MCxuPWkuc2lnbmFsLG89cj8uc2lnbmFsLHM9W107ZzAobyxcIm9wdGlvbnMuc2lnbmFsXCIpO2Z1bmN0aW9uIGEoKXt5KG5ldyBkMCl9bz8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsYSk7bGV0IHUsYyxoPVtdLGQ9MDtmdW5jdGlvbiBnKEMpe3koQywtLWQ9PT0wKX1mdW5jdGlvbiB5KEMsUil7aWYoQyYmKCF1fHx1LmNvZGU9PT1cIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFXCIpJiYodT1DKSwhKCF1JiYhUikpe2Zvcig7aC5sZW5ndGg7KWguc2hpZnQoKSh1KTtvPy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIixhKSxpLmFib3J0KCksUiYmKHV8fHMuZm9yRWFjaChVPT5VKCkpLGJpLm5leHRUaWNrKGUsdSxjKSl9fWxldCB3O2ZvcihsZXQgQz0wO0M8dC5sZW5ndGg7QysrKXtsZXQgUj10W0NdLFU9Qzx0Lmxlbmd0aC0xLE49Qz4wLFc9VXx8cj8uZW5kIT09ITEsSz1DPT09dC5sZW5ndGgtMTtpZihraChSKSl7bGV0IHo9ZnVuY3Rpb24oUSl7USYmUS5uYW1lIT09XCJBYm9ydEVycm9yXCImJlEuY29kZSE9PVwiRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0VcIiYmZyhRKX07dmFyIEk9ejtpZihXKXtsZXR7ZGVzdHJveTpRLGNsZWFudXA6ZGV9PXhoKFIsVSxOKTtoLnB1c2goUSksdm8oUikmJksmJnMucHVzaChkZSl9Ui5vbihcImVycm9yXCIseiksdm8oUikmJksmJnMucHVzaCgoKT0+e1IucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLHopfSl9aWYoQz09PTApaWYodHlwZW9mIFI9PVwiZnVuY3Rpb25cIil7aWYodz1SKHtzaWduYWw6bn0pLCFjcih3KSl0aHJvdyBuZXcgbW8oXCJJdGVyYWJsZSwgQXN5bmNJdGVyYWJsZSBvciBTdHJlYW1cIixcInNvdXJjZVwiLHcpfWVsc2UgY3IoUil8fHduKFIpfHwkcihSKT93PVI6dz1PaC5mcm9tKFIpO2Vsc2UgaWYodHlwZW9mIFI9PVwiZnVuY3Rpb25cIil7aWYoJHIodykpe3ZhciBFO3c9SW8oKEU9dyk9PT1udWxsfHxFPT09dm9pZCAwP3ZvaWQgMDpFLnJlYWRhYmxlKX1lbHNlIHc9SW8odyk7aWYodz1SKHcse3NpZ25hbDpufSksVSl7aWYoIWNyKHcsITApKXRocm93IG5ldyBtbyhcIkFzeW5jSXRlcmFibGVcIixgdHJhbnNmb3JtWyR7Qy0xfV1gLHcpfWVsc2V7dmFyIFM7U298fChTbz1fbygpKTtsZXQgej1uZXcgU28oe29iamVjdE1vZGU6ITB9KSxRPShTPXcpPT09bnVsbHx8Uz09PXZvaWQgMD92b2lkIDA6Uy50aGVuO2lmKHR5cGVvZiBRPT1cImZ1bmN0aW9uXCIpZCsrLFEuY2FsbCh3LHBlPT57Yz1wZSxwZSE9bnVsbCYmei53cml0ZShwZSksVyYmei5lbmQoKSxiaS5uZXh0VGljayhnKX0scGU9Pnt6LmRlc3Ryb3kocGUpLGJpLm5leHRUaWNrKGcscGUpfSk7ZWxzZSBpZihjcih3LCEwKSlkKyssYm4odyx6LGcse2VuZDpXfSk7ZWxzZSBpZihFbyh3KXx8JHIodykpe2xldCBwZT13LnJlYWRhYmxlfHx3O2QrKyxibihwZSx6LGcse2VuZDpXfSl9ZWxzZSB0aHJvdyBuZXcgbW8oXCJBc3luY0l0ZXJhYmxlIG9yIFByb21pc2VcIixcImRlc3RpbmF0aW9uXCIsdyk7dz16O2xldHtkZXN0cm95OmRlLGNsZWFudXA6R3R9PXhoKHcsITEsITApO2gucHVzaChkZSksSyYmcy5wdXNoKEd0KX19ZWxzZSBpZihraChSKSl7aWYod24odykpe2QrPTI7bGV0IHo9RTAodyxSLGcse2VuZDpXfSk7dm8oUikmJksmJnMucHVzaCh6KX1lbHNlIGlmKCRyKHcpfHxFbyh3KSl7bGV0IHo9dy5yZWFkYWJsZXx8dztkKyssYm4oeixSLGcse2VuZDpXfSl9ZWxzZSBpZihjcih3KSlkKyssYm4odyxSLGcse2VuZDpXfSk7ZWxzZSB0aHJvdyBuZXcgUm8oXCJ2YWxcIixbXCJSZWFkYWJsZVwiLFwiSXRlcmFibGVcIixcIkFzeW5jSXRlcmFibGVcIixcIlJlYWRhYmxlU3RyZWFtXCIsXCJUcmFuc2Zvcm1TdHJlYW1cIl0sdyk7dz1SfWVsc2UgaWYoeTAoUikpe2lmKHduKHcpKWQrKyxUbyhJbyh3KSxSLGcse2VuZDpXfSk7ZWxzZSBpZihFbyh3KXx8Y3IodykpZCsrLFRvKHcsUixnLHtlbmQ6V30pO2Vsc2UgaWYoJHIodykpZCsrLFRvKHcucmVhZGFibGUsUixnLHtlbmQ6V30pO2Vsc2UgdGhyb3cgbmV3IFJvKFwidmFsXCIsW1wiUmVhZGFibGVcIixcIkl0ZXJhYmxlXCIsXCJBc3luY0l0ZXJhYmxlXCIsXCJSZWFkYWJsZVN0cmVhbVwiLFwiVHJhbnNmb3JtU3RyZWFtXCJdLHcpO3c9Un1lbHNlIHc9T2guZnJvbShSKX1yZXR1cm4obiE9bnVsbCYmbi5hYm9ydGVkfHxvIT1udWxsJiZvLmFib3J0ZWQpJiZiaS5uZXh0VGljayhhKSx3fWZ1bmN0aW9uIEUwKHQsZSxyLHtlbmQ6aX0pe2xldCBuPSExO2lmKGUub24oXCJjbG9zZVwiLCgpPT57bnx8cihuZXcgaDApfSksdC5waXBlKGUse2VuZDohMX0pLGkpe2xldCBzPWZ1bmN0aW9uKCl7bj0hMCxlLmVuZCgpfTt2YXIgbz1zO2IwKHQpP2JpLm5leHRUaWNrKHMpOnQub25jZShcImVuZFwiLHMpfWVsc2UgcigpO3JldHVybiBfbih0LHtyZWFkYWJsZTohMCx3cml0YWJsZTohMX0scz0+e2xldCBhPXQuX3JlYWRhYmxlU3RhdGU7cyYmcy5jb2RlPT09XCJFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRVwiJiZhJiZhLmVuZGVkJiYhYS5lcnJvcmVkJiYhYS5lcnJvckVtaXR0ZWQ/dC5vbmNlKFwiZW5kXCIscikub25jZShcImVycm9yXCIscik6cihzKX0pLF9uKGUse3JlYWRhYmxlOiExLHdyaXRhYmxlOiEwfSxyKX1MaC5leHBvcnRzPXtwaXBlbGluZUltcGw6TWgscGlwZWxpbmU6djB9fSk7dmFyIEJvPU0oKGZDLEZoKT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhcntwaXBlbGluZTpTMH09bW4oKSx2bj1udCgpLHtkZXN0cm95ZXI6QTB9PXRyKCkse2lzTm9kZVN0cmVhbTpFbixpc1JlYWRhYmxlOlVoLGlzV3JpdGFibGU6TmgsaXNXZWJTdHJlYW06Q28saXNUcmFuc2Zvcm1TdHJlYW06aHIsaXNXcml0YWJsZVN0cmVhbTpxaCxpc1JlYWRhYmxlU3RyZWFtOkRofT10dCgpLHtBYm9ydEVycm9yOkkwLGNvZGVzOntFUlJfSU5WQUxJRF9BUkdfVkFMVUU6amgsRVJSX01JU1NJTkdfQVJHUzpUMH19PVNlKCksUjA9bXQoKTtGaC5leHBvcnRzPWZ1bmN0aW9uKC4uLmUpe2lmKGUubGVuZ3RoPT09MCl0aHJvdyBuZXcgVDAoXCJzdHJlYW1zXCIpO2lmKGUubGVuZ3RoPT09MSlyZXR1cm4gdm4uZnJvbShlWzBdKTtsZXQgcj1bLi4uZV07aWYodHlwZW9mIGVbMF09PVwiZnVuY3Rpb25cIiYmKGVbMF09dm4uZnJvbShlWzBdKSksdHlwZW9mIGVbZS5sZW5ndGgtMV09PVwiZnVuY3Rpb25cIil7bGV0IHk9ZS5sZW5ndGgtMTtlW3ldPXZuLmZyb20oZVt5XSl9Zm9yKGxldCB5PTA7eTxlLmxlbmd0aDsrK3kpaWYoISghRW4oZVt5XSkmJiFDbyhlW3ldKSkpe2lmKHk8ZS5sZW5ndGgtMSYmIShVaChlW3ldKXx8RGgoZVt5XSl8fGhyKGVbeV0pKSl0aHJvdyBuZXcgamgoYHN0cmVhbXNbJHt5fV1gLHJbeV0sXCJtdXN0IGJlIHJlYWRhYmxlXCIpO2lmKHk+MCYmIShOaChlW3ldKXx8cWgoZVt5XSl8fGhyKGVbeV0pKSl0aHJvdyBuZXcgamgoYHN0cmVhbXNbJHt5fV1gLHJbeV0sXCJtdXN0IGJlIHdyaXRhYmxlXCIpfWxldCBpLG4sbyxzLGE7ZnVuY3Rpb24gdSh5KXtsZXQgdz1zO3M9bnVsbCx3P3coeSk6eT9hLmRlc3Ryb3koeSk6IWcmJiFkJiZhLmRlc3Ryb3koKX1sZXQgYz1lWzBdLGg9UzAoZSx1KSxkPSEhKE5oKGMpfHxxaChjKXx8aHIoYykpLGc9ISEoVWgoaCl8fERoKGgpfHxocihoKSk7aWYoYT1uZXcgdm4oe3dyaXRhYmxlT2JqZWN0TW9kZTohIShjIT1udWxsJiZjLndyaXRhYmxlT2JqZWN0TW9kZSkscmVhZGFibGVPYmplY3RNb2RlOiEhKGghPW51bGwmJmgud3JpdGFibGVPYmplY3RNb2RlKSx3cml0YWJsZTpkLHJlYWRhYmxlOmd9KSxkKXtpZihFbihjKSlhLl93cml0ZT1mdW5jdGlvbih3LEUsUyl7Yy53cml0ZSh3LEUpP1MoKTppPVN9LGEuX2ZpbmFsPWZ1bmN0aW9uKHcpe2MuZW5kKCksbj13fSxjLm9uKFwiZHJhaW5cIixmdW5jdGlvbigpe2lmKGkpe2xldCB3PWk7aT1udWxsLHcoKX19KTtlbHNlIGlmKENvKGMpKXtsZXQgRT0oaHIoYyk/Yy53cml0YWJsZTpjKS5nZXRXcml0ZXIoKTthLl93cml0ZT1hc3luYyBmdW5jdGlvbihTLEksQyl7dHJ5e2F3YWl0IEUucmVhZHksRS53cml0ZShTKS5jYXRjaCgoKT0+e30pLEMoKX1jYXRjaChSKXtDKFIpfX0sYS5fZmluYWw9YXN5bmMgZnVuY3Rpb24oUyl7dHJ5e2F3YWl0IEUucmVhZHksRS5jbG9zZSgpLmNhdGNoKCgpPT57fSksbj1TfWNhdGNoKEkpe1MoSSl9fX1sZXQgeT1ocihoKT9oLnJlYWRhYmxlOmg7UjAoeSwoKT0+e2lmKG4pe2xldCB3PW47bj1udWxsLHcoKX19KX1pZihnKXtpZihFbihoKSloLm9uKFwicmVhZGFibGVcIixmdW5jdGlvbigpe2lmKG8pe2xldCB5PW87bz1udWxsLHkoKX19KSxoLm9uKFwiZW5kXCIsZnVuY3Rpb24oKXthLnB1c2gobnVsbCl9KSxhLl9yZWFkPWZ1bmN0aW9uKCl7Zm9yKDs7KXtsZXQgeT1oLnJlYWQoKTtpZih5PT09bnVsbCl7bz1hLl9yZWFkO3JldHVybn1pZighYS5wdXNoKHkpKXJldHVybn19O2Vsc2UgaWYoQ28oaCkpe2xldCB3PShocihoKT9oLnJlYWRhYmxlOmgpLmdldFJlYWRlcigpO2EuX3JlYWQ9YXN5bmMgZnVuY3Rpb24oKXtmb3IoOzspdHJ5e2xldHt2YWx1ZTpFLGRvbmU6U309YXdhaXQgdy5yZWFkKCk7aWYoIWEucHVzaChFKSlyZXR1cm47aWYoUyl7YS5wdXNoKG51bGwpO3JldHVybn19Y2F0Y2h7cmV0dXJufX19fXJldHVybiBhLl9kZXN0cm95PWZ1bmN0aW9uKHksdyl7IXkmJnMhPT1udWxsJiYoeT1uZXcgSTApLG89bnVsbCxpPW51bGwsbj1udWxsLHM9PT1udWxsP3coeSk6KHM9dyxFbihoKSYmQTAoaCx5KSl9LGF9fSk7dmFyIFFoPU0oKG1DLGtvKT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhciBWaD1nbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcnx8SGkoKS5BYm9ydENvbnRyb2xsZXIse2NvZGVzOntFUlJfSU5WQUxJRF9BUkdfVkFMVUU6QzAsRVJSX0lOVkFMSURfQVJHX1RZUEU6d2ksRVJSX01JU1NJTkdfQVJHUzpCMCxFUlJfT1VUX09GX1JBTkdFOlAwfSxBYm9ydEVycm9yOnN0fT1TZSgpLHt2YWxpZGF0ZUFib3J0U2lnbmFsOmRyLHZhbGlkYXRlSW50ZWdlcjpPMCx2YWxpZGF0ZU9iamVjdDpwcn09dWkoKSxrMD1jZSgpLlN5bWJvbChcImtXZWFrXCIpLHtmaW5pc2hlZDp4MH09bXQoKSxNMD1CbygpLHthZGRBYm9ydFNpZ25hbE5vVmFsaWRhdGU6TDB9PWZpKCkse2lzV3JpdGFibGU6VTAsaXNOb2RlU3RyZWFtOk4wfT10dCgpLHtBcnJheVByb3RvdHlwZVB1c2g6cTAsTWF0aEZsb29yOkQwLE51bWJlcjpqMCxOdW1iZXJJc05hTjpGMCxQcm9taXNlOldoLFByb21pc2VSZWplY3Q6JGgsUHJvbWlzZVByb3RvdHlwZVRoZW46VzAsU3ltYm9sOnpofT1jZSgpLFNuPXpoKFwia0VtcHR5XCIpLEhoPXpoKFwia0VvZlwiKTtmdW5jdGlvbiAkMCh0LGUpe2lmKGUhPW51bGwmJnByKGUsXCJvcHRpb25zXCIpLGU/LnNpZ25hbCE9bnVsbCYmZHIoZS5zaWduYWwsXCJvcHRpb25zLnNpZ25hbFwiKSxOMCh0KSYmIVUwKHQpKXRocm93IG5ldyBDMChcInN0cmVhbVwiLHQsXCJtdXN0IGJlIHdyaXRhYmxlXCIpO2xldCByPU0wKHRoaXMsdCk7cmV0dXJuIGUhPW51bGwmJmUuc2lnbmFsJiZMMChlLnNpZ25hbCxyKSxyfWZ1bmN0aW9uIEFuKHQsZSl7aWYodHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgd2koXCJmblwiLFtcIkZ1bmN0aW9uXCIsXCJBc3luY0Z1bmN0aW9uXCJdLHQpO2UhPW51bGwmJnByKGUsXCJvcHRpb25zXCIpLGU/LnNpZ25hbCE9bnVsbCYmZHIoZS5zaWduYWwsXCJvcHRpb25zLnNpZ25hbFwiKTtsZXQgcj0xO3JldHVybiBlPy5jb25jdXJyZW5jeSE9bnVsbCYmKHI9RDAoZS5jb25jdXJyZW5jeSkpLE8wKHIsXCJjb25jdXJyZW5jeVwiLDEpLGFzeW5jIGZ1bmN0aW9uKigpe3ZhciBuLG87bGV0IHM9bmV3IFZoLGE9dGhpcyx1PVtdLGM9cy5zaWduYWwsaD17c2lnbmFsOmN9LGQ9KCk9PnMuYWJvcnQoKTtlIT1udWxsJiYobj1lLnNpZ25hbCkhPT1udWxsJiZuIT09dm9pZCAwJiZuLmFib3J0ZWQmJmQoKSxlPT1udWxsfHwobz1lLnNpZ25hbCk9PT1udWxsfHxvPT09dm9pZCAwfHxvLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLGQpO2xldCBnLHksdz0hMTtmdW5jdGlvbiBFKCl7dz0hMH1hc3luYyBmdW5jdGlvbiBTKCl7dHJ5e2ZvciBhd2FpdChsZXQgUiBvZiBhKXt2YXIgSTtpZih3KXJldHVybjtpZihjLmFib3J0ZWQpdGhyb3cgbmV3IHN0O3RyeXtSPXQoUixoKX1jYXRjaChVKXtSPSRoKFUpfVIhPT1TbiYmKHR5cGVvZigoST1SKT09PW51bGx8fEk9PT12b2lkIDA/dm9pZCAwOkkuY2F0Y2gpPT1cImZ1bmN0aW9uXCImJlIuY2F0Y2goRSksdS5wdXNoKFIpLGcmJihnKCksZz1udWxsKSwhdyYmdS5sZW5ndGgmJnUubGVuZ3RoPj1yJiZhd2FpdCBuZXcgV2goVT0+e3k9VX0pKX11LnB1c2goSGgpfWNhdGNoKFIpe2xldCBVPSRoKFIpO1cwKFUsdm9pZCAwLEUpLHUucHVzaChVKX1maW5hbGx5e3ZhciBDO3c9ITAsZyYmKGcoKSxnPW51bGwpLGU9PW51bGx8fChDPWUuc2lnbmFsKT09PW51bGx8fEM9PT12b2lkIDB8fEMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsZCl9fVMoKTt0cnl7Zm9yKDs7KXtmb3IoO3UubGVuZ3RoPjA7KXtsZXQgST1hd2FpdCB1WzBdO2lmKEk9PT1IaClyZXR1cm47aWYoYy5hYm9ydGVkKXRocm93IG5ldyBzdDtJIT09U24mJih5aWVsZCBJKSx1LnNoaWZ0KCkseSYmKHkoKSx5PW51bGwpfWF3YWl0IG5ldyBXaChJPT57Zz1JfSl9fWZpbmFsbHl7cy5hYm9ydCgpLHc9ITAseSYmKHkoKSx5PW51bGwpfX0uY2FsbCh0aGlzKX1mdW5jdGlvbiBIMCh0PXZvaWQgMCl7cmV0dXJuIHQhPW51bGwmJnByKHQsXCJvcHRpb25zXCIpLHQ/LnNpZ25hbCE9bnVsbCYmZHIodC5zaWduYWwsXCJvcHRpb25zLnNpZ25hbFwiKSxhc3luYyBmdW5jdGlvbiooKXtsZXQgcj0wO2ZvciBhd2FpdChsZXQgbiBvZiB0aGlzKXt2YXIgaTtpZih0IT1udWxsJiYoaT10LnNpZ25hbCkhPT1udWxsJiZpIT09dm9pZCAwJiZpLmFib3J0ZWQpdGhyb3cgbmV3IHN0KHtjYXVzZTp0LnNpZ25hbC5yZWFzb259KTt5aWVsZFtyKyssbl19fS5jYWxsKHRoaXMpfWFzeW5jIGZ1bmN0aW9uIEtoKHQsZT12b2lkIDApe2ZvciBhd2FpdChsZXQgciBvZiBPby5jYWxsKHRoaXMsdCxlKSlyZXR1cm4hMDtyZXR1cm4hMX1hc3luYyBmdW5jdGlvbiBWMCh0LGU9dm9pZCAwKXtpZih0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyB3aShcImZuXCIsW1wiRnVuY3Rpb25cIixcIkFzeW5jRnVuY3Rpb25cIl0sdCk7cmV0dXJuIWF3YWl0IEtoLmNhbGwodGhpcyxhc3luYyguLi5yKT0+IWF3YWl0IHQoLi4uciksZSl9YXN5bmMgZnVuY3Rpb24gejAodCxlKXtmb3IgYXdhaXQobGV0IHIgb2YgT28uY2FsbCh0aGlzLHQsZSkpcmV0dXJuIHJ9YXN5bmMgZnVuY3Rpb24gSzAodCxlKXtpZih0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyB3aShcImZuXCIsW1wiRnVuY3Rpb25cIixcIkFzeW5jRnVuY3Rpb25cIl0sdCk7YXN5bmMgZnVuY3Rpb24gcihpLG4pe3JldHVybiBhd2FpdCB0KGksbiksU259Zm9yIGF3YWl0KGxldCBpIG9mIEFuLmNhbGwodGhpcyxyLGUpKTt9ZnVuY3Rpb24gT28odCxlKXtpZih0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyB3aShcImZuXCIsW1wiRnVuY3Rpb25cIixcIkFzeW5jRnVuY3Rpb25cIl0sdCk7YXN5bmMgZnVuY3Rpb24gcihpLG4pe3JldHVybiBhd2FpdCB0KGksbik/aTpTbn1yZXR1cm4gQW4uY2FsbCh0aGlzLHIsZSl9dmFyIFBvPWNsYXNzIGV4dGVuZHMgQjB7Y29uc3RydWN0b3IoKXtzdXBlcihcInJlZHVjZVwiKSx0aGlzLm1lc3NhZ2U9XCJSZWR1Y2Ugb2YgYW4gZW1wdHkgc3RyZWFtIHJlcXVpcmVzIGFuIGluaXRpYWwgdmFsdWVcIn19O2FzeW5jIGZ1bmN0aW9uIEcwKHQsZSxyKXt2YXIgaTtpZih0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyB3aShcInJlZHVjZXJcIixbXCJGdW5jdGlvblwiLFwiQXN5bmNGdW5jdGlvblwiXSx0KTtyIT1udWxsJiZwcihyLFwib3B0aW9uc1wiKSxyPy5zaWduYWwhPW51bGwmJmRyKHIuc2lnbmFsLFwib3B0aW9ucy5zaWduYWxcIik7bGV0IG49YXJndW1lbnRzLmxlbmd0aD4xO2lmKHIhPW51bGwmJihpPXIuc2lnbmFsKSE9PW51bGwmJmkhPT12b2lkIDAmJmkuYWJvcnRlZCl7bGV0IGM9bmV3IHN0KHZvaWQgMCx7Y2F1c2U6ci5zaWduYWwucmVhc29ufSk7dGhyb3cgdGhpcy5vbmNlKFwiZXJyb3JcIiwoKT0+e30pLGF3YWl0IHgwKHRoaXMuZGVzdHJveShjKSksY31sZXQgbz1uZXcgVmgscz1vLnNpZ25hbDtpZihyIT1udWxsJiZyLnNpZ25hbCl7bGV0IGM9e29uY2U6ITAsW2swXTp0aGlzfTtyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwoKT0+by5hYm9ydCgpLGMpfWxldCBhPSExO3RyeXtmb3IgYXdhaXQobGV0IGMgb2YgdGhpcyl7dmFyIHU7aWYoYT0hMCxyIT1udWxsJiYodT1yLnNpZ25hbCkhPT1udWxsJiZ1IT09dm9pZCAwJiZ1LmFib3J0ZWQpdGhyb3cgbmV3IHN0O24/ZT1hd2FpdCB0KGUsYyx7c2lnbmFsOnN9KTooZT1jLG49ITApfWlmKCFhJiYhbil0aHJvdyBuZXcgUG99ZmluYWxseXtvLmFib3J0KCl9cmV0dXJuIGV9YXN5bmMgZnVuY3Rpb24gUTAodCl7dCE9bnVsbCYmcHIodCxcIm9wdGlvbnNcIiksdD8uc2lnbmFsIT1udWxsJiZkcih0LnNpZ25hbCxcIm9wdGlvbnMuc2lnbmFsXCIpO2xldCBlPVtdO2ZvciBhd2FpdChsZXQgaSBvZiB0aGlzKXt2YXIgcjtpZih0IT1udWxsJiYocj10LnNpZ25hbCkhPT1udWxsJiZyIT09dm9pZCAwJiZyLmFib3J0ZWQpdGhyb3cgbmV3IHN0KHZvaWQgMCx7Y2F1c2U6dC5zaWduYWwucmVhc29ufSk7cTAoZSxpKX1yZXR1cm4gZX1mdW5jdGlvbiBZMCh0LGUpe2xldCByPUFuLmNhbGwodGhpcyx0LGUpO3JldHVybiBhc3luYyBmdW5jdGlvbiooKXtmb3IgYXdhaXQobGV0IG4gb2Ygcil5aWVsZCpufS5jYWxsKHRoaXMpfWZ1bmN0aW9uIEdoKHQpe2lmKHQ9ajAodCksRjAodCkpcmV0dXJuIDA7aWYodDwwKXRocm93IG5ldyBQMChcIm51bWJlclwiLFwiPj0gMFwiLHQpO3JldHVybiB0fWZ1bmN0aW9uIEowKHQsZT12b2lkIDApe3JldHVybiBlIT1udWxsJiZwcihlLFwib3B0aW9uc1wiKSxlPy5zaWduYWwhPW51bGwmJmRyKGUuc2lnbmFsLFwib3B0aW9ucy5zaWduYWxcIiksdD1HaCh0KSxhc3luYyBmdW5jdGlvbiooKXt2YXIgaTtpZihlIT1udWxsJiYoaT1lLnNpZ25hbCkhPT1udWxsJiZpIT09dm9pZCAwJiZpLmFib3J0ZWQpdGhyb3cgbmV3IHN0O2ZvciBhd2FpdChsZXQgbyBvZiB0aGlzKXt2YXIgbjtpZihlIT1udWxsJiYobj1lLnNpZ25hbCkhPT1udWxsJiZuIT09dm9pZCAwJiZuLmFib3J0ZWQpdGhyb3cgbmV3IHN0O3QtLTw9MCYmKHlpZWxkIG8pfX0uY2FsbCh0aGlzKX1mdW5jdGlvbiBYMCh0LGU9dm9pZCAwKXtyZXR1cm4gZSE9bnVsbCYmcHIoZSxcIm9wdGlvbnNcIiksZT8uc2lnbmFsIT1udWxsJiZkcihlLnNpZ25hbCxcIm9wdGlvbnMuc2lnbmFsXCIpLHQ9R2godCksYXN5bmMgZnVuY3Rpb24qKCl7dmFyIGk7aWYoZSE9bnVsbCYmKGk9ZS5zaWduYWwpIT09bnVsbCYmaSE9PXZvaWQgMCYmaS5hYm9ydGVkKXRocm93IG5ldyBzdDtmb3IgYXdhaXQobGV0IG8gb2YgdGhpcyl7dmFyIG47aWYoZSE9bnVsbCYmKG49ZS5zaWduYWwpIT09bnVsbCYmbiE9PXZvaWQgMCYmbi5hYm9ydGVkKXRocm93IG5ldyBzdDtpZih0LS0gPjApeWllbGQgbztlbHNlIHJldHVybn19LmNhbGwodGhpcyl9a28uZXhwb3J0cy5zdHJlYW1SZXR1cm5pbmdPcGVyYXRvcnM9e2FzSW5kZXhlZFBhaXJzOkgwLGRyb3A6SjAsZmlsdGVyOk9vLGZsYXRNYXA6WTAsbWFwOkFuLHRha2U6WDAsY29tcG9zZTokMH07a28uZXhwb3J0cy5wcm9taXNlUmV0dXJuaW5nT3BlcmF0b3JzPXtldmVyeTpWMCxmb3JFYWNoOkswLHJlZHVjZTpHMCx0b0FycmF5OlEwLHNvbWU6S2gsZmluZDp6MH19KTt2YXIgeG89TSgoUEMsWWgpPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7dmFye0FycmF5UHJvdG90eXBlUG9wOlowLFByb21pc2U6ZW19PWNlKCkse2lzSXRlcmFibGU6dG0saXNOb2RlU3RyZWFtOnJtLGlzV2ViU3RyZWFtOmltfT10dCgpLHtwaXBlbGluZUltcGw6bm19PW1uKCkse2ZpbmlzaGVkOnNtfT1tdCgpO01vKCk7ZnVuY3Rpb24gb20oLi4udCl7cmV0dXJuIG5ldyBlbSgoZSxyKT0+e2xldCBpLG4sbz10W3QubGVuZ3RoLTFdO2lmKG8mJnR5cGVvZiBvPT1cIm9iamVjdFwiJiYhcm0obykmJiF0bShvKSYmIWltKG8pKXtsZXQgcz1aMCh0KTtpPXMuc2lnbmFsLG49cy5lbmR9bm0odCwocyxhKT0+e3M/cihzKTplKGEpfSx7c2lnbmFsOmksZW5kOm59KX0pfVloLmV4cG9ydHM9e2ZpbmlzaGVkOnNtLHBpcGVsaW5lOm9tfX0pO3ZhciBNbz1NKChqQyxzZCk9Pnt2KCk7bSgpO18oKTt2YXJ7QnVmZmVyOmFtfT0od2UoKSxaKHZlKSkse09iamVjdERlZmluZVByb3BlcnR5OlR0LE9iamVjdEtleXM6WmgsUmVmbGVjdEFwcGx5OmVkfT1jZSgpLHtwcm9taXNpZnk6e2N1c3RvbTp0ZH19PUplKCkse3N0cmVhbVJldHVybmluZ09wZXJhdG9yczpKaCxwcm9taXNlUmV0dXJuaW5nT3BlcmF0b3JzOlhofT1RaCgpLHtjb2Rlczp7RVJSX0lMTEVHQUxfQ09OU1RSVUNUT1I6cmR9fT1TZSgpLGxtPUJvKCkse3BpcGVsaW5lOmlkfT1tbigpLHtkZXN0cm95ZXI6dW19PXRyKCksbmQ9bXQoKSxMbz14bygpLFVvPXR0KCksbGU9c2QuZXhwb3J0cz10bigpLlN0cmVhbTtsZS5pc0Rpc3R1cmJlZD1Vby5pc0Rpc3R1cmJlZDtsZS5pc0Vycm9yZWQ9VW8uaXNFcnJvcmVkO2xlLmlzUmVhZGFibGU9VW8uaXNSZWFkYWJsZTtsZS5SZWFkYWJsZT1oaSgpO2ZvcihsZXQgdCBvZiBaaChKaCkpe2xldCByPWZ1bmN0aW9uKC4uLmkpe2lmKG5ldy50YXJnZXQpdGhyb3cgcmQoKTtyZXR1cm4gbGUuUmVhZGFibGUuZnJvbShlZChlLHRoaXMsaSkpfTtObz1yO2xldCBlPUpoW3RdO1R0KHIsXCJuYW1lXCIse19fcHJvdG9fXzpudWxsLHZhbHVlOmUubmFtZX0pLFR0KHIsXCJsZW5ndGhcIix7X19wcm90b19fOm51bGwsdmFsdWU6ZS5sZW5ndGh9KSxUdChsZS5SZWFkYWJsZS5wcm90b3R5cGUsdCx7X19wcm90b19fOm51bGwsdmFsdWU6cixlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pfXZhciBObztmb3IobGV0IHQgb2YgWmgoWGgpKXtsZXQgcj1mdW5jdGlvbiguLi5uKXtpZihuZXcudGFyZ2V0KXRocm93IHJkKCk7cmV0dXJuIGVkKGUsdGhpcyxuKX07Tm89cjtsZXQgZT1YaFt0XTtUdChyLFwibmFtZVwiLHtfX3Byb3RvX186bnVsbCx2YWx1ZTplLm5hbWV9KSxUdChyLFwibGVuZ3RoXCIse19fcHJvdG9fXzpudWxsLHZhbHVlOmUubGVuZ3RofSksVHQobGUuUmVhZGFibGUucHJvdG90eXBlLHQse19fcHJvdG9fXzpudWxsLHZhbHVlOnIsZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KX12YXIgTm87bGUuV3JpdGFibGU9dW8oKTtsZS5EdXBsZXg9bnQoKTtsZS5UcmFuc2Zvcm09Ym8oKTtsZS5QYXNzVGhyb3VnaD1fbygpO2xlLnBpcGVsaW5lPWlkO3ZhcnthZGRBYm9ydFNpZ25hbDpmbX09ZmkoKTtsZS5hZGRBYm9ydFNpZ25hbD1mbTtsZS5maW5pc2hlZD1uZDtsZS5kZXN0cm95PXVtO2xlLmNvbXBvc2U9bG07VHQobGUsXCJwcm9taXNlc1wiLHtfX3Byb3RvX186bnVsbCxjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCxnZXQoKXtyZXR1cm4gTG99fSk7VHQoaWQsdGQse19fcHJvdG9fXzpudWxsLGVudW1lcmFibGU6ITAsZ2V0KCl7cmV0dXJuIExvLnBpcGVsaW5lfX0pO1R0KG5kLHRkLHtfX3Byb3RvX186bnVsbCxlbnVtZXJhYmxlOiEwLGdldCgpe3JldHVybiBMby5maW5pc2hlZH19KTtsZS5TdHJlYW09bGU7bGUuX2lzVWludDhBcnJheT1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl9O2xlLl91aW50OEFycmF5VG9CdWZmZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIGFtLmZyb20oZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCl9fSk7dmFyIER0PU0oKFlDLHVlKT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhciBoZT1NbygpLGNtPXhvKCksaG09aGUuUmVhZGFibGUuZGVzdHJveTt1ZS5leHBvcnRzPWhlLlJlYWRhYmxlO3VlLmV4cG9ydHMuX3VpbnQ4QXJyYXlUb0J1ZmZlcj1oZS5fdWludDhBcnJheVRvQnVmZmVyO3VlLmV4cG9ydHMuX2lzVWludDhBcnJheT1oZS5faXNVaW50OEFycmF5O3VlLmV4cG9ydHMuaXNEaXN0dXJiZWQ9aGUuaXNEaXN0dXJiZWQ7dWUuZXhwb3J0cy5pc0Vycm9yZWQ9aGUuaXNFcnJvcmVkO3VlLmV4cG9ydHMuaXNSZWFkYWJsZT1oZS5pc1JlYWRhYmxlO3VlLmV4cG9ydHMuUmVhZGFibGU9aGUuUmVhZGFibGU7dWUuZXhwb3J0cy5Xcml0YWJsZT1oZS5Xcml0YWJsZTt1ZS5leHBvcnRzLkR1cGxleD1oZS5EdXBsZXg7dWUuZXhwb3J0cy5UcmFuc2Zvcm09aGUuVHJhbnNmb3JtO3VlLmV4cG9ydHMuUGFzc1Rocm91Z2g9aGUuUGFzc1Rocm91Z2g7dWUuZXhwb3J0cy5hZGRBYm9ydFNpZ25hbD1oZS5hZGRBYm9ydFNpZ25hbDt1ZS5leHBvcnRzLmZpbmlzaGVkPWhlLmZpbmlzaGVkO3VlLmV4cG9ydHMuZGVzdHJveT1oZS5kZXN0cm95O3VlLmV4cG9ydHMuZGVzdHJveT1obTt1ZS5leHBvcnRzLnBpcGVsaW5lPWhlLnBpcGVsaW5lO3VlLmV4cG9ydHMuY29tcG9zZT1oZS5jb21wb3NlO09iamVjdC5kZWZpbmVQcm9wZXJ0eShoZSxcInByb21pc2VzXCIse2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLGdldCgpe3JldHVybiBjbX19KTt1ZS5leHBvcnRzLlN0cmVhbT1oZS5TdHJlYW07dWUuZXhwb3J0cy5kZWZhdWx0PXVlLmV4cG9ydHN9KTt2YXIgb2Q9TSgob0IscW8pPT57digpO20oKTtfKCk7dHlwZW9mIE9iamVjdC5jcmVhdGU9PVwiZnVuY3Rpb25cIj9xby5leHBvcnRzPWZ1bmN0aW9uKGUscil7ciYmKGUuc3VwZXJfPXIsZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSkpfTpxby5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYocil7ZS5zdXBlcl89cjt2YXIgaT1mdW5jdGlvbigpe307aS5wcm90b3R5cGU9ci5wcm90b3R5cGUsZS5wcm90b3R5cGU9bmV3IGksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZX19fSk7dmFyIHVkPU0oKHlCLGxkKT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhcntCdWZmZXI6emV9PSh3ZSgpLFoodmUpKSxhZD1TeW1ib2wuZm9yKFwiQnVmZmVyTGlzdFwiKTtmdW5jdGlvbiBlZSh0KXtpZighKHRoaXMgaW5zdGFuY2VvZiBlZSkpcmV0dXJuIG5ldyBlZSh0KTtlZS5faW5pdC5jYWxsKHRoaXMsdCl9ZWUuX2luaXQ9ZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsYWQse3ZhbHVlOiEwfSksdGhpcy5fYnVmcz1bXSx0aGlzLmxlbmd0aD0wLGUmJnRoaXMuYXBwZW5kKGUpfTtlZS5wcm90b3R5cGUuX25ldz1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IGVlKGUpfTtlZS5wcm90b3R5cGUuX29mZnNldD1mdW5jdGlvbihlKXtpZihlPT09MClyZXR1cm5bMCwwXTtsZXQgcj0wO2ZvcihsZXQgaT0wO2k8dGhpcy5fYnVmcy5sZW5ndGg7aSsrKXtsZXQgbj1yK3RoaXMuX2J1ZnNbaV0ubGVuZ3RoO2lmKGU8bnx8aT09PXRoaXMuX2J1ZnMubGVuZ3RoLTEpcmV0dXJuW2ksZS1yXTtyPW59fTtlZS5wcm90b3R5cGUuX3JldmVyc2VPZmZzZXQ9ZnVuY3Rpb24odCl7bGV0IGU9dFswXSxyPXRbMV07Zm9yKGxldCBpPTA7aTxlO2krKylyKz10aGlzLl9idWZzW2ldLmxlbmd0aDtyZXR1cm4gcn07ZWUucHJvdG90eXBlLmdldD1mdW5jdGlvbihlKXtpZihlPnRoaXMubGVuZ3RofHxlPDApcmV0dXJuO2xldCByPXRoaXMuX29mZnNldChlKTtyZXR1cm4gdGhpcy5fYnVmc1tyWzBdXVtyWzFdXX07ZWUucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKGUscil7cmV0dXJuIHR5cGVvZiBlPT1cIm51bWJlclwiJiZlPDAmJihlKz10aGlzLmxlbmd0aCksdHlwZW9mIHI9PVwibnVtYmVyXCImJnI8MCYmKHIrPXRoaXMubGVuZ3RoKSx0aGlzLmNvcHkobnVsbCwwLGUscil9O2VlLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGUscixpLG4pe2lmKCh0eXBlb2YgaSE9XCJudW1iZXJcInx8aTwwKSYmKGk9MCksKHR5cGVvZiBuIT1cIm51bWJlclwifHxuPnRoaXMubGVuZ3RoKSYmKG49dGhpcy5sZW5ndGgpLGk+PXRoaXMubGVuZ3RofHxuPD0wKXJldHVybiBlfHx6ZS5hbGxvYygwKTtsZXQgbz0hIWUscz10aGlzLl9vZmZzZXQoaSksYT1uLWksdT1hLGM9byYmcnx8MCxoPXNbMV07aWYoaT09PTAmJm49PT10aGlzLmxlbmd0aCl7aWYoIW8pcmV0dXJuIHRoaXMuX2J1ZnMubGVuZ3RoPT09MT90aGlzLl9idWZzWzBdOnplLmNvbmNhdCh0aGlzLl9idWZzLHRoaXMubGVuZ3RoKTtmb3IobGV0IGQ9MDtkPHRoaXMuX2J1ZnMubGVuZ3RoO2QrKyl0aGlzLl9idWZzW2RdLmNvcHkoZSxjKSxjKz10aGlzLl9idWZzW2RdLmxlbmd0aDtyZXR1cm4gZX1pZih1PD10aGlzLl9idWZzW3NbMF1dLmxlbmd0aC1oKXJldHVybiBvP3RoaXMuX2J1ZnNbc1swXV0uY29weShlLHIsaCxoK3UpOnRoaXMuX2J1ZnNbc1swXV0uc2xpY2UoaCxoK3UpO298fChlPXplLmFsbG9jVW5zYWZlKGEpKTtmb3IobGV0IGQ9c1swXTtkPHRoaXMuX2J1ZnMubGVuZ3RoO2QrKyl7bGV0IGc9dGhpcy5fYnVmc1tkXS5sZW5ndGgtaDtpZih1PmcpdGhpcy5fYnVmc1tkXS5jb3B5KGUsYyxoKSxjKz1nO2Vsc2V7dGhpcy5fYnVmc1tkXS5jb3B5KGUsYyxoLGgrdSksYys9ZzticmVha311LT1nLGgmJihoPTApfXJldHVybiBlLmxlbmd0aD5jP2Uuc2xpY2UoMCxjKTplfTtlZS5wcm90b3R5cGUuc2hhbGxvd1NsaWNlPWZ1bmN0aW9uKGUscil7aWYoZT1lfHwwLHI9dHlwZW9mIHIhPVwibnVtYmVyXCI/dGhpcy5sZW5ndGg6cixlPDAmJihlKz10aGlzLmxlbmd0aCkscjwwJiYocis9dGhpcy5sZW5ndGgpLGU9PT1yKXJldHVybiB0aGlzLl9uZXcoKTtsZXQgaT10aGlzLl9vZmZzZXQoZSksbj10aGlzLl9vZmZzZXQociksbz10aGlzLl9idWZzLnNsaWNlKGlbMF0sblswXSsxKTtyZXR1cm4gblsxXT09PTA/by5wb3AoKTpvW28ubGVuZ3RoLTFdPW9bby5sZW5ndGgtMV0uc2xpY2UoMCxuWzFdKSxpWzFdIT09MCYmKG9bMF09b1swXS5zbGljZShpWzFdKSksdGhpcy5fbmV3KG8pfTtlZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oZSxyLGkpe3JldHVybiB0aGlzLnNsaWNlKHIsaSkudG9TdHJpbmcoZSl9O2VlLnByb3RvdHlwZS5jb25zdW1lPWZ1bmN0aW9uKGUpe2lmKGU9TWF0aC50cnVuYyhlKSxOdW1iZXIuaXNOYU4oZSl8fGU8PTApcmV0dXJuIHRoaXM7Zm9yKDt0aGlzLl9idWZzLmxlbmd0aDspaWYoZT49dGhpcy5fYnVmc1swXS5sZW5ndGgpZS09dGhpcy5fYnVmc1swXS5sZW5ndGgsdGhpcy5sZW5ndGgtPXRoaXMuX2J1ZnNbMF0ubGVuZ3RoLHRoaXMuX2J1ZnMuc2hpZnQoKTtlbHNle3RoaXMuX2J1ZnNbMF09dGhpcy5fYnVmc1swXS5zbGljZShlKSx0aGlzLmxlbmd0aC09ZTticmVha31yZXR1cm4gdGhpc307ZWUucHJvdG90eXBlLmR1cGxpY2F0ZT1mdW5jdGlvbigpe2xldCBlPXRoaXMuX25ldygpO2ZvcihsZXQgcj0wO3I8dGhpcy5fYnVmcy5sZW5ndGg7cisrKWUuYXBwZW5kKHRoaXMuX2J1ZnNbcl0pO3JldHVybiBlfTtlZS5wcm90b3R5cGUuYXBwZW5kPWZ1bmN0aW9uKGUpe2lmKGU9PW51bGwpcmV0dXJuIHRoaXM7aWYoZS5idWZmZXIpdGhpcy5fYXBwZW5kQnVmZmVyKHplLmZyb20oZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCkpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShlKSlmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl0aGlzLmFwcGVuZChlW3JdKTtlbHNlIGlmKHRoaXMuX2lzQnVmZmVyTGlzdChlKSlmb3IobGV0IHI9MDtyPGUuX2J1ZnMubGVuZ3RoO3IrKyl0aGlzLmFwcGVuZChlLl9idWZzW3JdKTtlbHNlIHR5cGVvZiBlPT1cIm51bWJlclwiJiYoZT1lLnRvU3RyaW5nKCkpLHRoaXMuX2FwcGVuZEJ1ZmZlcih6ZS5mcm9tKGUpKTtyZXR1cm4gdGhpc307ZWUucHJvdG90eXBlLl9hcHBlbmRCdWZmZXI9ZnVuY3Rpb24oZSl7dGhpcy5fYnVmcy5wdXNoKGUpLHRoaXMubGVuZ3RoKz1lLmxlbmd0aH07ZWUucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24odCxlLHIpe2lmKHI9PT12b2lkIDAmJnR5cGVvZiBlPT1cInN0cmluZ1wiJiYocj1lLGU9dm9pZCAwKSx0eXBlb2YgdD09XCJmdW5jdGlvblwifHxBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQnVmZmVyTGlzdCwgb3IgVWludDhBcnJheS4nKTtpZih0eXBlb2YgdD09XCJudW1iZXJcIj90PXplLmZyb20oW3RdKTp0eXBlb2YgdD09XCJzdHJpbmdcIj90PXplLmZyb20odCxyKTp0aGlzLl9pc0J1ZmZlckxpc3QodCk/dD10LnNsaWNlKCk6QXJyYXkuaXNBcnJheSh0LmJ1ZmZlcik/dD16ZS5mcm9tKHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpOnplLmlzQnVmZmVyKHQpfHwodD16ZS5mcm9tKHQpKSxlPU51bWJlcihlfHwwKSxpc05hTihlKSYmKGU9MCksZTwwJiYoZT10aGlzLmxlbmd0aCtlKSxlPDAmJihlPTApLHQubGVuZ3RoPT09MClyZXR1cm4gZT50aGlzLmxlbmd0aD90aGlzLmxlbmd0aDplO2xldCBpPXRoaXMuX29mZnNldChlKSxuPWlbMF0sbz1pWzFdO2Zvcig7bjx0aGlzLl9idWZzLmxlbmd0aDtuKyspe2xldCBzPXRoaXMuX2J1ZnNbbl07Zm9yKDtvPHMubGVuZ3RoOylpZihzLmxlbmd0aC1vPj10Lmxlbmd0aCl7bGV0IHU9cy5pbmRleE9mKHQsbyk7aWYodSE9PS0xKXJldHVybiB0aGlzLl9yZXZlcnNlT2Zmc2V0KFtuLHVdKTtvPXMubGVuZ3RoLXQubGVuZ3RoKzF9ZWxzZXtsZXQgdT10aGlzLl9yZXZlcnNlT2Zmc2V0KFtuLG9dKTtpZih0aGlzLl9tYXRjaCh1LHQpKXJldHVybiB1O28rK31vPTB9cmV0dXJuLTF9O2VlLnByb3RvdHlwZS5fbWF0Y2g9ZnVuY3Rpb24odCxlKXtpZih0aGlzLmxlbmd0aC10PGUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKWlmKHRoaXMuZ2V0KHQrcikhPT1lW3JdKXJldHVybiExO3JldHVybiEwfTsoZnVuY3Rpb24oKXtsZXQgdD17cmVhZERvdWJsZUJFOjgscmVhZERvdWJsZUxFOjgscmVhZEZsb2F0QkU6NCxyZWFkRmxvYXRMRTo0LHJlYWRCaWdJbnQ2NEJFOjgscmVhZEJpZ0ludDY0TEU6OCxyZWFkQmlnVUludDY0QkU6OCxyZWFkQmlnVUludDY0TEU6OCxyZWFkSW50MzJCRTo0LHJlYWRJbnQzMkxFOjQscmVhZFVJbnQzMkJFOjQscmVhZFVJbnQzMkxFOjQscmVhZEludDE2QkU6MixyZWFkSW50MTZMRToyLHJlYWRVSW50MTZCRToyLHJlYWRVSW50MTZMRToyLHJlYWRJbnQ4OjEscmVhZFVJbnQ4OjEscmVhZEludEJFOm51bGwscmVhZEludExFOm51bGwscmVhZFVJbnRCRTpudWxsLHJlYWRVSW50TEU6bnVsbH07Zm9yKGxldCBlIGluIHQpKGZ1bmN0aW9uKHIpe3Rbcl09PT1udWxsP2VlLnByb3RvdHlwZVtyXT1mdW5jdGlvbihpLG4pe3JldHVybiB0aGlzLnNsaWNlKGksaStuKVtyXSgwLG4pfTplZS5wcm90b3R5cGVbcl09ZnVuY3Rpb24oaT0wKXtyZXR1cm4gdGhpcy5zbGljZShpLGkrdFtyXSlbcl0oMCl9fSkoZSl9KSgpO2VlLnByb3RvdHlwZS5faXNCdWZmZXJMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgZWV8fGVlLmlzQnVmZmVyTGlzdChlKX07ZWUuaXNCdWZmZXJMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiBlIT1udWxsJiZlW2FkXX07bGQuZXhwb3J0cz1lZX0pO3ZhciBmZD1NKChUQixJbik9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTt2YXIgRG89RHQoKS5EdXBsZXgsZG09b2QoKSxfaT11ZCgpO2Z1bmN0aW9uIEVlKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIEVlKSlyZXR1cm4gbmV3IEVlKHQpO2lmKHR5cGVvZiB0PT1cImZ1bmN0aW9uXCIpe3RoaXMuX2NhbGxiYWNrPXQ7bGV0IGU9ZnVuY3Rpb24oaSl7dGhpcy5fY2FsbGJhY2smJih0aGlzLl9jYWxsYmFjayhpKSx0aGlzLl9jYWxsYmFjaz1udWxsKX0uYmluZCh0aGlzKTt0aGlzLm9uKFwicGlwZVwiLGZ1bmN0aW9uKGkpe2kub24oXCJlcnJvclwiLGUpfSksdGhpcy5vbihcInVucGlwZVwiLGZ1bmN0aW9uKGkpe2kucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLGUpfSksdD1udWxsfV9pLl9pbml0LmNhbGwodGhpcyx0KSxEby5jYWxsKHRoaXMpfWRtKEVlLERvKTtPYmplY3QuYXNzaWduKEVlLnByb3RvdHlwZSxfaS5wcm90b3R5cGUpO0VlLnByb3RvdHlwZS5fbmV3PWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgRWUoZSl9O0VlLnByb3RvdHlwZS5fd3JpdGU9ZnVuY3Rpb24oZSxyLGkpe3RoaXMuX2FwcGVuZEJ1ZmZlcihlKSx0eXBlb2YgaT09XCJmdW5jdGlvblwiJiZpKCl9O0VlLnByb3RvdHlwZS5fcmVhZD1mdW5jdGlvbihlKXtpZighdGhpcy5sZW5ndGgpcmV0dXJuIHRoaXMucHVzaChudWxsKTtlPU1hdGgubWluKGUsdGhpcy5sZW5ndGgpLHRoaXMucHVzaCh0aGlzLnNsaWNlKDAsZSkpLHRoaXMuY29uc3VtZShlKX07RWUucHJvdG90eXBlLmVuZD1mdW5jdGlvbihlKXtEby5wcm90b3R5cGUuZW5kLmNhbGwodGhpcyxlKSx0aGlzLl9jYWxsYmFjayYmKHRoaXMuX2NhbGxiYWNrKG51bGwsdGhpcy5zbGljZSgpKSx0aGlzLl9jYWxsYmFjaz1udWxsKX07RWUucHJvdG90eXBlLl9kZXN0cm95PWZ1bmN0aW9uKGUscil7dGhpcy5fYnVmcy5sZW5ndGg9MCx0aGlzLmxlbmd0aD0wLHIoZSl9O0VlLnByb3RvdHlwZS5faXNCdWZmZXJMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgRWV8fGUgaW5zdGFuY2VvZiBfaXx8RWUuaXNCdWZmZXJMaXN0KGUpfTtFZS5pc0J1ZmZlckxpc3Q9X2kuaXNCdWZmZXJMaXN0O0luLmV4cG9ydHM9RWU7SW4uZXhwb3J0cy5CdWZmZXJMaXN0U3RyZWFtPUVlO0luLmV4cG9ydHMuQnVmZmVyTGlzdD1faX0pO3ZhciBoZD1NKChVQixjZCk9Pnt2KCk7bSgpO18oKTt2YXIgam89Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmNtZD1udWxsLHRoaXMucmV0YWluPSExLHRoaXMucW9zPTAsdGhpcy5kdXA9ITEsdGhpcy5sZW5ndGg9LTEsdGhpcy50b3BpYz1udWxsLHRoaXMucGF5bG9hZD1udWxsfX07Y2QuZXhwb3J0cz1qb30pO3ZhciBGbz1NKCh6QixkZCk9Pnt2KCk7bSgpO18oKTt2YXIgTD1kZC5leHBvcnRzLHtCdWZmZXI6T2V9PSh3ZSgpLFoodmUpKTtMLnR5cGVzPXswOlwicmVzZXJ2ZWRcIiwxOlwiY29ubmVjdFwiLDI6XCJjb25uYWNrXCIsMzpcInB1Ymxpc2hcIiw0OlwicHViYWNrXCIsNTpcInB1YnJlY1wiLDY6XCJwdWJyZWxcIiw3OlwicHViY29tcFwiLDg6XCJzdWJzY3JpYmVcIiw5Olwic3ViYWNrXCIsMTA6XCJ1bnN1YnNjcmliZVwiLDExOlwidW5zdWJhY2tcIiwxMjpcInBpbmdyZXFcIiwxMzpcInBpbmdyZXNwXCIsMTQ6XCJkaXNjb25uZWN0XCIsMTU6XCJhdXRoXCJ9O0wucmVxdWlyZWRIZWFkZXJGbGFncz17MTowLDI6MCw0OjAsNTowLDY6Miw3OjAsODoyLDk6MCwxMDoyLDExOjAsMTI6MCwxMzowLDE0OjAsMTU6MH07TC5yZXF1aXJlZEhlYWRlckZsYWdzRXJyb3JzPXt9O2ZvcihsZXQgdCBpbiBMLnJlcXVpcmVkSGVhZGVyRmxhZ3Mpe2xldCBlPUwucmVxdWlyZWRIZWFkZXJGbGFnc1t0XTtMLnJlcXVpcmVkSGVhZGVyRmxhZ3NFcnJvcnNbdF09XCJJbnZhbGlkIGhlYWRlciBmbGFnIGJpdHMsIG11c3QgYmUgMHhcIitlLnRvU3RyaW5nKDE2KStcIiBmb3IgXCIrTC50eXBlc1t0XStcIiBwYWNrZXRcIn1MLmNvZGVzPXt9O2ZvcihsZXQgdCBpbiBMLnR5cGVzKXtsZXQgZT1MLnR5cGVzW3RdO0wuY29kZXNbZV09dH1MLkNNRF9TSElGVD00O0wuQ01EX01BU0s9MjQwO0wuRFVQX01BU0s9ODtMLlFPU19NQVNLPTM7TC5RT1NfU0hJRlQ9MTtMLlJFVEFJTl9NQVNLPTE7TC5WQVJCWVRFSU5UX01BU0s9MTI3O0wuVkFSQllURUlOVF9GSU5fTUFTSz0xMjg7TC5WQVJCWVRFSU5UX01BWD0yNjg0MzU0NTU7TC5TRVNTSU9OUFJFU0VOVF9NQVNLPTE7TC5TRVNTSU9OUFJFU0VOVF9IRUFERVI9T2UuZnJvbShbTC5TRVNTSU9OUFJFU0VOVF9NQVNLXSk7TC5DT05OQUNLX0hFQURFUj1PZS5mcm9tKFtMLmNvZGVzLmNvbm5hY2s8PEwuQ01EX1NISUZUXSk7TC5VU0VSTkFNRV9NQVNLPTEyODtMLlBBU1NXT1JEX01BU0s9NjQ7TC5XSUxMX1JFVEFJTl9NQVNLPTMyO0wuV0lMTF9RT1NfTUFTSz0yNDtMLldJTExfUU9TX1NISUZUPTM7TC5XSUxMX0ZMQUdfTUFTSz00O0wuQ0xFQU5fU0VTU0lPTl9NQVNLPTI7TC5DT05ORUNUX0hFQURFUj1PZS5mcm9tKFtMLmNvZGVzLmNvbm5lY3Q8PEwuQ01EX1NISUZUXSk7TC5wcm9wZXJ0aWVzPXtzZXNzaW9uRXhwaXJ5SW50ZXJ2YWw6MTcsd2lsbERlbGF5SW50ZXJ2YWw6MjQscmVjZWl2ZU1heGltdW06MzMsbWF4aW11bVBhY2tldFNpemU6MzksdG9waWNBbGlhc01heGltdW06MzQscmVxdWVzdFJlc3BvbnNlSW5mb3JtYXRpb246MjUscmVxdWVzdFByb2JsZW1JbmZvcm1hdGlvbjoyMyx1c2VyUHJvcGVydGllczozOCxhdXRoZW50aWNhdGlvbk1ldGhvZDoyMSxhdXRoZW50aWNhdGlvbkRhdGE6MjIscGF5bG9hZEZvcm1hdEluZGljYXRvcjoxLG1lc3NhZ2VFeHBpcnlJbnRlcnZhbDoyLGNvbnRlbnRUeXBlOjMscmVzcG9uc2VUb3BpYzo4LGNvcnJlbGF0aW9uRGF0YTo5LG1heGltdW1Rb1M6MzYscmV0YWluQXZhaWxhYmxlOjM3LGFzc2lnbmVkQ2xpZW50SWRlbnRpZmllcjoxOCxyZWFzb25TdHJpbmc6MzEsd2lsZGNhcmRTdWJzY3JpcHRpb25BdmFpbGFibGU6NDAsc3Vic2NyaXB0aW9uSWRlbnRpZmllcnNBdmFpbGFibGU6NDEsc2hhcmVkU3Vic2NyaXB0aW9uQXZhaWxhYmxlOjQyLHNlcnZlcktlZXBBbGl2ZToxOSxyZXNwb25zZUluZm9ybWF0aW9uOjI2LHNlcnZlclJlZmVyZW5jZToyOCx0b3BpY0FsaWFzOjM1LHN1YnNjcmlwdGlvbklkZW50aWZpZXI6MTF9O0wucHJvcGVydGllc0NvZGVzPXt9O2ZvcihsZXQgdCBpbiBMLnByb3BlcnRpZXMpe2xldCBlPUwucHJvcGVydGllc1t0XTtMLnByb3BlcnRpZXNDb2Rlc1tlXT10fUwucHJvcGVydGllc1R5cGVzPXtzZXNzaW9uRXhwaXJ5SW50ZXJ2YWw6XCJpbnQzMlwiLHdpbGxEZWxheUludGVydmFsOlwiaW50MzJcIixyZWNlaXZlTWF4aW11bTpcImludDE2XCIsbWF4aW11bVBhY2tldFNpemU6XCJpbnQzMlwiLHRvcGljQWxpYXNNYXhpbXVtOlwiaW50MTZcIixyZXF1ZXN0UmVzcG9uc2VJbmZvcm1hdGlvbjpcImJ5dGVcIixyZXF1ZXN0UHJvYmxlbUluZm9ybWF0aW9uOlwiYnl0ZVwiLHVzZXJQcm9wZXJ0aWVzOlwicGFpclwiLGF1dGhlbnRpY2F0aW9uTWV0aG9kOlwic3RyaW5nXCIsYXV0aGVudGljYXRpb25EYXRhOlwiYmluYXJ5XCIscGF5bG9hZEZvcm1hdEluZGljYXRvcjpcImJ5dGVcIixtZXNzYWdlRXhwaXJ5SW50ZXJ2YWw6XCJpbnQzMlwiLGNvbnRlbnRUeXBlOlwic3RyaW5nXCIscmVzcG9uc2VUb3BpYzpcInN0cmluZ1wiLGNvcnJlbGF0aW9uRGF0YTpcImJpbmFyeVwiLG1heGltdW1Rb1M6XCJpbnQ4XCIscmV0YWluQXZhaWxhYmxlOlwiYnl0ZVwiLGFzc2lnbmVkQ2xpZW50SWRlbnRpZmllcjpcInN0cmluZ1wiLHJlYXNvblN0cmluZzpcInN0cmluZ1wiLHdpbGRjYXJkU3Vic2NyaXB0aW9uQXZhaWxhYmxlOlwiYnl0ZVwiLHN1YnNjcmlwdGlvbklkZW50aWZpZXJzQXZhaWxhYmxlOlwiYnl0ZVwiLHNoYXJlZFN1YnNjcmlwdGlvbkF2YWlsYWJsZTpcImJ5dGVcIixzZXJ2ZXJLZWVwQWxpdmU6XCJpbnQxNlwiLHJlc3BvbnNlSW5mb3JtYXRpb246XCJzdHJpbmdcIixzZXJ2ZXJSZWZlcmVuY2U6XCJzdHJpbmdcIix0b3BpY0FsaWFzOlwiaW50MTZcIixzdWJzY3JpcHRpb25JZGVudGlmaWVyOlwidmFyXCJ9O2Z1bmN0aW9uIGp0KHQpe3JldHVyblswLDEsMl0ubWFwKGU9PlswLDFdLm1hcChyPT5bMCwxXS5tYXAoaT0+e2xldCBuPU9lLmFsbG9jKDEpO3JldHVybiBuLndyaXRlVUludDgoTC5jb2Rlc1t0XTw8TC5DTURfU0hJRlR8KHI/TC5EVVBfTUFTSzowKXxlPDxMLlFPU19TSElGVHxpLDAsITApLG59KSkpfUwuUFVCTElTSF9IRUFERVI9anQoXCJwdWJsaXNoXCIpO0wuU1VCU0NSSUJFX0hFQURFUj1qdChcInN1YnNjcmliZVwiKTtMLlNVQlNDUklCRV9PUFRJT05TX1FPU19NQVNLPTM7TC5TVUJTQ1JJQkVfT1BUSU9OU19OTF9NQVNLPTE7TC5TVUJTQ1JJQkVfT1BUSU9OU19OTF9TSElGVD0yO0wuU1VCU0NSSUJFX09QVElPTlNfUkFQX01BU0s9MTtMLlNVQlNDUklCRV9PUFRJT05TX1JBUF9TSElGVD0zO0wuU1VCU0NSSUJFX09QVElPTlNfUkhfTUFTSz0zO0wuU1VCU0NSSUJFX09QVElPTlNfUkhfU0hJRlQ9NDtMLlNVQlNDUklCRV9PUFRJT05TX1JIPVswLDE2LDMyXTtMLlNVQlNDUklCRV9PUFRJT05TX05MPTQ7TC5TVUJTQ1JJQkVfT1BUSU9OU19SQVA9ODtMLlNVQlNDUklCRV9PUFRJT05TX1FPUz1bMCwxLDJdO0wuVU5TVUJTQ1JJQkVfSEVBREVSPWp0KFwidW5zdWJzY3JpYmVcIik7TC5BQ0tTPXt1bnN1YmFjazpqdChcInVuc3ViYWNrXCIpLHB1YmFjazpqdChcInB1YmFja1wiKSxwdWJjb21wOmp0KFwicHViY29tcFwiKSxwdWJyZWw6anQoXCJwdWJyZWxcIikscHVicmVjOmp0KFwicHVicmVjXCIpfTtMLlNVQkFDS19IRUFERVI9T2UuZnJvbShbTC5jb2Rlcy5zdWJhY2s8PEwuQ01EX1NISUZUXSk7TC5WRVJTSU9OMz1PZS5mcm9tKFszXSk7TC5WRVJTSU9OND1PZS5mcm9tKFs0XSk7TC5WRVJTSU9ONT1PZS5mcm9tKFs1XSk7TC5WRVJTSU9OMTMxPU9lLmZyb20oWzEzMV0pO0wuVkVSU0lPTjEzMj1PZS5mcm9tKFsxMzJdKTtMLlFPUz1bMCwxLDJdLm1hcCh0PT5PZS5mcm9tKFt0XSkpO0wuRU1QVFk9e3BpbmdyZXE6T2UuZnJvbShbTC5jb2Rlcy5waW5ncmVxPDw0LDBdKSxwaW5ncmVzcDpPZS5mcm9tKFtMLmNvZGVzLnBpbmdyZXNwPDw0LDBdKSxkaXNjb25uZWN0Ok9lLmZyb20oW0wuY29kZXMuZGlzY29ubmVjdDw8NCwwXSl9O0wuTVFUVDVfUFVCQUNLX1BVQlJFQ19DT0RFUz17MDpcIlN1Y2Nlc3NcIiwxNjpcIk5vIG1hdGNoaW5nIHN1YnNjcmliZXJzXCIsMTI4OlwiVW5zcGVjaWZpZWQgZXJyb3JcIiwxMzE6XCJJbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBlcnJvclwiLDEzNTpcIk5vdCBhdXRob3JpemVkXCIsMTQ0OlwiVG9waWMgTmFtZSBpbnZhbGlkXCIsMTQ1OlwiUGFja2V0IGlkZW50aWZpZXIgaW4gdXNlXCIsMTUxOlwiUXVvdGEgZXhjZWVkZWRcIiwxNTM6XCJQYXlsb2FkIGZvcm1hdCBpbnZhbGlkXCJ9O0wuTVFUVDVfUFVCUkVMX1BVQkNPTVBfQ09ERVM9ezA6XCJTdWNjZXNzXCIsMTQ2OlwiUGFja2V0IElkZW50aWZpZXIgbm90IGZvdW5kXCJ9O0wuTVFUVDVfU1VCQUNLX0NPREVTPXswOlwiR3JhbnRlZCBRb1MgMFwiLDE6XCJHcmFudGVkIFFvUyAxXCIsMjpcIkdyYW50ZWQgUW9TIDJcIiwxMjg6XCJVbnNwZWNpZmllZCBlcnJvclwiLDEzMTpcIkltcGxlbWVudGF0aW9uIHNwZWNpZmljIGVycm9yXCIsMTM1OlwiTm90IGF1dGhvcml6ZWRcIiwxNDM6XCJUb3BpYyBGaWx0ZXIgaW52YWxpZFwiLDE0NTpcIlBhY2tldCBJZGVudGlmaWVyIGluIHVzZVwiLDE1MTpcIlF1b3RhIGV4Y2VlZGVkXCIsMTU4OlwiU2hhcmVkIFN1YnNjcmlwdGlvbnMgbm90IHN1cHBvcnRlZFwiLDE2MTpcIlN1YnNjcmlwdGlvbiBJZGVudGlmaWVycyBub3Qgc3VwcG9ydGVkXCIsMTYyOlwiV2lsZGNhcmQgU3Vic2NyaXB0aW9ucyBub3Qgc3VwcG9ydGVkXCJ9O0wuTVFUVDVfVU5TVUJBQ0tfQ09ERVM9ezA6XCJTdWNjZXNzXCIsMTc6XCJObyBzdWJzY3JpcHRpb24gZXhpc3RlZFwiLDEyODpcIlVuc3BlY2lmaWVkIGVycm9yXCIsMTMxOlwiSW1wbGVtZW50YXRpb24gc3BlY2lmaWMgZXJyb3JcIiwxMzU6XCJOb3QgYXV0aG9yaXplZFwiLDE0MzpcIlRvcGljIEZpbHRlciBpbnZhbGlkXCIsMTQ1OlwiUGFja2V0IElkZW50aWZpZXIgaW4gdXNlXCJ9O0wuTVFUVDVfRElTQ09OTkVDVF9DT0RFUz17MDpcIk5vcm1hbCBkaXNjb25uZWN0aW9uXCIsNDpcIkRpc2Nvbm5lY3Qgd2l0aCBXaWxsIE1lc3NhZ2VcIiwxMjg6XCJVbnNwZWNpZmllZCBlcnJvclwiLDEyOTpcIk1hbGZvcm1lZCBQYWNrZXRcIiwxMzA6XCJQcm90b2NvbCBFcnJvclwiLDEzMTpcIkltcGxlbWVudGF0aW9uIHNwZWNpZmljIGVycm9yXCIsMTM1OlwiTm90IGF1dGhvcml6ZWRcIiwxMzc6XCJTZXJ2ZXIgYnVzeVwiLDEzOTpcIlNlcnZlciBzaHV0dGluZyBkb3duXCIsMTQxOlwiS2VlcCBBbGl2ZSB0aW1lb3V0XCIsMTQyOlwiU2Vzc2lvbiB0YWtlbiBvdmVyXCIsMTQzOlwiVG9waWMgRmlsdGVyIGludmFsaWRcIiwxNDQ6XCJUb3BpYyBOYW1lIGludmFsaWRcIiwxNDc6XCJSZWNlaXZlIE1heGltdW0gZXhjZWVkZWRcIiwxNDg6XCJUb3BpYyBBbGlhcyBpbnZhbGlkXCIsMTQ5OlwiUGFja2V0IHRvbyBsYXJnZVwiLDE1MDpcIk1lc3NhZ2UgcmF0ZSB0b28gaGlnaFwiLDE1MTpcIlF1b3RhIGV4Y2VlZGVkXCIsMTUyOlwiQWRtaW5pc3RyYXRpdmUgYWN0aW9uXCIsMTUzOlwiUGF5bG9hZCBmb3JtYXQgaW52YWxpZFwiLDE1NDpcIlJldGFpbiBub3Qgc3VwcG9ydGVkXCIsMTU1OlwiUW9TIG5vdCBzdXBwb3J0ZWRcIiwxNTY6XCJVc2UgYW5vdGhlciBzZXJ2ZXJcIiwxNTc6XCJTZXJ2ZXIgbW92ZWRcIiwxNTg6XCJTaGFyZWQgU3Vic2NyaXB0aW9ucyBub3Qgc3VwcG9ydGVkXCIsMTU5OlwiQ29ubmVjdGlvbiByYXRlIGV4Y2VlZGVkXCIsMTYwOlwiTWF4aW11bSBjb25uZWN0IHRpbWVcIiwxNjE6XCJTdWJzY3JpcHRpb24gSWRlbnRpZmllcnMgbm90IHN1cHBvcnRlZFwiLDE2MjpcIldpbGRjYXJkIFN1YnNjcmlwdGlvbnMgbm90IHN1cHBvcnRlZFwifTtMLk1RVFQ1X0FVVEhfQ09ERVM9ezA6XCJTdWNjZXNzXCIsMjQ6XCJDb250aW51ZSBhdXRoZW50aWNhdGlvblwiLDI1OlwiUmUtYXV0aGVudGljYXRlXCJ9fSk7dmFyIGdkPU0oKHJQLHBkKT0+e3YoKTttKCk7XygpO3ZhciBIcj0xZTMsVnI9SHIqNjAsenI9VnIqNjAsZ3I9enIqMjQscG09Z3IqNyxnbT1nciozNjUuMjU7cGQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2U9ZXx8e307dmFyIHI9dHlwZW9mIHQ7aWYocj09PVwic3RyaW5nXCImJnQubGVuZ3RoPjApcmV0dXJuIHltKHQpO2lmKHI9PT1cIm51bWJlclwiJiZpc0Zpbml0ZSh0KSlyZXR1cm4gZS5sb25nP3dtKHQpOmJtKHQpO3Rocm93IG5ldyBFcnJvcihcInZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9XCIrSlNPTi5zdHJpbmdpZnkodCkpfTtmdW5jdGlvbiB5bSh0KXtpZih0PVN0cmluZyh0KSwhKHQubGVuZ3RoPjEwMCkpe3ZhciBlPS9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyh0KTtpZihlKXt2YXIgcj1wYXJzZUZsb2F0KGVbMV0pLGk9KGVbMl18fFwibXNcIikudG9Mb3dlckNhc2UoKTtzd2l0Y2goaSl7Y2FzZVwieWVhcnNcIjpjYXNlXCJ5ZWFyXCI6Y2FzZVwieXJzXCI6Y2FzZVwieXJcIjpjYXNlXCJ5XCI6cmV0dXJuIHIqZ207Y2FzZVwid2Vla3NcIjpjYXNlXCJ3ZWVrXCI6Y2FzZVwid1wiOnJldHVybiByKnBtO2Nhc2VcImRheXNcIjpjYXNlXCJkYXlcIjpjYXNlXCJkXCI6cmV0dXJuIHIqZ3I7Y2FzZVwiaG91cnNcIjpjYXNlXCJob3VyXCI6Y2FzZVwiaHJzXCI6Y2FzZVwiaHJcIjpjYXNlXCJoXCI6cmV0dXJuIHIqenI7Y2FzZVwibWludXRlc1wiOmNhc2VcIm1pbnV0ZVwiOmNhc2VcIm1pbnNcIjpjYXNlXCJtaW5cIjpjYXNlXCJtXCI6cmV0dXJuIHIqVnI7Y2FzZVwic2Vjb25kc1wiOmNhc2VcInNlY29uZFwiOmNhc2VcInNlY3NcIjpjYXNlXCJzZWNcIjpjYXNlXCJzXCI6cmV0dXJuIHIqSHI7Y2FzZVwibWlsbGlzZWNvbmRzXCI6Y2FzZVwibWlsbGlzZWNvbmRcIjpjYXNlXCJtc2Vjc1wiOmNhc2VcIm1zZWNcIjpjYXNlXCJtc1wiOnJldHVybiByO2RlZmF1bHQ6cmV0dXJufX19fWZ1bmN0aW9uIGJtKHQpe3ZhciBlPU1hdGguYWJzKHQpO3JldHVybiBlPj1ncj9NYXRoLnJvdW5kKHQvZ3IpK1wiZFwiOmU+PXpyP01hdGgucm91bmQodC96cikrXCJoXCI6ZT49VnI/TWF0aC5yb3VuZCh0L1ZyKStcIm1cIjplPj1Icj9NYXRoLnJvdW5kKHQvSHIpK1wic1wiOnQrXCJtc1wifWZ1bmN0aW9uIHdtKHQpe3ZhciBlPU1hdGguYWJzKHQpO3JldHVybiBlPj1ncj9Ubih0LGUsZ3IsXCJkYXlcIik6ZT49enI/VG4odCxlLHpyLFwiaG91clwiKTplPj1Wcj9Ubih0LGUsVnIsXCJtaW51dGVcIik6ZT49SHI/VG4odCxlLEhyLFwic2Vjb25kXCIpOnQrXCIgbXNcIn1mdW5jdGlvbiBUbih0LGUscixpKXt2YXIgbj1lPj1yKjEuNTtyZXR1cm4gTWF0aC5yb3VuZCh0L3IpK1wiIFwiK2krKG4/XCJzXCI6XCJcIil9fSk7dmFyIGJkPU0oKGhQLHlkKT0+e3YoKTttKCk7XygpO2Z1bmN0aW9uIF9tKHQpe3IuZGVidWc9cixyLmRlZmF1bHQ9cixyLmNvZXJjZT11LHIuZGlzYWJsZT1vLHIuZW5hYmxlPW4sci5lbmFibGVkPXMsci5odW1hbml6ZT1nZCgpLHIuZGVzdHJveT1jLE9iamVjdC5rZXlzKHQpLmZvckVhY2goaD0+e3JbaF09dFtoXX0pLHIubmFtZXM9W10sci5za2lwcz1bXSxyLmZvcm1hdHRlcnM9e307ZnVuY3Rpb24gZShoKXtsZXQgZD0wO2ZvcihsZXQgZz0wO2c8aC5sZW5ndGg7ZysrKWQ9KGQ8PDUpLWQraC5jaGFyQ29kZUF0KGcpLGR8PTA7cmV0dXJuIHIuY29sb3JzW01hdGguYWJzKGQpJXIuY29sb3JzLmxlbmd0aF19ci5zZWxlY3RDb2xvcj1lO2Z1bmN0aW9uIHIoaCl7bGV0IGQsZz1udWxsLHksdztmdW5jdGlvbiBFKC4uLlMpe2lmKCFFLmVuYWJsZWQpcmV0dXJuO2xldCBJPUUsQz1OdW1iZXIobmV3IERhdGUpLFI9Qy0oZHx8Qyk7SS5kaWZmPVIsSS5wcmV2PWQsSS5jdXJyPUMsZD1DLFNbMF09ci5jb2VyY2UoU1swXSksdHlwZW9mIFNbMF0hPVwic3RyaW5nXCImJlMudW5zaGlmdChcIiVPXCIpO2xldCBVPTA7U1swXT1TWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLChXLEspPT57aWYoVz09PVwiJSVcIilyZXR1cm5cIiVcIjtVKys7bGV0IHo9ci5mb3JtYXR0ZXJzW0tdO2lmKHR5cGVvZiB6PT1cImZ1bmN0aW9uXCIpe2xldCBRPVNbVV07Vz16LmNhbGwoSSxRKSxTLnNwbGljZShVLDEpLFUtLX1yZXR1cm4gV30pLHIuZm9ybWF0QXJncy5jYWxsKEksUyksKEkubG9nfHxyLmxvZykuYXBwbHkoSSxTKX1yZXR1cm4gRS5uYW1lc3BhY2U9aCxFLnVzZUNvbG9ycz1yLnVzZUNvbG9ycygpLEUuY29sb3I9ci5zZWxlY3RDb2xvcihoKSxFLmV4dGVuZD1pLEUuZGVzdHJveT1yLmRlc3Ryb3ksT2JqZWN0LmRlZmluZVByb3BlcnR5KEUsXCJlbmFibGVkXCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExLGdldDooKT0+ZyE9PW51bGw/ZzooeSE9PXIubmFtZXNwYWNlcyYmKHk9ci5uYW1lc3BhY2VzLHc9ci5lbmFibGVkKGgpKSx3KSxzZXQ6Uz0+e2c9U319KSx0eXBlb2Ygci5pbml0PT1cImZ1bmN0aW9uXCImJnIuaW5pdChFKSxFfWZ1bmN0aW9uIGkoaCxkKXtsZXQgZz1yKHRoaXMubmFtZXNwYWNlKyh0eXBlb2YgZD5cInVcIj9cIjpcIjpkKStoKTtyZXR1cm4gZy5sb2c9dGhpcy5sb2csZ31mdW5jdGlvbiBuKGgpe3Iuc2F2ZShoKSxyLm5hbWVzcGFjZXM9aCxyLm5hbWVzPVtdLHIuc2tpcHM9W107bGV0IGQsZz0odHlwZW9mIGg9PVwic3RyaW5nXCI/aDpcIlwiKS5zcGxpdCgvW1xccyxdKy8pLHk9Zy5sZW5ndGg7Zm9yKGQ9MDtkPHk7ZCsrKWdbZF0mJihoPWdbZF0ucmVwbGFjZSgvXFwqL2csXCIuKj9cIiksaFswXT09PVwiLVwiP3Iuc2tpcHMucHVzaChuZXcgUmVnRXhwKFwiXlwiK2guc2xpY2UoMSkrXCIkXCIpKTpyLm5hbWVzLnB1c2gobmV3IFJlZ0V4cChcIl5cIitoK1wiJFwiKSkpfWZ1bmN0aW9uIG8oKXtsZXQgaD1bLi4uci5uYW1lcy5tYXAoYSksLi4uci5za2lwcy5tYXAoYSkubWFwKGQ9PlwiLVwiK2QpXS5qb2luKFwiLFwiKTtyZXR1cm4gci5lbmFibGUoXCJcIiksaH1mdW5jdGlvbiBzKGgpe2lmKGhbaC5sZW5ndGgtMV09PT1cIipcIilyZXR1cm4hMDtsZXQgZCxnO2ZvcihkPTAsZz1yLnNraXBzLmxlbmd0aDtkPGc7ZCsrKWlmKHIuc2tpcHNbZF0udGVzdChoKSlyZXR1cm4hMTtmb3IoZD0wLGc9ci5uYW1lcy5sZW5ndGg7ZDxnO2QrKylpZihyLm5hbWVzW2RdLnRlc3QoaCkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gYShoKXtyZXR1cm4gaC50b1N0cmluZygpLnN1YnN0cmluZygyLGgudG9TdHJpbmcoKS5sZW5ndGgtMikucmVwbGFjZSgvXFwuXFwqXFw/JC8sXCIqXCIpfWZ1bmN0aW9uIHUoaCl7cmV0dXJuIGggaW5zdGFuY2VvZiBFcnJvcj9oLnN0YWNrfHxoLm1lc3NhZ2U6aH1mdW5jdGlvbiBjKCl7Y29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKX1yZXR1cm4gci5lbmFibGUoci5sb2FkKCkpLHJ9eWQuZXhwb3J0cz1fbX0pO3ZhciBvdD1NKCh4ZSxSbik9Pnt2KCk7bSgpO18oKTt4ZS5mb3JtYXRBcmdzPXZtO3hlLnNhdmU9RW07eGUubG9hZD1TbTt4ZS51c2VDb2xvcnM9bW07eGUuc3RvcmFnZT1BbSgpO3hlLmRlc3Ryb3k9KCgpPT57bGV0IHQ9ITE7cmV0dXJuKCk9Pnt0fHwodD0hMCxjb25zb2xlLndhcm4oXCJJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuXCIpKX19KSgpO3hlLmNvbG9ycz1bXCIjMDAwMENDXCIsXCIjMDAwMEZGXCIsXCIjMDAzM0NDXCIsXCIjMDAzM0ZGXCIsXCIjMDA2NkNDXCIsXCIjMDA2NkZGXCIsXCIjMDA5OUNDXCIsXCIjMDA5OUZGXCIsXCIjMDBDQzAwXCIsXCIjMDBDQzMzXCIsXCIjMDBDQzY2XCIsXCIjMDBDQzk5XCIsXCIjMDBDQ0NDXCIsXCIjMDBDQ0ZGXCIsXCIjMzMwMENDXCIsXCIjMzMwMEZGXCIsXCIjMzMzM0NDXCIsXCIjMzMzM0ZGXCIsXCIjMzM2NkNDXCIsXCIjMzM2NkZGXCIsXCIjMzM5OUNDXCIsXCIjMzM5OUZGXCIsXCIjMzNDQzAwXCIsXCIjMzNDQzMzXCIsXCIjMzNDQzY2XCIsXCIjMzNDQzk5XCIsXCIjMzNDQ0NDXCIsXCIjMzNDQ0ZGXCIsXCIjNjYwMENDXCIsXCIjNjYwMEZGXCIsXCIjNjYzM0NDXCIsXCIjNjYzM0ZGXCIsXCIjNjZDQzAwXCIsXCIjNjZDQzMzXCIsXCIjOTkwMENDXCIsXCIjOTkwMEZGXCIsXCIjOTkzM0NDXCIsXCIjOTkzM0ZGXCIsXCIjOTlDQzAwXCIsXCIjOTlDQzMzXCIsXCIjQ0MwMDAwXCIsXCIjQ0MwMDMzXCIsXCIjQ0MwMDY2XCIsXCIjQ0MwMDk5XCIsXCIjQ0MwMENDXCIsXCIjQ0MwMEZGXCIsXCIjQ0MzMzAwXCIsXCIjQ0MzMzMzXCIsXCIjQ0MzMzY2XCIsXCIjQ0MzMzk5XCIsXCIjQ0MzM0NDXCIsXCIjQ0MzM0ZGXCIsXCIjQ0M2NjAwXCIsXCIjQ0M2NjMzXCIsXCIjQ0M5OTAwXCIsXCIjQ0M5OTMzXCIsXCIjQ0NDQzAwXCIsXCIjQ0NDQzMzXCIsXCIjRkYwMDAwXCIsXCIjRkYwMDMzXCIsXCIjRkYwMDY2XCIsXCIjRkYwMDk5XCIsXCIjRkYwMENDXCIsXCIjRkYwMEZGXCIsXCIjRkYzMzAwXCIsXCIjRkYzMzMzXCIsXCIjRkYzMzY2XCIsXCIjRkYzMzk5XCIsXCIjRkYzM0NDXCIsXCIjRkYzM0ZGXCIsXCIjRkY2NjAwXCIsXCIjRkY2NjMzXCIsXCIjRkY5OTAwXCIsXCIjRkY5OTMzXCIsXCIjRkZDQzAwXCIsXCIjRkZDQzMzXCJdO2Z1bmN0aW9uIG1tKCl7cmV0dXJuIHR5cGVvZiB3aW5kb3c8XCJ1XCImJndpbmRvdy5wcm9jZXNzJiYod2luZG93LnByb2Nlc3MudHlwZT09PVwicmVuZGVyZXJcInx8d2luZG93LnByb2Nlc3MuX19ud2pzKT8hMDp0eXBlb2YgQjxcInVcIiYmQi51c2VyQWdlbnQmJkIudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLyk/ITE6dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2V8fHR5cGVvZiB3aW5kb3c8XCJ1XCImJndpbmRvdy5jb25zb2xlJiYod2luZG93LmNvbnNvbGUuZmlyZWJ1Z3x8d2luZG93LmNvbnNvbGUuZXhjZXB0aW9uJiZ3aW5kb3cuY29uc29sZS50YWJsZSl8fHR5cGVvZiBCPFwidVwiJiZCLnVzZXJBZ2VudCYmQi51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pJiZwYXJzZUludChSZWdFeHAuJDEsMTApPj0zMXx8dHlwZW9mIEI8XCJ1XCImJkIudXNlckFnZW50JiZCLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pfWZ1bmN0aW9uIHZtKHQpe2lmKHRbMF09KHRoaXMudXNlQ29sb3JzP1wiJWNcIjpcIlwiKSt0aGlzLm5hbWVzcGFjZSsodGhpcy51c2VDb2xvcnM/XCIgJWNcIjpcIiBcIikrdFswXSsodGhpcy51c2VDb2xvcnM/XCIlYyBcIjpcIiBcIikrXCIrXCIrUm4uZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpLCF0aGlzLnVzZUNvbG9ycylyZXR1cm47bGV0IGU9XCJjb2xvcjogXCIrdGhpcy5jb2xvcjt0LnNwbGljZSgxLDAsZSxcImNvbG9yOiBpbmhlcml0XCIpO2xldCByPTAsaT0wO3RbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLG49PntuIT09XCIlJVwiJiYocisrLG49PT1cIiVjXCImJihpPXIpKX0pLHQuc3BsaWNlKGksMCxlKX14ZS5sb2c9Y29uc29sZS5kZWJ1Z3x8Y29uc29sZS5sb2d8fCgoKT0+e30pO2Z1bmN0aW9uIEVtKHQpe3RyeXt0P3hlLnN0b3JhZ2Uuc2V0SXRlbShcImRlYnVnXCIsdCk6eGUuc3RvcmFnZS5yZW1vdmVJdGVtKFwiZGVidWdcIil9Y2F0Y2h7fX1mdW5jdGlvbiBTbSgpe2xldCB0O3RyeXt0PXhlLnN0b3JhZ2UuZ2V0SXRlbShcImRlYnVnXCIpfWNhdGNoe31yZXR1cm4hdCYmdHlwZW9mIFA8XCJ1XCImJlwiZW52XCJpbiBQJiYodD1QLmVudi5ERUJVRyksdH1mdW5jdGlvbiBBbSgpe3RyeXtyZXR1cm4gbG9jYWxTdG9yYWdlfWNhdGNoe319Um4uZXhwb3J0cz1iZCgpKHhlKTt2YXJ7Zm9ybWF0dGVyczpJbX09Um4uZXhwb3J0cztJbS5qPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkodCl9Y2F0Y2goZSl7cmV0dXJuXCJbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogXCIrZS5tZXNzYWdlfX19KTt2YXIgbWQ9TSgoT1AsX2QpPT57digpO20oKTtfKCk7dmFyIFRtPWZkKCkse0V2ZW50RW1pdHRlcjpSbX09KGlyKCksWihycikpLHdkPWhkKCksVj1GbygpLEQ9b3QoKShcIm1xdHQtcGFja2V0OnBhcnNlclwiKSxXbz1jbGFzcyB0IGV4dGVuZHMgUm17Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMucGFyc2VyPXRoaXMuY29uc3RydWN0b3IucGFyc2VyfXN0YXRpYyBwYXJzZXIoZSl7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiB0Pyh0aGlzLnNldHRpbmdzPWV8fHt9LHRoaXMuX3N0YXRlcz1bXCJfcGFyc2VIZWFkZXJcIixcIl9wYXJzZUxlbmd0aFwiLFwiX3BhcnNlUGF5bG9hZFwiLFwiX25ld1BhY2tldFwiXSx0aGlzLl9yZXNldFN0YXRlKCksdGhpcyk6bmV3IHQoKS5wYXJzZXIoZSl9X3Jlc2V0U3RhdGUoKXtEKFwiX3Jlc2V0U3RhdGU6IHJlc2V0dGluZyBwYWNrZXQsIGVycm9yLCBfbGlzdCwgYW5kIF9zdGF0ZUNvdW50ZXJcIiksdGhpcy5wYWNrZXQ9bmV3IHdkLHRoaXMuZXJyb3I9bnVsbCx0aGlzLl9saXN0PVRtKCksdGhpcy5fc3RhdGVDb3VudGVyPTB9cGFyc2UoZSl7Zm9yKHRoaXMuZXJyb3ImJnRoaXMuX3Jlc2V0U3RhdGUoKSx0aGlzLl9saXN0LmFwcGVuZChlKSxEKFwicGFyc2U6IGN1cnJlbnQgc3RhdGU6ICVzXCIsdGhpcy5fc3RhdGVzW3RoaXMuX3N0YXRlQ291bnRlcl0pOyh0aGlzLnBhY2tldC5sZW5ndGghPT0tMXx8dGhpcy5fbGlzdC5sZW5ndGg+MCkmJnRoaXNbdGhpcy5fc3RhdGVzW3RoaXMuX3N0YXRlQ291bnRlcl1dKCkmJiF0aGlzLmVycm9yOyl0aGlzLl9zdGF0ZUNvdW50ZXIrKyxEKFwicGFyc2U6IHN0YXRlIGNvbXBsZXRlLiBfc3RhdGVDb3VudGVyIGlzIG5vdzogJWRcIix0aGlzLl9zdGF0ZUNvdW50ZXIpLEQoXCJwYXJzZTogcGFja2V0Lmxlbmd0aDogJWQsIGJ1ZmZlciBsaXN0IGxlbmd0aDogJWRcIix0aGlzLnBhY2tldC5sZW5ndGgsdGhpcy5fbGlzdC5sZW5ndGgpLHRoaXMuX3N0YXRlQ291bnRlcj49dGhpcy5fc3RhdGVzLmxlbmd0aCYmKHRoaXMuX3N0YXRlQ291bnRlcj0wKTtyZXR1cm4gRChcInBhcnNlOiBleGl0ZWQgd2hpbGUgbG9vcC4gcGFja2V0OiAlZCwgYnVmZmVyIGxpc3QgbGVuZ3RoOiAlZFwiLHRoaXMucGFja2V0Lmxlbmd0aCx0aGlzLl9saXN0Lmxlbmd0aCksdGhpcy5fbGlzdC5sZW5ndGh9X3BhcnNlSGVhZGVyKCl7bGV0IGU9dGhpcy5fbGlzdC5yZWFkVUludDgoMCkscj1lPj5WLkNNRF9TSElGVDt0aGlzLnBhY2tldC5jbWQ9Vi50eXBlc1tyXTtsZXQgaT1lJjE1LG49Vi5yZXF1aXJlZEhlYWRlckZsYWdzW3JdO3JldHVybiBuIT1udWxsJiZpIT09bj90aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFYucmVxdWlyZWRIZWFkZXJGbGFnc0Vycm9yc1tyXSkpOih0aGlzLnBhY2tldC5yZXRhaW49KGUmVi5SRVRBSU5fTUFTSykhPT0wLHRoaXMucGFja2V0LnFvcz1lPj5WLlFPU19TSElGVCZWLlFPU19NQVNLLHRoaXMucGFja2V0LnFvcz4yP3RoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJQYWNrZXQgbXVzdCBub3QgaGF2ZSBib3RoIFFvUyBiaXRzIHNldCB0byAxXCIpKToodGhpcy5wYWNrZXQuZHVwPShlJlYuRFVQX01BU0spIT09MCxEKFwiX3BhcnNlSGVhZGVyOiBwYWNrZXQ6ICVvXCIsdGhpcy5wYWNrZXQpLHRoaXMuX2xpc3QuY29uc3VtZSgxKSwhMCkpfV9wYXJzZUxlbmd0aCgpe2xldCBlPXRoaXMuX3BhcnNlVmFyQnl0ZU51bSghMCk7cmV0dXJuIGUmJih0aGlzLnBhY2tldC5sZW5ndGg9ZS52YWx1ZSx0aGlzLl9saXN0LmNvbnN1bWUoZS5ieXRlcykpLEQoXCJfcGFyc2VMZW5ndGggJWRcIixlLnZhbHVlKSwhIWV9X3BhcnNlUGF5bG9hZCgpe0QoXCJfcGFyc2VQYXlsb2FkOiBwYXlsb2FkICVPXCIsdGhpcy5fbGlzdCk7bGV0IGU9ITE7aWYodGhpcy5wYWNrZXQubGVuZ3RoPT09MHx8dGhpcy5fbGlzdC5sZW5ndGg+PXRoaXMucGFja2V0Lmxlbmd0aCl7c3dpdGNoKHRoaXMuX3Bvcz0wLHRoaXMucGFja2V0LmNtZCl7Y2FzZVwiY29ubmVjdFwiOnRoaXMuX3BhcnNlQ29ubmVjdCgpO2JyZWFrO2Nhc2VcImNvbm5hY2tcIjp0aGlzLl9wYXJzZUNvbm5hY2soKTticmVhaztjYXNlXCJwdWJsaXNoXCI6dGhpcy5fcGFyc2VQdWJsaXNoKCk7YnJlYWs7Y2FzZVwicHViYWNrXCI6Y2FzZVwicHVicmVjXCI6Y2FzZVwicHVicmVsXCI6Y2FzZVwicHViY29tcFwiOnRoaXMuX3BhcnNlQ29uZmlybWF0aW9uKCk7YnJlYWs7Y2FzZVwic3Vic2NyaWJlXCI6dGhpcy5fcGFyc2VTdWJzY3JpYmUoKTticmVhaztjYXNlXCJzdWJhY2tcIjp0aGlzLl9wYXJzZVN1YmFjaygpO2JyZWFrO2Nhc2VcInVuc3Vic2NyaWJlXCI6dGhpcy5fcGFyc2VVbnN1YnNjcmliZSgpO2JyZWFrO2Nhc2VcInVuc3ViYWNrXCI6dGhpcy5fcGFyc2VVbnN1YmFjaygpO2JyZWFrO2Nhc2VcInBpbmdyZXFcIjpjYXNlXCJwaW5ncmVzcFwiOmJyZWFrO2Nhc2VcImRpc2Nvbm5lY3RcIjp0aGlzLl9wYXJzZURpc2Nvbm5lY3QoKTticmVhaztjYXNlXCJhdXRoXCI6dGhpcy5fcGFyc2VBdXRoKCk7YnJlYWs7ZGVmYXVsdDp0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZFwiKSl9ZT0hMH1yZXR1cm4gRChcIl9wYXJzZVBheWxvYWQgY29tcGxldGUgcmVzdWx0OiAlc1wiLGUpLGV9X3BhcnNlQ29ubmVjdCgpe0QoXCJfcGFyc2VDb25uZWN0XCIpO2xldCBlLHIsaSxuLG89e30scz10aGlzLnBhY2tldCxhPXRoaXMuX3BhcnNlU3RyaW5nKCk7aWYoYT09PW51bGwpcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJDYW5ub3QgcGFyc2UgcHJvdG9jb2xJZFwiKSk7aWYoYSE9PVwiTVFUVFwiJiZhIT09XCJNUUlzZHBcIilyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIkludmFsaWQgcHJvdG9jb2xJZFwiKSk7aWYocy5wcm90b2NvbElkPWEsdGhpcy5fcG9zPj10aGlzLl9saXN0Lmxlbmd0aClyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIlBhY2tldCB0b28gc2hvcnRcIikpO2lmKHMucHJvdG9jb2xWZXJzaW9uPXRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3Bvcykscy5wcm90b2NvbFZlcnNpb24+PTEyOCYmKHMuYnJpZGdlTW9kZT0hMCxzLnByb3RvY29sVmVyc2lvbj1zLnByb3RvY29sVmVyc2lvbi0xMjgpLHMucHJvdG9jb2xWZXJzaW9uIT09MyYmcy5wcm90b2NvbFZlcnNpb24hPT00JiZzLnByb3RvY29sVmVyc2lvbiE9PTUpcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3RvY29sIHZlcnNpb25cIikpO2lmKHRoaXMuX3BvcysrLHRoaXMuX3Bvcz49dGhpcy5fbGlzdC5sZW5ndGgpcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJQYWNrZXQgdG9vIHNob3J0XCIpKTtpZih0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpJjEpcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJDb25uZWN0IGZsYWcgYml0IDAgbXVzdCBiZSAwLCBidXQgZ290IDFcIikpO28udXNlcm5hbWU9dGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSZWLlVTRVJOQU1FX01BU0ssby5wYXNzd29yZD10aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpJlYuUEFTU1dPUkRfTUFTSyxvLndpbGw9dGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSZWLldJTExfRkxBR19NQVNLO2xldCB1PSEhKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykmVi5XSUxMX1JFVEFJTl9NQVNLKSxjPSh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpJlYuV0lMTF9RT1NfTUFTSyk+PlYuV0lMTF9RT1NfU0hJRlQ7aWYoby53aWxsKXMud2lsbD17fSxzLndpbGwucmV0YWluPXUscy53aWxsLnFvcz1jO2Vsc2V7aWYodSlyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIldpbGwgUmV0YWluIEZsYWcgbXVzdCBiZSBzZXQgdG8gemVybyB3aGVuIFdpbGwgRmxhZyBpcyBzZXQgdG8gMFwiKSk7aWYoYylyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIldpbGwgUW9TIG11c3QgYmUgc2V0IHRvIHplcm8gd2hlbiBXaWxsIEZsYWcgaXMgc2V0IHRvIDBcIikpfWlmKHMuY2xlYW49KHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykmVi5DTEVBTl9TRVNTSU9OX01BU0spIT09MCx0aGlzLl9wb3MrKyxzLmtlZXBhbGl2ZT10aGlzLl9wYXJzZU51bSgpLHMua2VlcGFsaXZlPT09LTEpcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJQYWNrZXQgdG9vIHNob3J0XCIpKTtpZihzLnByb3RvY29sVmVyc2lvbj09PTUpe2xldCBkPXRoaXMuX3BhcnNlUHJvcGVydGllcygpO09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGQpLmxlbmd0aCYmKHMucHJvcGVydGllcz1kKX1sZXQgaD10aGlzLl9wYXJzZVN0cmluZygpO2lmKGg9PT1udWxsKXJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiUGFja2V0IHRvbyBzaG9ydFwiKSk7aWYocy5jbGllbnRJZD1oLEQoXCJfcGFyc2VDb25uZWN0OiBwYWNrZXQuY2xpZW50SWQ6ICVzXCIscy5jbGllbnRJZCksby53aWxsKXtpZihzLnByb3RvY29sVmVyc2lvbj09PTUpe2xldCBkPXRoaXMuX3BhcnNlUHJvcGVydGllcygpO09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGQpLmxlbmd0aCYmKHMud2lsbC5wcm9wZXJ0aWVzPWQpfWlmKGU9dGhpcy5fcGFyc2VTdHJpbmcoKSxlPT09bnVsbClyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIkNhbm5vdCBwYXJzZSB3aWxsIHRvcGljXCIpKTtpZihzLndpbGwudG9waWM9ZSxEKFwiX3BhcnNlQ29ubmVjdDogcGFja2V0LndpbGwudG9waWM6ICVzXCIscy53aWxsLnRvcGljKSxyPXRoaXMuX3BhcnNlQnVmZmVyKCkscj09PW51bGwpcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJDYW5ub3QgcGFyc2Ugd2lsbCBwYXlsb2FkXCIpKTtzLndpbGwucGF5bG9hZD1yLEQoXCJfcGFyc2VDb25uZWN0OiBwYWNrZXQud2lsbC5wYXlsYW9kOiAlc1wiLHMud2lsbC5wYXlsb2FkKX1pZihvLnVzZXJuYW1lKXtpZihuPXRoaXMuX3BhcnNlU3RyaW5nKCksbj09PW51bGwpcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJDYW5ub3QgcGFyc2UgdXNlcm5hbWVcIikpO3MudXNlcm5hbWU9bixEKFwiX3BhcnNlQ29ubmVjdDogcGFja2V0LnVzZXJuYW1lOiAlc1wiLHMudXNlcm5hbWUpfWlmKG8ucGFzc3dvcmQpe2lmKGk9dGhpcy5fcGFyc2VCdWZmZXIoKSxpPT09bnVsbClyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIkNhbm5vdCBwYXJzZSBwYXNzd29yZFwiKSk7cy5wYXNzd29yZD1pfXJldHVybiB0aGlzLnNldHRpbmdzPXMsRChcIl9wYXJzZUNvbm5lY3Q6IGNvbXBsZXRlXCIpLHN9X3BhcnNlQ29ubmFjaygpe0QoXCJfcGFyc2VDb25uYWNrXCIpO2xldCBlPXRoaXMucGFja2V0O2lmKHRoaXMuX2xpc3QubGVuZ3RoPDEpcmV0dXJuIG51bGw7bGV0IHI9dGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspO2lmKHI+MSlyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIkludmFsaWQgY29ubmFjayBmbGFncywgYml0cyA3LTEgbXVzdCBiZSBzZXQgdG8gMFwiKSk7aWYoZS5zZXNzaW9uUHJlc2VudD0hIShyJlYuU0VTU0lPTlBSRVNFTlRfTUFTSyksdGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb249PT01KXRoaXMuX2xpc3QubGVuZ3RoPj0yP2UucmVhc29uQ29kZT10aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MrKyk6ZS5yZWFzb25Db2RlPTA7ZWxzZXtpZih0aGlzLl9saXN0Lmxlbmd0aDwyKXJldHVybiBudWxsO2UucmV0dXJuQ29kZT10aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MrKyl9aWYoZS5yZXR1cm5Db2RlPT09LTF8fGUucmVhc29uQ29kZT09PS0xKXJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiQ2Fubm90IHBhcnNlIHJldHVybiBjb2RlXCIpKTtpZih0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbj09PTUpe2xldCBpPXRoaXMuX3BhcnNlUHJvcGVydGllcygpO09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGkpLmxlbmd0aCYmKGUucHJvcGVydGllcz1pKX1EKFwiX3BhcnNlQ29ubmFjazogY29tcGxldGVcIil9X3BhcnNlUHVibGlzaCgpe0QoXCJfcGFyc2VQdWJsaXNoXCIpO2xldCBlPXRoaXMucGFja2V0O2lmKGUudG9waWM9dGhpcy5fcGFyc2VTdHJpbmcoKSxlLnRvcGljPT09bnVsbClyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIkNhbm5vdCBwYXJzZSB0b3BpY1wiKSk7aWYoIShlLnFvcz4wJiYhdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkpe2lmKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uPT09NSl7bGV0IHI9dGhpcy5fcGFyc2VQcm9wZXJ0aWVzKCk7T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoJiYoZS5wcm9wZXJ0aWVzPXIpfWUucGF5bG9hZD10aGlzLl9saXN0LnNsaWNlKHRoaXMuX3BvcyxlLmxlbmd0aCksRChcIl9wYXJzZVB1Ymxpc2g6IHBheWxvYWQgZnJvbSBidWZmZXIgbGlzdDogJW9cIixlLnBheWxvYWQpfX1fcGFyc2VTdWJzY3JpYmUoKXtEKFwiX3BhcnNlU3Vic2NyaWJlXCIpO2xldCBlPXRoaXMucGFja2V0LHIsaSxuLG8scyxhLHU7aWYoZS5zdWJzY3JpcHRpb25zPVtdLCEhdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSl7aWYodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb249PT01KXtsZXQgYz10aGlzLl9wYXJzZVByb3BlcnRpZXMoKTtPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjKS5sZW5ndGgmJihlLnByb3BlcnRpZXM9Yyl9aWYoZS5sZW5ndGg8PTApcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJNYWxmb3JtZWQgc3Vic2NyaWJlLCBubyBwYXlsb2FkIHNwZWNpZmllZFwiKSk7Zm9yKDt0aGlzLl9wb3M8ZS5sZW5ndGg7KXtpZihyPXRoaXMuX3BhcnNlU3RyaW5nKCkscj09PW51bGwpcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJDYW5ub3QgcGFyc2UgdG9waWNcIikpO2lmKHRoaXMuX3Bvcz49ZS5sZW5ndGgpcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJNYWxmb3JtZWQgU3Vic2NyaWJlIFBheWxvYWRcIikpO2lmKGk9dGhpcy5fcGFyc2VCeXRlKCksdGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb249PT01KXtpZihpJjE5MilyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIkludmFsaWQgc3Vic2NyaWJlIHRvcGljIGZsYWcgYml0cywgYml0cyA3LTYgbXVzdCBiZSAwXCIpKX1lbHNlIGlmKGkmMjUyKXJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiSW52YWxpZCBzdWJzY3JpYmUgdG9waWMgZmxhZyBiaXRzLCBiaXRzIDctMiBtdXN0IGJlIDBcIikpO2lmKG49aSZWLlNVQlNDUklCRV9PUFRJT05TX1FPU19NQVNLLG4+MilyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIkludmFsaWQgc3Vic2NyaWJlIFFvUywgbXVzdCBiZSA8PSAyXCIpKTtpZihhPShpPj5WLlNVQlNDUklCRV9PUFRJT05TX05MX1NISUZUJlYuU1VCU0NSSUJFX09QVElPTlNfTkxfTUFTSykhPT0wLHM9KGk+PlYuU1VCU0NSSUJFX09QVElPTlNfUkFQX1NISUZUJlYuU1VCU0NSSUJFX09QVElPTlNfUkFQX01BU0spIT09MCxvPWk+PlYuU1VCU0NSSUJFX09QVElPTlNfUkhfU0hJRlQmVi5TVUJTQ1JJQkVfT1BUSU9OU19SSF9NQVNLLG8+MilyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIkludmFsaWQgcmV0YWluIGhhbmRsaW5nLCBtdXN0IGJlIDw9IDJcIikpO3U9e3RvcGljOnIscW9zOm59LHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uPT09NT8odS5ubD1hLHUucmFwPXMsdS5yaD1vKTp0aGlzLnNldHRpbmdzLmJyaWRnZU1vZGUmJih1LnJoPTAsdS5yYXA9ITAsdS5ubD0hMCksRChcIl9wYXJzZVN1YnNjcmliZTogcHVzaCBzdWJzY3JpcHRpb24gYCVzYCB0byBzdWJzY3JpcHRpb25cIix1KSxlLnN1YnNjcmlwdGlvbnMucHVzaCh1KX19fV9wYXJzZVN1YmFjaygpe0QoXCJfcGFyc2VTdWJhY2tcIik7bGV0IGU9dGhpcy5wYWNrZXQ7aWYodGhpcy5wYWNrZXQuZ3JhbnRlZD1bXSwhIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpe2lmKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uPT09NSl7bGV0IHI9dGhpcy5fcGFyc2VQcm9wZXJ0aWVzKCk7T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoJiYoZS5wcm9wZXJ0aWVzPXIpfWlmKGUubGVuZ3RoPD0wKXJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiTWFsZm9ybWVkIHN1YmFjaywgbm8gcGF5bG9hZCBzcGVjaWZpZWRcIikpO2Zvcig7dGhpcy5fcG9zPHRoaXMucGFja2V0Lmxlbmd0aDspe2xldCByPXRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcysrKTtpZih0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbj09PTUpe2lmKCFWLk1RVFQ1X1NVQkFDS19DT0RFU1tyXSlyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIkludmFsaWQgc3ViYWNrIGNvZGVcIikpfWVsc2UgaWYocj4yJiZyIT09MTI4KXJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiSW52YWxpZCBzdWJhY2sgUW9TLCBtdXN0IGJlIDAsIDEsIDIgb3IgMTI4XCIpKTt0aGlzLnBhY2tldC5ncmFudGVkLnB1c2gocil9fX1fcGFyc2VVbnN1YnNjcmliZSgpe0QoXCJfcGFyc2VVbnN1YnNjcmliZVwiKTtsZXQgZT10aGlzLnBhY2tldDtpZihlLnVuc3Vic2NyaXB0aW9ucz1bXSwhIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpe2lmKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uPT09NSl7bGV0IHI9dGhpcy5fcGFyc2VQcm9wZXJ0aWVzKCk7T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoJiYoZS5wcm9wZXJ0aWVzPXIpfWlmKGUubGVuZ3RoPD0wKXJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiTWFsZm9ybWVkIHVuc3Vic2NyaWJlLCBubyBwYXlsb2FkIHNwZWNpZmllZFwiKSk7Zm9yKDt0aGlzLl9wb3M8ZS5sZW5ndGg7KXtsZXQgcj10aGlzLl9wYXJzZVN0cmluZygpO2lmKHI9PT1udWxsKXJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiQ2Fubm90IHBhcnNlIHRvcGljXCIpKTtEKFwiX3BhcnNlVW5zdWJzY3JpYmU6IHB1c2ggdG9waWMgYCVzYCB0byB1bnN1YnNjcmlwdGlvbnNcIixyKSxlLnVuc3Vic2NyaXB0aW9ucy5wdXNoKHIpfX19X3BhcnNlVW5zdWJhY2soKXtEKFwiX3BhcnNlVW5zdWJhY2tcIik7bGV0IGU9dGhpcy5wYWNrZXQ7aWYoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJDYW5ub3QgcGFyc2UgbWVzc2FnZUlkXCIpKTtpZigodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb249PT0zfHx0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbj09PTQpJiZlLmxlbmd0aCE9PTIpcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdW5zdWJhY2ssIHBheWxvYWQgbGVuZ3RoIG11c3QgYmUgMlwiKSk7aWYoZS5sZW5ndGg8PTApcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdW5zdWJhY2ssIG5vIHBheWxvYWQgc3BlY2lmaWVkXCIpKTtpZih0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbj09PTUpe2xldCByPXRoaXMuX3BhcnNlUHJvcGVydGllcygpO2ZvcihPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKS5sZW5ndGgmJihlLnByb3BlcnRpZXM9ciksZS5ncmFudGVkPVtdO3RoaXMuX3Bvczx0aGlzLnBhY2tldC5sZW5ndGg7KXtsZXQgaT10aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MrKyk7aWYoIVYuTVFUVDVfVU5TVUJBQ0tfQ09ERVNbaV0pcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJJbnZhbGlkIHVuc3ViYWNrIGNvZGVcIikpO3RoaXMucGFja2V0LmdyYW50ZWQucHVzaChpKX19fV9wYXJzZUNvbmZpcm1hdGlvbigpe0QoXCJfcGFyc2VDb25maXJtYXRpb246IHBhY2tldC5jbWQ6IGAlc2BcIix0aGlzLnBhY2tldC5jbWQpO2xldCBlPXRoaXMucGFja2V0O2lmKHRoaXMuX3BhcnNlTWVzc2FnZUlkKCksdGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb249PT01KXtpZihlLmxlbmd0aD4yKXtzd2l0Y2goZS5yZWFzb25Db2RlPXRoaXMuX3BhcnNlQnl0ZSgpLHRoaXMucGFja2V0LmNtZCl7Y2FzZVwicHViYWNrXCI6Y2FzZVwicHVicmVjXCI6aWYoIVYuTVFUVDVfUFVCQUNLX1BVQlJFQ19DT0RFU1tlLnJlYXNvbkNvZGVdKXJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiSW52YWxpZCBcIit0aGlzLnBhY2tldC5jbWQrXCIgcmVhc29uIGNvZGVcIikpO2JyZWFrO2Nhc2VcInB1YnJlbFwiOmNhc2VcInB1YmNvbXBcIjppZighVi5NUVRUNV9QVUJSRUxfUFVCQ09NUF9DT0RFU1tlLnJlYXNvbkNvZGVdKXJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiSW52YWxpZCBcIit0aGlzLnBhY2tldC5jbWQrXCIgcmVhc29uIGNvZGVcIikpO2JyZWFrfUQoXCJfcGFyc2VDb25maXJtYXRpb246IHBhY2tldC5yZWFzb25Db2RlIGAlZGBcIixlLnJlYXNvbkNvZGUpfWVsc2UgZS5yZWFzb25Db2RlPTA7aWYoZS5sZW5ndGg+Myl7bGV0IHI9dGhpcy5fcGFyc2VQcm9wZXJ0aWVzKCk7T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoJiYoZS5wcm9wZXJ0aWVzPXIpfX1yZXR1cm4hMH1fcGFyc2VEaXNjb25uZWN0KCl7bGV0IGU9dGhpcy5wYWNrZXQ7aWYoRChcIl9wYXJzZURpc2Nvbm5lY3RcIiksdGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb249PT01KXt0aGlzLl9saXN0Lmxlbmd0aD4wPyhlLnJlYXNvbkNvZGU9dGhpcy5fcGFyc2VCeXRlKCksVi5NUVRUNV9ESVNDT05ORUNUX0NPREVTW2UucmVhc29uQ29kZV18fHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJJbnZhbGlkIGRpc2Nvbm5lY3QgcmVhc29uIGNvZGVcIikpKTplLnJlYXNvbkNvZGU9MDtsZXQgcj10aGlzLl9wYXJzZVByb3BlcnRpZXMoKTtPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKS5sZW5ndGgmJihlLnByb3BlcnRpZXM9cil9cmV0dXJuIEQoXCJfcGFyc2VEaXNjb25uZWN0IHJlc3VsdDogdHJ1ZVwiKSwhMH1fcGFyc2VBdXRoKCl7RChcIl9wYXJzZUF1dGhcIik7bGV0IGU9dGhpcy5wYWNrZXQ7aWYodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24hPT01KXJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCBhdXRoIHBhY2tldCBmb3IgdGhpcyB2ZXJzaW9uIE1RVFRcIikpO2lmKGUucmVhc29uQ29kZT10aGlzLl9wYXJzZUJ5dGUoKSwhVi5NUVRUNV9BVVRIX0NPREVTW2UucmVhc29uQ29kZV0pcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJJbnZhbGlkIGF1dGggcmVhc29uIGNvZGVcIikpO2xldCByPXRoaXMuX3BhcnNlUHJvcGVydGllcygpO3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKS5sZW5ndGgmJihlLnByb3BlcnRpZXM9ciksRChcIl9wYXJzZUF1dGg6IHJlc3VsdDogdHJ1ZVwiKSwhMH1fcGFyc2VNZXNzYWdlSWQoKXtsZXQgZT10aGlzLnBhY2tldDtyZXR1cm4gZS5tZXNzYWdlSWQ9dGhpcy5fcGFyc2VOdW0oKSxlLm1lc3NhZ2VJZD09PW51bGw/KHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJDYW5ub3QgcGFyc2UgbWVzc2FnZUlkXCIpKSwhMSk6KEQoXCJfcGFyc2VNZXNzYWdlSWQ6IHBhY2tldC5tZXNzYWdlSWQgJWRcIixlLm1lc3NhZ2VJZCksITApfV9wYXJzZVN0cmluZyhlKXtsZXQgcj10aGlzLl9wYXJzZU51bSgpLGk9cit0aGlzLl9wb3M7aWYocj09PS0xfHxpPnRoaXMuX2xpc3QubGVuZ3RofHxpPnRoaXMucGFja2V0Lmxlbmd0aClyZXR1cm4gbnVsbDtsZXQgbj10aGlzLl9saXN0LnRvU3RyaW5nKFwidXRmOFwiLHRoaXMuX3BvcyxpKTtyZXR1cm4gdGhpcy5fcG9zKz1yLEQoXCJfcGFyc2VTdHJpbmc6IHJlc3VsdDogJXNcIixuKSxufV9wYXJzZVN0cmluZ1BhaXIoKXtyZXR1cm4gRChcIl9wYXJzZVN0cmluZ1BhaXJcIikse25hbWU6dGhpcy5fcGFyc2VTdHJpbmcoKSx2YWx1ZTp0aGlzLl9wYXJzZVN0cmluZygpfX1fcGFyc2VCdWZmZXIoKXtsZXQgZT10aGlzLl9wYXJzZU51bSgpLHI9ZSt0aGlzLl9wb3M7aWYoZT09PS0xfHxyPnRoaXMuX2xpc3QubGVuZ3RofHxyPnRoaXMucGFja2V0Lmxlbmd0aClyZXR1cm4gbnVsbDtsZXQgaT10aGlzLl9saXN0LnNsaWNlKHRoaXMuX3BvcyxyKTtyZXR1cm4gdGhpcy5fcG9zKz1lLEQoXCJfcGFyc2VCdWZmZXI6IHJlc3VsdDogJW9cIixpKSxpfV9wYXJzZU51bSgpe2lmKHRoaXMuX2xpc3QubGVuZ3RoLXRoaXMuX3BvczwyKXJldHVybi0xO2xldCBlPXRoaXMuX2xpc3QucmVhZFVJbnQxNkJFKHRoaXMuX3Bvcyk7cmV0dXJuIHRoaXMuX3Bvcys9MixEKFwiX3BhcnNlTnVtOiByZXN1bHQ6ICVzXCIsZSksZX1fcGFyc2U0Qnl0ZU51bSgpe2lmKHRoaXMuX2xpc3QubGVuZ3RoLXRoaXMuX3Bvczw0KXJldHVybi0xO2xldCBlPXRoaXMuX2xpc3QucmVhZFVJbnQzMkJFKHRoaXMuX3Bvcyk7cmV0dXJuIHRoaXMuX3Bvcys9NCxEKFwiX3BhcnNlNEJ5dGVOdW06IHJlc3VsdDogJXNcIixlKSxlfV9wYXJzZVZhckJ5dGVOdW0oZSl7RChcIl9wYXJzZVZhckJ5dGVOdW1cIik7bGV0IHI9NCxpPTAsbj0xLG89MCxzPSExLGEsdT10aGlzLl9wb3M/dGhpcy5fcG9zOjA7Zm9yKDtpPHImJnUraTx0aGlzLl9saXN0Lmxlbmd0aDspe2lmKGE9dGhpcy5fbGlzdC5yZWFkVUludDgodStpKyspLG8rPW4qKGEmVi5WQVJCWVRFSU5UX01BU0spLG4qPTEyOCwhKGEmVi5WQVJCWVRFSU5UX0ZJTl9NQVNLKSl7cz0hMDticmVha31pZih0aGlzLl9saXN0Lmxlbmd0aDw9aSlicmVha31yZXR1cm4hcyYmaT09PXImJnRoaXMuX2xpc3QubGVuZ3RoPj1pJiZ0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiSW52YWxpZCB2YXJpYWJsZSBieXRlIGludGVnZXJcIikpLHUmJih0aGlzLl9wb3MrPWkpLHM/ZT9zPXtieXRlczppLHZhbHVlOm99OnM9bzpzPSExLEQoXCJfcGFyc2VWYXJCeXRlTnVtOiByZXN1bHQ6ICVvXCIscyksc31fcGFyc2VCeXRlKCl7bGV0IGU7cmV0dXJuIHRoaXMuX3Bvczx0aGlzLl9saXN0Lmxlbmd0aCYmKGU9dGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSx0aGlzLl9wb3MrKyksRChcIl9wYXJzZUJ5dGU6IHJlc3VsdDogJW9cIixlKSxlfV9wYXJzZUJ5VHlwZShlKXtzd2l0Y2goRChcIl9wYXJzZUJ5VHlwZTogdHlwZTogJXNcIixlKSxlKXtjYXNlXCJieXRlXCI6cmV0dXJuIHRoaXMuX3BhcnNlQnl0ZSgpIT09MDtjYXNlXCJpbnQ4XCI6cmV0dXJuIHRoaXMuX3BhcnNlQnl0ZSgpO2Nhc2VcImludDE2XCI6cmV0dXJuIHRoaXMuX3BhcnNlTnVtKCk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gdGhpcy5fcGFyc2U0Qnl0ZU51bSgpO2Nhc2VcInZhclwiOnJldHVybiB0aGlzLl9wYXJzZVZhckJ5dGVOdW0oKTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gdGhpcy5fcGFyc2VTdHJpbmcoKTtjYXNlXCJwYWlyXCI6cmV0dXJuIHRoaXMuX3BhcnNlU3RyaW5nUGFpcigpO2Nhc2VcImJpbmFyeVwiOnJldHVybiB0aGlzLl9wYXJzZUJ1ZmZlcigpfX1fcGFyc2VQcm9wZXJ0aWVzKCl7RChcIl9wYXJzZVByb3BlcnRpZXNcIik7bGV0IGU9dGhpcy5fcGFyc2VWYXJCeXRlTnVtKCksaT10aGlzLl9wb3MrZSxuPXt9O2Zvcig7dGhpcy5fcG9zPGk7KXtsZXQgbz10aGlzLl9wYXJzZUJ5dGUoKTtpZighbylyZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcIkNhbm5vdCBwYXJzZSBwcm9wZXJ0eSBjb2RlIHR5cGVcIikpLCExO2xldCBzPVYucHJvcGVydGllc0NvZGVzW29dO2lmKCFzKXJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwiVW5rbm93biBwcm9wZXJ0eVwiKSksITE7aWYocz09PVwidXNlclByb3BlcnRpZXNcIil7bltzXXx8KG5bc109T2JqZWN0LmNyZWF0ZShudWxsKSk7bGV0IGE9dGhpcy5fcGFyc2VCeVR5cGUoVi5wcm9wZXJ0aWVzVHlwZXNbc10pO2lmKG5bc11bYS5uYW1lXSlpZihBcnJheS5pc0FycmF5KG5bc11bYS5uYW1lXSkpbltzXVthLm5hbWVdLnB1c2goYS52YWx1ZSk7ZWxzZXtsZXQgdT1uW3NdW2EubmFtZV07bltzXVthLm5hbWVdPVt1XSxuW3NdW2EubmFtZV0ucHVzaChhLnZhbHVlKX1lbHNlIG5bc11bYS5uYW1lXT1hLnZhbHVlO2NvbnRpbnVlfW5bc10/QXJyYXkuaXNBcnJheShuW3NdKT9uW3NdLnB1c2godGhpcy5fcGFyc2VCeVR5cGUoVi5wcm9wZXJ0aWVzVHlwZXNbc10pKToobltzXT1bbltzXV0sbltzXS5wdXNoKHRoaXMuX3BhcnNlQnlUeXBlKFYucHJvcGVydGllc1R5cGVzW3NdKSkpOm5bc109dGhpcy5fcGFyc2VCeVR5cGUoVi5wcm9wZXJ0aWVzVHlwZXNbc10pfXJldHVybiBufV9uZXdQYWNrZXQoKXtyZXR1cm4gRChcIl9uZXdQYWNrZXRcIiksdGhpcy5wYWNrZXQmJih0aGlzLl9saXN0LmNvbnN1bWUodGhpcy5wYWNrZXQubGVuZ3RoKSxEKFwiX25ld1BhY2tldDogcGFyc2VyIGVtaXQgcGFja2V0OiBwYWNrZXQuY21kOiAlcywgcGFja2V0LnBheWxvYWQ6ICVzLCBwYWNrZXQubGVuZ3RoOiAlZFwiLHRoaXMucGFja2V0LmNtZCx0aGlzLnBhY2tldC5wYXlsb2FkLHRoaXMucGFja2V0Lmxlbmd0aCksdGhpcy5lbWl0KFwicGFja2V0XCIsdGhpcy5wYWNrZXQpKSxEKFwiX25ld1BhY2tldDogbmV3IHBhY2tldFwiKSx0aGlzLnBhY2tldD1uZXcgd2QsdGhpcy5fcG9zPTAsITB9X2VtaXRFcnJvcihlKXtEKFwiX2VtaXRFcnJvclwiLGUpLHRoaXMuZXJyb3I9ZSx0aGlzLmVtaXQoXCJlcnJvclwiLGUpfX07X2QuZXhwb3J0cz1Xb30pO3ZhciBBZD1NKChGUCxTZCk9Pnt2KCk7bSgpO18oKTt2YXJ7QnVmZmVyOm1pfT0od2UoKSxaKHZlKSksQ209NjU1MzYsdmQ9e30sQm09bWkuaXNCdWZmZXIobWkuZnJvbShbMSwyXSkuc3ViYXJyYXkoMCwxKSk7ZnVuY3Rpb24gRWQodCl7bGV0IGU9bWkuYWxsb2NVbnNhZmUoMik7cmV0dXJuIGUud3JpdGVVSW50OCh0Pj44LDApLGUud3JpdGVVSW50OCh0JjI1NSwwKzEpLGV9ZnVuY3Rpb24gUG0oKXtmb3IobGV0IHQ9MDt0PENtO3QrKyl2ZFt0XT1FZCh0KX1mdW5jdGlvbiBPbSh0KXtsZXQgcj0wLGk9MCxuPW1pLmFsbG9jVW5zYWZlKDQpO2RvIHI9dCUxMjh8MCx0PXQvMTI4fDAsdD4wJiYocj1yfDEyOCksbi53cml0ZVVJbnQ4KHIsaSsrKTt3aGlsZSh0PjAmJmk8NCk7cmV0dXJuIHQ+MCYmKGk9MCksQm0/bi5zdWJhcnJheSgwLGkpOm4uc2xpY2UoMCxpKX1mdW5jdGlvbiBrbSh0KXtsZXQgZT1taS5hbGxvY1Vuc2FmZSg0KTtyZXR1cm4gZS53cml0ZVVJbnQzMkJFKHQsMCksZX1TZC5leHBvcnRzPXtjYWNoZTp2ZCxnZW5lcmF0ZUNhY2hlOlBtLGdlbmVyYXRlTnVtYmVyOkVkLGdlbkJ1ZlZhcmlhYmxlQnl0ZUludDpPbSxnZW5lcmF0ZTRCeXRlQnVmZmVyOmttfX0pO3ZhciBJZD1NKChKUCwkbyk9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTt0eXBlb2YgUD5cInVcInx8IVAudmVyc2lvbnx8UC52ZXJzaW9uLmluZGV4T2YoXCJ2MC5cIik9PT0wfHxQLnZlcnNpb24uaW5kZXhPZihcInYxLlwiKT09PTAmJlAudmVyc2lvbi5pbmRleE9mKFwidjEuOC5cIikhPT0wPyRvLmV4cG9ydHM9e25leHRUaWNrOnhtfTokby5leHBvcnRzPVA7ZnVuY3Rpb24geG0odCxlLHIsaSl7aWYodHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7dmFyIG49YXJndW1lbnRzLmxlbmd0aCxvLHM7c3dpdGNoKG4pe2Nhc2UgMDpjYXNlIDE6cmV0dXJuIFAubmV4dFRpY2sodCk7Y2FzZSAyOnJldHVybiBQLm5leHRUaWNrKGZ1bmN0aW9uKCl7dC5jYWxsKG51bGwsZSl9KTtjYXNlIDM6cmV0dXJuIFAubmV4dFRpY2soZnVuY3Rpb24oKXt0LmNhbGwobnVsbCxlLHIpfSk7Y2FzZSA0OnJldHVybiBQLm5leHRUaWNrKGZ1bmN0aW9uKCl7dC5jYWxsKG51bGwsZSxyLGkpfSk7ZGVmYXVsdDpmb3Iobz1uZXcgQXJyYXkobi0xKSxzPTA7czxvLmxlbmd0aDspb1tzKytdPWFyZ3VtZW50c1tzXTtyZXR1cm4gUC5uZXh0VGljayhmdW5jdGlvbigpe3QuYXBwbHkobnVsbCxvKX0pfX19KTt2YXIgem89TSgoYU8seGQpPT57digpO20oKTtfKCk7dmFyIGo9Rm8oKSx7QnVmZmVyOnF9PSh3ZSgpLFoodmUpKSxNbT1xLmFsbG9jVW5zYWZlKDApLExtPXEuZnJvbShbMF0pLHZpPUFkKCksVW09SWQoKS5uZXh0VGljayxxZT1vdCgpKFwibXF0dC1wYWNrZXQ6d3JpdGVUb1N0cmVhbVwiKSxDbj12aS5jYWNoZSxObT12aS5nZW5lcmF0ZU51bWJlcixxbT12aS5nZW5lcmF0ZUNhY2hlLEhvPXZpLmdlbkJ1ZlZhcmlhYmxlQnl0ZUludCxEbT12aS5nZW5lcmF0ZTRCeXRlQnVmZmVyLEllPVZvLEJuPSEwO2Z1bmN0aW9uIE9kKHQsZSxyKXtzd2l0Y2gocWUoXCJnZW5lcmF0ZSBjYWxsZWRcIiksZS5jb3JrJiYoZS5jb3JrKCksVW0oam0sZSkpLEJuJiYoQm49ITEscW0oKSkscWUoXCJnZW5lcmF0ZTogcGFja2V0LmNtZDogJXNcIix0LmNtZCksdC5jbWQpe2Nhc2VcImNvbm5lY3RcIjpyZXR1cm4gRm0odCxlLHIpO2Nhc2VcImNvbm5hY2tcIjpyZXR1cm4gV20odCxlLHIpO2Nhc2VcInB1Ymxpc2hcIjpyZXR1cm4gJG0odCxlLHIpO2Nhc2VcInB1YmFja1wiOmNhc2VcInB1YnJlY1wiOmNhc2VcInB1YnJlbFwiOmNhc2VcInB1YmNvbXBcIjpyZXR1cm4gSG0odCxlLHIpO2Nhc2VcInN1YnNjcmliZVwiOnJldHVybiBWbSh0LGUscik7Y2FzZVwic3ViYWNrXCI6cmV0dXJuIHptKHQsZSxyKTtjYXNlXCJ1bnN1YnNjcmliZVwiOnJldHVybiBLbSh0LGUscik7Y2FzZVwidW5zdWJhY2tcIjpyZXR1cm4gR20odCxlLHIpO2Nhc2VcInBpbmdyZXFcIjpjYXNlXCJwaW5ncmVzcFwiOnJldHVybiBRbSh0LGUscik7Y2FzZVwiZGlzY29ubmVjdFwiOnJldHVybiBZbSh0LGUscik7Y2FzZVwiYXV0aFwiOnJldHVybiBKbSh0LGUscik7ZGVmYXVsdDpyZXR1cm4gZS5kZXN0cm95KG5ldyBFcnJvcihcIlVua25vd24gY29tbWFuZFwiKSksITF9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShPZCxcImNhY2hlTnVtYmVyc1wiLHtnZXQoKXtyZXR1cm4gSWU9PT1Wb30sc2V0KHQpe3Q/KCghQ258fE9iamVjdC5rZXlzKENuKS5sZW5ndGg9PT0wKSYmKEJuPSEwKSxJZT1Wbyk6KEJuPSExLEllPVhtKX19KTtmdW5jdGlvbiBqbSh0KXt0LnVuY29yaygpfWZ1bmN0aW9uIEZtKHQsZSxyKXtsZXQgaT10fHx7fSxuPWkucHJvdG9jb2xJZHx8XCJNUVRUXCIsbz1pLnByb3RvY29sVmVyc2lvbnx8NCxzPWkud2lsbCxhPWkuY2xlYW4sdT1pLmtlZXBhbGl2ZXx8MCxjPWkuY2xpZW50SWR8fFwiXCIsaD1pLnVzZXJuYW1lLGQ9aS5wYXNzd29yZCxnPWkucHJvcGVydGllczthPT09dm9pZCAwJiYoYT0hMCk7bGV0IHk9MDtpZighbnx8dHlwZW9mIG4hPVwic3RyaW5nXCImJiFxLmlzQnVmZmVyKG4pKXJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCBwcm90b2NvbElkXCIpKSwhMTtpZih5Kz1uLmxlbmd0aCsyLG8hPT0zJiZvIT09NCYmbyE9PTUpcmV0dXJuIGUuZGVzdHJveShuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3RvY29sIHZlcnNpb25cIikpLCExO2lmKHkrPTEsKHR5cGVvZiBjPT1cInN0cmluZ1wifHxxLmlzQnVmZmVyKGMpKSYmKGN8fG8+PTQpJiYoY3x8YSkpeSs9cS5ieXRlTGVuZ3RoKGMpKzI7ZWxzZXtpZihvPDQpcmV0dXJuIGUuZGVzdHJveShuZXcgRXJyb3IoXCJjbGllbnRJZCBtdXN0IGJlIHN1cHBsaWVkIGJlZm9yZSAzLjEuMVwiKSksITE7aWYoYSoxPT09MClyZXR1cm4gZS5kZXN0cm95KG5ldyBFcnJvcihcImNsaWVudElkIG11c3QgYmUgZ2l2ZW4gaWYgY2xlYW5TZXNzaW9uIHNldCB0byAwXCIpKSwhMX1pZih0eXBlb2YgdSE9XCJudW1iZXJcInx8dTwwfHx1PjY1NTM1fHx1JTEhPT0wKXJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCBrZWVwYWxpdmVcIikpLCExO3krPTIseSs9MTtsZXQgdyxFO2lmKG89PT01KXtpZih3PUZ0KGUsZyksIXcpcmV0dXJuITE7eSs9dy5sZW5ndGh9aWYocyl7aWYodHlwZW9mIHMhPVwib2JqZWN0XCIpcmV0dXJuIGUuZGVzdHJveShuZXcgRXJyb3IoXCJJbnZhbGlkIHdpbGxcIikpLCExO2lmKCFzLnRvcGljfHx0eXBlb2Ygcy50b3BpYyE9XCJzdHJpbmdcIilyZXR1cm4gZS5kZXN0cm95KG5ldyBFcnJvcihcIkludmFsaWQgd2lsbCB0b3BpY1wiKSksITE7aWYoeSs9cS5ieXRlTGVuZ3RoKHMudG9waWMpKzIseSs9MixzLnBheWxvYWQpaWYocy5wYXlsb2FkLmxlbmd0aD49MCl0eXBlb2Ygcy5wYXlsb2FkPT1cInN0cmluZ1wiP3krPXEuYnl0ZUxlbmd0aChzLnBheWxvYWQpOnkrPXMucGF5bG9hZC5sZW5ndGg7ZWxzZSByZXR1cm4gZS5kZXN0cm95KG5ldyBFcnJvcihcIkludmFsaWQgd2lsbCBwYXlsb2FkXCIpKSwhMTtpZihFPXt9LG89PT01KXtpZihFPUZ0KGUscy5wcm9wZXJ0aWVzKSwhRSlyZXR1cm4hMTt5Kz1FLmxlbmd0aH19bGV0IFM9ITE7aWYoaCE9bnVsbClpZihQZChoKSlTPSEwLHkrPXEuYnl0ZUxlbmd0aChoKSsyO2Vsc2UgcmV0dXJuIGUuZGVzdHJveShuZXcgRXJyb3IoXCJJbnZhbGlkIHVzZXJuYW1lXCIpKSwhMTtpZihkIT1udWxsKXtpZighUylyZXR1cm4gZS5kZXN0cm95KG5ldyBFcnJvcihcIlVzZXJuYW1lIGlzIHJlcXVpcmVkIHRvIHVzZSBwYXNzd29yZFwiKSksITE7aWYoUGQoZCkpeSs9a2QoZCkrMjtlbHNlIHJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCBwYXNzd29yZFwiKSksITF9ZS53cml0ZShqLkNPTk5FQ1RfSEVBREVSKSxEZShlLHkpLEtyKGUsbiksaS5icmlkZ2VNb2RlJiYobys9MTI4KSxlLndyaXRlKG89PT0xMzE/ai5WRVJTSU9OMTMxOm89PT0xMzI/ai5WRVJTSU9OMTMyOm89PT00P2ouVkVSU0lPTjQ6bz09PTU/ai5WRVJTSU9ONTpqLlZFUlNJT04zKTtsZXQgST0wO3JldHVybiBJfD1oIT1udWxsP2ouVVNFUk5BTUVfTUFTSzowLEl8PWQhPW51bGw/ai5QQVNTV09SRF9NQVNLOjAsSXw9cyYmcy5yZXRhaW4/ai5XSUxMX1JFVEFJTl9NQVNLOjAsSXw9cyYmcy5xb3M/cy5xb3M8PGouV0lMTF9RT1NfU0hJRlQ6MCxJfD1zP2ouV0lMTF9GTEFHX01BU0s6MCxJfD1hP2ouQ0xFQU5fU0VTU0lPTl9NQVNLOjAsZS53cml0ZShxLmZyb20oW0ldKSksSWUoZSx1KSxvPT09NSYmdy53cml0ZSgpLEtyKGUsYykscyYmKG89PT01JiZFLndyaXRlKCkseXIoZSxzLnRvcGljKSxLcihlLHMucGF5bG9hZCkpLGghPW51bGwmJktyKGUsaCksZCE9bnVsbCYmS3IoZSxkKSwhMH1mdW5jdGlvbiBXbSh0LGUscil7bGV0IGk9cj9yLnByb3RvY29sVmVyc2lvbjo0LG49dHx8e30sbz1pPT09NT9uLnJlYXNvbkNvZGU6bi5yZXR1cm5Db2RlLHM9bi5wcm9wZXJ0aWVzLGE9MjtpZih0eXBlb2YgbyE9XCJudW1iZXJcIilyZXR1cm4gZS5kZXN0cm95KG5ldyBFcnJvcihcIkludmFsaWQgcmV0dXJuIGNvZGVcIikpLCExO2xldCB1PW51bGw7aWYoaT09PTUpe2lmKHU9RnQoZSxzKSwhdSlyZXR1cm4hMTthKz11Lmxlbmd0aH1yZXR1cm4gZS53cml0ZShqLkNPTk5BQ0tfSEVBREVSKSxEZShlLGEpLGUud3JpdGUobi5zZXNzaW9uUHJlc2VudD9qLlNFU1NJT05QUkVTRU5UX0hFQURFUjpMbSksZS53cml0ZShxLmZyb20oW29dKSksdT8ud3JpdGUoKSwhMH1mdW5jdGlvbiAkbSh0LGUscil7cWUoXCJwdWJsaXNoOiBwYWNrZXQ6ICVvXCIsdCk7bGV0IGk9cj9yLnByb3RvY29sVmVyc2lvbjo0LG49dHx8e30sbz1uLnFvc3x8MCxzPW4ucmV0YWluP2ouUkVUQUlOX01BU0s6MCxhPW4udG9waWMsdT1uLnBheWxvYWR8fE1tLGM9bi5tZXNzYWdlSWQsaD1uLnByb3BlcnRpZXMsZD0wO2lmKHR5cGVvZiBhPT1cInN0cmluZ1wiKWQrPXEuYnl0ZUxlbmd0aChhKSsyO2Vsc2UgaWYocS5pc0J1ZmZlcihhKSlkKz1hLmxlbmd0aCsyO2Vsc2UgcmV0dXJuIGUuZGVzdHJveShuZXcgRXJyb3IoXCJJbnZhbGlkIHRvcGljXCIpKSwhMTtpZihxLmlzQnVmZmVyKHUpP2QrPXUubGVuZ3RoOmQrPXEuYnl0ZUxlbmd0aCh1KSxvJiZ0eXBlb2YgYyE9XCJudW1iZXJcIilyZXR1cm4gZS5kZXN0cm95KG5ldyBFcnJvcihcIkludmFsaWQgbWVzc2FnZUlkXCIpKSwhMTtvJiYoZCs9Mik7bGV0IGc9bnVsbDtpZihpPT09NSl7aWYoZz1GdChlLGgpLCFnKXJldHVybiExO2QrPWcubGVuZ3RofXJldHVybiBlLndyaXRlKGouUFVCTElTSF9IRUFERVJbb11bbi5kdXA/MTowXVtzPzE6MF0pLERlKGUsZCksSWUoZSxrZChhKSksZS53cml0ZShhKSxvPjAmJkllKGUsYyksZz8ud3JpdGUoKSxxZShcInB1Ymxpc2g6IHBheWxvYWQ6ICVvXCIsdSksZS53cml0ZSh1KX1mdW5jdGlvbiBIbSh0LGUscil7bGV0IGk9cj9yLnByb3RvY29sVmVyc2lvbjo0LG49dHx8e30sbz1uLmNtZHx8XCJwdWJhY2tcIixzPW4ubWVzc2FnZUlkLGE9bi5kdXAmJm89PT1cInB1YnJlbFwiP2ouRFVQX01BU0s6MCx1PTAsYz1uLnJlYXNvbkNvZGUsaD1uLnByb3BlcnRpZXMsZD1pPT09NT8zOjI7aWYobz09PVwicHVicmVsXCImJih1PTEpLHR5cGVvZiBzIT1cIm51bWJlclwiKXJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCBtZXNzYWdlSWRcIikpLCExO2xldCBnPW51bGw7aWYoaT09PTUmJnR5cGVvZiBoPT1cIm9iamVjdFwiKXtpZihnPUVpKGUsaCxyLGQpLCFnKXJldHVybiExO2QrPWcubGVuZ3RofXJldHVybiBlLndyaXRlKGouQUNLU1tvXVt1XVthXVswXSksZD09PTMmJihkKz1jIT09MD8xOi0xKSxEZShlLGQpLEllKGUscyksaT09PTUmJmQhPT0yJiZlLndyaXRlKHEuZnJvbShbY10pKSxnIT09bnVsbD9nLndyaXRlKCk6ZD09PTQmJmUud3JpdGUocS5mcm9tKFswXSkpLCEwfWZ1bmN0aW9uIFZtKHQsZSxyKXtxZShcInN1YnNjcmliZTogcGFja2V0OiBcIik7bGV0IGk9cj9yLnByb3RvY29sVmVyc2lvbjo0LG49dHx8e30sbz1uLmR1cD9qLkRVUF9NQVNLOjAscz1uLm1lc3NhZ2VJZCxhPW4uc3Vic2NyaXB0aW9ucyx1PW4ucHJvcGVydGllcyxjPTA7aWYodHlwZW9mIHMhPVwibnVtYmVyXCIpcmV0dXJuIGUuZGVzdHJveShuZXcgRXJyb3IoXCJJbnZhbGlkIG1lc3NhZ2VJZFwiKSksITE7Yys9MjtsZXQgaD1udWxsO2lmKGk9PT01KXtpZihoPUZ0KGUsdSksIWgpcmV0dXJuITE7Yys9aC5sZW5ndGh9aWYodHlwZW9mIGE9PVwib2JqZWN0XCImJmEubGVuZ3RoKWZvcihsZXQgZz0wO2c8YS5sZW5ndGg7Zys9MSl7bGV0IHk9YVtnXS50b3BpYyx3PWFbZ10ucW9zO2lmKHR5cGVvZiB5IT1cInN0cmluZ1wiKXJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCBzdWJzY3JpcHRpb25zIC0gaW52YWxpZCB0b3BpY1wiKSksITE7aWYodHlwZW9mIHchPVwibnVtYmVyXCIpcmV0dXJuIGUuZGVzdHJveShuZXcgRXJyb3IoXCJJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIHFvc1wiKSksITE7aWYoaT09PTUpe2lmKHR5cGVvZihhW2ddLm5sfHwhMSkhPVwiYm9vbGVhblwiKXJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCBzdWJzY3JpcHRpb25zIC0gaW52YWxpZCBObyBMb2NhbFwiKSksITE7aWYodHlwZW9mKGFbZ10ucmFwfHwhMSkhPVwiYm9vbGVhblwiKXJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCBzdWJzY3JpcHRpb25zIC0gaW52YWxpZCBSZXRhaW4gYXMgUHVibGlzaGVkXCIpKSwhMTtsZXQgST1hW2ddLnJofHwwO2lmKHR5cGVvZiBJIT1cIm51bWJlclwifHxJPjIpcmV0dXJuIGUuZGVzdHJveShuZXcgRXJyb3IoXCJJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIFJldGFpbiBIYW5kbGluZ1wiKSksITF9Yys9cS5ieXRlTGVuZ3RoKHkpKzIrMX1lbHNlIHJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCBzdWJzY3JpcHRpb25zXCIpKSwhMTtxZShcInN1YnNjcmliZTogd3JpdGluZyB0byBzdHJlYW06ICVvXCIsai5TVUJTQ1JJQkVfSEVBREVSKSxlLndyaXRlKGouU1VCU0NSSUJFX0hFQURFUlsxXVtvPzE6MF1bMF0pLERlKGUsYyksSWUoZSxzKSxoIT09bnVsbCYmaC53cml0ZSgpO2xldCBkPSEwO2ZvcihsZXQgZyBvZiBhKXtsZXQgeT1nLnRvcGljLHc9Zy5xb3MsRT0rZy5ubCxTPStnLnJhcCxJPWcucmgsQzt5cihlLHkpLEM9ai5TVUJTQ1JJQkVfT1BUSU9OU19RT1Nbd10saT09PTUmJihDfD1FP2ouU1VCU0NSSUJFX09QVElPTlNfTkw6MCxDfD1TP2ouU1VCU0NSSUJFX09QVElPTlNfUkFQOjAsQ3w9ST9qLlNVQlNDUklCRV9PUFRJT05TX1JIW0ldOjApLGQ9ZS53cml0ZShxLmZyb20oW0NdKSl9cmV0dXJuIGR9ZnVuY3Rpb24gem0odCxlLHIpe2xldCBpPXI/ci5wcm90b2NvbFZlcnNpb246NCxuPXR8fHt9LG89bi5tZXNzYWdlSWQscz1uLmdyYW50ZWQsYT1uLnByb3BlcnRpZXMsdT0wO2lmKHR5cGVvZiBvIT1cIm51bWJlclwiKXJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCBtZXNzYWdlSWRcIikpLCExO2lmKHUrPTIsdHlwZW9mIHM9PVwib2JqZWN0XCImJnMubGVuZ3RoKWZvcihsZXQgaD0wO2g8cy5sZW5ndGg7aCs9MSl7aWYodHlwZW9mIHNbaF0hPVwibnVtYmVyXCIpcmV0dXJuIGUuZGVzdHJveShuZXcgRXJyb3IoXCJJbnZhbGlkIHFvcyB2ZWN0b3JcIikpLCExO3UrPTF9ZWxzZSByZXR1cm4gZS5kZXN0cm95KG5ldyBFcnJvcihcIkludmFsaWQgcW9zIHZlY3RvclwiKSksITE7bGV0IGM9bnVsbDtpZihpPT09NSl7aWYoYz1FaShlLGEscix1KSwhYylyZXR1cm4hMTt1Kz1jLmxlbmd0aH1yZXR1cm4gZS53cml0ZShqLlNVQkFDS19IRUFERVIpLERlKGUsdSksSWUoZSxvKSxjIT09bnVsbCYmYy53cml0ZSgpLGUud3JpdGUocS5mcm9tKHMpKX1mdW5jdGlvbiBLbSh0LGUscil7bGV0IGk9cj9yLnByb3RvY29sVmVyc2lvbjo0LG49dHx8e30sbz1uLm1lc3NhZ2VJZCxzPW4uZHVwP2ouRFVQX01BU0s6MCxhPW4udW5zdWJzY3JpcHRpb25zLHU9bi5wcm9wZXJ0aWVzLGM9MDtpZih0eXBlb2YgbyE9XCJudW1iZXJcIilyZXR1cm4gZS5kZXN0cm95KG5ldyBFcnJvcihcIkludmFsaWQgbWVzc2FnZUlkXCIpKSwhMTtpZihjKz0yLHR5cGVvZiBhPT1cIm9iamVjdFwiJiZhLmxlbmd0aClmb3IobGV0IGc9MDtnPGEubGVuZ3RoO2crPTEpe2lmKHR5cGVvZiBhW2ddIT1cInN0cmluZ1wiKXJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCB1bnN1YnNjcmlwdGlvbnNcIikpLCExO2MrPXEuYnl0ZUxlbmd0aChhW2ddKSsyfWVsc2UgcmV0dXJuIGUuZGVzdHJveShuZXcgRXJyb3IoXCJJbnZhbGlkIHVuc3Vic2NyaXB0aW9uc1wiKSksITE7bGV0IGg9bnVsbDtpZihpPT09NSl7aWYoaD1GdChlLHUpLCFoKXJldHVybiExO2MrPWgubGVuZ3RofWUud3JpdGUoai5VTlNVQlNDUklCRV9IRUFERVJbMV1bcz8xOjBdWzBdKSxEZShlLGMpLEllKGUsbyksaCE9PW51bGwmJmgud3JpdGUoKTtsZXQgZD0hMDtmb3IobGV0IGc9MDtnPGEubGVuZ3RoO2crKylkPXlyKGUsYVtnXSk7cmV0dXJuIGR9ZnVuY3Rpb24gR20odCxlLHIpe2xldCBpPXI/ci5wcm90b2NvbFZlcnNpb246NCxuPXR8fHt9LG89bi5tZXNzYWdlSWQscz1uLmR1cD9qLkRVUF9NQVNLOjAsYT1uLmdyYW50ZWQsdT1uLnByb3BlcnRpZXMsYz1uLmNtZCxoPTAsZD0yO2lmKHR5cGVvZiBvIT1cIm51bWJlclwiKXJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCBtZXNzYWdlSWRcIikpLCExO2lmKGk9PT01KWlmKHR5cGVvZiBhPT1cIm9iamVjdFwiJiZhLmxlbmd0aClmb3IobGV0IHk9MDt5PGEubGVuZ3RoO3krPTEpe2lmKHR5cGVvZiBhW3ldIT1cIm51bWJlclwiKXJldHVybiBlLmRlc3Ryb3kobmV3IEVycm9yKFwiSW52YWxpZCBxb3MgdmVjdG9yXCIpKSwhMTtkKz0xfWVsc2UgcmV0dXJuIGUuZGVzdHJveShuZXcgRXJyb3IoXCJJbnZhbGlkIHFvcyB2ZWN0b3JcIikpLCExO2xldCBnPW51bGw7aWYoaT09PTUpe2lmKGc9RWkoZSx1LHIsZCksIWcpcmV0dXJuITE7ZCs9Zy5sZW5ndGh9cmV0dXJuIGUud3JpdGUoai5BQ0tTW2NdW2hdW3NdWzBdKSxEZShlLGQpLEllKGUsbyksZyE9PW51bGwmJmcud3JpdGUoKSxpPT09NSYmZS53cml0ZShxLmZyb20oYSkpLCEwfWZ1bmN0aW9uIFFtKHQsZSxyKXtyZXR1cm4gZS53cml0ZShqLkVNUFRZW3QuY21kXSl9ZnVuY3Rpb24gWW0odCxlLHIpe2xldCBpPXI/ci5wcm90b2NvbFZlcnNpb246NCxuPXR8fHt9LG89bi5yZWFzb25Db2RlLHM9bi5wcm9wZXJ0aWVzLGE9aT09PTU/MTowLHU9bnVsbDtpZihpPT09NSl7aWYodT1FaShlLHMscixhKSwhdSlyZXR1cm4hMTthKz11Lmxlbmd0aH1yZXR1cm4gZS53cml0ZShxLmZyb20oW2ouY29kZXMuZGlzY29ubmVjdDw8NF0pKSxEZShlLGEpLGk9PT01JiZlLndyaXRlKHEuZnJvbShbb10pKSx1IT09bnVsbCYmdS53cml0ZSgpLCEwfWZ1bmN0aW9uIEptKHQsZSxyKXtsZXQgaT1yP3IucHJvdG9jb2xWZXJzaW9uOjQsbj10fHx7fSxvPW4ucmVhc29uQ29kZSxzPW4ucHJvcGVydGllcyxhPWk9PT01PzE6MDtpIT09NSYmZS5kZXN0cm95KG5ldyBFcnJvcihcIkludmFsaWQgbXF0dCB2ZXJzaW9uIGZvciBhdXRoIHBhY2tldFwiKSk7bGV0IHU9RWkoZSxzLHIsYSk7cmV0dXJuIHU/KGErPXUubGVuZ3RoLGUud3JpdGUocS5mcm9tKFtqLmNvZGVzLmF1dGg8PDRdKSksRGUoZSxhKSxlLndyaXRlKHEuZnJvbShbb10pKSx1IT09bnVsbCYmdS53cml0ZSgpLCEwKTohMX12YXIgVGQ9e307ZnVuY3Rpb24gRGUodCxlKXtpZihlPmouVkFSQllURUlOVF9NQVgpcmV0dXJuIHQuZGVzdHJveShuZXcgRXJyb3IoYEludmFsaWQgdmFyaWFibGUgYnl0ZSBpbnRlZ2VyOiAke2V9YCkpLCExO2xldCByPVRkW2VdO3JldHVybiByfHwocj1IbyhlKSxlPDE2Mzg0JiYoVGRbZV09cikpLHFlKFwid3JpdGVWYXJCeXRlSW50OiB3cml0aW5nIHRvIHN0cmVhbTogJW9cIixyKSx0LndyaXRlKHIpfWZ1bmN0aW9uIHlyKHQsZSl7bGV0IHI9cS5ieXRlTGVuZ3RoKGUpO3JldHVybiBJZSh0LHIpLHFlKFwid3JpdGVTdHJpbmc6ICVzXCIsZSksdC53cml0ZShlLFwidXRmOFwiKX1mdW5jdGlvbiBSZCh0LGUscil7eXIodCxlKSx5cih0LHIpfWZ1bmN0aW9uIFZvKHQsZSl7cmV0dXJuIHFlKFwid3JpdGVOdW1iZXJDYWNoZWQ6IG51bWJlcjogJWRcIixlKSxxZShcIndyaXRlTnVtYmVyQ2FjaGVkOiAlb1wiLENuW2VdKSx0LndyaXRlKENuW2VdKX1mdW5jdGlvbiBYbSh0LGUpe2xldCByPU5tKGUpO3JldHVybiBxZShcIndyaXRlTnVtYmVyR2VuZXJhdGVkOiAlb1wiLHIpLHQud3JpdGUocil9ZnVuY3Rpb24gWm0odCxlKXtsZXQgcj1EbShlKTtyZXR1cm4gcWUoXCJ3cml0ZTRCeXRlTnVtYmVyOiAlb1wiLHIpLHQud3JpdGUocil9ZnVuY3Rpb24gS3IodCxlKXt0eXBlb2YgZT09XCJzdHJpbmdcIj95cih0LGUpOmU/KEllKHQsZS5sZW5ndGgpLHQud3JpdGUoZSkpOkllKHQsMCl9ZnVuY3Rpb24gRnQodCxlKXtpZih0eXBlb2YgZSE9XCJvYmplY3RcInx8ZS5sZW5ndGghPW51bGwpcmV0dXJue2xlbmd0aDoxLHdyaXRlKCl7QmQodCx7fSwwKX19O2xldCByPTA7ZnVuY3Rpb24gaShvLHMpe2xldCBhPWoucHJvcGVydGllc1R5cGVzW29dLHU9MDtzd2l0Y2goYSl7Y2FzZVwiYnl0ZVwiOntpZih0eXBlb2YgcyE9XCJib29sZWFuXCIpcmV0dXJuIHQuZGVzdHJveShuZXcgRXJyb3IoYEludmFsaWQgJHtvfTogJHtzfWApKSwhMTt1Kz0xKzE7YnJlYWt9Y2FzZVwiaW50OFwiOntpZih0eXBlb2YgcyE9XCJudW1iZXJcInx8czwwfHxzPjI1NSlyZXR1cm4gdC5kZXN0cm95KG5ldyBFcnJvcihgSW52YWxpZCAke299OiAke3N9YCkpLCExO3UrPTErMTticmVha31jYXNlXCJiaW5hcnlcIjp7aWYocyYmcz09PW51bGwpcmV0dXJuIHQuZGVzdHJveShuZXcgRXJyb3IoYEludmFsaWQgJHtvfTogJHtzfWApKSwhMTt1Kz0xK3EuYnl0ZUxlbmd0aChzKSsyO2JyZWFrfWNhc2VcImludDE2XCI6e2lmKHR5cGVvZiBzIT1cIm51bWJlclwifHxzPDB8fHM+NjU1MzUpcmV0dXJuIHQuZGVzdHJveShuZXcgRXJyb3IoYEludmFsaWQgJHtvfTogJHtzfWApKSwhMTt1Kz0xKzI7YnJlYWt9Y2FzZVwiaW50MzJcIjp7aWYodHlwZW9mIHMhPVwibnVtYmVyXCJ8fHM8MHx8cz40Mjk0OTY3Mjk1KXJldHVybiB0LmRlc3Ryb3kobmV3IEVycm9yKGBJbnZhbGlkICR7b306ICR7c31gKSksITE7dSs9MSs0O2JyZWFrfWNhc2VcInZhclwiOntpZih0eXBlb2YgcyE9XCJudW1iZXJcInx8czwwfHxzPjI2ODQzNTQ1NSlyZXR1cm4gdC5kZXN0cm95KG5ldyBFcnJvcihgSW52YWxpZCAke299OiAke3N9YCkpLCExO3UrPTErcS5ieXRlTGVuZ3RoKEhvKHMpKTticmVha31jYXNlXCJzdHJpbmdcIjp7aWYodHlwZW9mIHMhPVwic3RyaW5nXCIpcmV0dXJuIHQuZGVzdHJveShuZXcgRXJyb3IoYEludmFsaWQgJHtvfTogJHtzfWApKSwhMTt1Kz0xKzIrcS5ieXRlTGVuZ3RoKHMudG9TdHJpbmcoKSk7YnJlYWt9Y2FzZVwicGFpclwiOntpZih0eXBlb2YgcyE9XCJvYmplY3RcIilyZXR1cm4gdC5kZXN0cm95KG5ldyBFcnJvcihgSW52YWxpZCAke299OiAke3N9YCkpLCExO3UrPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHMpLnJlZHVjZSgoYyxoKT0+e2xldCBkPXNbaF07cmV0dXJuIEFycmF5LmlzQXJyYXkoZCk/Yys9ZC5yZWR1Y2UoKGcseSk9PihnKz0xKzIrcS5ieXRlTGVuZ3RoKGgudG9TdHJpbmcoKSkrMitxLmJ5dGVMZW5ndGgoeS50b1N0cmluZygpKSxnKSwwKTpjKz0xKzIrcS5ieXRlTGVuZ3RoKGgudG9TdHJpbmcoKSkrMitxLmJ5dGVMZW5ndGgoc1toXS50b1N0cmluZygpKSxjfSwwKTticmVha31kZWZhdWx0OnJldHVybiB0LmRlc3Ryb3kobmV3IEVycm9yKGBJbnZhbGlkIHByb3BlcnR5ICR7b306ICR7c31gKSksITF9cmV0dXJuIHV9aWYoZSlmb3IobGV0IG8gaW4gZSl7bGV0IHM9MCxhPTAsdT1lW29dO2lmKEFycmF5LmlzQXJyYXkodSkpZm9yKGxldCBjPTA7Yzx1Lmxlbmd0aDtjKyspe2lmKGE9aShvLHVbY10pLCFhKXJldHVybiExO3MrPWF9ZWxzZXtpZihhPWkobyx1KSwhYSlyZXR1cm4hMTtzPWF9aWYoIXMpcmV0dXJuITE7cis9c31yZXR1cm57bGVuZ3RoOnEuYnl0ZUxlbmd0aChIbyhyKSkrcix3cml0ZSgpe0JkKHQsZSxyKX19fWZ1bmN0aW9uIEVpKHQsZSxyLGkpe2xldCBuPVtcInJlYXNvblN0cmluZ1wiLFwidXNlclByb3BlcnRpZXNcIl0sbz1yJiZyLnByb3BlcnRpZXMmJnIucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZT9yLnByb3BlcnRpZXMubWF4aW11bVBhY2tldFNpemU6MCxzPUZ0KHQsZSk7aWYobylmb3IoO2krcy5sZW5ndGg+bzspe2xldCBhPW4uc2hpZnQoKTtpZihhJiZlW2FdKWRlbGV0ZSBlW2FdLHM9RnQodCxlKTtlbHNlIHJldHVybiExfXJldHVybiBzfWZ1bmN0aW9uIENkKHQsZSxyKXtzd2l0Y2goai5wcm9wZXJ0aWVzVHlwZXNbZV0pe2Nhc2VcImJ5dGVcIjp7dC53cml0ZShxLmZyb20oW2oucHJvcGVydGllc1tlXV0pKSx0LndyaXRlKHEuZnJvbShbK3JdKSk7YnJlYWt9Y2FzZVwiaW50OFwiOnt0LndyaXRlKHEuZnJvbShbai5wcm9wZXJ0aWVzW2VdXSkpLHQud3JpdGUocS5mcm9tKFtyXSkpO2JyZWFrfWNhc2VcImJpbmFyeVwiOnt0LndyaXRlKHEuZnJvbShbai5wcm9wZXJ0aWVzW2VdXSkpLEtyKHQscik7YnJlYWt9Y2FzZVwiaW50MTZcIjp7dC53cml0ZShxLmZyb20oW2oucHJvcGVydGllc1tlXV0pKSxJZSh0LHIpO2JyZWFrfWNhc2VcImludDMyXCI6e3Qud3JpdGUocS5mcm9tKFtqLnByb3BlcnRpZXNbZV1dKSksWm0odCxyKTticmVha31jYXNlXCJ2YXJcIjp7dC53cml0ZShxLmZyb20oW2oucHJvcGVydGllc1tlXV0pKSxEZSh0LHIpO2JyZWFrfWNhc2VcInN0cmluZ1wiOnt0LndyaXRlKHEuZnJvbShbai5wcm9wZXJ0aWVzW2VdXSkpLHlyKHQscik7YnJlYWt9Y2FzZVwicGFpclwiOntPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKS5mb3JFYWNoKG49PntsZXQgbz1yW25dO0FycmF5LmlzQXJyYXkobyk/by5mb3JFYWNoKHM9Pnt0LndyaXRlKHEuZnJvbShbai5wcm9wZXJ0aWVzW2VdXSkpLFJkKHQsbi50b1N0cmluZygpLHMudG9TdHJpbmcoKSl9KToodC53cml0ZShxLmZyb20oW2oucHJvcGVydGllc1tlXV0pKSxSZCh0LG4udG9TdHJpbmcoKSxvLnRvU3RyaW5nKCkpKX0pO2JyZWFrfWRlZmF1bHQ6cmV0dXJuIHQuZGVzdHJveShuZXcgRXJyb3IoYEludmFsaWQgcHJvcGVydHkgJHtlfSB2YWx1ZTogJHtyfWApKSwhMX19ZnVuY3Rpb24gQmQodCxlLHIpe0RlKHQscik7Zm9yKGxldCBpIGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsaSkmJmVbaV0hPT1udWxsKXtsZXQgbj1lW2ldO2lmKEFycmF5LmlzQXJyYXkobikpZm9yKGxldCBvPTA7bzxuLmxlbmd0aDtvKyspQ2QodCxpLG5bb10pO2Vsc2UgQ2QodCxpLG4pfX1mdW5jdGlvbiBrZCh0KXtyZXR1cm4gdD90IGluc3RhbmNlb2YgcT90Lmxlbmd0aDpxLmJ5dGVMZW5ndGgodCk6MH1mdW5jdGlvbiBQZCh0KXtyZXR1cm4gdHlwZW9mIHQ9PVwic3RyaW5nXCJ8fHQgaW5zdGFuY2VvZiBxfXhkLmV4cG9ydHM9T2R9KTt2YXIgVWQ9TSgoYk8sTGQpPT57digpO20oKTtfKCk7dmFyIGUxPXpvKCkse0V2ZW50RW1pdHRlcjp0MX09KGlyKCksWihycikpLHtCdWZmZXI6TWR9PSh3ZSgpLFoodmUpKTtmdW5jdGlvbiByMSh0LGUpe2xldCByPW5ldyBLbztyZXR1cm4gZTEodCxyLGUpLHIuY29uY2F0KCl9dmFyIEtvPWNsYXNzIGV4dGVuZHMgdDF7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuX2FycmF5PW5ldyBBcnJheSgyMCksdGhpcy5faT0wfXdyaXRlKGUpe3JldHVybiB0aGlzLl9hcnJheVt0aGlzLl9pKytdPWUsITB9Y29uY2F0KCl7bGV0IGU9MCxyPW5ldyBBcnJheSh0aGlzLl9hcnJheS5sZW5ndGgpLGk9dGhpcy5fYXJyYXksbj0wLG87Zm9yKG89MDtvPGkubGVuZ3RoJiZpW29dIT09dm9pZCAwO28rKyl0eXBlb2YgaVtvXSE9XCJzdHJpbmdcIj9yW29dPWlbb10ubGVuZ3RoOnJbb109TWQuYnl0ZUxlbmd0aChpW29dKSxlKz1yW29dO2xldCBzPU1kLmFsbG9jVW5zYWZlKGUpO2ZvcihvPTA7bzxpLmxlbmd0aCYmaVtvXSE9PXZvaWQgMDtvKyspdHlwZW9mIGlbb10hPVwic3RyaW5nXCI/KGlbb10uY29weShzLG4pLG4rPXJbb10pOihzLndyaXRlKGlbb10sbiksbis9cltvXSk7cmV0dXJuIHN9ZGVzdHJveShlKXtlJiZ0aGlzLmVtaXQoXCJlcnJvclwiLGUpfX07TGQuZXhwb3J0cz1yMX0pO3ZhciBOZD1NKFBuPT57digpO20oKTtfKCk7UG4ucGFyc2VyPW1kKCkucGFyc2VyO1BuLmdlbmVyYXRlPVVkKCk7UG4ud3JpdGVUb1N0cmVhbT16bygpfSk7dmFyIFlvPU0oUW89PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoUW8sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIEdvPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5uZXh0SWQ9TWF0aC5tYXgoMSxNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqNjU1MzUpKX1hbGxvY2F0ZSgpe2xldCBlPXRoaXMubmV4dElkKys7cmV0dXJuIHRoaXMubmV4dElkPT09NjU1MzYmJih0aGlzLm5leHRJZD0xKSxlfWdldExhc3RBbGxvY2F0ZWQoKXtyZXR1cm4gdGhpcy5uZXh0SWQ9PT0xPzY1NTM1OnRoaXMubmV4dElkLTF9cmVnaXN0ZXIoZSl7cmV0dXJuITB9ZGVhbGxvY2F0ZShlKXt9Y2xlYXIoKXt9fTtRby5kZWZhdWx0PUdvfSk7dmFyIERkPU0oKEtPLHFkKT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3FkLmV4cG9ydHM9aTE7ZnVuY3Rpb24gR3IodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBrP2suZnJvbSh0KTpuZXcgdC5jb25zdHJ1Y3Rvcih0LmJ1ZmZlci5zbGljZSgpLHQuYnl0ZU9mZnNldCx0Lmxlbmd0aCl9ZnVuY3Rpb24gaTEodCl7aWYodD10fHx7fSx0LmNpcmNsZXMpcmV0dXJuIG4xKHQpO3JldHVybiB0LnByb3RvP2k6cjtmdW5jdGlvbiBlKG4sbyl7Zm9yKHZhciBzPU9iamVjdC5rZXlzKG4pLGE9bmV3IEFycmF5KHMubGVuZ3RoKSx1PTA7dTxzLmxlbmd0aDt1Kyspe3ZhciBjPXNbdV0saD1uW2NdO3R5cGVvZiBoIT1cIm9iamVjdFwifHxoPT09bnVsbD9hW2NdPWg6aCBpbnN0YW5jZW9mIERhdGU/YVtjXT1uZXcgRGF0ZShoKTpBcnJheUJ1ZmZlci5pc1ZpZXcoaCk/YVtjXT1HcihoKTphW2NdPW8oaCl9cmV0dXJuIGF9ZnVuY3Rpb24gcihuKXtpZih0eXBlb2YgbiE9XCJvYmplY3RcInx8bj09PW51bGwpcmV0dXJuIG47aWYobiBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIG5ldyBEYXRlKG4pO2lmKEFycmF5LmlzQXJyYXkobikpcmV0dXJuIGUobixyKTtpZihuIGluc3RhbmNlb2YgTWFwKXJldHVybiBuZXcgTWFwKGUoQXJyYXkuZnJvbShuKSxyKSk7aWYobiBpbnN0YW5jZW9mIFNldClyZXR1cm4gbmV3IFNldChlKEFycmF5LmZyb20obikscikpO3ZhciBvPXt9O2Zvcih2YXIgcyBpbiBuKWlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4scykhPT0hMSl7dmFyIGE9bltzXTt0eXBlb2YgYSE9XCJvYmplY3RcInx8YT09PW51bGw/b1tzXT1hOmEgaW5zdGFuY2VvZiBEYXRlP29bc109bmV3IERhdGUoYSk6YSBpbnN0YW5jZW9mIE1hcD9vW3NdPW5ldyBNYXAoZShBcnJheS5mcm9tKGEpLHIpKTphIGluc3RhbmNlb2YgU2V0P29bc109bmV3IFNldChlKEFycmF5LmZyb20oYSkscikpOkFycmF5QnVmZmVyLmlzVmlldyhhKT9vW3NdPUdyKGEpOm9bc109cihhKX1yZXR1cm4gb31mdW5jdGlvbiBpKG4pe2lmKHR5cGVvZiBuIT1cIm9iamVjdFwifHxuPT09bnVsbClyZXR1cm4gbjtpZihuIGluc3RhbmNlb2YgRGF0ZSlyZXR1cm4gbmV3IERhdGUobik7aWYoQXJyYXkuaXNBcnJheShuKSlyZXR1cm4gZShuLGkpO2lmKG4gaW5zdGFuY2VvZiBNYXApcmV0dXJuIG5ldyBNYXAoZShBcnJheS5mcm9tKG4pLGkpKTtpZihuIGluc3RhbmNlb2YgU2V0KXJldHVybiBuZXcgU2V0KGUoQXJyYXkuZnJvbShuKSxpKSk7dmFyIG89e307Zm9yKHZhciBzIGluIG4pe3ZhciBhPW5bc107dHlwZW9mIGEhPVwib2JqZWN0XCJ8fGE9PT1udWxsP29bc109YTphIGluc3RhbmNlb2YgRGF0ZT9vW3NdPW5ldyBEYXRlKGEpOmEgaW5zdGFuY2VvZiBNYXA/b1tzXT1uZXcgTWFwKGUoQXJyYXkuZnJvbShhKSxpKSk6YSBpbnN0YW5jZW9mIFNldD9vW3NdPW5ldyBTZXQoZShBcnJheS5mcm9tKGEpLGkpKTpBcnJheUJ1ZmZlci5pc1ZpZXcoYSk/b1tzXT1HcihhKTpvW3NdPWkoYSl9cmV0dXJuIG99fWZ1bmN0aW9uIG4xKHQpe3ZhciBlPVtdLHI9W107cmV0dXJuIHQucHJvdG8/bzpuO2Z1bmN0aW9uIGkocyxhKXtmb3IodmFyIHU9T2JqZWN0LmtleXMocyksYz1uZXcgQXJyYXkodS5sZW5ndGgpLGg9MDtoPHUubGVuZ3RoO2grKyl7dmFyIGQ9dVtoXSxnPXNbZF07aWYodHlwZW9mIGchPVwib2JqZWN0XCJ8fGc9PT1udWxsKWNbZF09ZztlbHNlIGlmKGcgaW5zdGFuY2VvZiBEYXRlKWNbZF09bmV3IERhdGUoZyk7ZWxzZSBpZihBcnJheUJ1ZmZlci5pc1ZpZXcoZykpY1tkXT1HcihnKTtlbHNle3ZhciB5PWUuaW5kZXhPZihnKTt5IT09LTE/Y1tkXT1yW3ldOmNbZF09YShnKX19cmV0dXJuIGN9ZnVuY3Rpb24gbihzKXtpZih0eXBlb2YgcyE9XCJvYmplY3RcInx8cz09PW51bGwpcmV0dXJuIHM7aWYocyBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIG5ldyBEYXRlKHMpO2lmKEFycmF5LmlzQXJyYXkocykpcmV0dXJuIGkocyxuKTtpZihzIGluc3RhbmNlb2YgTWFwKXJldHVybiBuZXcgTWFwKGkoQXJyYXkuZnJvbShzKSxuKSk7aWYocyBpbnN0YW5jZW9mIFNldClyZXR1cm4gbmV3IFNldChpKEFycmF5LmZyb20ocyksbikpO3ZhciBhPXt9O2UucHVzaChzKSxyLnB1c2goYSk7Zm9yKHZhciB1IGluIHMpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocyx1KSE9PSExKXt2YXIgYz1zW3VdO2lmKHR5cGVvZiBjIT1cIm9iamVjdFwifHxjPT09bnVsbClhW3VdPWM7ZWxzZSBpZihjIGluc3RhbmNlb2YgRGF0ZSlhW3VdPW5ldyBEYXRlKGMpO2Vsc2UgaWYoYyBpbnN0YW5jZW9mIE1hcClhW3VdPW5ldyBNYXAoaShBcnJheS5mcm9tKGMpLG4pKTtlbHNlIGlmKGMgaW5zdGFuY2VvZiBTZXQpYVt1XT1uZXcgU2V0KGkoQXJyYXkuZnJvbShjKSxuKSk7ZWxzZSBpZihBcnJheUJ1ZmZlci5pc1ZpZXcoYykpYVt1XT1HcihjKTtlbHNle3ZhciBoPWUuaW5kZXhPZihjKTtoIT09LTE/YVt1XT1yW2hdOmFbdV09bihjKX19cmV0dXJuIGUucG9wKCksci5wb3AoKSxhfWZ1bmN0aW9uIG8ocyl7aWYodHlwZW9mIHMhPVwib2JqZWN0XCJ8fHM9PT1udWxsKXJldHVybiBzO2lmKHMgaW5zdGFuY2VvZiBEYXRlKXJldHVybiBuZXcgRGF0ZShzKTtpZihBcnJheS5pc0FycmF5KHMpKXJldHVybiBpKHMsbyk7aWYocyBpbnN0YW5jZW9mIE1hcClyZXR1cm4gbmV3IE1hcChpKEFycmF5LmZyb20ocyksbykpO2lmKHMgaW5zdGFuY2VvZiBTZXQpcmV0dXJuIG5ldyBTZXQoaShBcnJheS5mcm9tKHMpLG8pKTt2YXIgYT17fTtlLnB1c2gocyksci5wdXNoKGEpO2Zvcih2YXIgdSBpbiBzKXt2YXIgYz1zW3VdO2lmKHR5cGVvZiBjIT1cIm9iamVjdFwifHxjPT09bnVsbClhW3VdPWM7ZWxzZSBpZihjIGluc3RhbmNlb2YgRGF0ZSlhW3VdPW5ldyBEYXRlKGMpO2Vsc2UgaWYoYyBpbnN0YW5jZW9mIE1hcClhW3VdPW5ldyBNYXAoaShBcnJheS5mcm9tKGMpLG8pKTtlbHNlIGlmKGMgaW5zdGFuY2VvZiBTZXQpYVt1XT1uZXcgU2V0KGkoQXJyYXkuZnJvbShjKSxvKSk7ZWxzZSBpZihBcnJheUJ1ZmZlci5pc1ZpZXcoYykpYVt1XT1HcihjKTtlbHNle3ZhciBoPWUuaW5kZXhPZihjKTtoIT09LTE/YVt1XT1yW2hdOmFbdV09byhjKX19cmV0dXJuIGUucG9wKCksci5wb3AoKSxhfX19KTt2YXIgRmQ9TSgoaWssamQpPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7amQuZXhwb3J0cz1EZCgpKCl9KTt2YXIgJGQ9TShRcj0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShRcixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtRci52YWxpZGF0ZVRvcGljcz1Rci52YWxpZGF0ZVRvcGljPXZvaWQgMDtmdW5jdGlvbiBXZCh0KXtsZXQgZT10LnNwbGl0KFwiL1wiKTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKylpZihlW3JdIT09XCIrXCIpe2lmKGVbcl09PT1cIiNcIilyZXR1cm4gcj09PWUubGVuZ3RoLTE7aWYoZVtyXS5pbmRleE9mKFwiK1wiKSE9PS0xfHxlW3JdLmluZGV4T2YoXCIjXCIpIT09LTEpcmV0dXJuITF9cmV0dXJuITB9UXIudmFsaWRhdGVUb3BpYz1XZDtmdW5jdGlvbiBzMSh0KXtpZih0Lmxlbmd0aD09PTApcmV0dXJuXCJlbXB0eV90b3BpY19saXN0XCI7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoIVdkKHRbZV0pKXJldHVybiB0W2VdO3JldHVybiBudWxsfVFyLnZhbGlkYXRlVG9waWNzPXMxfSk7dmFyIFpvPU0oWG89PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoWG8sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG8xPUR0KCksYTE9e29iamVjdE1vZGU6ITB9LGwxPXtjbGVhbjohMH0sSm89Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5vcHRpb25zPWV8fHt9LHRoaXMub3B0aW9ucz1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbDEpLGUpLHRoaXMuX2luZmxpZ2h0cz1uZXcgTWFwfXB1dChlLHIpe3JldHVybiB0aGlzLl9pbmZsaWdodHMuc2V0KGUubWVzc2FnZUlkLGUpLHImJnIoKSx0aGlzfWNyZWF0ZVN0cmVhbSgpe2xldCBlPW5ldyBvMS5SZWFkYWJsZShhMSkscj1bXSxpPSExLG49MDtyZXR1cm4gdGhpcy5faW5mbGlnaHRzLmZvckVhY2goKG8scyk9PntyLnB1c2gobyl9KSxlLl9yZWFkPSgpPT57IWkmJm48ci5sZW5ndGg/ZS5wdXNoKHJbbisrXSk6ZS5wdXNoKG51bGwpfSxlLmRlc3Ryb3k9bz0+e2lmKCFpKXJldHVybiBpPSEwLHNldFRpbWVvdXQoKCk9PntlLmVtaXQoXCJjbG9zZVwiKX0sMCksZX0sZX1kZWwoZSxyKXtsZXQgaT10aGlzLl9pbmZsaWdodHMuZ2V0KGUubWVzc2FnZUlkKTtyZXR1cm4gaT8odGhpcy5faW5mbGlnaHRzLmRlbGV0ZShlLm1lc3NhZ2VJZCkscihudWxsLGkpKTpyJiZyKG5ldyBFcnJvcihcIm1pc3NpbmcgcGFja2V0XCIpKSx0aGlzfWdldChlLHIpe2xldCBpPXRoaXMuX2luZmxpZ2h0cy5nZXQoZS5tZXNzYWdlSWQpO3JldHVybiBpP3IobnVsbCxpKTpyJiZyKG5ldyBFcnJvcihcIm1pc3NpbmcgcGFja2V0XCIpKSx0aGlzfWNsb3NlKGUpe3RoaXMub3B0aW9ucy5jbGVhbiYmKHRoaXMuX2luZmxpZ2h0cz1udWxsKSxlJiZlKCl9fTtYby5kZWZhdWx0PUpvfSk7dmFyIFZkPU0oZWE9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZWEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIEhkPVswLDE2LDEyOCwxMzEsMTM1LDE0NCwxNDUsMTUxLDE1M10sdTE9KHQsZSxyKT0+e3QubG9nKFwiaGFuZGxlUHVibGlzaDogcGFja2V0ICVvXCIsZSkscj10eXBlb2YgcjxcInVcIj9yOnQubm9vcDtsZXQgaT1lLnRvcGljLnRvU3RyaW5nKCksbj1lLnBheWxvYWQse3FvczpvfT1lLHttZXNzYWdlSWQ6c309ZSx7b3B0aW9uczphfT10O2lmKHQub3B0aW9ucy5wcm90b2NvbFZlcnNpb249PT01KXtsZXQgdTtpZihlLnByb3BlcnRpZXMmJih1PWUucHJvcGVydGllcy50b3BpY0FsaWFzKSx0eXBlb2YgdTxcInVcIilpZihpLmxlbmd0aD09PTApaWYodT4wJiZ1PD02NTUzNSl7bGV0IGM9dC50b3BpY0FsaWFzUmVjdi5nZXRUb3BpY0J5QWxpYXModSk7aWYoYylpPWMsdC5sb2coXCJoYW5kbGVQdWJsaXNoIDo6IHRvcGljIGNvbXBsZW1lbnRlZCBieSBhbGlhcy4gdG9waWM6ICVzIC0gYWxpYXM6ICVkXCIsaSx1KTtlbHNle3QubG9nKFwiaGFuZGxlUHVibGlzaCA6OiB1bnJlZ2lzdGVyZWQgdG9waWMgYWxpYXMuIGFsaWFzOiAlZFwiLHUpLHQuZW1pdChcImVycm9yXCIsbmV3IEVycm9yKFwiUmVjZWl2ZWQgdW5yZWdpc3RlcmVkIFRvcGljIEFsaWFzXCIpKTtyZXR1cm59fWVsc2V7dC5sb2coXCJoYW5kbGVQdWJsaXNoIDo6IHRvcGljIGFsaWFzIG91dCBvZiByYW5nZS4gYWxpYXM6ICVkXCIsdSksdC5lbWl0KFwiZXJyb3JcIixuZXcgRXJyb3IoXCJSZWNlaXZlZCBUb3BpYyBBbGlhcyBpcyBvdXQgb2YgcmFuZ2VcIikpO3JldHVybn1lbHNlIGlmKHQudG9waWNBbGlhc1JlY3YucHV0KGksdSkpdC5sb2coXCJoYW5kbGVQdWJsaXNoIDo6IHJlZ2lzdGVyZWQgdG9waWM6ICVzIC0gYWxpYXM6ICVkXCIsaSx1KTtlbHNle3QubG9nKFwiaGFuZGxlUHVibGlzaCA6OiB0b3BpYyBhbGlhcyBvdXQgb2YgcmFuZ2UuIGFsaWFzOiAlZFwiLHUpLHQuZW1pdChcImVycm9yXCIsbmV3IEVycm9yKFwiUmVjZWl2ZWQgVG9waWMgQWxpYXMgaXMgb3V0IG9mIHJhbmdlXCIpKTtyZXR1cm59fXN3aXRjaCh0LmxvZyhcImhhbmRsZVB1Ymxpc2g6IHFvcyAlZFwiLG8pLG8pe2Nhc2UgMjp7YS5jdXN0b21IYW5kbGVBY2tzKGksbixlLCh1LGMpPT57aWYodHlwZW9mIHU9PVwibnVtYmVyXCImJihjPXUsdT1udWxsKSx1KXJldHVybiB0LmVtaXQoXCJlcnJvclwiLHUpO2lmKEhkLmluZGV4T2YoYyk9PT0tMSlyZXR1cm4gdC5lbWl0KFwiZXJyb3JcIixuZXcgRXJyb3IoXCJXcm9uZyByZWFzb24gY29kZSBmb3IgcHVicmVjXCIpKTtjP3QuX3NlbmRQYWNrZXQoe2NtZDpcInB1YnJlY1wiLG1lc3NhZ2VJZDpzLHJlYXNvbkNvZGU6Y30scik6dC5pbmNvbWluZ1N0b3JlLnB1dChlLCgpPT57dC5fc2VuZFBhY2tldCh7Y21kOlwicHVicmVjXCIsbWVzc2FnZUlkOnN9LHIpfSl9KTticmVha31jYXNlIDE6e2EuY3VzdG9tSGFuZGxlQWNrcyhpLG4sZSwodSxjKT0+e2lmKHR5cGVvZiB1PT1cIm51bWJlclwiJiYoYz11LHU9bnVsbCksdSlyZXR1cm4gdC5lbWl0KFwiZXJyb3JcIix1KTtpZihIZC5pbmRleE9mKGMpPT09LTEpcmV0dXJuIHQuZW1pdChcImVycm9yXCIsbmV3IEVycm9yKFwiV3JvbmcgcmVhc29uIGNvZGUgZm9yIHB1YmFja1wiKSk7Y3x8dC5lbWl0KFwibWVzc2FnZVwiLGksbixlKSx0LmhhbmRsZU1lc3NhZ2UoZSxoPT57aWYoaClyZXR1cm4gciYmcihoKTt0Ll9zZW5kUGFja2V0KHtjbWQ6XCJwdWJhY2tcIixtZXNzYWdlSWQ6cyxyZWFzb25Db2RlOmN9LHIpfSl9KTticmVha31jYXNlIDA6dC5lbWl0KFwibWVzc2FnZVwiLGksbixlKSx0LmhhbmRsZU1lc3NhZ2UoZSxyKTticmVhaztkZWZhdWx0OnQubG9nKFwiaGFuZGxlUHVibGlzaDogdW5rbm93biBRb1MuIERvaW5nIG5vdGhpbmcuXCIpO2JyZWFrfX07ZWEuZGVmYXVsdD11MX0pO3ZhciBZcj1NKFd0PT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KFd0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO1d0Lm5leHRUaWNrPVd0LmFwcGx5TWl4aW49V3QuRXJyb3JXaXRoUmVhc29uQ29kZT12b2lkIDA7dmFyIHRhPWNsYXNzIHQgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihlLHIpe3N1cGVyKGUpLHRoaXMuY29kZT1yLE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLHQucHJvdG90eXBlKSxPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykubmFtZT1cIkVycm9yV2l0aFJlYXNvbkNvZGVcIn19O1d0LkVycm9yV2l0aFJlYXNvbkNvZGU9dGE7ZnVuY3Rpb24gZjEodCxlLHI9ITEpe3ZhciBpO2xldCBuPVtlXTtmb3IoOzspe2xldCBvPW5bMF0scz1PYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7aWYocz8ucHJvdG90eXBlKW4udW5zaGlmdChzKTtlbHNlIGJyZWFrfWZvcihsZXQgbyBvZiBuKWZvcihsZXQgcyBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvLnByb3RvdHlwZSkpKHJ8fHMhPT1cImNvbnN0cnVjdG9yXCIpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUscywoaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8ucHJvdG90eXBlLHMpKSE9PW51bGwmJmkhPT12b2lkIDA/aTpPYmplY3QuY3JlYXRlKG51bGwpKX1XdC5hcHBseU1peGluPWYxO1d0Lm5leHRUaWNrPVA/UC5uZXh0VGljazp0PT57c2V0VGltZW91dCh0LDApfX0pO3ZhciBTaT1NKGJyPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGJyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2JyLlJlYXNvbkNvZGVzPXZvaWQgMDtici5SZWFzb25Db2Rlcz17MDpcIlwiLDE6XCJVbmFjY2VwdGFibGUgcHJvdG9jb2wgdmVyc2lvblwiLDI6XCJJZGVudGlmaWVyIHJlamVjdGVkXCIsMzpcIlNlcnZlciB1bmF2YWlsYWJsZVwiLDQ6XCJCYWQgdXNlcm5hbWUgb3IgcGFzc3dvcmRcIiw1OlwiTm90IGF1dGhvcml6ZWRcIiwxNjpcIk5vIG1hdGNoaW5nIHN1YnNjcmliZXJzXCIsMTc6XCJObyBzdWJzY3JpcHRpb24gZXhpc3RlZFwiLDEyODpcIlVuc3BlY2lmaWVkIGVycm9yXCIsMTI5OlwiTWFsZm9ybWVkIFBhY2tldFwiLDEzMDpcIlByb3RvY29sIEVycm9yXCIsMTMxOlwiSW1wbGVtZW50YXRpb24gc3BlY2lmaWMgZXJyb3JcIiwxMzI6XCJVbnN1cHBvcnRlZCBQcm90b2NvbCBWZXJzaW9uXCIsMTMzOlwiQ2xpZW50IElkZW50aWZpZXIgbm90IHZhbGlkXCIsMTM0OlwiQmFkIFVzZXIgTmFtZSBvciBQYXNzd29yZFwiLDEzNTpcIk5vdCBhdXRob3JpemVkXCIsMTM2OlwiU2VydmVyIHVuYXZhaWxhYmxlXCIsMTM3OlwiU2VydmVyIGJ1c3lcIiwxMzg6XCJCYW5uZWRcIiwxMzk6XCJTZXJ2ZXIgc2h1dHRpbmcgZG93blwiLDE0MDpcIkJhZCBhdXRoZW50aWNhdGlvbiBtZXRob2RcIiwxNDE6XCJLZWVwIEFsaXZlIHRpbWVvdXRcIiwxNDI6XCJTZXNzaW9uIHRha2VuIG92ZXJcIiwxNDM6XCJUb3BpYyBGaWx0ZXIgaW52YWxpZFwiLDE0NDpcIlRvcGljIE5hbWUgaW52YWxpZFwiLDE0NTpcIlBhY2tldCBpZGVudGlmaWVyIGluIHVzZVwiLDE0NjpcIlBhY2tldCBJZGVudGlmaWVyIG5vdCBmb3VuZFwiLDE0NzpcIlJlY2VpdmUgTWF4aW11bSBleGNlZWRlZFwiLDE0ODpcIlRvcGljIEFsaWFzIGludmFsaWRcIiwxNDk6XCJQYWNrZXQgdG9vIGxhcmdlXCIsMTUwOlwiTWVzc2FnZSByYXRlIHRvbyBoaWdoXCIsMTUxOlwiUXVvdGEgZXhjZWVkZWRcIiwxNTI6XCJBZG1pbmlzdHJhdGl2ZSBhY3Rpb25cIiwxNTM6XCJQYXlsb2FkIGZvcm1hdCBpbnZhbGlkXCIsMTU0OlwiUmV0YWluIG5vdCBzdXBwb3J0ZWRcIiwxNTU6XCJRb1Mgbm90IHN1cHBvcnRlZFwiLDE1NjpcIlVzZSBhbm90aGVyIHNlcnZlclwiLDE1NzpcIlNlcnZlciBtb3ZlZFwiLDE1ODpcIlNoYXJlZCBTdWJzY3JpcHRpb25zIG5vdCBzdXBwb3J0ZWRcIiwxNTk6XCJDb25uZWN0aW9uIHJhdGUgZXhjZWVkZWRcIiwxNjA6XCJNYXhpbXVtIGNvbm5lY3QgdGltZVwiLDE2MTpcIlN1YnNjcmlwdGlvbiBJZGVudGlmaWVycyBub3Qgc3VwcG9ydGVkXCIsMTYyOlwiV2lsZGNhcmQgU3Vic2NyaXB0aW9ucyBub3Qgc3VwcG9ydGVkXCJ9O3ZhciBjMT0odCxlKT0+e2xldHttZXNzYWdlSWQ6cn09ZSxpPWUuY21kLG49bnVsbCxvPXQub3V0Z29pbmdbcl0/dC5vdXRnb2luZ1tyXS5jYjpudWxsLHM7aWYoIW8pe3QubG9nKFwiX2hhbmRsZUFjayA6OiBTZXJ2ZXIgc2VudCBhbiBhY2sgaW4gZXJyb3IuIElnbm9yaW5nLlwiKTtyZXR1cm59c3dpdGNoKHQubG9nKFwiX2hhbmRsZUFjayA6OiBwYWNrZXQgdHlwZVwiLGkpLGkpe2Nhc2VcInB1YmNvbXBcIjpjYXNlXCJwdWJhY2tcIjp7bGV0IGE9ZS5yZWFzb25Db2RlO2EmJmE+MCYmYSE9PTE2PyhzPW5ldyBFcnJvcihgUHVibGlzaCBlcnJvcjogJHtici5SZWFzb25Db2Rlc1thXX1gKSxzLmNvZGU9YSx0Ll9yZW1vdmVPdXRnb2luZ0FuZFN0b3JlTWVzc2FnZShyLCgpPT57byhzLGUpfSkpOnQuX3JlbW92ZU91dGdvaW5nQW5kU3RvcmVNZXNzYWdlKHIsbyk7YnJlYWt9Y2FzZVwicHVicmVjXCI6e249e2NtZDpcInB1YnJlbFwiLHFvczoyLG1lc3NhZ2VJZDpyfTtsZXQgYT1lLnJlYXNvbkNvZGU7YSYmYT4wJiZhIT09MTY/KHM9bmV3IEVycm9yKGBQdWJsaXNoIGVycm9yOiAke2JyLlJlYXNvbkNvZGVzW2FdfWApLHMuY29kZT1hLHQuX3JlbW92ZU91dGdvaW5nQW5kU3RvcmVNZXNzYWdlKHIsKCk9PntvKHMsZSl9KSk6dC5fc2VuZFBhY2tldChuKTticmVha31jYXNlXCJzdWJhY2tcIjp7ZGVsZXRlIHQub3V0Z29pbmdbcl0sdC5tZXNzYWdlSWRQcm92aWRlci5kZWFsbG9jYXRlKHIpO2xldCBhPWUuZ3JhbnRlZDtmb3IobGV0IHU9MDt1PGEubGVuZ3RoO3UrKylpZihhW3VdJjEyOCl7bGV0IGM9dC5tZXNzYWdlSWRUb1RvcGljW3JdO2MmJmMuZm9yRWFjaChoPT57ZGVsZXRlIHQuX3Jlc3Vic2NyaWJlVG9waWNzW2hdfSl9ZGVsZXRlIHQubWVzc2FnZUlkVG9Ub3BpY1tyXSx0Ll9pbnZva2VTdG9yZVByb2Nlc3NpbmdRdWV1ZSgpLG8obnVsbCxlKTticmVha31jYXNlXCJ1bnN1YmFja1wiOntkZWxldGUgdC5vdXRnb2luZ1tyXSx0Lm1lc3NhZ2VJZFByb3ZpZGVyLmRlYWxsb2NhdGUociksdC5faW52b2tlU3RvcmVQcm9jZXNzaW5nUXVldWUoKSxvKG51bGwpO2JyZWFrfWRlZmF1bHQ6dC5lbWl0KFwiZXJyb3JcIixuZXcgRXJyb3IoXCJ1bnJlY29nbml6ZWQgcGFja2V0IHR5cGVcIikpfXQuZGlzY29ubmVjdGluZyYmT2JqZWN0LmtleXModC5vdXRnb2luZykubGVuZ3RoPT09MCYmdC5lbWl0KFwib3V0Z29pbmdFbXB0eVwiKX07YnIuZGVmYXVsdD1jMX0pO3ZhciBLZD1NKHJhPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHJhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB6ZD1ZcigpLGgxPVNpKCksZDE9KHQsZSk9PntsZXR7b3B0aW9uczpyfT10LGk9ci5wcm90b2NvbFZlcnNpb24sbj1pPT09NT9lLnJlYXNvbkNvZGU6ZS5yZXR1cm5Db2RlO2lmKGkhPT01KXtsZXQgbz1uZXcgemQuRXJyb3JXaXRoUmVhc29uQ29kZShgUHJvdG9jb2wgZXJyb3I6IEF1dGggcGFja2V0cyBhcmUgb25seSBzdXBwb3J0ZWQgaW4gTVFUVCA1LiBZb3VyIHZlcnNpb246JHtpfWAsbik7dC5lbWl0KFwiZXJyb3JcIixvKTtyZXR1cm59dC5oYW5kbGVBdXRoKGUsKG8scyk9PntpZihvKXt0LmVtaXQoXCJlcnJvclwiLG8pO3JldHVybn1pZihuPT09MjQpdC5yZWNvbm5lY3Rpbmc9ITEsdC5fc2VuZFBhY2tldChzKTtlbHNle2xldCBhPW5ldyB6ZC5FcnJvcldpdGhSZWFzb25Db2RlKGBDb25uZWN0aW9uIHJlZnVzZWQ6ICR7aDEuUmVhc29uQ29kZXNbbl19YCxuKTt0LmVtaXQoXCJlcnJvclwiLGEpfX0pfTtyYS5kZWZhdWx0PWQxfSk7dmFyIFhkPU0oa249PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoa24sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7a24uTFJVQ2FjaGU9dm9pZCAwO3ZhciBBaT10eXBlb2YgcGVyZm9ybWFuY2U9PVwib2JqZWN0XCImJnBlcmZvcm1hbmNlJiZ0eXBlb2YgcGVyZm9ybWFuY2Uubm93PT1cImZ1bmN0aW9uXCI/cGVyZm9ybWFuY2U6RGF0ZSxRZD1uZXcgU2V0LGlhPXR5cGVvZiBQPT1cIm9iamVjdFwiJiZQP1A6e30sWWQ9KHQsZSxyLGkpPT57dHlwZW9mIGlhLmVtaXRXYXJuaW5nPT1cImZ1bmN0aW9uXCI/aWEuZW1pdFdhcm5pbmcodCxlLHIsaSk6Y29uc29sZS5lcnJvcihgWyR7cn1dICR7ZX06ICR7dH1gKX0sT249Z2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIsR2Q9Z2xvYmFsVGhpcy5BYm9ydFNpZ25hbDtpZih0eXBlb2YgT24+XCJ1XCIpe0dkPWNsYXNze29uYWJvcnQ7X29uYWJvcnQ9W107cmVhc29uO2Fib3J0ZWQ9ITE7YWRkRXZlbnRMaXN0ZW5lcihpLG4pe3RoaXMuX29uYWJvcnQucHVzaChuKX19LE9uPWNsYXNze2NvbnN0cnVjdG9yKCl7ZSgpfXNpZ25hbD1uZXcgR2Q7YWJvcnQoaSl7aWYoIXRoaXMuc2lnbmFsLmFib3J0ZWQpe3RoaXMuc2lnbmFsLnJlYXNvbj1pLHRoaXMuc2lnbmFsLmFib3J0ZWQ9ITA7Zm9yKGxldCBuIG9mIHRoaXMuc2lnbmFsLl9vbmFib3J0KW4oaSk7dGhpcy5zaWduYWwub25hYm9ydD8uKGkpfX19O2xldCB0PWlhLmVudj8uTFJVX0NBQ0hFX0lHTk9SRV9BQ19XQVJOSU5HIT09XCIxXCIsZT0oKT0+e3QmJih0PSExLFlkKFwiQWJvcnRDb250cm9sbGVyIGlzIG5vdCBkZWZpbmVkLiBJZiB1c2luZyBscnUtY2FjaGUgaW4gbm9kZSAxNCwgbG9hZCBhbiBBYm9ydENvbnRyb2xsZXIgcG9seWZpbGwgZnJvbSB0aGUgYG5vZGUtYWJvcnQtY29udHJvbGxlcmAgcGFja2FnZS4gQSBtaW5pbWFsIHBvbHlmaWxsIGlzIHByb3ZpZGVkIGZvciB1c2UgYnkgTFJVQ2FjaGUuZmV0Y2goKSwgYnV0IGl0IHNob3VsZCBub3QgYmUgcmVsaWVkIHVwb24gaW4gb3RoZXIgY29udGV4dHMgKGVnLCBwYXNzaW5nIGl0IHRvIG90aGVyIEFQSXMgdGhhdCB1c2UgQWJvcnRDb250cm9sbGVyL0Fib3J0U2lnbmFsIG1pZ2h0IGhhdmUgdW5kZXNpcmFibGUgZWZmZWN0cykuIFlvdSBtYXkgZGlzYWJsZSB0aGlzIHdpdGggTFJVX0NBQ0hFX0lHTk9SRV9BQ19XQVJOSU5HPTEgaW4gdGhlIGVudi5cIixcIk5PX0FCT1JUX0NPTlRST0xMRVJcIixcIkVOT1RTVVBcIixlKSl9fXZhciBwMT10PT4hUWQuaGFzKHQpLEV4PVN5bWJvbChcInR5cGVcIiksJHQ9dD0+dCYmdD09PU1hdGguZmxvb3IodCkmJnQ+MCYmaXNGaW5pdGUodCksSmQ9dD0+JHQodCk/dDw9TWF0aC5wb3coMiw4KT9VaW50OEFycmF5OnQ8PU1hdGgucG93KDIsMTYpP1VpbnQxNkFycmF5OnQ8PU1hdGgucG93KDIsMzIpP1VpbnQzMkFycmF5OnQ8PU51bWJlci5NQVhfU0FGRV9JTlRFR0VSP0pyOm51bGw6bnVsbCxKcj1jbGFzcyBleHRlbmRzIEFycmF5e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuZmlsbCgwKX19LG5hPWNsYXNzIHR7aGVhcDtsZW5ndGg7c3RhdGljI2w9ITE7c3RhdGljIGNyZWF0ZShlKXtsZXQgcj1KZChlKTtpZighcilyZXR1cm5bXTt0LiNsPSEwO2xldCBpPW5ldyB0KGUscik7cmV0dXJuIHQuI2w9ITEsaX1jb25zdHJ1Y3RvcihlLHIpe2lmKCF0LiNsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnN0YW50aWF0ZSBTdGFjayB1c2luZyBTdGFjay5jcmVhdGUobilcIik7dGhpcy5oZWFwPW5ldyByKGUpLHRoaXMubGVuZ3RoPTB9cHVzaChlKXt0aGlzLmhlYXBbdGhpcy5sZW5ndGgrK109ZX1wb3AoKXtyZXR1cm4gdGhpcy5oZWFwWy0tdGhpcy5sZW5ndGhdfX0sc2E9Y2xhc3MgdHsjbDsjYzsjcDsjZzsjQjt0dGw7dHRsUmVzb2x1dGlvbjt0dGxBdXRvcHVyZ2U7dXBkYXRlQWdlT25HZXQ7dXBkYXRlQWdlT25IYXM7YWxsb3dTdGFsZTtub0Rpc3Bvc2VPblNldDtub1VwZGF0ZVRUTDttYXhFbnRyeVNpemU7c2l6ZUNhbGN1bGF0aW9uO25vRGVsZXRlT25GZXRjaFJlamVjdGlvbjtub0RlbGV0ZU9uU3RhbGVHZXQ7YWxsb3dTdGFsZU9uRmV0Y2hBYm9ydDthbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbjtpZ25vcmVGZXRjaEFib3J0OyNpOyN5OyNuOyNyOyNlOyN1OyNoOyNhOyNzOyNiOyNvOyNFOyNTOyN3OyNfOyNJOyNmO3N0YXRpYyB1bnNhZmVFeHBvc2VJbnRlcm5hbHMoZSl7cmV0dXJue3N0YXJ0czplLiNTLHR0bHM6ZS4jdyxzaXplczplLiNFLGtleU1hcDplLiNuLGtleUxpc3Q6ZS4jcix2YWxMaXN0OmUuI2UsbmV4dDplLiN1LHByZXY6ZS4jaCxnZXQgaGVhZCgpe3JldHVybiBlLiNhfSxnZXQgdGFpbCgpe3JldHVybiBlLiNzfSxmcmVlOmUuI2IsaXNCYWNrZ3JvdW5kRmV0Y2g6cj0+ZS4jdChyKSxiYWNrZ3JvdW5kRmV0Y2g6KHIsaSxuLG8pPT5lLiNrKHIsaSxuLG8pLG1vdmVUb1RhaWw6cj0+ZS4jQyhyKSxpbmRleGVzOnI9PmUuI20ocikscmluZGV4ZXM6cj0+ZS4jdihyKSxpc1N0YWxlOnI9PmUuI2Qocil9fWdldCBtYXgoKXtyZXR1cm4gdGhpcy4jbH1nZXQgbWF4U2l6ZSgpe3JldHVybiB0aGlzLiNjfWdldCBjYWxjdWxhdGVkU2l6ZSgpe3JldHVybiB0aGlzLiN5fWdldCBzaXplKCl7cmV0dXJuIHRoaXMuI2l9Z2V0IGZldGNoTWV0aG9kKCl7cmV0dXJuIHRoaXMuI0J9Z2V0IGRpc3Bvc2UoKXtyZXR1cm4gdGhpcy4jcH1nZXQgZGlzcG9zZUFmdGVyKCl7cmV0dXJuIHRoaXMuI2d9Y29uc3RydWN0b3IoZSl7bGV0e21heDpyPTAsdHRsOmksdHRsUmVzb2x1dGlvbjpuPTEsdHRsQXV0b3B1cmdlOm8sdXBkYXRlQWdlT25HZXQ6cyx1cGRhdGVBZ2VPbkhhczphLGFsbG93U3RhbGU6dSxkaXNwb3NlOmMsZGlzcG9zZUFmdGVyOmgsbm9EaXNwb3NlT25TZXQ6ZCxub1VwZGF0ZVRUTDpnLG1heFNpemU6eT0wLG1heEVudHJ5U2l6ZTp3PTAsc2l6ZUNhbGN1bGF0aW9uOkUsZmV0Y2hNZXRob2Q6Uyxub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb246SSxub0RlbGV0ZU9uU3RhbGVHZXQ6QyxhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbjpSLGFsbG93U3RhbGVPbkZldGNoQWJvcnQ6VSxpZ25vcmVGZXRjaEFib3J0Ok59PWU7aWYociE9PTAmJiEkdChyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwibWF4IG9wdGlvbiBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlclwiKTtsZXQgVz1yP0pkKHIpOkFycmF5O2lmKCFXKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgbWF4IHZhbHVlOiBcIityKTtpZih0aGlzLiNsPXIsdGhpcy4jYz15LHRoaXMubWF4RW50cnlTaXplPXd8fHRoaXMuI2MsdGhpcy5zaXplQ2FsY3VsYXRpb249RSx0aGlzLnNpemVDYWxjdWxhdGlvbil7aWYoIXRoaXMuI2MmJiF0aGlzLm1heEVudHJ5U2l6ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IHNldCBzaXplQ2FsY3VsYXRpb24gd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb3IgbWF4RW50cnlTaXplXCIpO2lmKHR5cGVvZiB0aGlzLnNpemVDYWxjdWxhdGlvbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJzaXplQ2FsY3VsYXRpb24gc2V0IHRvIG5vbi1mdW5jdGlvblwiKX1pZihTIT09dm9pZCAwJiZ0eXBlb2YgUyE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJmZXRjaE1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgc3BlY2lmaWVkXCIpO2lmKHRoaXMuI0I9Uyx0aGlzLiNJPSEhUyx0aGlzLiNuPW5ldyBNYXAsdGhpcy4jcj1uZXcgQXJyYXkocikuZmlsbCh2b2lkIDApLHRoaXMuI2U9bmV3IEFycmF5KHIpLmZpbGwodm9pZCAwKSx0aGlzLiN1PW5ldyBXKHIpLHRoaXMuI2g9bmV3IFcociksdGhpcy4jYT0wLHRoaXMuI3M9MCx0aGlzLiNiPW5hLmNyZWF0ZShyKSx0aGlzLiNpPTAsdGhpcy4jeT0wLHR5cGVvZiBjPT1cImZ1bmN0aW9uXCImJih0aGlzLiNwPWMpLHR5cGVvZiBoPT1cImZ1bmN0aW9uXCI/KHRoaXMuI2c9aCx0aGlzLiNvPVtdKToodGhpcy4jZz12b2lkIDAsdGhpcy4jbz12b2lkIDApLHRoaXMuI189ISF0aGlzLiNwLHRoaXMuI2Y9ISF0aGlzLiNnLHRoaXMubm9EaXNwb3NlT25TZXQ9ISFkLHRoaXMubm9VcGRhdGVUVEw9ISFnLHRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uPSEhSSx0aGlzLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uPSEhUix0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQ9ISFVLHRoaXMuaWdub3JlRmV0Y2hBYm9ydD0hIU4sdGhpcy5tYXhFbnRyeVNpemUhPT0wKXtpZih0aGlzLiNjIT09MCYmISR0KHRoaXMuI2MpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJtYXhTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZFwiKTtpZighJHQodGhpcy5tYXhFbnRyeVNpemUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJtYXhFbnRyeVNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkXCIpO3RoaXMuI3EoKX1pZih0aGlzLmFsbG93U3RhbGU9ISF1LHRoaXMubm9EZWxldGVPblN0YWxlR2V0PSEhQyx0aGlzLnVwZGF0ZUFnZU9uR2V0PSEhcyx0aGlzLnVwZGF0ZUFnZU9uSGFzPSEhYSx0aGlzLnR0bFJlc29sdXRpb249JHQobil8fG49PT0wP246MSx0aGlzLnR0bEF1dG9wdXJnZT0hIW8sdGhpcy50dGw9aXx8MCx0aGlzLnR0bCl7aWYoISR0KHRoaXMudHRsKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwidHRsIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZFwiKTt0aGlzLiN4KCl9aWYodGhpcy4jbD09PTAmJnRoaXMudHRsPT09MCYmdGhpcy4jYz09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIkF0IGxlYXN0IG9uZSBvZiBtYXgsIG1heFNpemUsIG9yIHR0bCBpcyByZXF1aXJlZFwiKTtpZighdGhpcy50dGxBdXRvcHVyZ2UmJiF0aGlzLiNsJiYhdGhpcy4jYyl7bGV0IEs9XCJMUlVfQ0FDSEVfVU5CT1VOREVEXCI7cDEoSykmJihRZC5hZGQoSyksWWQoXCJUVEwgY2FjaGluZyB3aXRob3V0IHR0bEF1dG9wdXJnZSwgbWF4LCBvciBtYXhTaXplIGNhbiByZXN1bHQgaW4gdW5ib3VuZGVkIG1lbW9yeSBjb25zdW1wdGlvbi5cIixcIlVuYm91bmRlZENhY2hlV2FybmluZ1wiLEssdCkpfX1nZXRSZW1haW5pbmdUVEwoZSl7cmV0dXJuIHRoaXMuI24uaGFzKGUpPzEvMDowfSN4KCl7bGV0IGU9bmV3IEpyKHRoaXMuI2wpLHI9bmV3IEpyKHRoaXMuI2wpO3RoaXMuI3c9ZSx0aGlzLiNTPXIsdGhpcy4jTT0obyxzLGE9QWkubm93KCkpPT57aWYocltvXT1zIT09MD9hOjAsZVtvXT1zLHMhPT0wJiZ0aGlzLnR0bEF1dG9wdXJnZSl7bGV0IHU9c2V0VGltZW91dCgoKT0+e3RoaXMuI2QobykmJnRoaXMuZGVsZXRlKHRoaXMuI3Jbb10pfSxzKzEpO3UudW5yZWYmJnUudW5yZWYoKX19LHRoaXMuI1Q9bz0+e3Jbb109ZVtvXSE9PTA/QWkubm93KCk6MH0sdGhpcy4jQT0obyxzKT0+e2lmKGVbc10pe2xldCBhPWVbc10sdT1yW3NdO28udHRsPWEsby5zdGFydD11LG8ubm93PWl8fG4oKTtsZXQgYz1vLm5vdy11O28ucmVtYWluaW5nVFRMPWEtY319O2xldCBpPTAsbj0oKT0+e2xldCBvPUFpLm5vdygpO2lmKHRoaXMudHRsUmVzb2x1dGlvbj4wKXtpPW87bGV0IHM9c2V0VGltZW91dCgoKT0+aT0wLHRoaXMudHRsUmVzb2x1dGlvbik7cy51bnJlZiYmcy51bnJlZigpfXJldHVybiBvfTt0aGlzLmdldFJlbWFpbmluZ1RUTD1vPT57bGV0IHM9dGhpcy4jbi5nZXQobyk7aWYocz09PXZvaWQgMClyZXR1cm4gMDtsZXQgYT1lW3NdLHU9cltzXTtpZihhPT09MHx8dT09PTApcmV0dXJuIDEvMDtsZXQgYz0oaXx8bigpKS11O3JldHVybiBhLWN9LHRoaXMuI2Q9bz0+ZVtvXSE9PTAmJnJbb10hPT0wJiYoaXx8bigpKS1yW29dPmVbb119I1Q9KCk9Pnt9OyNBPSgpPT57fTsjTT0oKT0+e307I2Q9KCk9PiExOyNxKCl7bGV0IGU9bmV3IEpyKHRoaXMuI2wpO3RoaXMuI3k9MCx0aGlzLiNFPWUsdGhpcy4jUj1yPT57dGhpcy4jeS09ZVtyXSxlW3JdPTB9LHRoaXMuI0w9KHIsaSxuLG8pPT57aWYodGhpcy4jdChpKSlyZXR1cm4gMDtpZighJHQobikpaWYobyl7aWYodHlwZW9mIG8hPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKFwic2l6ZUNhbGN1bGF0aW9uIG11c3QgYmUgYSBmdW5jdGlvblwiKTtpZihuPW8oaSxyKSwhJHQobikpdGhyb3cgbmV3IFR5cGVFcnJvcihcInNpemVDYWxjdWxhdGlvbiByZXR1cm4gaW52YWxpZCAoZXhwZWN0IHBvc2l0aXZlIGludGVnZXIpXCIpfWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgc2l6ZSB2YWx1ZSAobXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyKS4gV2hlbiBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZSBpcyB1c2VkLCBzaXplQ2FsY3VsYXRpb24gb3Igc2l6ZSBtdXN0IGJlIHNldC5cIik7cmV0dXJuIG59LHRoaXMuI1A9KHIsaSxuKT0+e2lmKGVbcl09aSx0aGlzLiNjKXtsZXQgbz10aGlzLiNjLWVbcl07Zm9yKDt0aGlzLiN5Pm87KXRoaXMuI08oITApfXRoaXMuI3krPWVbcl0sbiYmKG4uZW50cnlTaXplPWksbi50b3RhbENhbGN1bGF0ZWRTaXplPXRoaXMuI3kpfX0jUj1lPT57fTsjUD0oZSxyLGkpPT57fTsjTD0oZSxyLGksbik9PntpZihpfHxuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3Qgc2V0IHNpemUgd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb3IgbWF4RW50cnlTaXplIG9uIGNhY2hlXCIpO3JldHVybiAwfTsqI20oe2FsbG93U3RhbGU6ZT10aGlzLmFsbG93U3RhbGV9PXt9KXtpZih0aGlzLiNpKWZvcihsZXQgcj10aGlzLiNzOyEoIXRoaXMuI1Uocil8fCgoZXx8IXRoaXMuI2QocikpJiYoeWllbGQgcikscj09PXRoaXMuI2EpKTspcj10aGlzLiNoW3JdfSojdih7YWxsb3dTdGFsZTplPXRoaXMuYWxsb3dTdGFsZX09e30pe2lmKHRoaXMuI2kpZm9yKGxldCByPXRoaXMuI2E7ISghdGhpcy4jVShyKXx8KChlfHwhdGhpcy4jZChyKSkmJih5aWVsZCByKSxyPT09dGhpcy4jcykpOylyPXRoaXMuI3Vbcl19I1UoZSl7cmV0dXJuIGUhPT12b2lkIDAmJnRoaXMuI24uZ2V0KHRoaXMuI3JbZV0pPT09ZX0qZW50cmllcygpe2ZvcihsZXQgZSBvZiB0aGlzLiNtKCkpdGhpcy4jZVtlXSE9PXZvaWQgMCYmdGhpcy4jcltlXSE9PXZvaWQgMCYmIXRoaXMuI3QodGhpcy4jZVtlXSkmJih5aWVsZFt0aGlzLiNyW2VdLHRoaXMuI2VbZV1dKX0qcmVudHJpZXMoKXtmb3IobGV0IGUgb2YgdGhpcy4jdigpKXRoaXMuI2VbZV0hPT12b2lkIDAmJnRoaXMuI3JbZV0hPT12b2lkIDAmJiF0aGlzLiN0KHRoaXMuI2VbZV0pJiYoeWllbGRbdGhpcy4jcltlXSx0aGlzLiNlW2VdXSl9KmtleXMoKXtmb3IobGV0IGUgb2YgdGhpcy4jbSgpKXtsZXQgcj10aGlzLiNyW2VdO3IhPT12b2lkIDAmJiF0aGlzLiN0KHRoaXMuI2VbZV0pJiYoeWllbGQgcil9fSpya2V5cygpe2ZvcihsZXQgZSBvZiB0aGlzLiN2KCkpe2xldCByPXRoaXMuI3JbZV07ciE9PXZvaWQgMCYmIXRoaXMuI3QodGhpcy4jZVtlXSkmJih5aWVsZCByKX19KnZhbHVlcygpe2ZvcihsZXQgZSBvZiB0aGlzLiNtKCkpdGhpcy4jZVtlXSE9PXZvaWQgMCYmIXRoaXMuI3QodGhpcy4jZVtlXSkmJih5aWVsZCB0aGlzLiNlW2VdKX0qcnZhbHVlcygpe2ZvcihsZXQgZSBvZiB0aGlzLiN2KCkpdGhpcy4jZVtlXSE9PXZvaWQgMCYmIXRoaXMuI3QodGhpcy4jZVtlXSkmJih5aWVsZCB0aGlzLiNlW2VdKX1bU3ltYm9sLml0ZXJhdG9yXSgpe3JldHVybiB0aGlzLmVudHJpZXMoKX1maW5kKGUscj17fSl7Zm9yKGxldCBpIG9mIHRoaXMuI20oKSl7bGV0IG49dGhpcy4jZVtpXSxvPXRoaXMuI3Qobik/bi5fX3N0YWxlV2hpbGVGZXRjaGluZzpuO2lmKG8hPT12b2lkIDAmJmUobyx0aGlzLiNyW2ldLHRoaXMpKXJldHVybiB0aGlzLmdldCh0aGlzLiNyW2ldLHIpfX1mb3JFYWNoKGUscj10aGlzKXtmb3IobGV0IGkgb2YgdGhpcy4jbSgpKXtsZXQgbj10aGlzLiNlW2ldLG89dGhpcy4jdChuKT9uLl9fc3RhbGVXaGlsZUZldGNoaW5nOm47byE9PXZvaWQgMCYmZS5jYWxsKHIsbyx0aGlzLiNyW2ldLHRoaXMpfX1yZm9yRWFjaChlLHI9dGhpcyl7Zm9yKGxldCBpIG9mIHRoaXMuI3YoKSl7bGV0IG49dGhpcy4jZVtpXSxvPXRoaXMuI3Qobik/bi5fX3N0YWxlV2hpbGVGZXRjaGluZzpuO28hPT12b2lkIDAmJmUuY2FsbChyLG8sdGhpcy4jcltpXSx0aGlzKX19cHVyZ2VTdGFsZSgpe2xldCBlPSExO2ZvcihsZXQgciBvZiB0aGlzLiN2KHthbGxvd1N0YWxlOiEwfSkpdGhpcy4jZChyKSYmKHRoaXMuZGVsZXRlKHRoaXMuI3Jbcl0pLGU9ITApO3JldHVybiBlfWR1bXAoKXtsZXQgZT1bXTtmb3IobGV0IHIgb2YgdGhpcy4jbSh7YWxsb3dTdGFsZTohMH0pKXtsZXQgaT10aGlzLiNyW3JdLG49dGhpcy4jZVtyXSxvPXRoaXMuI3Qobik/bi5fX3N0YWxlV2hpbGVGZXRjaGluZzpuO2lmKG89PT12b2lkIDB8fGk9PT12b2lkIDApY29udGludWU7bGV0IHM9e3ZhbHVlOm99O2lmKHRoaXMuI3cmJnRoaXMuI1Mpe3MudHRsPXRoaXMuI3dbcl07bGV0IGE9QWkubm93KCktdGhpcy4jU1tyXTtzLnN0YXJ0PU1hdGguZmxvb3IoRGF0ZS5ub3coKS1hKX10aGlzLiNFJiYocy5zaXplPXRoaXMuI0Vbcl0pLGUudW5zaGlmdChbaSxzXSl9cmV0dXJuIGV9bG9hZChlKXt0aGlzLmNsZWFyKCk7Zm9yKGxldFtyLGldb2YgZSl7aWYoaS5zdGFydCl7bGV0IG49RGF0ZS5ub3coKS1pLnN0YXJ0O2kuc3RhcnQ9QWkubm93KCktbn10aGlzLnNldChyLGkudmFsdWUsaSl9fXNldChlLHIsaT17fSl7aWYocj09PXZvaWQgMClyZXR1cm4gdGhpcy5kZWxldGUoZSksdGhpcztsZXR7dHRsOm49dGhpcy50dGwsc3RhcnQ6byxub0Rpc3Bvc2VPblNldDpzPXRoaXMubm9EaXNwb3NlT25TZXQsc2l6ZUNhbGN1bGF0aW9uOmE9dGhpcy5zaXplQ2FsY3VsYXRpb24sc3RhdHVzOnV9PWkse25vVXBkYXRlVFRMOmM9dGhpcy5ub1VwZGF0ZVRUTH09aSxoPXRoaXMuI0woZSxyLGkuc2l6ZXx8MCxhKTtpZih0aGlzLm1heEVudHJ5U2l6ZSYmaD50aGlzLm1heEVudHJ5U2l6ZSlyZXR1cm4gdSYmKHUuc2V0PVwibWlzc1wiLHUubWF4RW50cnlTaXplRXhjZWVkZWQ9ITApLHRoaXMuZGVsZXRlKGUpLHRoaXM7bGV0IGQ9dGhpcy4jaT09PTA/dm9pZCAwOnRoaXMuI24uZ2V0KGUpO2lmKGQ9PT12b2lkIDApZD10aGlzLiNpPT09MD90aGlzLiNzOnRoaXMuI2IubGVuZ3RoIT09MD90aGlzLiNiLnBvcCgpOnRoaXMuI2k9PT10aGlzLiNsP3RoaXMuI08oITEpOnRoaXMuI2ksdGhpcy4jcltkXT1lLHRoaXMuI2VbZF09cix0aGlzLiNuLnNldChlLGQpLHRoaXMuI3VbdGhpcy4jc109ZCx0aGlzLiNoW2RdPXRoaXMuI3MsdGhpcy4jcz1kLHRoaXMuI2krKyx0aGlzLiNQKGQsaCx1KSx1JiYodS5zZXQ9XCJhZGRcIiksYz0hMTtlbHNle3RoaXMuI0MoZCk7bGV0IGc9dGhpcy4jZVtkXTtpZihyIT09Zyl7aWYodGhpcy4jSSYmdGhpcy4jdChnKSl7Zy5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoXCJyZXBsYWNlZFwiKSk7bGV0e19fc3RhbGVXaGlsZUZldGNoaW5nOnl9PWc7eSE9PXZvaWQgMCYmIXMmJih0aGlzLiNfJiZ0aGlzLiNwPy4oeSxlLFwic2V0XCIpLHRoaXMuI2YmJnRoaXMuI28/LnB1c2goW3ksZSxcInNldFwiXSkpfWVsc2Ugc3x8KHRoaXMuI18mJnRoaXMuI3A/LihnLGUsXCJzZXRcIiksdGhpcy4jZiYmdGhpcy4jbz8ucHVzaChbZyxlLFwic2V0XCJdKSk7aWYodGhpcy4jUihkKSx0aGlzLiNQKGQsaCx1KSx0aGlzLiNlW2RdPXIsdSl7dS5zZXQ9XCJyZXBsYWNlXCI7bGV0IHk9ZyYmdGhpcy4jdChnKT9nLl9fc3RhbGVXaGlsZUZldGNoaW5nOmc7eSE9PXZvaWQgMCYmKHUub2xkVmFsdWU9eSl9fWVsc2UgdSYmKHUuc2V0PVwidXBkYXRlXCIpfWlmKG4hPT0wJiYhdGhpcy4jdyYmdGhpcy4jeCgpLHRoaXMuI3cmJihjfHx0aGlzLiNNKGQsbixvKSx1JiZ0aGlzLiNBKHUsZCkpLCFzJiZ0aGlzLiNmJiZ0aGlzLiNvKXtsZXQgZz10aGlzLiNvLHk7Zm9yKDt5PWc/LnNoaWZ0KCk7KXRoaXMuI2c/LiguLi55KX1yZXR1cm4gdGhpc31wb3AoKXt0cnl7Zm9yKDt0aGlzLiNpOyl7bGV0IGU9dGhpcy4jZVt0aGlzLiNhXTtpZih0aGlzLiNPKCEwKSx0aGlzLiN0KGUpKXtpZihlLl9fc3RhbGVXaGlsZUZldGNoaW5nKXJldHVybiBlLl9fc3RhbGVXaGlsZUZldGNoaW5nfWVsc2UgaWYoZSE9PXZvaWQgMClyZXR1cm4gZX19ZmluYWxseXtpZih0aGlzLiNmJiZ0aGlzLiNvKXtsZXQgZT10aGlzLiNvLHI7Zm9yKDtyPWU/LnNoaWZ0KCk7KXRoaXMuI2c/LiguLi5yKX19fSNPKGUpe2xldCByPXRoaXMuI2EsaT10aGlzLiNyW3JdLG49dGhpcy4jZVtyXTtyZXR1cm4gdGhpcy4jSSYmdGhpcy4jdChuKT9uLl9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcihcImV2aWN0ZWRcIikpOih0aGlzLiNffHx0aGlzLiNmKSYmKHRoaXMuI18mJnRoaXMuI3A/LihuLGksXCJldmljdFwiKSx0aGlzLiNmJiZ0aGlzLiNvPy5wdXNoKFtuLGksXCJldmljdFwiXSkpLHRoaXMuI1IociksZSYmKHRoaXMuI3Jbcl09dm9pZCAwLHRoaXMuI2Vbcl09dm9pZCAwLHRoaXMuI2IucHVzaChyKSksdGhpcy4jaT09PTE/KHRoaXMuI2E9dGhpcy4jcz0wLHRoaXMuI2IubGVuZ3RoPTApOnRoaXMuI2E9dGhpcy4jdVtyXSx0aGlzLiNuLmRlbGV0ZShpKSx0aGlzLiNpLS0scn1oYXMoZSxyPXt9KXtsZXR7dXBkYXRlQWdlT25IYXM6aT10aGlzLnVwZGF0ZUFnZU9uSGFzLHN0YXR1czpufT1yLG89dGhpcy4jbi5nZXQoZSk7aWYobyE9PXZvaWQgMCl7bGV0IHM9dGhpcy4jZVtvXTtpZih0aGlzLiN0KHMpJiZzLl9fc3RhbGVXaGlsZUZldGNoaW5nPT09dm9pZCAwKXJldHVybiExO2lmKHRoaXMuI2QobykpbiYmKG4uaGFzPVwic3RhbGVcIix0aGlzLiNBKG4sbykpO2Vsc2UgcmV0dXJuIGkmJnRoaXMuI1QobyksbiYmKG4uaGFzPVwiaGl0XCIsdGhpcy4jQShuLG8pKSwhMH1lbHNlIG4mJihuLmhhcz1cIm1pc3NcIik7cmV0dXJuITF9cGVlayhlLHI9e30pe2xldHthbGxvd1N0YWxlOmk9dGhpcy5hbGxvd1N0YWxlfT1yLG49dGhpcy4jbi5nZXQoZSk7aWYobiE9PXZvaWQgMCYmKGl8fCF0aGlzLiNkKG4pKSl7bGV0IG89dGhpcy4jZVtuXTtyZXR1cm4gdGhpcy4jdChvKT9vLl9fc3RhbGVXaGlsZUZldGNoaW5nOm99fSNrKGUscixpLG4pe2xldCBvPXI9PT12b2lkIDA/dm9pZCAwOnRoaXMuI2Vbcl07aWYodGhpcy4jdChvKSlyZXR1cm4gbztsZXQgcz1uZXcgT24se3NpZ25hbDphfT1pO2E/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCgpPT5zLmFib3J0KGEucmVhc29uKSx7c2lnbmFsOnMuc2lnbmFsfSk7bGV0IHU9e3NpZ25hbDpzLnNpZ25hbCxvcHRpb25zOmksY29udGV4dDpufSxjPShFLFM9ITEpPT57bGV0e2Fib3J0ZWQ6SX09cy5zaWduYWwsQz1pLmlnbm9yZUZldGNoQWJvcnQmJkUhPT12b2lkIDA7aWYoaS5zdGF0dXMmJihJJiYhUz8oaS5zdGF0dXMuZmV0Y2hBYm9ydGVkPSEwLGkuc3RhdHVzLmZldGNoRXJyb3I9cy5zaWduYWwucmVhc29uLEMmJihpLnN0YXR1cy5mZXRjaEFib3J0SWdub3JlZD0hMCkpOmkuc3RhdHVzLmZldGNoUmVzb2x2ZWQ9ITApLEkmJiFDJiYhUylyZXR1cm4gZChzLnNpZ25hbC5yZWFzb24pO2xldCBSPXk7cmV0dXJuIHRoaXMuI2Vbcl09PT15JiYoRT09PXZvaWQgMD9SLl9fc3RhbGVXaGlsZUZldGNoaW5nP3RoaXMuI2Vbcl09Ui5fX3N0YWxlV2hpbGVGZXRjaGluZzp0aGlzLmRlbGV0ZShlKTooaS5zdGF0dXMmJihpLnN0YXR1cy5mZXRjaFVwZGF0ZWQ9ITApLHRoaXMuc2V0KGUsRSx1Lm9wdGlvbnMpKSksRX0saD1FPT4oaS5zdGF0dXMmJihpLnN0YXR1cy5mZXRjaFJlamVjdGVkPSEwLGkuc3RhdHVzLmZldGNoRXJyb3I9RSksZChFKSksZD1FPT57bGV0e2Fib3J0ZWQ6U309cy5zaWduYWwsST1TJiZpLmFsbG93U3RhbGVPbkZldGNoQWJvcnQsQz1JfHxpLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLFI9Q3x8aS5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24sVT15O2lmKHRoaXMuI2Vbcl09PT15JiYoIVJ8fFUuX19zdGFsZVdoaWxlRmV0Y2hpbmc9PT12b2lkIDA/dGhpcy5kZWxldGUoZSk6SXx8KHRoaXMuI2Vbcl09VS5fX3N0YWxlV2hpbGVGZXRjaGluZykpLEMpcmV0dXJuIGkuc3RhdHVzJiZVLl9fc3RhbGVXaGlsZUZldGNoaW5nIT09dm9pZCAwJiYoaS5zdGF0dXMucmV0dXJuZWRTdGFsZT0hMCksVS5fX3N0YWxlV2hpbGVGZXRjaGluZztpZihVLl9fcmV0dXJuZWQ9PT1VKXRocm93IEV9LGc9KEUsUyk9PntsZXQgST10aGlzLiNCPy4oZSxvLHUpO0kmJkkgaW5zdGFuY2VvZiBQcm9taXNlJiZJLnRoZW4oQz0+RShDPT09dm9pZCAwP3ZvaWQgMDpDKSxTKSxzLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwoKT0+eyghaS5pZ25vcmVGZXRjaEFib3J0fHxpLmFsbG93U3RhbGVPbkZldGNoQWJvcnQpJiYoRSh2b2lkIDApLGkuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCYmKEU9Qz0+YyhDLCEwKSkpfSl9O2kuc3RhdHVzJiYoaS5zdGF0dXMuZmV0Y2hEaXNwYXRjaGVkPSEwKTtsZXQgeT1uZXcgUHJvbWlzZShnKS50aGVuKGMsaCksdz1PYmplY3QuYXNzaWduKHkse19fYWJvcnRDb250cm9sbGVyOnMsX19zdGFsZVdoaWxlRmV0Y2hpbmc6byxfX3JldHVybmVkOnZvaWQgMH0pO3JldHVybiByPT09dm9pZCAwPyh0aGlzLnNldChlLHcsey4uLnUub3B0aW9ucyxzdGF0dXM6dm9pZCAwfSkscj10aGlzLiNuLmdldChlKSk6dGhpcy4jZVtyXT13LHd9I3QoZSl7aWYoIXRoaXMuI0kpcmV0dXJuITE7bGV0IHI9ZTtyZXR1cm4hIXImJnIgaW5zdGFuY2VvZiBQcm9taXNlJiZyLmhhc093blByb3BlcnR5KFwiX19zdGFsZVdoaWxlRmV0Y2hpbmdcIikmJnIuX19hYm9ydENvbnRyb2xsZXIgaW5zdGFuY2VvZiBPbn1hc3luYyBmZXRjaChlLHI9e30pe2xldHthbGxvd1N0YWxlOmk9dGhpcy5hbGxvd1N0YWxlLHVwZGF0ZUFnZU9uR2V0Om49dGhpcy51cGRhdGVBZ2VPbkdldCxub0RlbGV0ZU9uU3RhbGVHZXQ6bz10aGlzLm5vRGVsZXRlT25TdGFsZUdldCx0dGw6cz10aGlzLnR0bCxub0Rpc3Bvc2VPblNldDphPXRoaXMubm9EaXNwb3NlT25TZXQsc2l6ZTp1PTAsc2l6ZUNhbGN1bGF0aW9uOmM9dGhpcy5zaXplQ2FsY3VsYXRpb24sbm9VcGRhdGVUVEw6aD10aGlzLm5vVXBkYXRlVFRMLG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjpkPXRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uOmc9dGhpcy5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbixpZ25vcmVGZXRjaEFib3J0Onk9dGhpcy5pZ25vcmVGZXRjaEFib3J0LGFsbG93U3RhbGVPbkZldGNoQWJvcnQ6dz10aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQsY29udGV4dDpFLGZvcmNlUmVmcmVzaDpTPSExLHN0YXR1czpJLHNpZ25hbDpDfT1yO2lmKCF0aGlzLiNJKXJldHVybiBJJiYoSS5mZXRjaD1cImdldFwiKSx0aGlzLmdldChlLHthbGxvd1N0YWxlOmksdXBkYXRlQWdlT25HZXQ6bixub0RlbGV0ZU9uU3RhbGVHZXQ6byxzdGF0dXM6SX0pO2xldCBSPXthbGxvd1N0YWxlOmksdXBkYXRlQWdlT25HZXQ6bixub0RlbGV0ZU9uU3RhbGVHZXQ6byx0dGw6cyxub0Rpc3Bvc2VPblNldDphLHNpemU6dSxzaXplQ2FsY3VsYXRpb246Yyxub1VwZGF0ZVRUTDpoLG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjpkLGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uOmcsYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydDp3LGlnbm9yZUZldGNoQWJvcnQ6eSxzdGF0dXM6SSxzaWduYWw6Q30sVT10aGlzLiNuLmdldChlKTtpZihVPT09dm9pZCAwKXtJJiYoSS5mZXRjaD1cIm1pc3NcIik7bGV0IE49dGhpcy4jayhlLFUsUixFKTtyZXR1cm4gTi5fX3JldHVybmVkPU59ZWxzZXtsZXQgTj10aGlzLiNlW1VdO2lmKHRoaXMuI3QoTikpe2xldCBkZT1pJiZOLl9fc3RhbGVXaGlsZUZldGNoaW5nIT09dm9pZCAwO3JldHVybiBJJiYoSS5mZXRjaD1cImluZmxpZ2h0XCIsZGUmJihJLnJldHVybmVkU3RhbGU9ITApKSxkZT9OLl9fc3RhbGVXaGlsZUZldGNoaW5nOk4uX19yZXR1cm5lZD1OfWxldCBXPXRoaXMuI2QoVSk7aWYoIVMmJiFXKXJldHVybiBJJiYoSS5mZXRjaD1cImhpdFwiKSx0aGlzLiNDKFUpLG4mJnRoaXMuI1QoVSksSSYmdGhpcy4jQShJLFUpLE47bGV0IEs9dGhpcy4jayhlLFUsUixFKSxRPUsuX19zdGFsZVdoaWxlRmV0Y2hpbmchPT12b2lkIDAmJmk7cmV0dXJuIEkmJihJLmZldGNoPVc/XCJzdGFsZVwiOlwicmVmcmVzaFwiLFEmJlcmJihJLnJldHVybmVkU3RhbGU9ITApKSxRP0suX19zdGFsZVdoaWxlRmV0Y2hpbmc6Sy5fX3JldHVybmVkPUt9fWdldChlLHI9e30pe2xldHthbGxvd1N0YWxlOmk9dGhpcy5hbGxvd1N0YWxlLHVwZGF0ZUFnZU9uR2V0Om49dGhpcy51cGRhdGVBZ2VPbkdldCxub0RlbGV0ZU9uU3RhbGVHZXQ6bz10aGlzLm5vRGVsZXRlT25TdGFsZUdldCxzdGF0dXM6c309cixhPXRoaXMuI24uZ2V0KGUpO2lmKGEhPT12b2lkIDApe2xldCB1PXRoaXMuI2VbYV0sYz10aGlzLiN0KHUpO3JldHVybiBzJiZ0aGlzLiNBKHMsYSksdGhpcy4jZChhKT8ocyYmKHMuZ2V0PVwic3RhbGVcIiksYz8ocyYmaSYmdS5fX3N0YWxlV2hpbGVGZXRjaGluZyE9PXZvaWQgMCYmKHMucmV0dXJuZWRTdGFsZT0hMCksaT91Ll9fc3RhbGVXaGlsZUZldGNoaW5nOnZvaWQgMCk6KG98fHRoaXMuZGVsZXRlKGUpLHMmJmkmJihzLnJldHVybmVkU3RhbGU9ITApLGk/dTp2b2lkIDApKToocyYmKHMuZ2V0PVwiaGl0XCIpLGM/dS5fX3N0YWxlV2hpbGVGZXRjaGluZzoodGhpcy4jQyhhKSxuJiZ0aGlzLiNUKGEpLHUpKX1lbHNlIHMmJihzLmdldD1cIm1pc3NcIil9I04oZSxyKXt0aGlzLiNoW3JdPWUsdGhpcy4jdVtlXT1yfSNDKGUpe2UhPT10aGlzLiNzJiYoZT09PXRoaXMuI2E/dGhpcy4jYT10aGlzLiN1W2VdOnRoaXMuI04odGhpcy4jaFtlXSx0aGlzLiN1W2VdKSx0aGlzLiNOKHRoaXMuI3MsZSksdGhpcy4jcz1lKX1kZWxldGUoZSl7bGV0IHI9ITE7aWYodGhpcy4jaSE9PTApe2xldCBpPXRoaXMuI24uZ2V0KGUpO2lmKGkhPT12b2lkIDApaWYocj0hMCx0aGlzLiNpPT09MSl0aGlzLmNsZWFyKCk7ZWxzZXt0aGlzLiNSKGkpO2xldCBuPXRoaXMuI2VbaV07dGhpcy4jdChuKT9uLl9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcihcImRlbGV0ZWRcIikpOih0aGlzLiNffHx0aGlzLiNmKSYmKHRoaXMuI18mJnRoaXMuI3A/LihuLGUsXCJkZWxldGVcIiksdGhpcy4jZiYmdGhpcy4jbz8ucHVzaChbbixlLFwiZGVsZXRlXCJdKSksdGhpcy4jbi5kZWxldGUoZSksdGhpcy4jcltpXT12b2lkIDAsdGhpcy4jZVtpXT12b2lkIDAsaT09PXRoaXMuI3M/dGhpcy4jcz10aGlzLiNoW2ldOmk9PT10aGlzLiNhP3RoaXMuI2E9dGhpcy4jdVtpXToodGhpcy4jdVt0aGlzLiNoW2ldXT10aGlzLiN1W2ldLHRoaXMuI2hbdGhpcy4jdVtpXV09dGhpcy4jaFtpXSksdGhpcy4jaS0tLHRoaXMuI2IucHVzaChpKX19aWYodGhpcy4jZiYmdGhpcy4jbz8ubGVuZ3RoKXtsZXQgaT10aGlzLiNvLG47Zm9yKDtuPWk/LnNoaWZ0KCk7KXRoaXMuI2c/LiguLi5uKX1yZXR1cm4gcn1jbGVhcigpe2ZvcihsZXQgZSBvZiB0aGlzLiN2KHthbGxvd1N0YWxlOiEwfSkpe2xldCByPXRoaXMuI2VbZV07aWYodGhpcy4jdChyKSlyLl9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcihcImRlbGV0ZWRcIikpO2Vsc2V7bGV0IGk9dGhpcy4jcltlXTt0aGlzLiNfJiZ0aGlzLiNwPy4ocixpLFwiZGVsZXRlXCIpLHRoaXMuI2YmJnRoaXMuI28/LnB1c2goW3IsaSxcImRlbGV0ZVwiXSl9fWlmKHRoaXMuI24uY2xlYXIoKSx0aGlzLiNlLmZpbGwodm9pZCAwKSx0aGlzLiNyLmZpbGwodm9pZCAwKSx0aGlzLiN3JiZ0aGlzLiNTJiYodGhpcy4jdy5maWxsKDApLHRoaXMuI1MuZmlsbCgwKSksdGhpcy4jRSYmdGhpcy4jRS5maWxsKDApLHRoaXMuI2E9MCx0aGlzLiNzPTAsdGhpcy4jYi5sZW5ndGg9MCx0aGlzLiN5PTAsdGhpcy4jaT0wLHRoaXMuI2YmJnRoaXMuI28pe2xldCBlPXRoaXMuI28scjtmb3IoO3I9ZT8uc2hpZnQoKTspdGhpcy4jZz8uKC4uLnIpfX19O2tuLkxSVUNhY2hlPXNhfSk7dmFyIGF0PU0oSHQ9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSHQsXCJ0XCIse3ZhbHVlOiEwfSk7SHQuQ29udGFpbmVySXRlcmF0b3I9SHQuQ29udGFpbmVyPUh0LkJhc2U9dm9pZCAwO3ZhciBvYT1jbGFzc3tjb25zdHJ1Y3RvcihlPTApe3RoaXMuaXRlcmF0b3JUeXBlPWV9ZXF1YWxzKGUpe3JldHVybiB0aGlzLm89PT1lLm99fTtIdC5Db250YWluZXJJdGVyYXRvcj1vYTt2YXIgeG49Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmk9MH1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuaX1zaXplKCl7cmV0dXJuIHRoaXMuaX1lbXB0eSgpe3JldHVybiB0aGlzLmk9PT0wfX07SHQuQmFzZT14bjt2YXIgYWE9Y2xhc3MgZXh0ZW5kcyB4bnt9O0h0LkNvbnRhaW5lcj1hYX0pO3ZhciBaZD1NKE1uPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE1uLFwidFwiLHt2YWx1ZTohMH0pO01uLmRlZmF1bHQ9dm9pZCAwO3ZhciBnMT1hdCgpLGxhPWNsYXNzIGV4dGVuZHMgZzEuQmFzZXtjb25zdHJ1Y3RvcihlPVtdKXtzdXBlcigpLHRoaXMuUz1bXTtsZXQgcj10aGlzO2UuZm9yRWFjaChmdW5jdGlvbihpKXtyLnB1c2goaSl9KX1jbGVhcigpe3RoaXMuaT0wLHRoaXMuUz1bXX1wdXNoKGUpe3JldHVybiB0aGlzLlMucHVzaChlKSx0aGlzLmkrPTEsdGhpcy5pfXBvcCgpe2lmKHRoaXMuaSE9PTApcmV0dXJuIHRoaXMuaS09MSx0aGlzLlMucG9wKCl9dG9wKCl7cmV0dXJuIHRoaXMuU1t0aGlzLmktMV19fSx5MT1sYTtNbi5kZWZhdWx0PXkxfSk7dmFyIGVwPU0oTG49PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTG4sXCJ0XCIse3ZhbHVlOiEwfSk7TG4uZGVmYXVsdD12b2lkIDA7dmFyIGIxPWF0KCksdWE9Y2xhc3MgZXh0ZW5kcyBiMS5CYXNle2NvbnN0cnVjdG9yKGU9W10pe3N1cGVyKCksdGhpcy5qPTAsdGhpcy5xPVtdO2xldCByPXRoaXM7ZS5mb3JFYWNoKGZ1bmN0aW9uKGkpe3IucHVzaChpKX0pfWNsZWFyKCl7dGhpcy5xPVtdLHRoaXMuaT10aGlzLmo9MH1wdXNoKGUpe2xldCByPXRoaXMucS5sZW5ndGg7aWYodGhpcy5qL3I+LjUmJnRoaXMuait0aGlzLmk+PXImJnI+NDA5Nil7bGV0IGk9dGhpcy5pO2ZvcihsZXQgbj0wO248aTsrK24pdGhpcy5xW25dPXRoaXMucVt0aGlzLmorbl07dGhpcy5qPTAsdGhpcy5xW3RoaXMuaV09ZX1lbHNlIHRoaXMucVt0aGlzLmordGhpcy5pXT1lO3JldHVybisrdGhpcy5pfXBvcCgpe2lmKHRoaXMuaT09PTApcmV0dXJuO2xldCBlPXRoaXMucVt0aGlzLmorK107cmV0dXJuIHRoaXMuaS09MSxlfWZyb250KCl7aWYodGhpcy5pIT09MClyZXR1cm4gdGhpcy5xW3RoaXMual19fSx3MT11YTtMbi5kZWZhdWx0PXcxfSk7dmFyIHRwPU0oVW49PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoVW4sXCJ0XCIse3ZhbHVlOiEwfSk7VW4uZGVmYXVsdD12b2lkIDA7dmFyIF8xPWF0KCksZmE9Y2xhc3MgZXh0ZW5kcyBfMS5CYXNle2NvbnN0cnVjdG9yKGU9W10scj1mdW5jdGlvbihuLG8pe3JldHVybiBuPm8/LTE6bjxvPzE6MH0saT0hMCl7aWYoc3VwZXIoKSx0aGlzLnY9cixBcnJheS5pc0FycmF5KGUpKXRoaXMuQz1pP1suLi5lXTplO2Vsc2V7dGhpcy5DPVtdO2xldCBvPXRoaXM7ZS5mb3JFYWNoKGZ1bmN0aW9uKHMpe28uQy5wdXNoKHMpfSl9dGhpcy5pPXRoaXMuQy5sZW5ndGg7bGV0IG49dGhpcy5pPj4xO2ZvcihsZXQgbz10aGlzLmktMT4+MTtvPj0wOy0tbyl0aGlzLmsobyxuKX1tKGUpe2xldCByPXRoaXMuQ1tlXTtmb3IoO2U+MDspe2xldCBpPWUtMT4+MSxuPXRoaXMuQ1tpXTtpZih0aGlzLnYobixyKTw9MClicmVhazt0aGlzLkNbZV09bixlPWl9dGhpcy5DW2VdPXJ9ayhlLHIpe2xldCBpPXRoaXMuQ1tlXTtmb3IoO2U8cjspe2xldCBuPWU8PDF8MSxvPW4rMSxzPXRoaXMuQ1tuXTtpZihvPHRoaXMuaSYmdGhpcy52KHMsdGhpcy5DW29dKT4wJiYobj1vLHM9dGhpcy5DW29dKSx0aGlzLnYocyxpKT49MClicmVhazt0aGlzLkNbZV09cyxlPW59dGhpcy5DW2VdPWl9Y2xlYXIoKXt0aGlzLmk9MCx0aGlzLkMubGVuZ3RoPTB9cHVzaChlKXt0aGlzLkMucHVzaChlKSx0aGlzLm0odGhpcy5pKSx0aGlzLmkrPTF9cG9wKCl7aWYodGhpcy5pPT09MClyZXR1cm47bGV0IGU9dGhpcy5DWzBdLHI9dGhpcy5DLnBvcCgpO3JldHVybiB0aGlzLmktPTEsdGhpcy5pJiYodGhpcy5DWzBdPXIsdGhpcy5rKDAsdGhpcy5pPj4xKSksZX10b3AoKXtyZXR1cm4gdGhpcy5DWzBdfWZpbmQoZSl7cmV0dXJuIHRoaXMuQy5pbmRleE9mKGUpPj0wfXJlbW92ZShlKXtsZXQgcj10aGlzLkMuaW5kZXhPZihlKTtyZXR1cm4gcjwwPyExOihyPT09MD90aGlzLnBvcCgpOnI9PT10aGlzLmktMT8odGhpcy5DLnBvcCgpLHRoaXMuaS09MSk6KHRoaXMuQy5zcGxpY2UociwxLHRoaXMuQy5wb3AoKSksdGhpcy5pLT0xLHRoaXMubShyKSx0aGlzLmsocix0aGlzLmk+PjEpKSwhMCl9dXBkYXRlSXRlbShlKXtsZXQgcj10aGlzLkMuaW5kZXhPZihlKTtyZXR1cm4gcjwwPyExOih0aGlzLm0ociksdGhpcy5rKHIsdGhpcy5pPj4xKSwhMCl9dG9BcnJheSgpe3JldHVyblsuLi50aGlzLkNdfX0sbTE9ZmE7VW4uZGVmYXVsdD1tMX0pO3ZhciBxbj1NKE5uPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE5uLFwidFwiLHt2YWx1ZTohMH0pO05uLmRlZmF1bHQ9dm9pZCAwO3ZhciB2MT1hdCgpLGNhPWNsYXNzIGV4dGVuZHMgdjEuQ29udGFpbmVye30sRTE9Y2E7Tm4uZGVmYXVsdD1FMX0pO3ZhciBsdD1NKGhhPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGhhLFwidFwiLHt2YWx1ZTohMH0pO2hhLnRocm93SXRlcmF0b3JBY2Nlc3NFcnJvcj1TMTtmdW5jdGlvbiBTMSgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiSXRlcmF0b3IgYWNjZXNzIGRlbmllZCFcIil9fSk7dmFyIHBhPU0oam49PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoam4sXCJ0XCIse3ZhbHVlOiEwfSk7am4uUmFuZG9tSXRlcmF0b3I9dm9pZCAwO3ZhciBBMT1hdCgpLERuPWx0KCksZGE9Y2xhc3MgZXh0ZW5kcyBBMS5Db250YWluZXJJdGVyYXRvcntjb25zdHJ1Y3RvcihlLHIpe3N1cGVyKHIpLHRoaXMubz1lLHRoaXMuaXRlcmF0b3JUeXBlPT09MD8odGhpcy5wcmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vPT09MCYmKDAsRG4udGhyb3dJdGVyYXRvckFjY2Vzc0Vycm9yKSgpLHRoaXMuby09MSx0aGlzfSx0aGlzLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vPT09dGhpcy5jb250YWluZXIuc2l6ZSgpJiYoMCxEbi50aHJvd0l0ZXJhdG9yQWNjZXNzRXJyb3IpKCksdGhpcy5vKz0xLHRoaXN9KToodGhpcy5wcmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vPT09dGhpcy5jb250YWluZXIuc2l6ZSgpLTEmJigwLERuLnRocm93SXRlcmF0b3JBY2Nlc3NFcnJvcikoKSx0aGlzLm8rPTEsdGhpc30sdGhpcy5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubz09PS0xJiYoMCxEbi50aHJvd0l0ZXJhdG9yQWNjZXNzRXJyb3IpKCksdGhpcy5vLT0xLHRoaXN9KX1nZXQgcG9pbnRlcigpe3JldHVybiB0aGlzLmNvbnRhaW5lci5nZXRFbGVtZW50QnlQb3ModGhpcy5vKX1zZXQgcG9pbnRlcihlKXt0aGlzLmNvbnRhaW5lci5zZXRFbGVtZW50QnlQb3ModGhpcy5vLGUpfX07am4uUmFuZG9tSXRlcmF0b3I9ZGF9KTt2YXIgcnA9TShGbj0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShGbixcInRcIix7dmFsdWU6ITB9KTtGbi5kZWZhdWx0PXZvaWQgMDt2YXIgSTE9UjEocW4oKSksVDE9cGEoKTtmdW5jdGlvbiBSMSh0KXtyZXR1cm4gdCYmdC50P3Q6e2RlZmF1bHQ6dH19dmFyIHdyPWNsYXNzIHQgZXh0ZW5kcyBUMS5SYW5kb21JdGVyYXRvcntjb25zdHJ1Y3RvcihlLHIsaSl7c3VwZXIoZSxpKSx0aGlzLmNvbnRhaW5lcj1yfWNvcHkoKXtyZXR1cm4gbmV3IHQodGhpcy5vLHRoaXMuY29udGFpbmVyLHRoaXMuaXRlcmF0b3JUeXBlKX19LGdhPWNsYXNzIGV4dGVuZHMgSTEuZGVmYXVsdHtjb25zdHJ1Y3RvcihlPVtdLHI9ITApe2lmKHN1cGVyKCksQXJyYXkuaXNBcnJheShlKSl0aGlzLko9cj9bLi4uZV06ZSx0aGlzLmk9ZS5sZW5ndGg7ZWxzZXt0aGlzLko9W107bGV0IGk9dGhpcztlLmZvckVhY2goZnVuY3Rpb24obil7aS5wdXNoQmFjayhuKX0pfX1jbGVhcigpe3RoaXMuaT0wLHRoaXMuSi5sZW5ndGg9MH1iZWdpbigpe3JldHVybiBuZXcgd3IoMCx0aGlzKX1lbmQoKXtyZXR1cm4gbmV3IHdyKHRoaXMuaSx0aGlzKX1yQmVnaW4oKXtyZXR1cm4gbmV3IHdyKHRoaXMuaS0xLHRoaXMsMSl9ckVuZCgpe3JldHVybiBuZXcgd3IoLTEsdGhpcywxKX1mcm9udCgpe3JldHVybiB0aGlzLkpbMF19YmFjaygpe3JldHVybiB0aGlzLkpbdGhpcy5pLTFdfWdldEVsZW1lbnRCeVBvcyhlKXtpZihlPDB8fGU+dGhpcy5pLTEpdGhyb3cgbmV3IFJhbmdlRXJyb3I7cmV0dXJuIHRoaXMuSltlXX1lcmFzZUVsZW1lbnRCeVBvcyhlKXtpZihlPDB8fGU+dGhpcy5pLTEpdGhyb3cgbmV3IFJhbmdlRXJyb3I7cmV0dXJuIHRoaXMuSi5zcGxpY2UoZSwxKSx0aGlzLmktPTEsdGhpcy5pfWVyYXNlRWxlbWVudEJ5VmFsdWUoZSl7bGV0IHI9MDtmb3IobGV0IGk9MDtpPHRoaXMuaTsrK2kpdGhpcy5KW2ldIT09ZSYmKHRoaXMuSltyKytdPXRoaXMuSltpXSk7cmV0dXJuIHRoaXMuaT10aGlzLkoubGVuZ3RoPXIsdGhpcy5pfWVyYXNlRWxlbWVudEJ5SXRlcmF0b3IoZSl7bGV0IHI9ZS5vO3JldHVybiBlPWUubmV4dCgpLHRoaXMuZXJhc2VFbGVtZW50QnlQb3MociksZX1wdXNoQmFjayhlKXtyZXR1cm4gdGhpcy5KLnB1c2goZSksdGhpcy5pKz0xLHRoaXMuaX1wb3BCYWNrKCl7aWYodGhpcy5pIT09MClyZXR1cm4gdGhpcy5pLT0xLHRoaXMuSi5wb3AoKX1zZXRFbGVtZW50QnlQb3MoZSxyKXtpZihlPDB8fGU+dGhpcy5pLTEpdGhyb3cgbmV3IFJhbmdlRXJyb3I7dGhpcy5KW2VdPXJ9aW5zZXJ0KGUscixpPTEpe2lmKGU8MHx8ZT50aGlzLmkpdGhyb3cgbmV3IFJhbmdlRXJyb3I7cmV0dXJuIHRoaXMuSi5zcGxpY2UoZSwwLC4uLm5ldyBBcnJheShpKS5maWxsKHIpKSx0aGlzLmkrPWksdGhpcy5pfWZpbmQoZSl7Zm9yKGxldCByPTA7cjx0aGlzLmk7KytyKWlmKHRoaXMuSltyXT09PWUpcmV0dXJuIG5ldyB3cihyLHRoaXMpO3JldHVybiB0aGlzLmVuZCgpfXJldmVyc2UoKXt0aGlzLkoucmV2ZXJzZSgpfXVuaXF1ZSgpe2xldCBlPTE7Zm9yKGxldCByPTE7cjx0aGlzLmk7KytyKXRoaXMuSltyXSE9PXRoaXMuSltyLTFdJiYodGhpcy5KW2UrK109dGhpcy5KW3JdKTtyZXR1cm4gdGhpcy5pPXRoaXMuSi5sZW5ndGg9ZSx0aGlzLml9c29ydChlKXt0aGlzLkouc29ydChlKX1mb3JFYWNoKGUpe2ZvcihsZXQgcj0wO3I8dGhpcy5pOysrcillKHRoaXMuSltyXSxyLHRoaXMpfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIGZ1bmN0aW9uKigpe3lpZWxkKnRoaXMuSn0uYmluZCh0aGlzKSgpfX0sQzE9Z2E7Rm4uZGVmYXVsdD1DMX0pO3ZhciBpcD1NKFduPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KFduLFwidFwiLHt2YWx1ZTohMH0pO1duLmRlZmF1bHQ9dm9pZCAwO3ZhciBCMT1PMShxbigpKSxQMT1hdCgpLF9yPWx0KCk7ZnVuY3Rpb24gTzEodCl7cmV0dXJuIHQmJnQudD90OntkZWZhdWx0OnR9fXZhciBtcj1jbGFzcyB0IGV4dGVuZHMgUDEuQ29udGFpbmVySXRlcmF0b3J7Y29uc3RydWN0b3IoZSxyLGksbil7c3VwZXIobiksdGhpcy5vPWUsdGhpcy5oPXIsdGhpcy5jb250YWluZXI9aSx0aGlzLml0ZXJhdG9yVHlwZT09PTA/KHRoaXMucHJlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuby5MPT09dGhpcy5oJiYoMCxfci50aHJvd0l0ZXJhdG9yQWNjZXNzRXJyb3IpKCksdGhpcy5vPXRoaXMuby5MLHRoaXN9LHRoaXMubmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm89PT10aGlzLmgmJigwLF9yLnRocm93SXRlcmF0b3JBY2Nlc3NFcnJvcikoKSx0aGlzLm89dGhpcy5vLkIsdGhpc30pOih0aGlzLnByZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm8uQj09PXRoaXMuaCYmKDAsX3IudGhyb3dJdGVyYXRvckFjY2Vzc0Vycm9yKSgpLHRoaXMubz10aGlzLm8uQix0aGlzfSx0aGlzLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vPT09dGhpcy5oJiYoMCxfci50aHJvd0l0ZXJhdG9yQWNjZXNzRXJyb3IpKCksdGhpcy5vPXRoaXMuby5MLHRoaXN9KX1nZXQgcG9pbnRlcigpe3JldHVybiB0aGlzLm89PT10aGlzLmgmJigwLF9yLnRocm93SXRlcmF0b3JBY2Nlc3NFcnJvcikoKSx0aGlzLm8ubH1zZXQgcG9pbnRlcihlKXt0aGlzLm89PT10aGlzLmgmJigwLF9yLnRocm93SXRlcmF0b3JBY2Nlc3NFcnJvcikoKSx0aGlzLm8ubD1lfWNvcHkoKXtyZXR1cm4gbmV3IHQodGhpcy5vLHRoaXMuaCx0aGlzLmNvbnRhaW5lcix0aGlzLml0ZXJhdG9yVHlwZSl9fSx5YT1jbGFzcyBleHRlbmRzIEIxLmRlZmF1bHR7Y29uc3RydWN0b3IoZT1bXSl7c3VwZXIoKSx0aGlzLmg9e30sdGhpcy5wPXRoaXMuXz10aGlzLmguTD10aGlzLmguQj10aGlzLmg7bGV0IHI9dGhpcztlLmZvckVhY2goZnVuY3Rpb24oaSl7ci5wdXNoQmFjayhpKX0pfVYoZSl7bGV0e0w6cixCOml9PWU7ci5CPWksaS5MPXIsZT09PXRoaXMucCYmKHRoaXMucD1pKSxlPT09dGhpcy5fJiYodGhpcy5fPXIpLHRoaXMuaS09MX1HKGUscil7bGV0IGk9ci5CLG49e2w6ZSxMOnIsQjppfTtyLkI9bixpLkw9bixyPT09dGhpcy5oJiYodGhpcy5wPW4pLGk9PT10aGlzLmgmJih0aGlzLl89biksdGhpcy5pKz0xfWNsZWFyKCl7dGhpcy5pPTAsdGhpcy5wPXRoaXMuXz10aGlzLmguTD10aGlzLmguQj10aGlzLmh9YmVnaW4oKXtyZXR1cm4gbmV3IG1yKHRoaXMucCx0aGlzLmgsdGhpcyl9ZW5kKCl7cmV0dXJuIG5ldyBtcih0aGlzLmgsdGhpcy5oLHRoaXMpfXJCZWdpbigpe3JldHVybiBuZXcgbXIodGhpcy5fLHRoaXMuaCx0aGlzLDEpfXJFbmQoKXtyZXR1cm4gbmV3IG1yKHRoaXMuaCx0aGlzLmgsdGhpcywxKX1mcm9udCgpe3JldHVybiB0aGlzLnAubH1iYWNrKCl7cmV0dXJuIHRoaXMuXy5sfWdldEVsZW1lbnRCeVBvcyhlKXtpZihlPDB8fGU+dGhpcy5pLTEpdGhyb3cgbmV3IFJhbmdlRXJyb3I7bGV0IHI9dGhpcy5wO2Zvcig7ZS0tOylyPXIuQjtyZXR1cm4gci5sfWVyYXNlRWxlbWVudEJ5UG9zKGUpe2lmKGU8MHx8ZT50aGlzLmktMSl0aHJvdyBuZXcgUmFuZ2VFcnJvcjtsZXQgcj10aGlzLnA7Zm9yKDtlLS07KXI9ci5CO3JldHVybiB0aGlzLlYociksdGhpcy5pfWVyYXNlRWxlbWVudEJ5VmFsdWUoZSl7bGV0IHI9dGhpcy5wO2Zvcig7ciE9PXRoaXMuaDspci5sPT09ZSYmdGhpcy5WKHIpLHI9ci5CO3JldHVybiB0aGlzLml9ZXJhc2VFbGVtZW50QnlJdGVyYXRvcihlKXtsZXQgcj1lLm87cmV0dXJuIHI9PT10aGlzLmgmJigwLF9yLnRocm93SXRlcmF0b3JBY2Nlc3NFcnJvcikoKSxlPWUubmV4dCgpLHRoaXMuVihyKSxlfXB1c2hCYWNrKGUpe3JldHVybiB0aGlzLkcoZSx0aGlzLl8pLHRoaXMuaX1wb3BCYWNrKCl7aWYodGhpcy5pPT09MClyZXR1cm47bGV0IGU9dGhpcy5fLmw7cmV0dXJuIHRoaXMuVih0aGlzLl8pLGV9cHVzaEZyb250KGUpe3JldHVybiB0aGlzLkcoZSx0aGlzLmgpLHRoaXMuaX1wb3BGcm9udCgpe2lmKHRoaXMuaT09PTApcmV0dXJuO2xldCBlPXRoaXMucC5sO3JldHVybiB0aGlzLlYodGhpcy5wKSxlfXNldEVsZW1lbnRCeVBvcyhlLHIpe2lmKGU8MHx8ZT50aGlzLmktMSl0aHJvdyBuZXcgUmFuZ2VFcnJvcjtsZXQgaT10aGlzLnA7Zm9yKDtlLS07KWk9aS5CO2kubD1yfWluc2VydChlLHIsaT0xKXtpZihlPDB8fGU+dGhpcy5pKXRocm93IG5ldyBSYW5nZUVycm9yO2lmKGk8PTApcmV0dXJuIHRoaXMuaTtpZihlPT09MClmb3IoO2ktLTspdGhpcy5wdXNoRnJvbnQocik7ZWxzZSBpZihlPT09dGhpcy5pKWZvcig7aS0tOyl0aGlzLnB1c2hCYWNrKHIpO2Vsc2V7bGV0IG49dGhpcy5wO2ZvcihsZXQgcz0xO3M8ZTsrK3Mpbj1uLkI7bGV0IG89bi5CO2Zvcih0aGlzLmkrPWk7aS0tOyluLkI9e2w6cixMOm59LG4uQi5MPW4sbj1uLkI7bi5CPW8sby5MPW59cmV0dXJuIHRoaXMuaX1maW5kKGUpe2xldCByPXRoaXMucDtmb3IoO3IhPT10aGlzLmg7KXtpZihyLmw9PT1lKXJldHVybiBuZXcgbXIocix0aGlzLmgsdGhpcyk7cj1yLkJ9cmV0dXJuIHRoaXMuZW5kKCl9cmV2ZXJzZSgpe2lmKHRoaXMuaTw9MSlyZXR1cm47bGV0IGU9dGhpcy5wLHI9dGhpcy5fLGk9MDtmb3IoO2k8PDE8dGhpcy5pOyl7bGV0IG49ZS5sO2UubD1yLmwsci5sPW4sZT1lLkIscj1yLkwsaSs9MX19dW5pcXVlKCl7aWYodGhpcy5pPD0xKXJldHVybiB0aGlzLmk7bGV0IGU9dGhpcy5wO2Zvcig7ZSE9PXRoaXMuaDspe2xldCByPWU7Zm9yKDtyLkIhPT10aGlzLmgmJnIubD09PXIuQi5sOylyPXIuQix0aGlzLmktPTE7ZS5CPXIuQixlLkIuTD1lLGU9ZS5CfXJldHVybiB0aGlzLml9c29ydChlKXtpZih0aGlzLmk8PTEpcmV0dXJuO2xldCByPVtdO3RoaXMuZm9yRWFjaChmdW5jdGlvbihuKXtyLnB1c2gobil9KSxyLnNvcnQoZSk7bGV0IGk9dGhpcy5wO3IuZm9yRWFjaChmdW5jdGlvbihuKXtpLmw9bixpPWkuQn0pfW1lcmdlKGUpe2xldCByPXRoaXM7aWYodGhpcy5pPT09MCllLmZvckVhY2goZnVuY3Rpb24oaSl7ci5wdXNoQmFjayhpKX0pO2Vsc2V7bGV0IGk9dGhpcy5wO2UuZm9yRWFjaChmdW5jdGlvbihuKXtmb3IoO2khPT1yLmgmJmkubDw9bjspaT1pLkI7ci5HKG4saS5MKX0pfXJldHVybiB0aGlzLml9Zm9yRWFjaChlKXtsZXQgcj10aGlzLnAsaT0wO2Zvcig7ciE9PXRoaXMuaDspZShyLmwsaSsrLHRoaXMpLHI9ci5CfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIGZ1bmN0aW9uKigpe2lmKHRoaXMuaT09PTApcmV0dXJuO2xldCBlPXRoaXMucDtmb3IoO2UhPT10aGlzLmg7KXlpZWxkIGUubCxlPWUuQn0uYmluZCh0aGlzKSgpfX0sazE9eWE7V24uZGVmYXVsdD1rMX0pO3ZhciBucD1NKCRuPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KCRuLFwidFwiLHt2YWx1ZTohMH0pOyRuLmRlZmF1bHQ9dm9pZCAwO3ZhciB4MT1MMShxbigpKSxNMT1wYSgpO2Z1bmN0aW9uIEwxKHQpe3JldHVybiB0JiZ0LnQ/dDp7ZGVmYXVsdDp0fX12YXIgdnI9Y2xhc3MgdCBleHRlbmRzIE0xLlJhbmRvbUl0ZXJhdG9ye2NvbnN0cnVjdG9yKGUscixpKXtzdXBlcihlLGkpLHRoaXMuY29udGFpbmVyPXJ9Y29weSgpe3JldHVybiBuZXcgdCh0aGlzLm8sdGhpcy5jb250YWluZXIsdGhpcy5pdGVyYXRvclR5cGUpfX0sYmE9Y2xhc3MgZXh0ZW5kcyB4MS5kZWZhdWx0e2NvbnN0cnVjdG9yKGU9W10scj00MDk2KXtzdXBlcigpLHRoaXMuaj0wLHRoaXMuRD0wLHRoaXMuUj0wLHRoaXMuTj0wLHRoaXMuUD0wLHRoaXMuQT1bXTtsZXQgaT0oKCk9PntpZih0eXBlb2YgZS5sZW5ndGg9PVwibnVtYmVyXCIpcmV0dXJuIGUubGVuZ3RoO2lmKHR5cGVvZiBlLnNpemU9PVwibnVtYmVyXCIpcmV0dXJuIGUuc2l6ZTtpZih0eXBlb2YgZS5zaXplPT1cImZ1bmN0aW9uXCIpcmV0dXJuIGUuc2l6ZSgpO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBsZW5ndGggb3Igc2l6ZSBvZiB0aGUgY29udGFpbmVyXCIpfSkoKTt0aGlzLkY9cix0aGlzLlA9TWF0aC5tYXgoTWF0aC5jZWlsKGkvdGhpcy5GKSwxKTtmb3IobGV0IHM9MDtzPHRoaXMuUDsrK3MpdGhpcy5BLnB1c2gobmV3IEFycmF5KHRoaXMuRikpO2xldCBuPU1hdGguY2VpbChpL3RoaXMuRik7dGhpcy5qPXRoaXMuUj0odGhpcy5QPj4xKS0obj4+MSksdGhpcy5EPXRoaXMuTj10aGlzLkYtaSV0aGlzLkY+PjE7bGV0IG89dGhpcztlLmZvckVhY2goZnVuY3Rpb24ocyl7by5wdXNoQmFjayhzKX0pfVQoKXtsZXQgZT1bXSxyPU1hdGgubWF4KHRoaXMuUD4+MSwxKTtmb3IobGV0IGk9MDtpPHI7KytpKWVbaV09bmV3IEFycmF5KHRoaXMuRik7Zm9yKGxldCBpPXRoaXMuajtpPHRoaXMuUDsrK2kpZVtlLmxlbmd0aF09dGhpcy5BW2ldO2ZvcihsZXQgaT0wO2k8dGhpcy5SOysraSllW2UubGVuZ3RoXT10aGlzLkFbaV07ZVtlLmxlbmd0aF09Wy4uLnRoaXMuQVt0aGlzLlJdXSx0aGlzLmo9cix0aGlzLlI9ZS5sZW5ndGgtMTtmb3IobGV0IGk9MDtpPHI7KytpKWVbZS5sZW5ndGhdPW5ldyBBcnJheSh0aGlzLkYpO3RoaXMuQT1lLHRoaXMuUD1lLmxlbmd0aH1PKGUpe2xldCByPXRoaXMuRCtlKzEsaT1yJXRoaXMuRixuPWktMSxvPXRoaXMuaisoci1pKS90aGlzLkY7cmV0dXJuIGk9PT0wJiYoby09MSksbyU9dGhpcy5QLG48MCYmKG4rPXRoaXMuRikse2N1ck5vZGVCdWNrZXRJbmRleDpvLGN1ck5vZGVQb2ludGVySW5kZXg6bn19Y2xlYXIoKXt0aGlzLkE9W25ldyBBcnJheSh0aGlzLkYpXSx0aGlzLlA9MSx0aGlzLmo9dGhpcy5SPXRoaXMuaT0wLHRoaXMuRD10aGlzLk49dGhpcy5GPj4xfWJlZ2luKCl7cmV0dXJuIG5ldyB2cigwLHRoaXMpfWVuZCgpe3JldHVybiBuZXcgdnIodGhpcy5pLHRoaXMpfXJCZWdpbigpe3JldHVybiBuZXcgdnIodGhpcy5pLTEsdGhpcywxKX1yRW5kKCl7cmV0dXJuIG5ldyB2cigtMSx0aGlzLDEpfWZyb250KCl7aWYodGhpcy5pIT09MClyZXR1cm4gdGhpcy5BW3RoaXMual1bdGhpcy5EXX1iYWNrKCl7aWYodGhpcy5pIT09MClyZXR1cm4gdGhpcy5BW3RoaXMuUl1bdGhpcy5OXX1wdXNoQmFjayhlKXtyZXR1cm4gdGhpcy5pJiYodGhpcy5OPHRoaXMuRi0xP3RoaXMuTis9MTp0aGlzLlI8dGhpcy5QLTE/KHRoaXMuUis9MSx0aGlzLk49MCk6KHRoaXMuUj0wLHRoaXMuTj0wKSx0aGlzLlI9PT10aGlzLmomJnRoaXMuTj09PXRoaXMuRCYmdGhpcy5UKCkpLHRoaXMuaSs9MSx0aGlzLkFbdGhpcy5SXVt0aGlzLk5dPWUsdGhpcy5pfXBvcEJhY2soKXtpZih0aGlzLmk9PT0wKXJldHVybjtsZXQgZT10aGlzLkFbdGhpcy5SXVt0aGlzLk5dO3JldHVybiB0aGlzLmkhPT0xJiYodGhpcy5OPjA/dGhpcy5OLT0xOnRoaXMuUj4wPyh0aGlzLlItPTEsdGhpcy5OPXRoaXMuRi0xKToodGhpcy5SPXRoaXMuUC0xLHRoaXMuTj10aGlzLkYtMSkpLHRoaXMuaS09MSxlfXB1c2hGcm9udChlKXtyZXR1cm4gdGhpcy5pJiYodGhpcy5EPjA/dGhpcy5ELT0xOnRoaXMuaj4wPyh0aGlzLmotPTEsdGhpcy5EPXRoaXMuRi0xKToodGhpcy5qPXRoaXMuUC0xLHRoaXMuRD10aGlzLkYtMSksdGhpcy5qPT09dGhpcy5SJiZ0aGlzLkQ9PT10aGlzLk4mJnRoaXMuVCgpKSx0aGlzLmkrPTEsdGhpcy5BW3RoaXMual1bdGhpcy5EXT1lLHRoaXMuaX1wb3BGcm9udCgpe2lmKHRoaXMuaT09PTApcmV0dXJuO2xldCBlPXRoaXMuQVt0aGlzLmpdW3RoaXMuRF07cmV0dXJuIHRoaXMuaSE9PTEmJih0aGlzLkQ8dGhpcy5GLTE/dGhpcy5EKz0xOnRoaXMuajx0aGlzLlAtMT8odGhpcy5qKz0xLHRoaXMuRD0wKToodGhpcy5qPTAsdGhpcy5EPTApKSx0aGlzLmktPTEsZX1nZXRFbGVtZW50QnlQb3MoZSl7aWYoZTwwfHxlPnRoaXMuaS0xKXRocm93IG5ldyBSYW5nZUVycm9yO2xldHtjdXJOb2RlQnVja2V0SW5kZXg6cixjdXJOb2RlUG9pbnRlckluZGV4Oml9PXRoaXMuTyhlKTtyZXR1cm4gdGhpcy5BW3JdW2ldfXNldEVsZW1lbnRCeVBvcyhlLHIpe2lmKGU8MHx8ZT50aGlzLmktMSl0aHJvdyBuZXcgUmFuZ2VFcnJvcjtsZXR7Y3VyTm9kZUJ1Y2tldEluZGV4OmksY3VyTm9kZVBvaW50ZXJJbmRleDpufT10aGlzLk8oZSk7dGhpcy5BW2ldW25dPXJ9aW5zZXJ0KGUscixpPTEpe2lmKGU8MHx8ZT50aGlzLmkpdGhyb3cgbmV3IFJhbmdlRXJyb3I7aWYoZT09PTApZm9yKDtpLS07KXRoaXMucHVzaEZyb250KHIpO2Vsc2UgaWYoZT09PXRoaXMuaSlmb3IoO2ktLTspdGhpcy5wdXNoQmFjayhyKTtlbHNle2xldCBuPVtdO2ZvcihsZXQgbz1lO288dGhpcy5pOysrbyluLnB1c2godGhpcy5nZXRFbGVtZW50QnlQb3MobykpO3RoaXMuY3V0KGUtMSk7Zm9yKGxldCBvPTA7bzxpOysrbyl0aGlzLnB1c2hCYWNrKHIpO2ZvcihsZXQgbz0wO288bi5sZW5ndGg7KytvKXRoaXMucHVzaEJhY2sobltvXSl9cmV0dXJuIHRoaXMuaX1jdXQoZSl7aWYoZTwwKXJldHVybiB0aGlzLmNsZWFyKCksMDtsZXR7Y3VyTm9kZUJ1Y2tldEluZGV4OnIsY3VyTm9kZVBvaW50ZXJJbmRleDppfT10aGlzLk8oZSk7cmV0dXJuIHRoaXMuUj1yLHRoaXMuTj1pLHRoaXMuaT1lKzEsdGhpcy5pfWVyYXNlRWxlbWVudEJ5UG9zKGUpe2lmKGU8MHx8ZT50aGlzLmktMSl0aHJvdyBuZXcgUmFuZ2VFcnJvcjtpZihlPT09MCl0aGlzLnBvcEZyb250KCk7ZWxzZSBpZihlPT09dGhpcy5pLTEpdGhpcy5wb3BCYWNrKCk7ZWxzZXtsZXQgcj1bXTtmb3IobGV0IG49ZSsxO248dGhpcy5pOysrbilyLnB1c2godGhpcy5nZXRFbGVtZW50QnlQb3MobikpO3RoaXMuY3V0KGUpLHRoaXMucG9wQmFjaygpO2xldCBpPXRoaXM7ci5mb3JFYWNoKGZ1bmN0aW9uKG4pe2kucHVzaEJhY2sobil9KX1yZXR1cm4gdGhpcy5pfWVyYXNlRWxlbWVudEJ5VmFsdWUoZSl7aWYodGhpcy5pPT09MClyZXR1cm4gMDtsZXQgcj1bXTtmb3IobGV0IG49MDtuPHRoaXMuaTsrK24pe2xldCBvPXRoaXMuZ2V0RWxlbWVudEJ5UG9zKG4pO28hPT1lJiZyLnB1c2gobyl9bGV0IGk9ci5sZW5ndGg7Zm9yKGxldCBuPTA7bjxpOysrbil0aGlzLnNldEVsZW1lbnRCeVBvcyhuLHJbbl0pO3JldHVybiB0aGlzLmN1dChpLTEpfWVyYXNlRWxlbWVudEJ5SXRlcmF0b3IoZSl7bGV0IHI9ZS5vO3JldHVybiB0aGlzLmVyYXNlRWxlbWVudEJ5UG9zKHIpLGU9ZS5uZXh0KCksZX1maW5kKGUpe2ZvcihsZXQgcj0wO3I8dGhpcy5pOysrcilpZih0aGlzLmdldEVsZW1lbnRCeVBvcyhyKT09PWUpcmV0dXJuIG5ldyB2cihyLHRoaXMpO3JldHVybiB0aGlzLmVuZCgpfXJldmVyc2UoKXtsZXQgZT0wLHI9dGhpcy5pLTE7Zm9yKDtlPHI7KXtsZXQgaT10aGlzLmdldEVsZW1lbnRCeVBvcyhlKTt0aGlzLnNldEVsZW1lbnRCeVBvcyhlLHRoaXMuZ2V0RWxlbWVudEJ5UG9zKHIpKSx0aGlzLnNldEVsZW1lbnRCeVBvcyhyLGkpLGUrPTEsci09MX19dW5pcXVlKCl7aWYodGhpcy5pPD0xKXJldHVybiB0aGlzLmk7bGV0IGU9MSxyPXRoaXMuZ2V0RWxlbWVudEJ5UG9zKDApO2ZvcihsZXQgaT0xO2k8dGhpcy5pOysraSl7bGV0IG49dGhpcy5nZXRFbGVtZW50QnlQb3MoaSk7biE9PXImJihyPW4sdGhpcy5zZXRFbGVtZW50QnlQb3MoZSsrLG4pKX1mb3IoO3RoaXMuaT5lOyl0aGlzLnBvcEJhY2soKTtyZXR1cm4gdGhpcy5pfXNvcnQoZSl7bGV0IHI9W107Zm9yKGxldCBpPTA7aTx0aGlzLmk7KytpKXIucHVzaCh0aGlzLmdldEVsZW1lbnRCeVBvcyhpKSk7ci5zb3J0KGUpO2ZvcihsZXQgaT0wO2k8dGhpcy5pOysraSl0aGlzLnNldEVsZW1lbnRCeVBvcyhpLHJbaV0pfXNocmlua1RvRml0KCl7aWYodGhpcy5pPT09MClyZXR1cm47bGV0IGU9W107dGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHIpe2UucHVzaChyKX0pLHRoaXMuUD1NYXRoLm1heChNYXRoLmNlaWwodGhpcy5pL3RoaXMuRiksMSksdGhpcy5pPXRoaXMuaj10aGlzLlI9dGhpcy5EPXRoaXMuTj0wLHRoaXMuQT1bXTtmb3IobGV0IHI9MDtyPHRoaXMuUDsrK3IpdGhpcy5BLnB1c2gobmV3IEFycmF5KHRoaXMuRikpO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKXRoaXMucHVzaEJhY2soZVtyXSl9Zm9yRWFjaChlKXtmb3IobGV0IHI9MDtyPHRoaXMuaTsrK3IpZSh0aGlzLmdldEVsZW1lbnRCeVBvcyhyKSxyLHRoaXMpfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIGZ1bmN0aW9uKigpe2ZvcihsZXQgZT0wO2U8dGhpcy5pOysrZSl5aWVsZCB0aGlzLmdldEVsZW1lbnRCeVBvcyhlKX0uYmluZCh0aGlzKSgpfX0sVTE9YmE7JG4uZGVmYXVsdD1VMX0pO3ZhciBzcD1NKFhyPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KFhyLFwidFwiLHt2YWx1ZTohMH0pO1hyLlRyZWVOb2RlRW5hYmxlSW5kZXg9WHIuVHJlZU5vZGU9dm9pZCAwO3ZhciBIbj1jbGFzc3tjb25zdHJ1Y3RvcihlLHIpe3RoaXMuZWU9MSx0aGlzLnU9dm9pZCAwLHRoaXMubD12b2lkIDAsdGhpcy5VPXZvaWQgMCx0aGlzLlc9dm9pZCAwLHRoaXMudHQ9dm9pZCAwLHRoaXMudT1lLHRoaXMubD1yfUwoKXtsZXQgZT10aGlzO2lmKGUuZWU9PT0xJiZlLnR0LnR0PT09ZSllPWUuVztlbHNlIGlmKGUuVSlmb3IoZT1lLlU7ZS5XOyllPWUuVztlbHNle2xldCByPWUudHQ7Zm9yKDtyLlU9PT1lOyllPXIscj1lLnR0O2U9cn1yZXR1cm4gZX1CKCl7bGV0IGU9dGhpcztpZihlLlcpe2ZvcihlPWUuVztlLlU7KWU9ZS5VO3JldHVybiBlfWVsc2V7bGV0IHI9ZS50dDtmb3IoO3IuVz09PWU7KWU9cixyPWUudHQ7cmV0dXJuIGUuVyE9PXI/cjplfX10ZSgpe2xldCBlPXRoaXMudHQscj10aGlzLlcsaT1yLlU7cmV0dXJuIGUudHQ9PT10aGlzP2UudHQ9cjplLlU9PT10aGlzP2UuVT1yOmUuVz1yLHIudHQ9ZSxyLlU9dGhpcyx0aGlzLnR0PXIsdGhpcy5XPWksaSYmKGkudHQ9dGhpcykscn1zZSgpe2xldCBlPXRoaXMudHQscj10aGlzLlUsaT1yLlc7cmV0dXJuIGUudHQ9PT10aGlzP2UudHQ9cjplLlU9PT10aGlzP2UuVT1yOmUuVz1yLHIudHQ9ZSxyLlc9dGhpcyx0aGlzLnR0PXIsdGhpcy5VPWksaSYmKGkudHQ9dGhpcykscn19O1hyLlRyZWVOb2RlPUhuO3ZhciB3YT1jbGFzcyBleHRlbmRzIEhue2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnJ0PTF9dGUoKXtsZXQgZT1zdXBlci50ZSgpO3JldHVybiB0aGlzLmllKCksZS5pZSgpLGV9c2UoKXtsZXQgZT1zdXBlci5zZSgpO3JldHVybiB0aGlzLmllKCksZS5pZSgpLGV9aWUoKXt0aGlzLnJ0PTEsdGhpcy5VJiYodGhpcy5ydCs9dGhpcy5VLnJ0KSx0aGlzLlcmJih0aGlzLnJ0Kz10aGlzLlcucnQpfX07WHIuVHJlZU5vZGVFbmFibGVJbmRleD13YX0pO3ZhciBtYT1NKFZuPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KFZuLFwidFwiLHt2YWx1ZTohMH0pO1ZuLmRlZmF1bHQ9dm9pZCAwO3ZhciBvcD1zcCgpLE4xPWF0KCksYXA9bHQoKSxfYT1jbGFzcyBleHRlbmRzIE4xLkNvbnRhaW5lcntjb25zdHJ1Y3RvcihlPWZ1bmN0aW9uKGksbil7cmV0dXJuIGk8bj8tMTppPm4/MTowfSxyPSExKXtzdXBlcigpLHRoaXMuWT12b2lkIDAsdGhpcy52PWUscj8odGhpcy5yZT1vcC5UcmVlTm9kZUVuYWJsZUluZGV4LHRoaXMuTT1mdW5jdGlvbihpLG4sbyl7bGV0IHM9dGhpcy5uZShpLG4sbyk7aWYocyl7bGV0IGE9cy50dDtmb3IoO2EhPT10aGlzLmg7KWEucnQrPTEsYT1hLnR0O2xldCB1PXRoaXMuaGUocyk7aWYodSl7bGV0e3BhcmVudE5vZGU6YyxncmFuZFBhcmVudDpoLGN1ck5vZGU6ZH09dTtjLmllKCksaC5pZSgpLGQuaWUoKX19cmV0dXJuIHRoaXMuaX0sdGhpcy5WPWZ1bmN0aW9uKGkpe2xldCBuPXRoaXMuZmUoaSk7Zm9yKDtuIT09dGhpcy5oOyluLnJ0LT0xLG49bi50dH0pOih0aGlzLnJlPW9wLlRyZWVOb2RlLHRoaXMuTT1mdW5jdGlvbihpLG4sbyl7bGV0IHM9dGhpcy5uZShpLG4sbyk7cmV0dXJuIHMmJnRoaXMuaGUocyksdGhpcy5pfSx0aGlzLlY9dGhpcy5mZSksdGhpcy5oPW5ldyB0aGlzLnJlfVgoZSxyKXtsZXQgaT10aGlzLmg7Zm9yKDtlOyl7bGV0IG49dGhpcy52KGUudSxyKTtpZihuPDApZT1lLlc7ZWxzZSBpZihuPjApaT1lLGU9ZS5VO2Vsc2UgcmV0dXJuIGV9cmV0dXJuIGl9WihlLHIpe2xldCBpPXRoaXMuaDtmb3IoO2U7KXRoaXMudihlLnUscik8PTA/ZT1lLlc6KGk9ZSxlPWUuVSk7cmV0dXJuIGl9JChlLHIpe2xldCBpPXRoaXMuaDtmb3IoO2U7KXtsZXQgbj10aGlzLnYoZS51LHIpO2lmKG48MClpPWUsZT1lLlc7ZWxzZSBpZihuPjApZT1lLlU7ZWxzZSByZXR1cm4gZX1yZXR1cm4gaX1ycihlLHIpe2xldCBpPXRoaXMuaDtmb3IoO2U7KXRoaXMudihlLnUscik8MD8oaT1lLGU9ZS5XKTplPWUuVTtyZXR1cm4gaX11ZShlKXtmb3IoOzspe2xldCByPWUudHQ7aWYocj09PXRoaXMuaClyZXR1cm47aWYoZS5lZT09PTEpe2UuZWU9MDtyZXR1cm59aWYoZT09PXIuVSl7bGV0IGk9ci5XO2lmKGkuZWU9PT0xKWkuZWU9MCxyLmVlPTEscj09PXRoaXMuWT90aGlzLlk9ci50ZSgpOnIudGUoKTtlbHNlIGlmKGkuVyYmaS5XLmVlPT09MSl7aS5lZT1yLmVlLHIuZWU9MCxpLlcuZWU9MCxyPT09dGhpcy5ZP3RoaXMuWT1yLnRlKCk6ci50ZSgpO3JldHVybn1lbHNlIGkuVSYmaS5VLmVlPT09MT8oaS5lZT0xLGkuVS5lZT0wLGkuc2UoKSk6KGkuZWU9MSxlPXIpfWVsc2V7bGV0IGk9ci5VO2lmKGkuZWU9PT0xKWkuZWU9MCxyLmVlPTEscj09PXRoaXMuWT90aGlzLlk9ci5zZSgpOnIuc2UoKTtlbHNlIGlmKGkuVSYmaS5VLmVlPT09MSl7aS5lZT1yLmVlLHIuZWU9MCxpLlUuZWU9MCxyPT09dGhpcy5ZP3RoaXMuWT1yLnNlKCk6ci5zZSgpO3JldHVybn1lbHNlIGkuVyYmaS5XLmVlPT09MT8oaS5lZT0xLGkuVy5lZT0wLGkudGUoKSk6KGkuZWU9MSxlPXIpfX19ZmUoZSl7aWYodGhpcy5pPT09MSlyZXR1cm4gdGhpcy5jbGVhcigpLHRoaXMuaDtsZXQgcj1lO2Zvcig7ci5VfHxyLlc7KXtpZihyLlcpZm9yKHI9ci5XO3IuVTspcj1yLlU7ZWxzZSByPXIuVTtbZS51LHIudV09W3IudSxlLnVdLFtlLmwsci5sXT1bci5sLGUubF0sZT1yfXRoaXMuaC5VPT09cj90aGlzLmguVT1yLnR0OnRoaXMuaC5XPT09ciYmKHRoaXMuaC5XPXIudHQpLHRoaXMudWUocik7bGV0IGk9ci50dDtyZXR1cm4gcj09PWkuVT9pLlU9dm9pZCAwOmkuVz12b2lkIDAsdGhpcy5pLT0xLHRoaXMuWS5lZT0wLGl9b2UoZSxyKXtyZXR1cm4gZT09PXZvaWQgMD8hMTp0aGlzLm9lKGUuVSxyKXx8cihlKT8hMDp0aGlzLm9lKGUuVyxyKX1oZShlKXtmb3IoOzspe2xldCByPWUudHQ7aWYoci5lZT09PTApcmV0dXJuO2xldCBpPXIudHQ7aWYocj09PWkuVSl7bGV0IG49aS5XO2lmKG4mJm4uZWU9PT0xKXtpZihuLmVlPXIuZWU9MCxpPT09dGhpcy5ZKXJldHVybjtpLmVlPTEsZT1pO2NvbnRpbnVlfWVsc2UgaWYoZT09PXIuVyl7aWYoZS5lZT0wLGUuVSYmKGUuVS50dD1yKSxlLlcmJihlLlcudHQ9aSksci5XPWUuVSxpLlU9ZS5XLGUuVT1yLGUuVz1pLGk9PT10aGlzLlkpdGhpcy5ZPWUsdGhpcy5oLnR0PWU7ZWxzZXtsZXQgbz1pLnR0O28uVT09PWk/by5VPWU6by5XPWV9cmV0dXJuIGUudHQ9aS50dCxyLnR0PWUsaS50dD1lLGkuZWU9MSx7cGFyZW50Tm9kZTpyLGdyYW5kUGFyZW50OmksY3VyTm9kZTplfX1lbHNlIHIuZWU9MCxpPT09dGhpcy5ZP3RoaXMuWT1pLnNlKCk6aS5zZSgpLGkuZWU9MX1lbHNle2xldCBuPWkuVTtpZihuJiZuLmVlPT09MSl7aWYobi5lZT1yLmVlPTAsaT09PXRoaXMuWSlyZXR1cm47aS5lZT0xLGU9aTtjb250aW51ZX1lbHNlIGlmKGU9PT1yLlUpe2lmKGUuZWU9MCxlLlUmJihlLlUudHQ9aSksZS5XJiYoZS5XLnR0PXIpLGkuVz1lLlUsci5VPWUuVyxlLlU9aSxlLlc9cixpPT09dGhpcy5ZKXRoaXMuWT1lLHRoaXMuaC50dD1lO2Vsc2V7bGV0IG89aS50dDtvLlU9PT1pP28uVT1lOm8uVz1lfXJldHVybiBlLnR0PWkudHQsci50dD1lLGkudHQ9ZSxpLmVlPTEse3BhcmVudE5vZGU6cixncmFuZFBhcmVudDppLGN1ck5vZGU6ZX19ZWxzZSByLmVlPTAsaT09PXRoaXMuWT90aGlzLlk9aS50ZSgpOmkudGUoKSxpLmVlPTF9cmV0dXJufX1uZShlLHIsaSl7aWYodGhpcy5ZPT09dm9pZCAwKXt0aGlzLmkrPTEsdGhpcy5ZPW5ldyB0aGlzLnJlKGUsciksdGhpcy5ZLmVlPTAsdGhpcy5ZLnR0PXRoaXMuaCx0aGlzLmgudHQ9dGhpcy5ZLHRoaXMuaC5VPXRoaXMuWSx0aGlzLmguVz10aGlzLlk7cmV0dXJufWxldCBuLG89dGhpcy5oLlUscz10aGlzLnYoby51LGUpO2lmKHM9PT0wKXtvLmw9cjtyZXR1cm59ZWxzZSBpZihzPjApby5VPW5ldyB0aGlzLnJlKGUsciksby5VLnR0PW8sbj1vLlUsdGhpcy5oLlU9bjtlbHNle2xldCBhPXRoaXMuaC5XLHU9dGhpcy52KGEudSxlKTtpZih1PT09MCl7YS5sPXI7cmV0dXJufWVsc2UgaWYodTwwKWEuVz1uZXcgdGhpcy5yZShlLHIpLGEuVy50dD1hLG49YS5XLHRoaXMuaC5XPW47ZWxzZXtpZihpIT09dm9pZCAwKXtsZXQgYz1pLm87aWYoYyE9PXRoaXMuaCl7bGV0IGg9dGhpcy52KGMudSxlKTtpZihoPT09MCl7Yy5sPXI7cmV0dXJufWVsc2UgaWYoaD4wKXtsZXQgZD1jLkwoKSxnPXRoaXMudihkLnUsZSk7aWYoZz09PTApe2QubD1yO3JldHVybn1lbHNlIGc8MCYmKG49bmV3IHRoaXMucmUoZSxyKSxkLlc9PT12b2lkIDA/KGQuVz1uLG4udHQ9ZCk6KGMuVT1uLG4udHQ9YykpfX19aWYobj09PXZvaWQgMClmb3Iobj10aGlzLlk7Oyl7bGV0IGM9dGhpcy52KG4udSxlKTtpZihjPjApe2lmKG4uVT09PXZvaWQgMCl7bi5VPW5ldyB0aGlzLnJlKGUsciksbi5VLnR0PW4sbj1uLlU7YnJlYWt9bj1uLlV9ZWxzZSBpZihjPDApe2lmKG4uVz09PXZvaWQgMCl7bi5XPW5ldyB0aGlzLnJlKGUsciksbi5XLnR0PW4sbj1uLlc7YnJlYWt9bj1uLld9ZWxzZXtuLmw9cjtyZXR1cm59fX19cmV0dXJuIHRoaXMuaSs9MSxufUkoZSxyKXtmb3IoO2U7KXtsZXQgaT10aGlzLnYoZS51LHIpO2lmKGk8MCllPWUuVztlbHNlIGlmKGk+MCllPWUuVTtlbHNlIHJldHVybiBlfXJldHVybiBlfHx0aGlzLmh9Y2xlYXIoKXt0aGlzLmk9MCx0aGlzLlk9dm9pZCAwLHRoaXMuaC50dD12b2lkIDAsdGhpcy5oLlU9dGhpcy5oLlc9dm9pZCAwfXVwZGF0ZUtleUJ5SXRlcmF0b3IoZSxyKXtsZXQgaT1lLm87aWYoaT09PXRoaXMuaCYmKDAsYXAudGhyb3dJdGVyYXRvckFjY2Vzc0Vycm9yKSgpLHRoaXMuaT09PTEpcmV0dXJuIGkudT1yLCEwO2lmKGk9PT10aGlzLmguVSlyZXR1cm4gdGhpcy52KGkuQigpLnUscik+MD8oaS51PXIsITApOiExO2lmKGk9PT10aGlzLmguVylyZXR1cm4gdGhpcy52KGkuTCgpLnUscik8MD8oaS51PXIsITApOiExO2xldCBuPWkuTCgpLnU7aWYodGhpcy52KG4scik+PTApcmV0dXJuITE7bGV0IG89aS5CKCkudTtyZXR1cm4gdGhpcy52KG8scik8PTA/ITE6KGkudT1yLCEwKX1lcmFzZUVsZW1lbnRCeVBvcyhlKXtpZihlPDB8fGU+dGhpcy5pLTEpdGhyb3cgbmV3IFJhbmdlRXJyb3I7bGV0IHI9MCxpPXRoaXM7cmV0dXJuIHRoaXMub2UodGhpcy5ZLGZ1bmN0aW9uKG4pe3JldHVybiBlPT09cj8oaS5WKG4pLCEwKToocis9MSwhMSl9KSx0aGlzLml9ZXJhc2VFbGVtZW50QnlLZXkoZSl7aWYodGhpcy5pPT09MClyZXR1cm4hMTtsZXQgcj10aGlzLkkodGhpcy5ZLGUpO3JldHVybiByPT09dGhpcy5oPyExOih0aGlzLlYociksITApfWVyYXNlRWxlbWVudEJ5SXRlcmF0b3IoZSl7bGV0IHI9ZS5vO3I9PT10aGlzLmgmJigwLGFwLnRocm93SXRlcmF0b3JBY2Nlc3NFcnJvcikoKTtsZXQgaT1yLlc9PT12b2lkIDA7cmV0dXJuIGUuaXRlcmF0b3JUeXBlPT09MD9pJiZlLm5leHQoKTooIWl8fHIuVT09PXZvaWQgMCkmJmUubmV4dCgpLHRoaXMuVihyKSxlfWZvckVhY2goZSl7bGV0IHI9MDtmb3IobGV0IGkgb2YgdGhpcyllKGkscisrLHRoaXMpfWdldEVsZW1lbnRCeVBvcyhlKXtpZihlPDB8fGU+dGhpcy5pLTEpdGhyb3cgbmV3IFJhbmdlRXJyb3I7bGV0IHIsaT0wO2ZvcihsZXQgbiBvZiB0aGlzKXtpZihpPT09ZSl7cj1uO2JyZWFrfWkrPTF9cmV0dXJuIHJ9Z2V0SGVpZ2h0KCl7aWYodGhpcy5pPT09MClyZXR1cm4gMDtsZXQgZT1mdW5jdGlvbihyKXtyZXR1cm4gcj9NYXRoLm1heChlKHIuVSksZShyLlcpKSsxOjB9O3JldHVybiBlKHRoaXMuWSl9fSxxMT1fYTtWbi5kZWZhdWx0PXExfSk7dmFyIEVhPU0oS249PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoS24sXCJ0XCIse3ZhbHVlOiEwfSk7S24uZGVmYXVsdD12b2lkIDA7dmFyIEQxPWF0KCksem49bHQoKSx2YT1jbGFzcyBleHRlbmRzIEQxLkNvbnRhaW5lckl0ZXJhdG9ye2NvbnN0cnVjdG9yKGUscixpKXtzdXBlcihpKSx0aGlzLm89ZSx0aGlzLmg9cix0aGlzLml0ZXJhdG9yVHlwZT09PTA/KHRoaXMucHJlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubz09PXRoaXMuaC5VJiYoMCx6bi50aHJvd0l0ZXJhdG9yQWNjZXNzRXJyb3IpKCksdGhpcy5vPXRoaXMuby5MKCksdGhpc30sdGhpcy5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubz09PXRoaXMuaCYmKDAsem4udGhyb3dJdGVyYXRvckFjY2Vzc0Vycm9yKSgpLHRoaXMubz10aGlzLm8uQigpLHRoaXN9KToodGhpcy5wcmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vPT09dGhpcy5oLlcmJigwLHpuLnRocm93SXRlcmF0b3JBY2Nlc3NFcnJvcikoKSx0aGlzLm89dGhpcy5vLkIoKSx0aGlzfSx0aGlzLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vPT09dGhpcy5oJiYoMCx6bi50aHJvd0l0ZXJhdG9yQWNjZXNzRXJyb3IpKCksdGhpcy5vPXRoaXMuby5MKCksdGhpc30pfWdldCBpbmRleCgpe2xldCBlPXRoaXMubyxyPXRoaXMuaC50dDtpZihlPT09dGhpcy5oKXJldHVybiByP3IucnQtMTowO2xldCBpPTA7Zm9yKGUuVSYmKGkrPWUuVS5ydCk7ZSE9PXI7KXtsZXQgbj1lLnR0O2U9PT1uLlcmJihpKz0xLG4uVSYmKGkrPW4uVS5ydCkpLGU9bn1yZXR1cm4gaX19LGoxPXZhO0tuLmRlZmF1bHQ9ajF9KTt2YXIgdXA9TShHbj0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShHbixcInRcIix7dmFsdWU6ITB9KTtHbi5kZWZhdWx0PXZvaWQgMDt2YXIgRjE9bHAobWEoKSksVzE9bHAoRWEoKSksJDE9bHQoKTtmdW5jdGlvbiBscCh0KXtyZXR1cm4gdCYmdC50P3Q6e2RlZmF1bHQ6dH19dmFyIEtlPWNsYXNzIHQgZXh0ZW5kcyBXMS5kZWZhdWx0e2NvbnN0cnVjdG9yKGUscixpLG4pe3N1cGVyKGUscixuKSx0aGlzLmNvbnRhaW5lcj1pfWdldCBwb2ludGVyKCl7cmV0dXJuIHRoaXMubz09PXRoaXMuaCYmKDAsJDEudGhyb3dJdGVyYXRvckFjY2Vzc0Vycm9yKSgpLHRoaXMuby51fWNvcHkoKXtyZXR1cm4gbmV3IHQodGhpcy5vLHRoaXMuaCx0aGlzLmNvbnRhaW5lcix0aGlzLml0ZXJhdG9yVHlwZSl9fSxTYT1jbGFzcyBleHRlbmRzIEYxLmRlZmF1bHR7Y29uc3RydWN0b3IoZT1bXSxyLGkpe3N1cGVyKHIsaSk7bGV0IG49dGhpcztlLmZvckVhY2goZnVuY3Rpb24obyl7bi5pbnNlcnQobyl9KX0qSyhlKXtlIT09dm9pZCAwJiYoeWllbGQqdGhpcy5LKGUuVSkseWllbGQgZS51LHlpZWxkKnRoaXMuSyhlLlcpKX1iZWdpbigpe3JldHVybiBuZXcgS2UodGhpcy5oLlV8fHRoaXMuaCx0aGlzLmgsdGhpcyl9ZW5kKCl7cmV0dXJuIG5ldyBLZSh0aGlzLmgsdGhpcy5oLHRoaXMpfXJCZWdpbigpe3JldHVybiBuZXcgS2UodGhpcy5oLld8fHRoaXMuaCx0aGlzLmgsdGhpcywxKX1yRW5kKCl7cmV0dXJuIG5ldyBLZSh0aGlzLmgsdGhpcy5oLHRoaXMsMSl9ZnJvbnQoKXtyZXR1cm4gdGhpcy5oLlU/dGhpcy5oLlUudTp2b2lkIDB9YmFjaygpe3JldHVybiB0aGlzLmguVz90aGlzLmguVy51OnZvaWQgMH1pbnNlcnQoZSxyKXtyZXR1cm4gdGhpcy5NKGUsdm9pZCAwLHIpfWZpbmQoZSl7bGV0IHI9dGhpcy5JKHRoaXMuWSxlKTtyZXR1cm4gbmV3IEtlKHIsdGhpcy5oLHRoaXMpfWxvd2VyQm91bmQoZSl7bGV0IHI9dGhpcy5YKHRoaXMuWSxlKTtyZXR1cm4gbmV3IEtlKHIsdGhpcy5oLHRoaXMpfXVwcGVyQm91bmQoZSl7bGV0IHI9dGhpcy5aKHRoaXMuWSxlKTtyZXR1cm4gbmV3IEtlKHIsdGhpcy5oLHRoaXMpfXJldmVyc2VMb3dlckJvdW5kKGUpe2xldCByPXRoaXMuJCh0aGlzLlksZSk7cmV0dXJuIG5ldyBLZShyLHRoaXMuaCx0aGlzKX1yZXZlcnNlVXBwZXJCb3VuZChlKXtsZXQgcj10aGlzLnJyKHRoaXMuWSxlKTtyZXR1cm4gbmV3IEtlKHIsdGhpcy5oLHRoaXMpfXVuaW9uKGUpe2xldCByPXRoaXM7cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihpKXtyLmluc2VydChpKX0pLHRoaXMuaX1bU3ltYm9sLml0ZXJhdG9yXSgpe3JldHVybiB0aGlzLksodGhpcy5ZKX19LEgxPVNhO0duLmRlZmF1bHQ9SDF9KTt2YXIgY3A9TShRbj0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShRbixcInRcIix7dmFsdWU6ITB9KTtRbi5kZWZhdWx0PXZvaWQgMDt2YXIgVjE9ZnAobWEoKSksejE9ZnAoRWEoKSksSzE9bHQoKTtmdW5jdGlvbiBmcCh0KXtyZXR1cm4gdCYmdC50P3Q6e2RlZmF1bHQ6dH19dmFyIEdlPWNsYXNzIHQgZXh0ZW5kcyB6MS5kZWZhdWx0e2NvbnN0cnVjdG9yKGUscixpLG4pe3N1cGVyKGUscixuKSx0aGlzLmNvbnRhaW5lcj1pfWdldCBwb2ludGVyKCl7dGhpcy5vPT09dGhpcy5oJiYoMCxLMS50aHJvd0l0ZXJhdG9yQWNjZXNzRXJyb3IpKCk7bGV0IGU9dGhpcztyZXR1cm4gbmV3IFByb3h5KFtdLHtnZXQocixpKXtpZihpPT09XCIwXCIpcmV0dXJuIGUuby51O2lmKGk9PT1cIjFcIilyZXR1cm4gZS5vLmx9LHNldChyLGksbil7aWYoaSE9PVwiMVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJwcm9wcyBtdXN0IGJlIDFcIik7cmV0dXJuIGUuby5sPW4sITB9fSl9Y29weSgpe3JldHVybiBuZXcgdCh0aGlzLm8sdGhpcy5oLHRoaXMuY29udGFpbmVyLHRoaXMuaXRlcmF0b3JUeXBlKX19LEFhPWNsYXNzIGV4dGVuZHMgVjEuZGVmYXVsdHtjb25zdHJ1Y3RvcihlPVtdLHIsaSl7c3VwZXIocixpKTtsZXQgbj10aGlzO2UuZm9yRWFjaChmdW5jdGlvbihvKXtuLnNldEVsZW1lbnQob1swXSxvWzFdKX0pfSpLKGUpe2UhPT12b2lkIDAmJih5aWVsZCp0aGlzLksoZS5VKSx5aWVsZFtlLnUsZS5sXSx5aWVsZCp0aGlzLksoZS5XKSl9YmVnaW4oKXtyZXR1cm4gbmV3IEdlKHRoaXMuaC5VfHx0aGlzLmgsdGhpcy5oLHRoaXMpfWVuZCgpe3JldHVybiBuZXcgR2UodGhpcy5oLHRoaXMuaCx0aGlzKX1yQmVnaW4oKXtyZXR1cm4gbmV3IEdlKHRoaXMuaC5XfHx0aGlzLmgsdGhpcy5oLHRoaXMsMSl9ckVuZCgpe3JldHVybiBuZXcgR2UodGhpcy5oLHRoaXMuaCx0aGlzLDEpfWZyb250KCl7aWYodGhpcy5pPT09MClyZXR1cm47bGV0IGU9dGhpcy5oLlU7cmV0dXJuW2UudSxlLmxdfWJhY2soKXtpZih0aGlzLmk9PT0wKXJldHVybjtsZXQgZT10aGlzLmguVztyZXR1cm5bZS51LGUubF19bG93ZXJCb3VuZChlKXtsZXQgcj10aGlzLlgodGhpcy5ZLGUpO3JldHVybiBuZXcgR2Uocix0aGlzLmgsdGhpcyl9dXBwZXJCb3VuZChlKXtsZXQgcj10aGlzLloodGhpcy5ZLGUpO3JldHVybiBuZXcgR2Uocix0aGlzLmgsdGhpcyl9cmV2ZXJzZUxvd2VyQm91bmQoZSl7bGV0IHI9dGhpcy4kKHRoaXMuWSxlKTtyZXR1cm4gbmV3IEdlKHIsdGhpcy5oLHRoaXMpfXJldmVyc2VVcHBlckJvdW5kKGUpe2xldCByPXRoaXMucnIodGhpcy5ZLGUpO3JldHVybiBuZXcgR2Uocix0aGlzLmgsdGhpcyl9c2V0RWxlbWVudChlLHIsaSl7cmV0dXJuIHRoaXMuTShlLHIsaSl9ZmluZChlKXtsZXQgcj10aGlzLkkodGhpcy5ZLGUpO3JldHVybiBuZXcgR2Uocix0aGlzLmgsdGhpcyl9Z2V0RWxlbWVudEJ5S2V5KGUpe3JldHVybiB0aGlzLkkodGhpcy5ZLGUpLmx9dW5pb24oZSl7bGV0IHI9dGhpcztyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGkpe3Iuc2V0RWxlbWVudChpWzBdLGlbMV0pfSksdGhpcy5pfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIHRoaXMuSyh0aGlzLlkpfX0sRzE9QWE7UW4uZGVmYXVsdD1HMX0pO3ZhciBUYT1NKElhPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KElhLFwidFwiLHt2YWx1ZTohMH0pO0lhLmRlZmF1bHQ9UTE7ZnVuY3Rpb24gUTEodCl7bGV0IGU9dHlwZW9mIHQ7cmV0dXJuIGU9PT1cIm9iamVjdFwiJiZ0IT09bnVsbHx8ZT09PVwiZnVuY3Rpb25cIn19KTt2YXIgUGE9TShacj0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShacixcInRcIix7dmFsdWU6ITB9KTtaci5IYXNoQ29udGFpbmVySXRlcmF0b3I9WnIuSGFzaENvbnRhaW5lcj12b2lkIDA7dmFyIGhwPWF0KCksUmE9WTEoVGEoKSksSWk9bHQoKTtmdW5jdGlvbiBZMSh0KXtyZXR1cm4gdCYmdC50P3Q6e2RlZmF1bHQ6dH19dmFyIENhPWNsYXNzIGV4dGVuZHMgaHAuQ29udGFpbmVySXRlcmF0b3J7Y29uc3RydWN0b3IoZSxyLGkpe3N1cGVyKGkpLHRoaXMubz1lLHRoaXMuaD1yLHRoaXMuaXRlcmF0b3JUeXBlPT09MD8odGhpcy5wcmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vLkw9PT10aGlzLmgmJigwLElpLnRocm93SXRlcmF0b3JBY2Nlc3NFcnJvcikoKSx0aGlzLm89dGhpcy5vLkwsdGhpc30sdGhpcy5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubz09PXRoaXMuaCYmKDAsSWkudGhyb3dJdGVyYXRvckFjY2Vzc0Vycm9yKSgpLHRoaXMubz10aGlzLm8uQix0aGlzfSk6KHRoaXMucHJlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuby5CPT09dGhpcy5oJiYoMCxJaS50aHJvd0l0ZXJhdG9yQWNjZXNzRXJyb3IpKCksdGhpcy5vPXRoaXMuby5CLHRoaXN9LHRoaXMubmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm89PT10aGlzLmgmJigwLElpLnRocm93SXRlcmF0b3JBY2Nlc3NFcnJvcikoKSx0aGlzLm89dGhpcy5vLkwsdGhpc30pfX07WnIuSGFzaENvbnRhaW5lckl0ZXJhdG9yPUNhO3ZhciBCYT1jbGFzcyBleHRlbmRzIGhwLkNvbnRhaW5lcntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5IPVtdLHRoaXMuZz17fSx0aGlzLkhBU0hfVEFHPVN5bWJvbChcIkBASEFTSF9UQUdcIiksT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMuZyxudWxsKSx0aGlzLmg9e30sdGhpcy5oLkw9dGhpcy5oLkI9dGhpcy5wPXRoaXMuXz10aGlzLmh9VihlKXtsZXR7TDpyLEI6aX09ZTtyLkI9aSxpLkw9cixlPT09dGhpcy5wJiYodGhpcy5wPWkpLGU9PT10aGlzLl8mJih0aGlzLl89ciksdGhpcy5pLT0xfU0oZSxyLGkpe2k9PT12b2lkIDAmJihpPSgwLFJhLmRlZmF1bHQpKGUpKTtsZXQgbjtpZihpKXtsZXQgbz1lW3RoaXMuSEFTSF9UQUddO2lmKG8hPT12b2lkIDApcmV0dXJuIHRoaXMuSFtvXS5sPXIsdGhpcy5pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHRoaXMuSEFTSF9UQUcse3ZhbHVlOnRoaXMuSC5sZW5ndGgsY29uZmlndXJhYmxlOiEwfSksbj17dTplLGw6cixMOnRoaXMuXyxCOnRoaXMuaH0sdGhpcy5ILnB1c2gobil9ZWxzZXtsZXQgbz10aGlzLmdbZV07aWYobylyZXR1cm4gby5sPXIsdGhpcy5pO249e3U6ZSxsOnIsTDp0aGlzLl8sQjp0aGlzLmh9LHRoaXMuZ1tlXT1ufXJldHVybiB0aGlzLmk9PT0wPyh0aGlzLnA9bix0aGlzLmguQj1uKTp0aGlzLl8uQj1uLHRoaXMuXz1uLHRoaXMuaC5MPW4sKyt0aGlzLml9SShlLHIpe2lmKHI9PT12b2lkIDAmJihyPSgwLFJhLmRlZmF1bHQpKGUpKSxyKXtsZXQgaT1lW3RoaXMuSEFTSF9UQUddO3JldHVybiBpPT09dm9pZCAwP3RoaXMuaDp0aGlzLkhbaV19ZWxzZSByZXR1cm4gdGhpcy5nW2VdfHx0aGlzLmh9Y2xlYXIoKXtsZXQgZT10aGlzLkhBU0hfVEFHO3RoaXMuSC5mb3JFYWNoKGZ1bmN0aW9uKHIpe2RlbGV0ZSByLnVbZV19KSx0aGlzLkg9W10sdGhpcy5nPXt9LE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLmcsbnVsbCksdGhpcy5pPTAsdGhpcy5wPXRoaXMuXz10aGlzLmguTD10aGlzLmguQj10aGlzLmh9ZXJhc2VFbGVtZW50QnlLZXkoZSxyKXtsZXQgaTtpZihyPT09dm9pZCAwJiYocj0oMCxSYS5kZWZhdWx0KShlKSkscil7bGV0IG49ZVt0aGlzLkhBU0hfVEFHXTtpZihuPT09dm9pZCAwKXJldHVybiExO2RlbGV0ZSBlW3RoaXMuSEFTSF9UQUddLGk9dGhpcy5IW25dLGRlbGV0ZSB0aGlzLkhbbl19ZWxzZXtpZihpPXRoaXMuZ1tlXSxpPT09dm9pZCAwKXJldHVybiExO2RlbGV0ZSB0aGlzLmdbZV19cmV0dXJuIHRoaXMuVihpKSwhMH1lcmFzZUVsZW1lbnRCeUl0ZXJhdG9yKGUpe2xldCByPWUubztyZXR1cm4gcj09PXRoaXMuaCYmKDAsSWkudGhyb3dJdGVyYXRvckFjY2Vzc0Vycm9yKSgpLHRoaXMuVihyKSxlLm5leHQoKX1lcmFzZUVsZW1lbnRCeVBvcyhlKXtpZihlPDB8fGU+dGhpcy5pLTEpdGhyb3cgbmV3IFJhbmdlRXJyb3I7bGV0IHI9dGhpcy5wO2Zvcig7ZS0tOylyPXIuQjtyZXR1cm4gdGhpcy5WKHIpLHRoaXMuaX19O1pyLkhhc2hDb250YWluZXI9QmF9KTt2YXIgcHA9TShZbj0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShZbixcInRcIix7dmFsdWU6ITB9KTtZbi5kZWZhdWx0PXZvaWQgMDt2YXIgZHA9UGEoKSxKMT1sdCgpLEVyPWNsYXNzIHQgZXh0ZW5kcyBkcC5IYXNoQ29udGFpbmVySXRlcmF0b3J7Y29uc3RydWN0b3IoZSxyLGksbil7c3VwZXIoZSxyLG4pLHRoaXMuY29udGFpbmVyPWl9Z2V0IHBvaW50ZXIoKXtyZXR1cm4gdGhpcy5vPT09dGhpcy5oJiYoMCxKMS50aHJvd0l0ZXJhdG9yQWNjZXNzRXJyb3IpKCksdGhpcy5vLnV9Y29weSgpe3JldHVybiBuZXcgdCh0aGlzLm8sdGhpcy5oLHRoaXMuY29udGFpbmVyLHRoaXMuaXRlcmF0b3JUeXBlKX19LE9hPWNsYXNzIGV4dGVuZHMgZHAuSGFzaENvbnRhaW5lcntjb25zdHJ1Y3RvcihlPVtdKXtzdXBlcigpO2xldCByPXRoaXM7ZS5mb3JFYWNoKGZ1bmN0aW9uKGkpe3IuaW5zZXJ0KGkpfSl9YmVnaW4oKXtyZXR1cm4gbmV3IEVyKHRoaXMucCx0aGlzLmgsdGhpcyl9ZW5kKCl7cmV0dXJuIG5ldyBFcih0aGlzLmgsdGhpcy5oLHRoaXMpfXJCZWdpbigpe3JldHVybiBuZXcgRXIodGhpcy5fLHRoaXMuaCx0aGlzLDEpfXJFbmQoKXtyZXR1cm4gbmV3IEVyKHRoaXMuaCx0aGlzLmgsdGhpcywxKX1mcm9udCgpe3JldHVybiB0aGlzLnAudX1iYWNrKCl7cmV0dXJuIHRoaXMuXy51fWluc2VydChlLHIpe3JldHVybiB0aGlzLk0oZSx2b2lkIDAscil9Z2V0RWxlbWVudEJ5UG9zKGUpe2lmKGU8MHx8ZT50aGlzLmktMSl0aHJvdyBuZXcgUmFuZ2VFcnJvcjtsZXQgcj10aGlzLnA7Zm9yKDtlLS07KXI9ci5CO3JldHVybiByLnV9ZmluZChlLHIpe2xldCBpPXRoaXMuSShlLHIpO3JldHVybiBuZXcgRXIoaSx0aGlzLmgsdGhpcyl9Zm9yRWFjaChlKXtsZXQgcj0wLGk9dGhpcy5wO2Zvcig7aSE9PXRoaXMuaDspZShpLnUscisrLHRoaXMpLGk9aS5CfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIGZ1bmN0aW9uKigpe2xldCBlPXRoaXMucDtmb3IoO2UhPT10aGlzLmg7KXlpZWxkIGUudSxlPWUuQn0uYmluZCh0aGlzKSgpfX0sWDE9T2E7WW4uZGVmYXVsdD1YMX0pO3ZhciB5cD1NKEpuPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEpuLFwidFwiLHt2YWx1ZTohMH0pO0puLmRlZmF1bHQ9dm9pZCAwO3ZhciBncD1QYSgpLFoxPXR2KFRhKCkpLGV2PWx0KCk7ZnVuY3Rpb24gdHYodCl7cmV0dXJuIHQmJnQudD90OntkZWZhdWx0OnR9fXZhciBTcj1jbGFzcyB0IGV4dGVuZHMgZ3AuSGFzaENvbnRhaW5lckl0ZXJhdG9ye2NvbnN0cnVjdG9yKGUscixpLG4pe3N1cGVyKGUscixuKSx0aGlzLmNvbnRhaW5lcj1pfWdldCBwb2ludGVyKCl7dGhpcy5vPT09dGhpcy5oJiYoMCxldi50aHJvd0l0ZXJhdG9yQWNjZXNzRXJyb3IpKCk7bGV0IGU9dGhpcztyZXR1cm4gbmV3IFByb3h5KFtdLHtnZXQocixpKXtpZihpPT09XCIwXCIpcmV0dXJuIGUuby51O2lmKGk9PT1cIjFcIilyZXR1cm4gZS5vLmx9LHNldChyLGksbil7aWYoaSE9PVwiMVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJwcm9wcyBtdXN0IGJlIDFcIik7cmV0dXJuIGUuby5sPW4sITB9fSl9Y29weSgpe3JldHVybiBuZXcgdCh0aGlzLm8sdGhpcy5oLHRoaXMuY29udGFpbmVyLHRoaXMuaXRlcmF0b3JUeXBlKX19LGthPWNsYXNzIGV4dGVuZHMgZ3AuSGFzaENvbnRhaW5lcntjb25zdHJ1Y3RvcihlPVtdKXtzdXBlcigpO2xldCByPXRoaXM7ZS5mb3JFYWNoKGZ1bmN0aW9uKGkpe3Iuc2V0RWxlbWVudChpWzBdLGlbMV0pfSl9YmVnaW4oKXtyZXR1cm4gbmV3IFNyKHRoaXMucCx0aGlzLmgsdGhpcyl9ZW5kKCl7cmV0dXJuIG5ldyBTcih0aGlzLmgsdGhpcy5oLHRoaXMpfXJCZWdpbigpe3JldHVybiBuZXcgU3IodGhpcy5fLHRoaXMuaCx0aGlzLDEpfXJFbmQoKXtyZXR1cm4gbmV3IFNyKHRoaXMuaCx0aGlzLmgsdGhpcywxKX1mcm9udCgpe2lmKHRoaXMuaSE9PTApcmV0dXJuW3RoaXMucC51LHRoaXMucC5sXX1iYWNrKCl7aWYodGhpcy5pIT09MClyZXR1cm5bdGhpcy5fLnUsdGhpcy5fLmxdfXNldEVsZW1lbnQoZSxyLGkpe3JldHVybiB0aGlzLk0oZSxyLGkpfWdldEVsZW1lbnRCeUtleShlLHIpe2lmKHI9PT12b2lkIDAmJihyPSgwLFoxLmRlZmF1bHQpKGUpKSxyKXtsZXQgbj1lW3RoaXMuSEFTSF9UQUddO3JldHVybiBuIT09dm9pZCAwP3RoaXMuSFtuXS5sOnZvaWQgMH1sZXQgaT10aGlzLmdbZV07cmV0dXJuIGk/aS5sOnZvaWQgMH1nZXRFbGVtZW50QnlQb3MoZSl7aWYoZTwwfHxlPnRoaXMuaS0xKXRocm93IG5ldyBSYW5nZUVycm9yO2xldCByPXRoaXMucDtmb3IoO2UtLTspcj1yLkI7cmV0dXJuW3IudSxyLmxdfWZpbmQoZSxyKXtsZXQgaT10aGlzLkkoZSxyKTtyZXR1cm4gbmV3IFNyKGksdGhpcy5oLHRoaXMpfWZvckVhY2goZSl7bGV0IHI9MCxpPXRoaXMucDtmb3IoO2khPT10aGlzLmg7KWUoW2kudSxpLmxdLHIrKyx0aGlzKSxpPWkuQn1bU3ltYm9sLml0ZXJhdG9yXSgpe3JldHVybiBmdW5jdGlvbiooKXtsZXQgZT10aGlzLnA7Zm9yKDtlIT09dGhpcy5oOyl5aWVsZFtlLnUsZS5sXSxlPWUuQn0uYmluZCh0aGlzKSgpfX0scnY9a2E7Sm4uZGVmYXVsdD1ydn0pO3ZhciBicD1NKGplPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGplLFwidFwiLHt2YWx1ZTohMH0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShqZSxcIkRlcXVlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGx2LmRlZmF1bHR9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGplLFwiSGFzaE1hcFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBodi5kZWZhdWx0fX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShqZSxcIkhhc2hTZXRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY3YuZGVmYXVsdH19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoamUsXCJMaW5rTGlzdFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhdi5kZWZhdWx0fX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShqZSxcIk9yZGVyZWRNYXBcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZnYuZGVmYXVsdH19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoamUsXCJPcmRlcmVkU2V0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHV2LmRlZmF1bHR9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGplLFwiUHJpb3JpdHlRdWV1ZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzdi5kZWZhdWx0fX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShqZSxcIlF1ZXVlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG52LmRlZmF1bHR9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGplLFwiU3RhY2tcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaXYuZGVmYXVsdH19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoamUsXCJWZWN0b3JcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb3YuZGVmYXVsdH19KTt2YXIgaXY9dXQoWmQoKSksbnY9dXQoZXAoKSksc3Y9dXQodHAoKSksb3Y9dXQocnAoKSksYXY9dXQoaXAoKSksbHY9dXQobnAoKSksdXY9dXQodXAoKSksZnY9dXQoY3AoKSksY3Y9dXQocHAoKSksaHY9dXQoeXAoKSk7ZnVuY3Rpb24gdXQodCl7cmV0dXJuIHQmJnQudD90OntkZWZhdWx0OnR9fX0pO3ZhciBfcD1NKChiTix3cCk9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTt2YXIgZHY9YnAoKS5PcmRlcmVkU2V0LGZ0PW90KCkoXCJudW1iZXItYWxsb2NhdG9yOnRyYWNlXCIpLHB2PW90KCkoXCJudW1iZXItYWxsb2NhdG9yOmVycm9yXCIpO2Z1bmN0aW9uIFRlKHQsZSl7dGhpcy5sb3c9dCx0aGlzLmhpZ2g9ZX1UZS5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxvdz09PXQubG93JiZ0aGlzLmhpZ2g9PT10LmhpZ2h9O1RlLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxvdzx0LmxvdyYmdGhpcy5oaWdoPHQubG93Py0xOnQubG93PHRoaXMubG93JiZ0LmhpZ2g8dGhpcy5sb3c/MTowfTtmdW5jdGlvbiBjdCh0LGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGN0KSlyZXR1cm4gbmV3IGN0KHQsZSk7dGhpcy5taW49dCx0aGlzLm1heD1lLHRoaXMuc3M9bmV3IGR2KFtdLChyLGkpPT5yLmNvbXBhcmUoaSkpLGZ0KFwiQ3JlYXRlXCIpLHRoaXMuY2xlYXIoKX1jdC5wcm90b3R5cGUuZmlyc3RWYWNhbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zcy5zaXplKCk9PT0wP251bGw6dGhpcy5zcy5mcm9udCgpLmxvd307Y3QucHJvdG90eXBlLmFsbG9jPWZ1bmN0aW9uKCl7aWYodGhpcy5zcy5zaXplKCk9PT0wKXJldHVybiBmdChcImFsbG9jKCk6ZW1wdHlcIiksbnVsbDtsZXQgdD10aGlzLnNzLmJlZ2luKCksZT10LnBvaW50ZXIubG93LHI9dC5wb2ludGVyLmhpZ2gsaT1lO3JldHVybiBpKzE8PXI/dGhpcy5zcy51cGRhdGVLZXlCeUl0ZXJhdG9yKHQsbmV3IFRlKGUrMSxyKSk6dGhpcy5zcy5lcmFzZUVsZW1lbnRCeVBvcygwKSxmdChcImFsbG9jKCk6XCIraSksaX07Y3QucHJvdG90eXBlLnVzZT1mdW5jdGlvbih0KXtsZXQgZT1uZXcgVGUodCx0KSxyPXRoaXMuc3MubG93ZXJCb3VuZChlKTtpZighci5lcXVhbHModGhpcy5zcy5lbmQoKSkpe2xldCBpPXIucG9pbnRlci5sb3csbj1yLnBvaW50ZXIuaGlnaDtyZXR1cm4gci5wb2ludGVyLmVxdWFscyhlKT8odGhpcy5zcy5lcmFzZUVsZW1lbnRCeUl0ZXJhdG9yKHIpLGZ0KFwidXNlKCk6XCIrdCksITApOmk+dD8hMTppPT09dD8odGhpcy5zcy51cGRhdGVLZXlCeUl0ZXJhdG9yKHIsbmV3IFRlKGkrMSxuKSksZnQoXCJ1c2UoKTpcIit0KSwhMCk6bj09PXQ/KHRoaXMuc3MudXBkYXRlS2V5QnlJdGVyYXRvcihyLG5ldyBUZShpLG4tMSkpLGZ0KFwidXNlKCk6XCIrdCksITApOih0aGlzLnNzLnVwZGF0ZUtleUJ5SXRlcmF0b3IocixuZXcgVGUodCsxLG4pKSx0aGlzLnNzLmluc2VydChuZXcgVGUoaSx0LTEpKSxmdChcInVzZSgpOlwiK3QpLCEwKX1yZXR1cm4gZnQoXCJ1c2UoKTpmYWlsZWRcIiksITF9O2N0LnByb3RvdHlwZS5mcmVlPWZ1bmN0aW9uKHQpe2lmKHQ8dGhpcy5taW58fHQ+dGhpcy5tYXgpe3B2KFwiZnJlZSgpOlwiK3QrXCIgaXMgb3V0IG9mIHJhbmdlXCIpO3JldHVybn1sZXQgZT1uZXcgVGUodCx0KSxyPXRoaXMuc3MudXBwZXJCb3VuZChlKTtpZihyLmVxdWFscyh0aGlzLnNzLmVuZCgpKSl7aWYoci5lcXVhbHModGhpcy5zcy5iZWdpbigpKSl7dGhpcy5zcy5pbnNlcnQoZSk7cmV0dXJufXIucHJlKCk7bGV0IGk9ci5wb2ludGVyLmhpZ2g7ci5wb2ludGVyLmhpZ2grMT09PXQ/dGhpcy5zcy51cGRhdGVLZXlCeUl0ZXJhdG9yKHIsbmV3IFRlKGksdCkpOnRoaXMuc3MuaW5zZXJ0KGUpfWVsc2UgaWYoci5lcXVhbHModGhpcy5zcy5iZWdpbigpKSlpZih0KzE9PT1yLnBvaW50ZXIubG93KXtsZXQgaT1yLnBvaW50ZXIuaGlnaDt0aGlzLnNzLnVwZGF0ZUtleUJ5SXRlcmF0b3IocixuZXcgVGUodCxpKSl9ZWxzZSB0aGlzLnNzLmluc2VydChlKTtlbHNle2xldCBpPXIucG9pbnRlci5sb3csbj1yLnBvaW50ZXIuaGlnaDtyLnByZSgpO2xldCBvPXIucG9pbnRlci5sb3c7ci5wb2ludGVyLmhpZ2grMT09PXQ/dCsxPT09aT8odGhpcy5zcy5lcmFzZUVsZW1lbnRCeUl0ZXJhdG9yKHIpLHRoaXMuc3MudXBkYXRlS2V5QnlJdGVyYXRvcihyLG5ldyBUZShvLG4pKSk6dGhpcy5zcy51cGRhdGVLZXlCeUl0ZXJhdG9yKHIsbmV3IFRlKG8sdCkpOnQrMT09PWk/KHRoaXMuc3MuZXJhc2VFbGVtZW50QnlJdGVyYXRvcihyLm5leHQoKSksdGhpcy5zcy5pbnNlcnQobmV3IFRlKHQsbikpKTp0aGlzLnNzLmluc2VydChlKX1mdChcImZyZWUoKTpcIit0KX07Y3QucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7ZnQoXCJjbGVhcigpXCIpLHRoaXMuc3MuY2xlYXIoKSx0aGlzLnNzLmluc2VydChuZXcgVGUodGhpcy5taW4sdGhpcy5tYXgpKX07Y3QucHJvdG90eXBlLmludGVydmFsQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zcy5zaXplKCl9O2N0LnByb3RvdHlwZS5kdW1wPWZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCJsZW5ndGg6XCIrdGhpcy5zcy5zaXplKCkpO2ZvcihsZXQgdCBvZiB0aGlzLnNzKWNvbnNvbGUubG9nKHQpfTt3cC5leHBvcnRzPWN0fSk7dmFyIHhhPU0oKFJOLG1wKT0+e3YoKTttKCk7XygpO3ZhciBndj1fcCgpO21wLmV4cG9ydHMuTnVtYmVyQWxsb2NhdG9yPWd2fSk7dmFyIHZwPU0oTGE9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTGEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHl2PVhkKCksYnY9eGEoKSxNYT1jbGFzc3tjb25zdHJ1Y3RvcihlKXtlPjAmJih0aGlzLmFsaWFzVG9Ub3BpYz1uZXcgeXYuTFJVQ2FjaGUoe21heDplfSksdGhpcy50b3BpY1RvQWxpYXM9e30sdGhpcy5udW1iZXJBbGxvY2F0b3I9bmV3IGJ2Lk51bWJlckFsbG9jYXRvcigxLGUpLHRoaXMubWF4PWUsdGhpcy5sZW5ndGg9MCl9cHV0KGUscil7aWYocj09PTB8fHI+dGhpcy5tYXgpcmV0dXJuITE7bGV0IGk9dGhpcy5hbGlhc1RvVG9waWMuZ2V0KHIpO3JldHVybiBpJiZkZWxldGUgdGhpcy50b3BpY1RvQWxpYXNbaV0sdGhpcy5hbGlhc1RvVG9waWMuc2V0KHIsZSksdGhpcy50b3BpY1RvQWxpYXNbZV09cix0aGlzLm51bWJlckFsbG9jYXRvci51c2UociksdGhpcy5sZW5ndGg9dGhpcy5hbGlhc1RvVG9waWMuc2l6ZSwhMH1nZXRUb3BpY0J5QWxpYXMoZSl7cmV0dXJuIHRoaXMuYWxpYXNUb1RvcGljLmdldChlKX1nZXRBbGlhc0J5VG9waWMoZSl7bGV0IHI9dGhpcy50b3BpY1RvQWxpYXNbZV07cmV0dXJuIHR5cGVvZiByPFwidVwiJiZ0aGlzLmFsaWFzVG9Ub3BpYy5nZXQocikscn1jbGVhcigpe3RoaXMuYWxpYXNUb1RvcGljLmNsZWFyKCksdGhpcy50b3BpY1RvQWxpYXM9e30sdGhpcy5udW1iZXJBbGxvY2F0b3IuY2xlYXIoKSx0aGlzLmxlbmd0aD0wfWdldExydUFsaWFzKCl7bGV0IGU9dGhpcy5udW1iZXJBbGxvY2F0b3IuZmlyc3RWYWNhbnQoKTtyZXR1cm4gZXx8Wy4uLnRoaXMuYWxpYXNUb1RvcGljLmtleXMoKV1bdGhpcy5hbGlhc1RvVG9waWMuc2l6ZS0xXX19O0xhLmRlZmF1bHQ9TWF9KTt2YXIgRXA9TShUaT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhciB3dj1UaSYmVGkuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShUaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgX3Y9U2koKSxtdj13dih2cCgpKSx2dj1ZcigpLEV2PSh0LGUpPT57dC5sb2coXCJfaGFuZGxlQ29ubmFja1wiKTtsZXR7b3B0aW9uczpyfT10LG49ci5wcm90b2NvbFZlcnNpb249PT01P2UucmVhc29uQ29kZTplLnJldHVybkNvZGU7aWYoY2xlYXJUaW1lb3V0KHQuY29ubmFja1RpbWVyKSxkZWxldGUgdC50b3BpY0FsaWFzU2VuZCxlLnByb3BlcnRpZXMpe2lmKGUucHJvcGVydGllcy50b3BpY0FsaWFzTWF4aW11bSl7aWYoZS5wcm9wZXJ0aWVzLnRvcGljQWxpYXNNYXhpbXVtPjY1NTM1KXt0LmVtaXQoXCJlcnJvclwiLG5ldyBFcnJvcihcInRvcGljQWxpYXNNYXhpbXVtIGZyb20gYnJva2VyIGlzIG91dCBvZiByYW5nZVwiKSk7cmV0dXJufWUucHJvcGVydGllcy50b3BpY0FsaWFzTWF4aW11bT4wJiYodC50b3BpY0FsaWFzU2VuZD1uZXcgbXYuZGVmYXVsdChlLnByb3BlcnRpZXMudG9waWNBbGlhc01heGltdW0pKX1lLnByb3BlcnRpZXMuc2VydmVyS2VlcEFsaXZlJiZyLmtlZXBhbGl2ZSYmKHIua2VlcGFsaXZlPWUucHJvcGVydGllcy5zZXJ2ZXJLZWVwQWxpdmUsdC5fc2hpZnRQaW5nSW50ZXJ2YWwoKSksZS5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplJiYoci5wcm9wZXJ0aWVzfHwoci5wcm9wZXJ0aWVzPXt9KSxyLnByb3BlcnRpZXMubWF4aW11bVBhY2tldFNpemU9ZS5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplKX1pZihuPT09MCl0LnJlY29ubmVjdGluZz0hMSx0Ll9vbkNvbm5lY3QoZSk7ZWxzZSBpZihuPjApe2xldCBvPW5ldyB2di5FcnJvcldpdGhSZWFzb25Db2RlKGBDb25uZWN0aW9uIHJlZnVzZWQ6ICR7X3YuUmVhc29uQ29kZXNbbl19YCxuKTt0LmVtaXQoXCJlcnJvclwiLG8pfX07VGkuZGVmYXVsdD1Fdn0pO3ZhciBTcD1NKFVhPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KFVhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBTdj0odCxlLHIpPT57dC5sb2coXCJoYW5kbGluZyBwdWJyZWwgcGFja2V0XCIpO2xldCBpPXR5cGVvZiByPFwidVwiP3I6dC5ub29wLHttZXNzYWdlSWQ6bn09ZSxvPXtjbWQ6XCJwdWJjb21wXCIsbWVzc2FnZUlkOm59O3QuaW5jb21pbmdTdG9yZS5nZXQoZSwocyxhKT0+e3M/dC5fc2VuZFBhY2tldChvLGkpOih0LmVtaXQoXCJtZXNzYWdlXCIsYS50b3BpYyxhLnBheWxvYWQsYSksdC5oYW5kbGVNZXNzYWdlKGEsdT0+e2lmKHUpcmV0dXJuIGkodSk7dC5pbmNvbWluZ1N0b3JlLmRlbChhLHQubm9vcCksdC5fc2VuZFBhY2tldChvLGkpfSkpfSl9O1VhLmRlZmF1bHQ9U3Z9KTt2YXIgQXA9TShSaT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhciBDaT1SaSYmUmkuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShSaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgQXY9Q2koVmQoKSksSXY9Q2koS2QoKSksVHY9Q2koRXAoKSksUnY9Q2koU2koKSksQ3Y9Q2koU3AoKSksQnY9KHQsZSxyKT0+e2xldHtvcHRpb25zOml9PXQ7aWYoaS5wcm90b2NvbFZlcnNpb249PT01JiZpLnByb3BlcnRpZXMmJmkucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZSYmaS5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplPGUubGVuZ3RoKXJldHVybiB0LmVtaXQoXCJlcnJvclwiLG5ldyBFcnJvcihgZXhjZWVkaW5nIHBhY2tldHMgc2l6ZSAke2UuY21kfWApKSx0LmVuZCh7cmVhc29uQ29kZToxNDkscHJvcGVydGllczp7cmVhc29uU3RyaW5nOlwiTWF4aW11bSBwYWNrZXQgc2l6ZSB3YXMgZXhjZWVkZWRcIn19KSx0O3N3aXRjaCh0LmxvZyhcIl9oYW5kbGVQYWNrZXQgOjogZW1pdHRpbmcgcGFja2V0cmVjZWl2ZVwiKSx0LmVtaXQoXCJwYWNrZXRyZWNlaXZlXCIsZSksZS5jbWQpe2Nhc2VcInB1Ymxpc2hcIjooMCxBdi5kZWZhdWx0KSh0LGUscik7YnJlYWs7Y2FzZVwicHViYWNrXCI6Y2FzZVwicHVicmVjXCI6Y2FzZVwicHViY29tcFwiOmNhc2VcInN1YmFja1wiOmNhc2VcInVuc3ViYWNrXCI6KDAsUnYuZGVmYXVsdCkodCxlKSxyKCk7YnJlYWs7Y2FzZVwicHVicmVsXCI6KDAsQ3YuZGVmYXVsdCkodCxlLHIpO2JyZWFrO2Nhc2VcImNvbm5hY2tcIjooMCxUdi5kZWZhdWx0KSh0LGUpLHIoKTticmVhaztjYXNlXCJhdXRoXCI6KDAsSXYuZGVmYXVsdCkodCxlKSxyKCk7YnJlYWs7Y2FzZVwicGluZ3Jlc3BcIjp0LnBpbmdSZXNwPSEwLHIoKTticmVhaztjYXNlXCJkaXNjb25uZWN0XCI6dC5lbWl0KFwiZGlzY29ubmVjdFwiLGUpLHIoKTticmVhaztkZWZhdWx0OnQubG9nKFwiX2hhbmRsZVBhY2tldCA6OiB1bmtub3duIGNvbW1hbmRcIikscigpO2JyZWFrfX07UmkuZGVmYXVsdD1Cdn0pO3ZhciBJcD1NKGVpPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7dmFyIFB2PWVpJiZlaS5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGVpLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2VpLlR5cGVkRXZlbnRFbWl0dGVyPXZvaWQgMDt2YXIgT3Y9UHYoKGlyKCksWihycikpKSxrdj1ZcigpLFhuPWNsYXNze307ZWkuVHlwZWRFdmVudEVtaXR0ZXI9WG47KDAsa3YuYXBwbHlNaXhpbikoWG4sT3YuZGVmYXVsdCl9KTt2YXIgUGk9TShCaT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShCaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtCaS5pc1dlYldvcmtlcj12b2lkIDA7dmFyIHh2PSgpPT50eXBlb2Ygd2luZG93PFwidVwiJiZ0eXBlb2Ygd2luZG93LmRvY3VtZW50PFwidVwiLFRwPSgpPT57dmFyIHQsZTtyZXR1cm4hISh0eXBlb2Ygc2VsZj09XCJvYmplY3RcIiYmKCEoKGU9KHQ9c2VsZj8uY29uc3RydWN0b3IpPT09bnVsbHx8dD09PXZvaWQgMD92b2lkIDA6dC5uYW1lKT09PW51bGx8fGU9PT12b2lkIDApJiZlLmluY2x1ZGVzKFwiV29ya2VyR2xvYmFsU2NvcGVcIikpKX0sTXY9KCk9PnR5cGVvZiBCPFwidVwiJiZCLnByb2R1Y3Q9PT1cIlJlYWN0TmF0aXZlXCIsTHY9eHYoKXx8VHAoKXx8TXYoKTtCaS5pc1dlYldvcmtlcj1UcCgpO0JpLmRlZmF1bHQ9THZ9KTt2YXIgQ3A9TSgoWm4sUnApPT57digpO20oKTtfKCk7KGZ1bmN0aW9uKHQsZSl7dHlwZW9mIFpuPT1cIm9iamVjdFwiJiZ0eXBlb2YgUnA8XCJ1XCI/ZShabik6dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGUpOih0PXR5cGVvZiBnbG9iYWxUaGlzPFwidVwiP2dsb2JhbFRoaXM6dHx8c2VsZixlKHQuZmFzdFVuaXF1ZU51bWJlcnM9e30pKX0pKFpuLGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO3ZhciBlPWZ1bmN0aW9uKGcpe3JldHVybiBmdW5jdGlvbih5KXt2YXIgdz1nKHkpO3JldHVybiB5LmFkZCh3KSx3fX0scj1mdW5jdGlvbihnKXtyZXR1cm4gZnVuY3Rpb24oeSx3KXtyZXR1cm4gZy5zZXQoeSx3KSx3fX0saT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUj09PXZvaWQgMD85MDA3MTk5MjU0NzQwOTkxOk51bWJlci5NQVhfU0FGRV9JTlRFR0VSLG49NTM2ODcwOTEyLG89bioyLHM9ZnVuY3Rpb24oZyx5KXtyZXR1cm4gZnVuY3Rpb24odyl7dmFyIEU9eS5nZXQodyksUz1FPT09dm9pZCAwP3cuc2l6ZTpFPG8/RSsxOjA7aWYoIXcuaGFzKFMpKXJldHVybiBnKHcsUyk7aWYody5zaXplPG4pe2Zvcig7dy5oYXMoUyk7KVM9TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKm8pO3JldHVybiBnKHcsUyl9aWYody5zaXplPmkpdGhyb3cgbmV3IEVycm9yKFwiQ29uZ3JhdHVsYXRpb25zLCB5b3UgY3JlYXRlZCBhIGNvbGxlY3Rpb24gb2YgdW5pcXVlIG51bWJlcnMgd2hpY2ggdXNlcyBhbGwgYXZhaWxhYmxlIGludGVnZXJzIVwiKTtmb3IoO3cuaGFzKFMpOylTPU1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSppKTtyZXR1cm4gZyh3LFMpfX0sYT1uZXcgV2Vha01hcCx1PXIoYSksYz1zKHUsYSksaD1lKGMpO3QuYWRkVW5pcXVlTnVtYmVyPWgsdC5nZW5lcmF0ZVVuaXF1ZU51bWJlcj1jfSl9KTt2YXIgUHA9TSgoZXMsQnApPT57digpO20oKTtfKCk7KGZ1bmN0aW9uKHQsZSl7dHlwZW9mIGVzPT1cIm9iamVjdFwiJiZ0eXBlb2YgQnA8XCJ1XCI/ZShlcyxDcCgpKTp0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIixcImZhc3QtdW5pcXVlLW51bWJlcnNcIl0sZSk6KHQ9dHlwZW9mIGdsb2JhbFRoaXM8XCJ1XCI/Z2xvYmFsVGhpczp0fHxzZWxmLGUodC53b3JrZXJUaW1lcnNCcm9rZXI9e30sdC5mYXN0VW5pcXVlTnVtYmVycykpfSkoZXMsZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1mdW5jdGlvbihzKXtyZXR1cm4gcy5tZXRob2QhPT12b2lkIDAmJnMubWV0aG9kPT09XCJjYWxsXCJ9LGk9ZnVuY3Rpb24ocyl7cmV0dXJuIHMuZXJyb3I9PT1udWxsJiZ0eXBlb2Ygcy5pZD09XCJudW1iZXJcIn0sbj1mdW5jdGlvbihzKXt2YXIgYT1uZXcgTWFwKFtbMCxmdW5jdGlvbigpe31dXSksdT1uZXcgTWFwKFtbMCxmdW5jdGlvbigpe31dXSksYz1uZXcgTWFwLGg9bmV3IFdvcmtlcihzKTtoLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsZnVuY3Rpb24oRSl7dmFyIFM9RS5kYXRhO2lmKHIoUykpe3ZhciBJPVMucGFyYW1zLEM9SS50aW1lcklkLFI9SS50aW1lclR5cGU7aWYoUj09PVwiaW50ZXJ2YWxcIil7dmFyIFU9YS5nZXQoQyk7aWYodHlwZW9mIFU9PVwibnVtYmVyXCIpe3ZhciBOPWMuZ2V0KFUpO2lmKE49PT12b2lkIDB8fE4udGltZXJJZCE9PUN8fE4udGltZXJUeXBlIT09Uil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGltZXIgaXMgaW4gYW4gdW5kZWZpbmVkIHN0YXRlLlwiKX1lbHNlIGlmKHR5cGVvZiBVPFwidVwiKVUoKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIlRoZSB0aW1lciBpcyBpbiBhbiB1bmRlZmluZWQgc3RhdGUuXCIpfWVsc2UgaWYoUj09PVwidGltZW91dFwiKXt2YXIgVz11LmdldChDKTtpZih0eXBlb2YgVz09XCJudW1iZXJcIil7dmFyIEs9Yy5nZXQoVyk7aWYoSz09PXZvaWQgMHx8Sy50aW1lcklkIT09Q3x8Sy50aW1lclR5cGUhPT1SKXRocm93IG5ldyBFcnJvcihcIlRoZSB0aW1lciBpcyBpbiBhbiB1bmRlZmluZWQgc3RhdGUuXCIpfWVsc2UgaWYodHlwZW9mIFc8XCJ1XCIpVygpLHUuZGVsZXRlKEMpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHRpbWVyIGlzIGluIGFuIHVuZGVmaW5lZCBzdGF0ZS5cIil9fWVsc2UgaWYoaShTKSl7dmFyIHo9Uy5pZCxRPWMuZ2V0KHopO2lmKFE9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiVGhlIHRpbWVyIGlzIGluIGFuIHVuZGVmaW5lZCBzdGF0ZS5cIik7dmFyIGRlPVEudGltZXJJZCxHdD1RLnRpbWVyVHlwZTtjLmRlbGV0ZSh6KSxHdD09PVwiaW50ZXJ2YWxcIj9hLmRlbGV0ZShkZSk6dS5kZWxldGUoZGUpfWVsc2V7dmFyIHBlPVMuZXJyb3IubWVzc2FnZTt0aHJvdyBuZXcgRXJyb3IocGUpfX0pO3ZhciBkPWZ1bmN0aW9uKFMpe3ZhciBJPWUuZ2VuZXJhdGVVbmlxdWVOdW1iZXIoYyk7Yy5zZXQoSSx7dGltZXJJZDpTLHRpbWVyVHlwZTpcImludGVydmFsXCJ9KSxhLnNldChTLEkpLGgucG9zdE1lc3NhZ2Uoe2lkOkksbWV0aG9kOlwiY2xlYXJcIixwYXJhbXM6e3RpbWVySWQ6Uyx0aW1lclR5cGU6XCJpbnRlcnZhbFwifX0pfSxnPWZ1bmN0aW9uKFMpe3ZhciBJPWUuZ2VuZXJhdGVVbmlxdWVOdW1iZXIoYyk7Yy5zZXQoSSx7dGltZXJJZDpTLHRpbWVyVHlwZTpcInRpbWVvdXRcIn0pLHUuc2V0KFMsSSksaC5wb3N0TWVzc2FnZSh7aWQ6SSxtZXRob2Q6XCJjbGVhclwiLHBhcmFtczp7dGltZXJJZDpTLHRpbWVyVHlwZTpcInRpbWVvdXRcIn19KX0seT1mdW5jdGlvbihTKXt2YXIgST1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06MCxDPWUuZ2VuZXJhdGVVbmlxdWVOdW1iZXIoYSk7cmV0dXJuIGEuc2V0KEMsZnVuY3Rpb24oKXtTKCksdHlwZW9mIGEuZ2V0KEMpPT1cImZ1bmN0aW9uXCImJmgucG9zdE1lc3NhZ2Uoe2lkOm51bGwsbWV0aG9kOlwic2V0XCIscGFyYW1zOntkZWxheTpJLG5vdzpwZXJmb3JtYW5jZS5ub3coKSx0aW1lcklkOkMsdGltZXJUeXBlOlwiaW50ZXJ2YWxcIn19KX0pLGgucG9zdE1lc3NhZ2Uoe2lkOm51bGwsbWV0aG9kOlwic2V0XCIscGFyYW1zOntkZWxheTpJLG5vdzpwZXJmb3JtYW5jZS5ub3coKSx0aW1lcklkOkMsdGltZXJUeXBlOlwiaW50ZXJ2YWxcIn19KSxDfSx3PWZ1bmN0aW9uKFMpe3ZhciBJPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTowLEM9ZS5nZW5lcmF0ZVVuaXF1ZU51bWJlcih1KTtyZXR1cm4gdS5zZXQoQyxTKSxoLnBvc3RNZXNzYWdlKHtpZDpudWxsLG1ldGhvZDpcInNldFwiLHBhcmFtczp7ZGVsYXk6SSxub3c6cGVyZm9ybWFuY2Uubm93KCksdGltZXJJZDpDLHRpbWVyVHlwZTpcInRpbWVvdXRcIn19KSxDfTtyZXR1cm57Y2xlYXJJbnRlcnZhbDpkLGNsZWFyVGltZW91dDpnLHNldEludGVydmFsOnksc2V0VGltZW91dDp3fX07dC5sb2FkPW59KX0pO3ZhciBrcD1NKCh0cyxPcCk9Pnt2KCk7bSgpO18oKTsoZnVuY3Rpb24odCxlKXt0eXBlb2YgdHM9PVwib2JqZWN0XCImJnR5cGVvZiBPcDxcInVcIj9lKHRzLFBwKCkpOnR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiLFwid29ya2VyLXRpbWVycy1icm9rZXJcIl0sZSk6KHQ9dHlwZW9mIGdsb2JhbFRoaXM8XCJ1XCI/Z2xvYmFsVGhpczp0fHxzZWxmLGUodC53b3JrZXJUaW1lcnM9e30sdC53b3JrZXJUaW1lcnNCcm9rZXIpKX0pKHRzLGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9ZnVuY3Rpb24oaCxkKXt2YXIgZz1udWxsO3JldHVybiBmdW5jdGlvbigpe2lmKGchPT1udWxsKXJldHVybiBnO3ZhciB5PW5ldyBCbG9iKFtkXSx7dHlwZTpcImFwcGxpY2F0aW9uL2phdmFzY3JpcHQ7IGNoYXJzZXQ9dXRmLThcIn0pLHc9VVJMLmNyZWF0ZU9iamVjdFVSTCh5KTtyZXR1cm4gZz1oKHcpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gVVJMLnJldm9rZU9iamVjdFVSTCh3KX0pLGd9fSxpPWAoKCk9Pnt2YXIgZT17NDcyOihlLHQscik9Pnt2YXIgbyxpO3ZvaWQgMD09PShpPVwiZnVuY3Rpb25cIj09dHlwZW9mKG89ZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT1uZXcgTWFwLHQ9bmV3IE1hcCxyPWZ1bmN0aW9uKHQpe3ZhciByPWUuZ2V0KHQpO2lmKHZvaWQgMD09PXIpdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBpbnRlcnZhbCBzY2hlZHVsZWQgd2l0aCB0aGUgZ2l2ZW4gaWQgXCInLmNvbmNhdCh0LCdcIi4nKSk7Y2xlYXJUaW1lb3V0KHIpLGUuZGVsZXRlKHQpfSxvPWZ1bmN0aW9uKGUpe3ZhciByPXQuZ2V0KGUpO2lmKHZvaWQgMD09PXIpdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyB0aW1lb3V0IHNjaGVkdWxlZCB3aXRoIHRoZSBnaXZlbiBpZCBcIicuY29uY2F0KGUsJ1wiLicpKTtjbGVhclRpbWVvdXQociksdC5kZWxldGUoZSl9LGk9ZnVuY3Rpb24oZSx0KXt2YXIgcixvPXBlcmZvcm1hbmNlLm5vdygpO3JldHVybntleHBlY3RlZDpvKyhyPWUtTWF0aC5tYXgoMCxvLXQpKSxyZW1haW5pbmdEZWxheTpyfX0sbj1mdW5jdGlvbiBlKHQscixvLGkpe3ZhciBuPXBlcmZvcm1hbmNlLm5vdygpO24+bz9wb3N0TWVzc2FnZSh7aWQ6bnVsbCxtZXRob2Q6XCJjYWxsXCIscGFyYW1zOnt0aW1lcklkOnIsdGltZXJUeXBlOml9fSk6dC5zZXQocixzZXRUaW1lb3V0KGUsby1uLHQscixvLGkpKX0sYT1mdW5jdGlvbih0LHIsbyl7dmFyIGE9aSh0LG8pLHM9YS5leHBlY3RlZCxkPWEucmVtYWluaW5nRGVsYXk7ZS5zZXQocixzZXRUaW1lb3V0KG4sZCxlLHIscyxcImludGVydmFsXCIpKX0scz1mdW5jdGlvbihlLHIsbyl7dmFyIGE9aShlLG8pLHM9YS5leHBlY3RlZCxkPWEucmVtYWluaW5nRGVsYXk7dC5zZXQocixzZXRUaW1lb3V0KG4sZCx0LHIscyxcInRpbWVvdXRcIikpfTthZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLChmdW5jdGlvbihlKXt2YXIgdD1lLmRhdGE7dHJ5e2lmKFwiY2xlYXJcIj09PXQubWV0aG9kKXt2YXIgaT10LmlkLG49dC5wYXJhbXMsZD1uLnRpbWVySWQsYz1uLnRpbWVyVHlwZTtpZihcImludGVydmFsXCI9PT1jKXIoZCkscG9zdE1lc3NhZ2Uoe2Vycm9yOm51bGwsaWQ6aX0pO2Vsc2V7aWYoXCJ0aW1lb3V0XCIhPT1jKXRocm93IG5ldyBFcnJvcignVGhlIGdpdmVuIHR5cGUgXCInLmNvbmNhdChjLCdcIiBpcyBub3Qgc3VwcG9ydGVkJykpO28oZCkscG9zdE1lc3NhZ2Uoe2Vycm9yOm51bGwsaWQ6aX0pfX1lbHNle2lmKFwic2V0XCIhPT10Lm1ldGhvZCl0aHJvdyBuZXcgRXJyb3IoJ1RoZSBnaXZlbiBtZXRob2QgXCInLmNvbmNhdCh0Lm1ldGhvZCwnXCIgaXMgbm90IHN1cHBvcnRlZCcpKTt2YXIgdT10LnBhcmFtcyxsPXUuZGVsYXkscD11Lm5vdyxtPXUudGltZXJJZCx2PXUudGltZXJUeXBlO2lmKFwiaW50ZXJ2YWxcIj09PXYpYShsLG0scCk7ZWxzZXtpZihcInRpbWVvdXRcIiE9PXYpdGhyb3cgbmV3IEVycm9yKCdUaGUgZ2l2ZW4gdHlwZSBcIicuY29uY2F0KHYsJ1wiIGlzIG5vdCBzdXBwb3J0ZWQnKSk7cyhsLG0scCl9fX1jYXRjaChlKXtwb3N0TWVzc2FnZSh7ZXJyb3I6e21lc3NhZ2U6ZS5tZXNzYWdlfSxpZDp0LmlkLHJlc3VsdDpudWxsfSl9fSkpfSk/by5jYWxsKHQscix0LGUpOm8pfHwoZS5leHBvcnRzPWkpfX0sdD17fTtmdW5jdGlvbiByKG8pe3ZhciBpPXRbb107aWYodm9pZCAwIT09aSlyZXR1cm4gaS5leHBvcnRzO3ZhciBuPXRbb109e2V4cG9ydHM6e319O3JldHVybiBlW29dKG4sbi5leHBvcnRzLHIpLG4uZXhwb3J0c31yLm49ZT0+e3ZhciB0PWUmJmUuX19lc01vZHVsZT8oKT0+ZS5kZWZhdWx0OigpPT5lO3JldHVybiByLmQodCx7YTp0fSksdH0sci5kPShlLHQpPT57Zm9yKHZhciBvIGluIHQpci5vKHQsbykmJiFyLm8oZSxvKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbyx7ZW51bWVyYWJsZTohMCxnZXQ6dFtvXX0pfSxyLm89KGUsdCk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpLCgoKT0+e1widXNlIHN0cmljdFwiO3IoNDcyKX0pKCl9KSgpO2Asbj1yKGUubG9hZCxpKSxvPWZ1bmN0aW9uKGgpe3JldHVybiBuKCkuY2xlYXJJbnRlcnZhbChoKX0scz1mdW5jdGlvbihoKXtyZXR1cm4gbigpLmNsZWFyVGltZW91dChoKX0sYT1mdW5jdGlvbigpe3ZhciBoO3JldHVybihoPW4oKSkuc2V0SW50ZXJ2YWwuYXBwbHkoaCxhcmd1bWVudHMpfSx1PWZ1bmN0aW9uKCl7dmFyIGg7cmV0dXJuKGg9bigpKS5zZXRUaW1lb3V0LmFwcGx5KGgsYXJndW1lbnRzKX07dC5jbGVhckludGVydmFsPW8sdC5jbGVhclRpbWVvdXQ9cyx0LnNldEludGVydmFsPWEsdC5zZXRUaW1lb3V0PXV9KX0pO3ZhciBNcD1NKFJ0PT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7dmFyIFV2PVJ0JiZSdC5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSxyLGkpe2k9PT12b2lkIDAmJihpPXIpO3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxyKTsoIW58fChcImdldFwiaW4gbj8hZS5fX2VzTW9kdWxlOm4ud3JpdGFibGV8fG4uY29uZmlndXJhYmxlKSkmJihuPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGksbil9OmZ1bmN0aW9uKHQsZSxyLGkpe2k9PT12b2lkIDAmJihpPXIpLHRbaV09ZVtyXX0pLE52PVJ0JiZSdC5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSkscXY9UnQmJlJ0Ll9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKHQhPW51bGwpZm9yKHZhciByIGluIHQpciE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmVXYoZSx0LHIpO3JldHVybiBOdihlLHQpLGV9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShSdCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcnM9cXYoUGkoKSkseHA9a3AoKSxEdj17c2V0OnJzLmRlZmF1bHQmJiFycy5pc1dlYldvcmtlcj94cC5zZXRUaW1lb3V0Oih0LGUpPT5zZXRUaW1lb3V0KHQsZSksY2xlYXI6cnMuZGVmYXVsdCYmIXJzLmlzV2ViV29ya2VyP3hwLmNsZWFyVGltZW91dDp0PT5jbGVhclRpbWVvdXQodCl9O1J0LmRlZmF1bHQ9RHZ9KTt2YXIgcWE9TShPaT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhciBqdj1PaSYmT2kuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShPaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgTHA9anYoTXAoKSksTmE9Y2xhc3N7Y29uc3RydWN0b3IoZSxyKXt0aGlzLmtlZXBhbGl2ZT1lKjFlMyx0aGlzLmNoZWNrUGluZz1yLHRoaXMucmVzY2hlZHVsZSgpfWNsZWFyKCl7dGhpcy50aW1lciYmKExwLmRlZmF1bHQuY2xlYXIodGhpcy50aW1lciksdGhpcy50aW1lcj1udWxsKX1yZXNjaGVkdWxlKCl7dGhpcy5jbGVhcigpLHRoaXMudGltZXI9THAuZGVmYXVsdC5zZXQoKCk9Pnt0aGlzLmNoZWNrUGluZygpLHRoaXMudGltZXImJnRoaXMucmVzY2hlZHVsZSgpfSx0aGlzLmtlZXBhbGl2ZSl9fTtPaS5kZWZhdWx0PU5hfSk7dmFyIG5zPU0oUWU9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTt2YXIgRnY9UWUmJlFlLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLHIsaSl7aT09PXZvaWQgMCYmKGk9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHIpOyghbnx8KFwiZ2V0XCJpbiBuPyFlLl9fZXNNb2R1bGU6bi53cml0YWJsZXx8bi5jb25maWd1cmFibGUpKSYmKG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaSxuKX06ZnVuY3Rpb24odCxlLHIsaSl7aT09PXZvaWQgMCYmKGk9ciksdFtpXT1lW3JdfSksV3Y9UWUmJlFlLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTplfSl9OmZ1bmN0aW9uKHQsZSl7dC5kZWZhdWx0PWV9KSxqcD1RZSYmUWUuX19pbXBvcnRTdGFyfHxmdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGU9e307aWYodCE9bnVsbClmb3IodmFyIHIgaW4gdClyIT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiZGdihlLHQscik7cmV0dXJuIFd2KGUsdCksZX0sVnQ9UWUmJlFlLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoUWUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyICR2PVZ0KEd1KCkpLERhPVZ0KE5kKCkpLEh2PVZ0KFlvKCkpLFZ2PUR0KCksVXA9VnQoRmQoKSksTnA9anAoJGQoKSksenY9VnQob3QoKSksaXM9VnQoWm8oKSksS3Y9VnQoQXAoKSksRmE9WXIoKSxHdj1JcCgpLFF2PVZ0KHFhKCkpLHFwPWpwKFBpKCkpLGphPWdsb2JhbFRoaXMuc2V0SW1tZWRpYXRlfHwoKC4uLnQpPT57bGV0IGU9dC5zaGlmdCgpOygwLEZhLm5leHRUaWNrKSgoKT0+e2UoLi4udCl9KX0pLERwPXtrZWVwYWxpdmU6NjAscmVzY2hlZHVsZVBpbmdzOiEwLHByb3RvY29sSWQ6XCJNUVRUXCIscHJvdG9jb2xWZXJzaW9uOjQscmVjb25uZWN0UGVyaW9kOjFlMyxjb25uZWN0VGltZW91dDozMCoxZTMsY2xlYW46ITAscmVzdWJzY3JpYmU6ITAsd3JpdGVDYWNoZTohMH0sV2E9Y2xhc3MgdCBleHRlbmRzIEd2LlR5cGVkRXZlbnRFbWl0dGVye3N0YXRpYyBkZWZhdWx0SWQoKXtyZXR1cm5gbXF0dGpzXyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygxNikuc3Vic3RyKDIsOCl9YH1jb25zdHJ1Y3RvcihlLHIpe3N1cGVyKCksdGhpcy5vcHRpb25zPXJ8fHt9O2ZvcihsZXQgaSBpbiBEcCl0eXBlb2YgdGhpcy5vcHRpb25zW2ldPlwidVwiP3RoaXMub3B0aW9uc1tpXT1EcFtpXTp0aGlzLm9wdGlvbnNbaV09cltpXTt0aGlzLmxvZz10aGlzLm9wdGlvbnMubG9nfHwoMCx6di5kZWZhdWx0KShcIm1xdHRqczpjbGllbnRcIiksdGhpcy5ub29wPXRoaXMuX25vb3AuYmluZCh0aGlzKSx0aGlzLmxvZyhcIk1xdHRDbGllbnQgOjogdmVyc2lvbjpcIixcIjUuNC4wXCIpLHFwLmlzV2ViV29ya2VyP3RoaXMubG9nKFwiTXF0dENsaWVudCA6OiBlbnZpcm9ubWVudFwiLFwid2Vid29ya2VyXCIpOnRoaXMubG9nKFwiTXF0dENsaWVudCA6OiBlbnZpcm9ubWVudFwiLHFwLmRlZmF1bHQ/XCJicm93c2VyXCI6XCJub2RlXCIpLHRoaXMubG9nKFwiTXF0dENsaWVudCA6OiBvcHRpb25zLnByb3RvY29sXCIsci5wcm90b2NvbCksdGhpcy5sb2coXCJNcXR0Q2xpZW50IDo6IG9wdGlvbnMucHJvdG9jb2xWZXJzaW9uXCIsci5wcm90b2NvbFZlcnNpb24pLHRoaXMubG9nKFwiTXF0dENsaWVudCA6OiBvcHRpb25zLnVzZXJuYW1lXCIsci51c2VybmFtZSksdGhpcy5sb2coXCJNcXR0Q2xpZW50IDo6IG9wdGlvbnMua2VlcGFsaXZlXCIsci5rZWVwYWxpdmUpLHRoaXMubG9nKFwiTXF0dENsaWVudCA6OiBvcHRpb25zLnJlY29ubmVjdFBlcmlvZFwiLHIucmVjb25uZWN0UGVyaW9kKSx0aGlzLmxvZyhcIk1xdHRDbGllbnQgOjogb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWRcIixyLnJlamVjdFVuYXV0aG9yaXplZCksdGhpcy5sb2coXCJNcXR0Q2xpZW50IDo6IG9wdGlvbnMucHJvcGVydGllcy50b3BpY0FsaWFzTWF4aW11bVwiLHIucHJvcGVydGllcz9yLnByb3BlcnRpZXMudG9waWNBbGlhc01heGltdW06dm9pZCAwKSx0aGlzLm9wdGlvbnMuY2xpZW50SWQ9dHlwZW9mIHIuY2xpZW50SWQ9PVwic3RyaW5nXCI/ci5jbGllbnRJZDp0LmRlZmF1bHRJZCgpLHRoaXMubG9nKFwiTXF0dENsaWVudCA6OiBjbGllbnRJZFwiLHRoaXMub3B0aW9ucy5jbGllbnRJZCksdGhpcy5vcHRpb25zLmN1c3RvbUhhbmRsZUFja3M9ci5wcm90b2NvbFZlcnNpb249PT01JiZyLmN1c3RvbUhhbmRsZUFja3M/ci5jdXN0b21IYW5kbGVBY2tzOiguLi5pKT0+e2lbM10obnVsbCwwKX0sdGhpcy5vcHRpb25zLndyaXRlQ2FjaGV8fChEYS5kZWZhdWx0LndyaXRlVG9TdHJlYW0uY2FjaGVOdW1iZXJzPSExKSx0aGlzLnN0cmVhbUJ1aWxkZXI9ZSx0aGlzLm1lc3NhZ2VJZFByb3ZpZGVyPXR5cGVvZiB0aGlzLm9wdGlvbnMubWVzc2FnZUlkUHJvdmlkZXI+XCJ1XCI/bmV3IEh2LmRlZmF1bHQ6dGhpcy5vcHRpb25zLm1lc3NhZ2VJZFByb3ZpZGVyLHRoaXMub3V0Z29pbmdTdG9yZT1yLm91dGdvaW5nU3RvcmV8fG5ldyBpcy5kZWZhdWx0LHRoaXMuaW5jb21pbmdTdG9yZT1yLmluY29taW5nU3RvcmV8fG5ldyBpcy5kZWZhdWx0LHRoaXMucXVldWVRb1NaZXJvPXIucXVldWVRb1NaZXJvPT09dm9pZCAwPyEwOnIucXVldWVRb1NaZXJvLHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzPXt9LHRoaXMubWVzc2FnZUlkVG9Ub3BpYz17fSx0aGlzLnBpbmdUaW1lcj1udWxsLHRoaXMuY29ubmVjdGVkPSExLHRoaXMuZGlzY29ubmVjdGluZz0hMSx0aGlzLnJlY29ubmVjdGluZz0hMSx0aGlzLnF1ZXVlPVtdLHRoaXMuY29ubmFja1RpbWVyPW51bGwsdGhpcy5yZWNvbm5lY3RUaW1lcj1udWxsLHRoaXMuX3N0b3JlUHJvY2Vzc2luZz0hMSx0aGlzLl9wYWNrZXRJZHNEdXJpbmdTdG9yZVByb2Nlc3Npbmc9e30sdGhpcy5fc3RvcmVQcm9jZXNzaW5nUXVldWU9W10sdGhpcy5vdXRnb2luZz17fSx0aGlzLl9maXJzdENvbm5lY3Rpb249ITAsci5wcm9wZXJ0aWVzJiZyLnByb3BlcnRpZXMudG9waWNBbGlhc01heGltdW0+MCYmKHIucHJvcGVydGllcy50b3BpY0FsaWFzTWF4aW11bT42NTUzNT90aGlzLmxvZyhcIk1xdHRDbGllbnQgOjogb3B0aW9ucy5wcm9wZXJ0aWVzLnRvcGljQWxpYXNNYXhpbXVtIGlzIG91dCBvZiByYW5nZVwiKTp0aGlzLnRvcGljQWxpYXNSZWN2PW5ldyAkdi5kZWZhdWx0KHIucHJvcGVydGllcy50b3BpY0FsaWFzTWF4aW11bSkpLHRoaXMub24oXCJjb25uZWN0XCIsKCk9PntsZXR7cXVldWU6aX09dGhpcyxuPSgpPT57bGV0IG89aS5zaGlmdCgpO3RoaXMubG9nKFwiZGVsaXZlciA6OiBlbnRyeSAlb1wiLG8pO2xldCBzPW51bGw7aWYoIW8pe3RoaXMuX3Jlc3Vic2NyaWJlKCk7cmV0dXJufXM9by5wYWNrZXQsdGhpcy5sb2coXCJkZWxpdmVyIDo6IGNhbGwgX3NlbmRQYWNrZXQgZm9yICVvXCIscyk7bGV0IGE9ITA7cy5tZXNzYWdlSWQmJnMubWVzc2FnZUlkIT09MCYmKHRoaXMubWVzc2FnZUlkUHJvdmlkZXIucmVnaXN0ZXIocy5tZXNzYWdlSWQpfHwoYT0hMSkpLGE/dGhpcy5fc2VuZFBhY2tldChzLHU9PntvLmNiJiZvLmNiKHUpLG4oKX0pOih0aGlzLmxvZyhcIm1lc3NhZ2VJZDogJWQgaGFzIGFscmVhZHkgdXNlZC4gVGhlIG1lc3NhZ2UgaXMgc2tpcHBlZCBhbmQgcmVtb3ZlZC5cIixzLm1lc3NhZ2VJZCksbigpKX07dGhpcy5sb2coXCJjb25uZWN0IDo6IHNlbmRpbmcgcXVldWVkIHBhY2tldHNcIiksbigpfSksdGhpcy5vbihcImNsb3NlXCIsKCk9Pnt0aGlzLmxvZyhcImNsb3NlIDo6IGNvbm5lY3RlZCBzZXQgdG8gYGZhbHNlYFwiKSx0aGlzLmNvbm5lY3RlZD0hMSx0aGlzLmxvZyhcImNsb3NlIDo6IGNsZWFyaW5nIGNvbm5hY2tUaW1lclwiKSxjbGVhclRpbWVvdXQodGhpcy5jb25uYWNrVGltZXIpLHRoaXMubG9nKFwiY2xvc2UgOjogY2xlYXJpbmcgcGluZyB0aW1lclwiKSx0aGlzLnBpbmdUaW1lciYmKHRoaXMucGluZ1RpbWVyLmNsZWFyKCksdGhpcy5waW5nVGltZXI9bnVsbCksdGhpcy50b3BpY0FsaWFzUmVjdiYmdGhpcy50b3BpY0FsaWFzUmVjdi5jbGVhcigpLHRoaXMubG9nKFwiY2xvc2UgOjogY2FsbGluZyBfc2V0dXBSZWNvbm5lY3RcIiksdGhpcy5fc2V0dXBSZWNvbm5lY3QoKX0pLHRoaXMub3B0aW9ucy5tYW51YWxDb25uZWN0fHwodGhpcy5sb2coXCJNcXR0Q2xpZW50IDo6IHNldHRpbmcgdXAgc3RyZWFtXCIpLHRoaXMuY29ubmVjdCgpKX1oYW5kbGVBdXRoKGUscil7cigpfWhhbmRsZU1lc3NhZ2UoZSxyKXtyKCl9X25leHRJZCgpe3JldHVybiB0aGlzLm1lc3NhZ2VJZFByb3ZpZGVyLmFsbG9jYXRlKCl9Z2V0TGFzdE1lc3NhZ2VJZCgpe3JldHVybiB0aGlzLm1lc3NhZ2VJZFByb3ZpZGVyLmdldExhc3RBbGxvY2F0ZWQoKX1jb25uZWN0KCl7dmFyIGU7bGV0IHI9bmV3IFZ2LldyaXRhYmxlLGk9RGEuZGVmYXVsdC5wYXJzZXIodGhpcy5vcHRpb25zKSxuPW51bGwsbz1bXTt0aGlzLmxvZyhcImNvbm5lY3QgOjogY2FsbGluZyBtZXRob2QgdG8gY2xlYXIgcmVjb25uZWN0XCIpLHRoaXMuX2NsZWFyUmVjb25uZWN0KCksdGhpcy5sb2coXCJjb25uZWN0IDo6IHVzaW5nIHN0cmVhbUJ1aWxkZXIgcHJvdmlkZWQgdG8gY2xpZW50IHRvIGNyZWF0ZSBzdHJlYW1cIiksdGhpcy5zdHJlYW09dGhpcy5zdHJlYW1CdWlsZGVyKHRoaXMpLGkub24oXCJwYWNrZXRcIixoPT57dGhpcy5sb2coXCJwYXJzZXIgOjogb24gcGFja2V0IHB1c2ggdG8gcGFja2V0cyBhcnJheS5cIiksby5wdXNoKGgpfSk7bGV0IHM9KCk9Pnt0aGlzLmxvZyhcIndvcmsgOjogZ2V0dGluZyBuZXh0IHBhY2tldCBpbiBxdWV1ZVwiKTtsZXQgaD1vLnNoaWZ0KCk7aWYoaCl0aGlzLmxvZyhcIndvcmsgOjogcGFja2V0IHB1bGxlZCBmcm9tIHF1ZXVlXCIpLCgwLEt2LmRlZmF1bHQpKHRoaXMsaCxhKTtlbHNle3RoaXMubG9nKFwid29yayA6OiBubyBwYWNrZXRzIGluIHF1ZXVlXCIpO2xldCBkPW47bj1udWxsLHRoaXMubG9nKFwid29yayA6OiBkb25lIGZsYWcgaXMgJXNcIiwhIWQpLGQmJmQoKX19LGE9KCk9PntpZihvLmxlbmd0aCkoMCxGYS5uZXh0VGljaykocyk7ZWxzZXtsZXQgaD1uO249bnVsbCxoKCl9fTtyLl93cml0ZT0oaCxkLGcpPT57bj1nLHRoaXMubG9nKFwid3JpdGFibGUgc3RyZWFtIDo6IHBhcnNpbmcgYnVmZmVyXCIpLGkucGFyc2UoaCkscygpfTtsZXQgdT1oPT57dGhpcy5sb2coXCJzdHJlYW1FcnJvckhhbmRsZXIgOjogZXJyb3JcIixoLm1lc3NhZ2UpLGguY29kZT8odGhpcy5sb2coXCJzdHJlYW1FcnJvckhhbmRsZXIgOjogZW1pdHRpbmcgZXJyb3JcIiksdGhpcy5lbWl0KFwiZXJyb3JcIixoKSk6dGhpcy5ub29wKGgpfTt0aGlzLmxvZyhcImNvbm5lY3QgOjogcGlwZSBzdHJlYW0gdG8gd3JpdGFibGUgc3RyZWFtXCIpLHRoaXMuc3RyZWFtLnBpcGUociksdGhpcy5zdHJlYW0ub24oXCJlcnJvclwiLHUpLHRoaXMuc3RyZWFtLm9uKFwiY2xvc2VcIiwoKT0+e3RoaXMubG9nKFwiKCVzKXN0cmVhbSA6OiBvbiBjbG9zZVwiLHRoaXMub3B0aW9ucy5jbGllbnRJZCksdGhpcy5fZmx1c2hWb2xhdGlsZSgpLHRoaXMubG9nKFwic3RyZWFtOiBlbWl0IGNsb3NlIHRvIE1xdHRDbGllbnRcIiksdGhpcy5lbWl0KFwiY2xvc2VcIil9KSx0aGlzLmxvZyhcImNvbm5lY3Q6IHNlbmRpbmcgcGFja2V0IGBjb25uZWN0YFwiKTtsZXQgYz17Y21kOlwiY29ubmVjdFwiLHByb3RvY29sSWQ6dGhpcy5vcHRpb25zLnByb3RvY29sSWQscHJvdG9jb2xWZXJzaW9uOnRoaXMub3B0aW9ucy5wcm90b2NvbFZlcnNpb24sY2xlYW46dGhpcy5vcHRpb25zLmNsZWFuLGNsaWVudElkOnRoaXMub3B0aW9ucy5jbGllbnRJZCxrZWVwYWxpdmU6dGhpcy5vcHRpb25zLmtlZXBhbGl2ZSx1c2VybmFtZTp0aGlzLm9wdGlvbnMudXNlcm5hbWUscGFzc3dvcmQ6dGhpcy5vcHRpb25zLnBhc3N3b3JkLHByb3BlcnRpZXM6dGhpcy5vcHRpb25zLnByb3BlcnRpZXN9O2lmKHRoaXMub3B0aW9ucy53aWxsJiYoYy53aWxsPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLm9wdGlvbnMud2lsbCkse3BheWxvYWQ6KGU9dGhpcy5vcHRpb25zLndpbGwpPT09bnVsbHx8ZT09PXZvaWQgMD92b2lkIDA6ZS5wYXlsb2FkfSkpLHRoaXMudG9waWNBbGlhc1JlY3YmJihjLnByb3BlcnRpZXN8fChjLnByb3BlcnRpZXM9e30pLHRoaXMudG9waWNBbGlhc1JlY3YmJihjLnByb3BlcnRpZXMudG9waWNBbGlhc01heGltdW09dGhpcy50b3BpY0FsaWFzUmVjdi5tYXgpKSx0aGlzLl93cml0ZVBhY2tldChjKSxpLm9uKFwiZXJyb3JcIix0aGlzLmVtaXQuYmluZCh0aGlzLFwiZXJyb3JcIikpLHRoaXMub3B0aW9ucy5wcm9wZXJ0aWVzKXtpZighdGhpcy5vcHRpb25zLnByb3BlcnRpZXMuYXV0aGVudGljYXRpb25NZXRob2QmJnRoaXMub3B0aW9ucy5wcm9wZXJ0aWVzLmF1dGhlbnRpY2F0aW9uRGF0YSlyZXR1cm4gdGhpcy5lbmQoKCk9PnRoaXMuZW1pdChcImVycm9yXCIsbmV3IEVycm9yKFwiUGFja2V0IGhhcyBubyBBdXRoZW50aWNhdGlvbiBNZXRob2RcIikpKSx0aGlzO2lmKHRoaXMub3B0aW9ucy5wcm9wZXJ0aWVzLmF1dGhlbnRpY2F0aW9uTWV0aG9kJiZ0aGlzLm9wdGlvbnMuYXV0aFBhY2tldCYmdHlwZW9mIHRoaXMub3B0aW9ucy5hdXRoUGFja2V0PT1cIm9iamVjdFwiKXtsZXQgaD1PYmplY3QuYXNzaWduKHtjbWQ6XCJhdXRoXCIscmVhc29uQ29kZTowfSx0aGlzLm9wdGlvbnMuYXV0aFBhY2tldCk7dGhpcy5fd3JpdGVQYWNrZXQoaCl9fXJldHVybiB0aGlzLnN0cmVhbS5zZXRNYXhMaXN0ZW5lcnMoMWUzKSxjbGVhclRpbWVvdXQodGhpcy5jb25uYWNrVGltZXIpLHRoaXMuY29ubmFja1RpbWVyPXNldFRpbWVvdXQoKCk9Pnt0aGlzLmxvZyhcIiEhY29ubmVjdFRpbWVvdXQgaGl0ISEgQ2FsbGluZyBfY2xlYW5VcCB3aXRoIGZvcmNlIGB0cnVlYFwiKSx0aGlzLmVtaXQoXCJlcnJvclwiLG5ldyBFcnJvcihcImNvbm5hY2sgdGltZW91dFwiKSksdGhpcy5fY2xlYW5VcCghMCl9LHRoaXMub3B0aW9ucy5jb25uZWN0VGltZW91dCksdGhpc31wdWJsaXNoKGUscixpLG4pe3RoaXMubG9nKFwicHVibGlzaCA6OiBtZXNzYWdlIGAlc2AgdG8gdG9waWMgYCVzYFwiLHIsZSk7bGV0e29wdGlvbnM6b309dGhpczt0eXBlb2YgaT09XCJmdW5jdGlvblwiJiYobj1pLGk9bnVsbCksaT1pfHx7fSxpPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx7cW9zOjAscmV0YWluOiExLGR1cDohMX0pLGkpO2xldHtxb3M6YSxyZXRhaW46dSxkdXA6Yyxwcm9wZXJ0aWVzOmgsY2JTdG9yZVB1dDpkfT1pO2lmKHRoaXMuX2NoZWNrRGlzY29ubmVjdGluZyhuKSlyZXR1cm4gdGhpcztsZXQgZz0oKT0+e2xldCB5PTA7aWYoKGE9PT0xfHxhPT09MikmJih5PXRoaXMuX25leHRJZCgpLHk9PT1udWxsKSlyZXR1cm4gdGhpcy5sb2coXCJObyBtZXNzYWdlSWQgbGVmdFwiKSwhMTtsZXQgdz17Y21kOlwicHVibGlzaFwiLHRvcGljOmUscGF5bG9hZDpyLHFvczphLHJldGFpbjp1LG1lc3NhZ2VJZDp5LGR1cDpjfTtzd2l0Y2goby5wcm90b2NvbFZlcnNpb249PT01JiYody5wcm9wZXJ0aWVzPWgpLHRoaXMubG9nKFwicHVibGlzaCA6OiBxb3NcIixhKSxhKXtjYXNlIDE6Y2FzZSAyOnRoaXMub3V0Z29pbmdbdy5tZXNzYWdlSWRdPXt2b2xhdGlsZTohMSxjYjpufHx0aGlzLm5vb3B9LHRoaXMubG9nKFwiTXF0dENsaWVudDpwdWJsaXNoOiBwYWNrZXQgY21kOiAlc1wiLHcuY21kKSx0aGlzLl9zZW5kUGFja2V0KHcsdm9pZCAwLGQpO2JyZWFrO2RlZmF1bHQ6dGhpcy5sb2coXCJNcXR0Q2xpZW50OnB1Ymxpc2g6IHBhY2tldCBjbWQ6ICVzXCIsdy5jbWQpLHRoaXMuX3NlbmRQYWNrZXQodyxuLGQpO2JyZWFrfXJldHVybiEwfTtyZXR1cm4odGhpcy5fc3RvcmVQcm9jZXNzaW5nfHx0aGlzLl9zdG9yZVByb2Nlc3NpbmdRdWV1ZS5sZW5ndGg+MHx8IWcoKSkmJnRoaXMuX3N0b3JlUHJvY2Vzc2luZ1F1ZXVlLnB1c2goe2ludm9rZTpnLGNiU3RvcmVQdXQ6aS5jYlN0b3JlUHV0LGNhbGxiYWNrOm59KSx0aGlzfXB1Ymxpc2hBc3luYyhlLHIsaSl7cmV0dXJuIG5ldyBQcm9taXNlKChuLG8pPT57dGhpcy5wdWJsaXNoKGUscixpLChzLGEpPT57cz9vKHMpOm4oYSl9KX0pfXN1YnNjcmliZShlLHIsaSl7bGV0IG49dGhpcy5vcHRpb25zLnByb3RvY29sVmVyc2lvbjt0eXBlb2Ygcj09XCJmdW5jdGlvblwiJiYoaT1yKSxpPWl8fHRoaXMubm9vcDtsZXQgbz0hMSxzPVtdO3R5cGVvZiBlPT1cInN0cmluZ1wiPyhlPVtlXSxzPWUpOkFycmF5LmlzQXJyYXkoZSk/cz1lOnR5cGVvZiBlPT1cIm9iamVjdFwiJiYobz1lLnJlc3Vic2NyaWJlLGRlbGV0ZSBlLnJlc3Vic2NyaWJlLHM9T2JqZWN0LmtleXMoZSkpO2xldCBhPU5wLnZhbGlkYXRlVG9waWNzKHMpO2lmKGEhPT1udWxsKXJldHVybiBqYShpLG5ldyBFcnJvcihgSW52YWxpZCB0b3BpYyAke2F9YCkpLHRoaXM7aWYodGhpcy5fY2hlY2tEaXNjb25uZWN0aW5nKGkpKXJldHVybiB0aGlzLmxvZyhcInN1YnNjcmliZTogZGlzY2NvbmVjdGluZyB0cnVlXCIpLHRoaXM7bGV0IHU9e3FvczowfTtuPT09NSYmKHUubmw9ITEsdS5yYXA9ITEsdS5yaD0wKSxyPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSxyKTtsZXQgYz1yLnByb3BlcnRpZXMsaD1bXSxkPSh5LHcpPT57aWYodz13fHxyLCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MseSl8fHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzW3ldLnFvczx3LnFvc3x8byl7bGV0IEU9e3RvcGljOnkscW9zOncucW9zfTtuPT09NSYmKEUubmw9dy5ubCxFLnJhcD13LnJhcCxFLnJoPXcucmgsRS5wcm9wZXJ0aWVzPWMpLHRoaXMubG9nKFwic3Vic2NyaWJlOiBwdXNoaW5nIHRvcGljIGAlc2AgYW5kIHFvcyBgJXNgIHRvIHN1YnMgbGlzdFwiLEUudG9waWMsRS5xb3MpLGgucHVzaChFKX19O2lmKEFycmF5LmlzQXJyYXkoZSk/ZS5mb3JFYWNoKHk9Pnt0aGlzLmxvZyhcInN1YnNjcmliZTogYXJyYXkgdG9waWMgJXNcIix5KSxkKHkpfSk6T2JqZWN0LmtleXMoZSkuZm9yRWFjaCh5PT57dGhpcy5sb2coXCJzdWJzY3JpYmU6IG9iamVjdCB0b3BpYyAlcywgJW9cIix5LGVbeV0pLGQoeSxlW3ldKX0pLCFoLmxlbmd0aClyZXR1cm4gaShudWxsLFtdKSx0aGlzO2xldCBnPSgpPT57bGV0IHk9dGhpcy5fbmV4dElkKCk7aWYoeT09PW51bGwpcmV0dXJuIHRoaXMubG9nKFwiTm8gbWVzc2FnZUlkIGxlZnRcIiksITE7bGV0IHc9e2NtZDpcInN1YnNjcmliZVwiLHN1YnNjcmlwdGlvbnM6aCxtZXNzYWdlSWQ6eX07aWYoYyYmKHcucHJvcGVydGllcz1jKSx0aGlzLm9wdGlvbnMucmVzdWJzY3JpYmUpe3RoaXMubG9nKFwic3Vic2NyaWJlIDo6IHJlc3Vic2NyaWJlIHRydWVcIik7bGV0IEU9W107aC5mb3JFYWNoKFM9PntpZih0aGlzLm9wdGlvbnMucmVjb25uZWN0UGVyaW9kPjApe2xldCBJPXtxb3M6Uy5xb3N9O249PT01JiYoSS5ubD1TLm5sfHwhMSxJLnJhcD1TLnJhcHx8ITEsSS5yaD1TLnJofHwwLEkucHJvcGVydGllcz1TLnByb3BlcnRpZXMpLHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzW1MudG9waWNdPUksRS5wdXNoKFMudG9waWMpfX0pLHRoaXMubWVzc2FnZUlkVG9Ub3BpY1t3Lm1lc3NhZ2VJZF09RX1yZXR1cm4gdGhpcy5vdXRnb2luZ1t3Lm1lc3NhZ2VJZF09e3ZvbGF0aWxlOiEwLGNiKEUsUyl7aWYoIUUpe2xldHtncmFudGVkOkl9PVM7Zm9yKGxldCBDPTA7QzxJLmxlbmd0aDtDKz0xKWhbQ10ucW9zPUlbQ119aShFLGgpfX0sdGhpcy5sb2coXCJzdWJzY3JpYmUgOjogY2FsbCBfc2VuZFBhY2tldFwiKSx0aGlzLl9zZW5kUGFja2V0KHcpLCEwfTtyZXR1cm4odGhpcy5fc3RvcmVQcm9jZXNzaW5nfHx0aGlzLl9zdG9yZVByb2Nlc3NpbmdRdWV1ZS5sZW5ndGg+MHx8IWcoKSkmJnRoaXMuX3N0b3JlUHJvY2Vzc2luZ1F1ZXVlLnB1c2goe2ludm9rZTpnLGNhbGxiYWNrOml9KSx0aGlzfXN1YnNjcmliZUFzeW5jKGUscil7cmV0dXJuIG5ldyBQcm9taXNlKChpLG4pPT57dGhpcy5zdWJzY3JpYmUoZSxyLChvLHMpPT57bz9uKG8pOmkocyl9KX0pfXVuc3Vic2NyaWJlKGUscixpKXt0eXBlb2YgZT09XCJzdHJpbmdcIiYmKGU9W2VdKSx0eXBlb2Ygcj09XCJmdW5jdGlvblwiJiYoaT1yKSxpPWl8fHRoaXMubm9vcDtsZXQgbj1OcC52YWxpZGF0ZVRvcGljcyhlKTtpZihuIT09bnVsbClyZXR1cm4gamEoaSxuZXcgRXJyb3IoYEludmFsaWQgdG9waWMgJHtufWApKSx0aGlzO2lmKHRoaXMuX2NoZWNrRGlzY29ubmVjdGluZyhpKSlyZXR1cm4gdGhpcztsZXQgbz0oKT0+e2xldCBzPXRoaXMuX25leHRJZCgpO2lmKHM9PT1udWxsKXJldHVybiB0aGlzLmxvZyhcIk5vIG1lc3NhZ2VJZCBsZWZ0XCIpLCExO2xldCBhPXtjbWQ6XCJ1bnN1YnNjcmliZVwiLG1lc3NhZ2VJZDpzLHVuc3Vic2NyaXB0aW9uczpbXX07cmV0dXJuIHR5cGVvZiBlPT1cInN0cmluZ1wiP2EudW5zdWJzY3JpcHRpb25zPVtlXTpBcnJheS5pc0FycmF5KGUpJiYoYS51bnN1YnNjcmlwdGlvbnM9ZSksdGhpcy5vcHRpb25zLnJlc3Vic2NyaWJlJiZhLnVuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHU9PntkZWxldGUgdGhpcy5fcmVzdWJzY3JpYmVUb3BpY3NbdV19KSx0eXBlb2Ygcj09XCJvYmplY3RcIiYmci5wcm9wZXJ0aWVzJiYoYS5wcm9wZXJ0aWVzPXIucHJvcGVydGllcyksdGhpcy5vdXRnb2luZ1thLm1lc3NhZ2VJZF09e3ZvbGF0aWxlOiEwLGNiOml9LHRoaXMubG9nKFwidW5zdWJzY3JpYmU6IGNhbGwgX3NlbmRQYWNrZXRcIiksdGhpcy5fc2VuZFBhY2tldChhKSwhMH07cmV0dXJuKHRoaXMuX3N0b3JlUHJvY2Vzc2luZ3x8dGhpcy5fc3RvcmVQcm9jZXNzaW5nUXVldWUubGVuZ3RoPjB8fCFvKCkpJiZ0aGlzLl9zdG9yZVByb2Nlc3NpbmdRdWV1ZS5wdXNoKHtpbnZva2U6byxjYWxsYmFjazppfSksdGhpc311bnN1YnNjcmliZUFzeW5jKGUscil7cmV0dXJuIG5ldyBQcm9taXNlKChpLG4pPT57dGhpcy51bnN1YnNjcmliZShlLHIsKG8scyk9PntvP24obyk6aShzKX0pfSl9ZW5kKGUscixpKXt0aGlzLmxvZyhcImVuZCA6OiAoJXMpXCIsdGhpcy5vcHRpb25zLmNsaWVudElkKSwoZT09bnVsbHx8dHlwZW9mIGUhPVwiYm9vbGVhblwiKSYmKGk9aXx8cixyPWUsZT0hMSksdHlwZW9mIHIhPVwib2JqZWN0XCImJihpPWl8fHIscj1udWxsKSx0aGlzLmxvZyhcImVuZCA6OiBjYj8gJXNcIiwhIWkpLCghaXx8dHlwZW9mIGkhPVwiZnVuY3Rpb25cIikmJihpPXRoaXMubm9vcCk7bGV0IG49KCk9Pnt0aGlzLmxvZyhcImVuZCA6OiBjbG9zZVN0b3JlczogY2xvc2luZyBpbmNvbWluZyBhbmQgb3V0Z29pbmcgc3RvcmVzXCIpLHRoaXMuZGlzY29ubmVjdGVkPSEwLHRoaXMuaW5jb21pbmdTdG9yZS5jbG9zZShzPT57dGhpcy5vdXRnb2luZ1N0b3JlLmNsb3NlKGE9PntpZih0aGlzLmxvZyhcImVuZCA6OiBjbG9zZVN0b3JlczogZW1pdHRpbmcgZW5kXCIpLHRoaXMuZW1pdChcImVuZFwiKSxpKXtsZXQgdT1zfHxhO3RoaXMubG9nKFwiZW5kIDo6IGNsb3NlU3RvcmVzOiBpbnZva2luZyBjYWxsYmFjayB3aXRoIGFyZ3NcIiksaSh1KX19KX0pLHRoaXMuX2RlZmVycmVkUmVjb25uZWN0JiZ0aGlzLl9kZWZlcnJlZFJlY29ubmVjdCgpfSxvPSgpPT57dGhpcy5sb2coXCJlbmQgOjogKCVzKSA6OiBmaW5pc2ggOjogY2FsbGluZyBfY2xlYW5VcCB3aXRoIGZvcmNlICVzXCIsdGhpcy5vcHRpb25zLmNsaWVudElkLGUpLHRoaXMuX2NsZWFuVXAoZSwoKT0+e3RoaXMubG9nKFwiZW5kIDo6IGZpbmlzaCA6OiBjYWxsaW5nIHByb2Nlc3MubmV4dFRpY2sgb24gY2xvc2VTdG9yZXNcIiksKDAsRmEubmV4dFRpY2spKG4pfSxyKX07cmV0dXJuIHRoaXMuZGlzY29ubmVjdGluZz8oaSgpLHRoaXMpOih0aGlzLl9jbGVhclJlY29ubmVjdCgpLHRoaXMuZGlzY29ubmVjdGluZz0hMCwhZSYmT2JqZWN0LmtleXModGhpcy5vdXRnb2luZykubGVuZ3RoPjA/KHRoaXMubG9nKFwiZW5kIDo6ICglcykgOjogY2FsbGluZyBmaW5pc2ggaW4gMTBtcyBvbmNlIG91dGdvaW5nIGlzIGVtcHR5XCIsdGhpcy5vcHRpb25zLmNsaWVudElkKSx0aGlzLm9uY2UoXCJvdXRnb2luZ0VtcHR5XCIsc2V0VGltZW91dC5iaW5kKG51bGwsbywxMCkpKToodGhpcy5sb2coXCJlbmQgOjogKCVzKSA6OiBpbW1lZGlhdGVseSBjYWxsaW5nIGZpbmlzaFwiLHRoaXMub3B0aW9ucy5jbGllbnRJZCksbygpKSx0aGlzKX1lbmRBc3luYyhlLHIpe3JldHVybiBuZXcgUHJvbWlzZSgoaSxuKT0+e3RoaXMuZW5kKGUscixvPT57bz9uKG8pOmkoKX0pfSl9cmVtb3ZlT3V0Z29pbmdNZXNzYWdlKGUpe2lmKHRoaXMub3V0Z29pbmdbZV0pe2xldHtjYjpyfT10aGlzLm91dGdvaW5nW2VdO3RoaXMuX3JlbW92ZU91dGdvaW5nQW5kU3RvcmVNZXNzYWdlKGUsKCk9PntyKG5ldyBFcnJvcihcIk1lc3NhZ2UgcmVtb3ZlZFwiKSl9KX1yZXR1cm4gdGhpc31yZWNvbm5lY3QoZSl7dGhpcy5sb2coXCJjbGllbnQgcmVjb25uZWN0XCIpO2xldCByPSgpPT57ZT8odGhpcy5vcHRpb25zLmluY29taW5nU3RvcmU9ZS5pbmNvbWluZ1N0b3JlLHRoaXMub3B0aW9ucy5vdXRnb2luZ1N0b3JlPWUub3V0Z29pbmdTdG9yZSk6KHRoaXMub3B0aW9ucy5pbmNvbWluZ1N0b3JlPW51bGwsdGhpcy5vcHRpb25zLm91dGdvaW5nU3RvcmU9bnVsbCksdGhpcy5pbmNvbWluZ1N0b3JlPXRoaXMub3B0aW9ucy5pbmNvbWluZ1N0b3JlfHxuZXcgaXMuZGVmYXVsdCx0aGlzLm91dGdvaW5nU3RvcmU9dGhpcy5vcHRpb25zLm91dGdvaW5nU3RvcmV8fG5ldyBpcy5kZWZhdWx0LHRoaXMuZGlzY29ubmVjdGluZz0hMSx0aGlzLmRpc2Nvbm5lY3RlZD0hMSx0aGlzLl9kZWZlcnJlZFJlY29ubmVjdD1udWxsLHRoaXMuX3JlY29ubmVjdCgpfTtyZXR1cm4gdGhpcy5kaXNjb25uZWN0aW5nJiYhdGhpcy5kaXNjb25uZWN0ZWQ/dGhpcy5fZGVmZXJyZWRSZWNvbm5lY3Q9cjpyKCksdGhpc31fZmx1c2hWb2xhdGlsZSgpe3RoaXMub3V0Z29pbmcmJih0aGlzLmxvZyhcIl9mbHVzaFZvbGF0aWxlIDo6IGRlbGV0aW5nIHZvbGF0aWxlIG1lc3NhZ2VzIGZyb20gdGhlIHF1ZXVlIGFuZCBzZXR0aW5nIHRoZWlyIGNhbGxiYWNrcyBhcyBlcnJvciBmdW5jdGlvblwiKSxPYmplY3Qua2V5cyh0aGlzLm91dGdvaW5nKS5mb3JFYWNoKGU9Pnt0aGlzLm91dGdvaW5nW2VdLnZvbGF0aWxlJiZ0eXBlb2YgdGhpcy5vdXRnb2luZ1tlXS5jYj09XCJmdW5jdGlvblwiJiYodGhpcy5vdXRnb2luZ1tlXS5jYihuZXcgRXJyb3IoXCJDb25uZWN0aW9uIGNsb3NlZFwiKSksZGVsZXRlIHRoaXMub3V0Z29pbmdbZV0pfSkpfV9mbHVzaCgpe3RoaXMub3V0Z29pbmcmJih0aGlzLmxvZyhcIl9mbHVzaDogcXVldWUgZXhpc3RzPyAlYlwiLCEhdGhpcy5vdXRnb2luZyksT2JqZWN0LmtleXModGhpcy5vdXRnb2luZykuZm9yRWFjaChlPT57dHlwZW9mIHRoaXMub3V0Z29pbmdbZV0uY2I9PVwiZnVuY3Rpb25cIiYmKHRoaXMub3V0Z29pbmdbZV0uY2IobmV3IEVycm9yKFwiQ29ubmVjdGlvbiBjbG9zZWRcIikpLGRlbGV0ZSB0aGlzLm91dGdvaW5nW2VdKX0pKX1fcmVtb3ZlVG9waWNBbGlhc0FuZFJlY292ZXJUb3BpY05hbWUoZSl7bGV0IHI7ZS5wcm9wZXJ0aWVzJiYocj1lLnByb3BlcnRpZXMudG9waWNBbGlhcyk7bGV0IGk9ZS50b3BpYy50b1N0cmluZygpO2lmKHRoaXMubG9nKFwiX3JlbW92ZVRvcGljQWxpYXNBbmRSZWNvdmVyVG9waWNOYW1lIDo6IGFsaWFzICVkLCB0b3BpYyAlb1wiLHIsaSksaS5sZW5ndGg9PT0wKXtpZih0eXBlb2Ygcj5cInVcIilyZXR1cm4gbmV3IEVycm9yKFwiVW5yZWdpc3RlcmVkIFRvcGljIEFsaWFzXCIpO2lmKGk9dGhpcy50b3BpY0FsaWFzU2VuZC5nZXRUb3BpY0J5QWxpYXMociksdHlwZW9mIGk+XCJ1XCIpcmV0dXJuIG5ldyBFcnJvcihcIlVucmVnaXN0ZXJlZCBUb3BpYyBBbGlhc1wiKTtlLnRvcGljPWl9ciYmZGVsZXRlIGUucHJvcGVydGllcy50b3BpY0FsaWFzfV9jaGVja0Rpc2Nvbm5lY3RpbmcoZSl7cmV0dXJuIHRoaXMuZGlzY29ubmVjdGluZyYmKGUmJmUhPT10aGlzLm5vb3A/ZShuZXcgRXJyb3IoXCJjbGllbnQgZGlzY29ubmVjdGluZ1wiKSk6dGhpcy5lbWl0KFwiZXJyb3JcIixuZXcgRXJyb3IoXCJjbGllbnQgZGlzY29ubmVjdGluZ1wiKSkpLHRoaXMuZGlzY29ubmVjdGluZ31fcmVjb25uZWN0KCl7dGhpcy5sb2coXCJfcmVjb25uZWN0OiBlbWl0dGluZyByZWNvbm5lY3QgdG8gY2xpZW50XCIpLHRoaXMuZW1pdChcInJlY29ubmVjdFwiKSx0aGlzLmNvbm5lY3RlZD8odGhpcy5lbmQoKCk9Pnt0aGlzLmNvbm5lY3QoKX0pLHRoaXMubG9nKFwiY2xpZW50IGFscmVhZHkgY29ubmVjdGVkLiBkaXNjb25uZWN0aW5nIGZpcnN0LlwiKSk6KHRoaXMubG9nKFwiX3JlY29ubmVjdDogY2FsbGluZyBjb25uZWN0XCIpLHRoaXMuY29ubmVjdCgpKX1fc2V0dXBSZWNvbm5lY3QoKXshdGhpcy5kaXNjb25uZWN0aW5nJiYhdGhpcy5yZWNvbm5lY3RUaW1lciYmdGhpcy5vcHRpb25zLnJlY29ubmVjdFBlcmlvZD4wPyh0aGlzLnJlY29ubmVjdGluZ3x8KHRoaXMubG9nKFwiX3NldHVwUmVjb25uZWN0IDo6IGVtaXQgYG9mZmxpbmVgIHN0YXRlXCIpLHRoaXMuZW1pdChcIm9mZmxpbmVcIiksdGhpcy5sb2coXCJfc2V0dXBSZWNvbm5lY3QgOjogc2V0IGByZWNvbm5lY3RpbmdgIHRvIGB0cnVlYFwiKSx0aGlzLnJlY29ubmVjdGluZz0hMCksdGhpcy5sb2coXCJfc2V0dXBSZWNvbm5lY3QgOjogc2V0dGluZyByZWNvbm5lY3RUaW1lciBmb3IgJWQgbXNcIix0aGlzLm9wdGlvbnMucmVjb25uZWN0UGVyaW9kKSx0aGlzLnJlY29ubmVjdFRpbWVyPXNldEludGVydmFsKCgpPT57dGhpcy5sb2coXCJyZWNvbm5lY3RUaW1lciA6OiByZWNvbm5lY3QgdHJpZ2dlcmVkIVwiKSx0aGlzLl9yZWNvbm5lY3QoKX0sdGhpcy5vcHRpb25zLnJlY29ubmVjdFBlcmlvZCkpOnRoaXMubG9nKFwiX3NldHVwUmVjb25uZWN0IDo6IGRvaW5nIG5vdGhpbmcuLi5cIil9X2NsZWFyUmVjb25uZWN0KCl7dGhpcy5sb2coXCJfY2xlYXJSZWNvbm5lY3QgOiBjbGVhcmluZyByZWNvbm5lY3QgdGltZXJcIiksdGhpcy5yZWNvbm5lY3RUaW1lciYmKGNsZWFySW50ZXJ2YWwodGhpcy5yZWNvbm5lY3RUaW1lciksdGhpcy5yZWNvbm5lY3RUaW1lcj1udWxsKX1fY2xlYW5VcChlLHIsaT17fSl7aWYociYmKHRoaXMubG9nKFwiX2NsZWFuVXAgOjogZG9uZSBjYWxsYmFjayBwcm92aWRlZCBmb3Igb24gc3RyZWFtIGNsb3NlXCIpLHRoaXMuc3RyZWFtLm9uKFwiY2xvc2VcIixyKSksdGhpcy5sb2coXCJfY2xlYW5VcCA6OiBmb3JjZWQ/ICVzXCIsZSksZSl0aGlzLm9wdGlvbnMucmVjb25uZWN0UGVyaW9kPT09MCYmdGhpcy5vcHRpb25zLmNsZWFuJiZ0aGlzLl9mbHVzaCgpLHRoaXMubG9nKFwiX2NsZWFuVXAgOjogKCVzKSA6OiBkZXN0cm95aW5nIHN0cmVhbVwiLHRoaXMub3B0aW9ucy5jbGllbnRJZCksdGhpcy5zdHJlYW0uZGVzdHJveSgpO2Vsc2V7bGV0IG49T2JqZWN0LmFzc2lnbih7Y21kOlwiZGlzY29ubmVjdFwifSxpKTt0aGlzLmxvZyhcIl9jbGVhblVwIDo6ICglcykgOjogY2FsbCBfc2VuZFBhY2tldCB3aXRoIGRpc2Nvbm5lY3QgcGFja2V0XCIsdGhpcy5vcHRpb25zLmNsaWVudElkKSx0aGlzLl9zZW5kUGFja2V0KG4sKCk9Pnt0aGlzLmxvZyhcIl9jbGVhblVwIDo6ICglcykgOjogZGVzdHJveWluZyBzdHJlYW1cIix0aGlzLm9wdGlvbnMuY2xpZW50SWQpLGphKCgpPT57dGhpcy5zdHJlYW0uZW5kKCgpPT57dGhpcy5sb2coXCJfY2xlYW5VcCA6OiAoJXMpIDo6IHN0cmVhbSBkZXN0cm95ZWRcIix0aGlzLm9wdGlvbnMuY2xpZW50SWQpfSl9KX0pfSF0aGlzLmRpc2Nvbm5lY3RpbmcmJiF0aGlzLnJlY29ubmVjdGluZyYmKHRoaXMubG9nKFwiX2NsZWFuVXAgOjogY2xpZW50IG5vdCBkaXNjb25uZWN0aW5nL3JlY29ubmVjdGluZy4gQ2xlYXJpbmcgYW5kIHJlc2V0dGluZyByZWNvbm5lY3QuXCIpLHRoaXMuX2NsZWFyUmVjb25uZWN0KCksdGhpcy5fc2V0dXBSZWNvbm5lY3QoKSksdGhpcy5waW5nVGltZXImJih0aGlzLmxvZyhcIl9jbGVhblVwIDo6IGNsZWFyaW5nIHBpbmdUaW1lclwiKSx0aGlzLnBpbmdUaW1lci5jbGVhcigpLHRoaXMucGluZ1RpbWVyPW51bGwpLHImJiF0aGlzLmNvbm5lY3RlZCYmKHRoaXMubG9nKFwiX2NsZWFuVXAgOjogKCVzKSA6OiByZW1vdmluZyBzdHJlYW0gYGRvbmVgIGNhbGxiYWNrIGBjbG9zZWAgbGlzdGVuZXJcIix0aGlzLm9wdGlvbnMuY2xpZW50SWQpLHRoaXMuc3RyZWFtLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixyKSxyKCkpfV9zdG9yZUFuZFNlbmQoZSxyLGkpe3RoaXMubG9nKFwic3RvcmVBbmRTZW5kIDo6IHN0b3JlIHBhY2tldCB3aXRoIGNtZCAlcyB0byBvdXRnb2luZ1N0b3JlXCIsZS5jbWQpO2xldCBuPWUsbztpZihuLmNtZD09PVwicHVibGlzaFwiJiYobj0oMCxVcC5kZWZhdWx0KShlKSxvPXRoaXMuX3JlbW92ZVRvcGljQWxpYXNBbmRSZWNvdmVyVG9waWNOYW1lKG4pLG8pKXJldHVybiByJiZyKG8pO3RoaXMub3V0Z29pbmdTdG9yZS5wdXQobixzPT57aWYocylyZXR1cm4gciYmcihzKTtpKCksdGhpcy5fd3JpdGVQYWNrZXQoZSxyKX0pfV9hcHBseVRvcGljQWxpYXMoZSl7aWYodGhpcy5vcHRpb25zLnByb3RvY29sVmVyc2lvbj09PTUmJmUuY21kPT09XCJwdWJsaXNoXCIpe2xldCByO2UucHJvcGVydGllcyYmKHI9ZS5wcm9wZXJ0aWVzLnRvcGljQWxpYXMpO2xldCBpPWUudG9waWMudG9TdHJpbmcoKTtpZih0aGlzLnRvcGljQWxpYXNTZW5kKWlmKHIpe2lmKGkubGVuZ3RoIT09MCYmKHRoaXMubG9nKFwiYXBwbHlUb3BpY0FsaWFzIDo6IHJlZ2lzdGVyIHRvcGljOiAlcyAtIGFsaWFzOiAlZFwiLGksciksIXRoaXMudG9waWNBbGlhc1NlbmQucHV0KGkscikpKXJldHVybiB0aGlzLmxvZyhcImFwcGx5VG9waWNBbGlhcyA6OiBlcnJvciBvdXQgb2YgcmFuZ2UuIHRvcGljOiAlcyAtIGFsaWFzOiAlZFwiLGksciksbmV3IEVycm9yKFwiU2VuZGluZyBUb3BpYyBBbGlhcyBvdXQgb2YgcmFuZ2VcIil9ZWxzZSBpLmxlbmd0aCE9PTAmJih0aGlzLm9wdGlvbnMuYXV0b0Fzc2lnblRvcGljQWxpYXM/KHI9dGhpcy50b3BpY0FsaWFzU2VuZC5nZXRBbGlhc0J5VG9waWMoaSkscj8oZS50b3BpYz1cIlwiLGUucHJvcGVydGllcz1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZS5wcm9wZXJ0aWVzKSx7dG9waWNBbGlhczpyfSksdGhpcy5sb2coXCJhcHBseVRvcGljQWxpYXMgOjogYXV0byBhc3NpZ24odXNlKSB0b3BpYzogJXMgLSBhbGlhczogJWRcIixpLHIpKToocj10aGlzLnRvcGljQWxpYXNTZW5kLmdldExydUFsaWFzKCksdGhpcy50b3BpY0FsaWFzU2VuZC5wdXQoaSxyKSxlLnByb3BlcnRpZXM9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUucHJvcGVydGllcykse3RvcGljQWxpYXM6cn0pLHRoaXMubG9nKFwiYXBwbHlUb3BpY0FsaWFzIDo6IGF1dG8gYXNzaWduIHRvcGljOiAlcyAtIGFsaWFzOiAlZFwiLGkscikpKTp0aGlzLm9wdGlvbnMuYXV0b1VzZVRvcGljQWxpYXMmJihyPXRoaXMudG9waWNBbGlhc1NlbmQuZ2V0QWxpYXNCeVRvcGljKGkpLHImJihlLnRvcGljPVwiXCIsZS5wcm9wZXJ0aWVzPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlLnByb3BlcnRpZXMpLHt0b3BpY0FsaWFzOnJ9KSx0aGlzLmxvZyhcImFwcGx5VG9waWNBbGlhcyA6OiBhdXRvIHVzZSB0b3BpYzogJXMgLSBhbGlhczogJWRcIixpLHIpKSkpO2Vsc2UgaWYocilyZXR1cm4gdGhpcy5sb2coXCJhcHBseVRvcGljQWxpYXMgOjogZXJyb3Igb3V0IG9mIHJhbmdlLiB0b3BpYzogJXMgLSBhbGlhczogJWRcIixpLHIpLG5ldyBFcnJvcihcIlNlbmRpbmcgVG9waWMgQWxpYXMgb3V0IG9mIHJhbmdlXCIpfX1fbm9vcChlKXt0aGlzLmxvZyhcIm5vb3AgOjpcIixlKX1fd3JpdGVQYWNrZXQoZSxyKXt0aGlzLmxvZyhcIl93cml0ZVBhY2tldCA6OiBwYWNrZXQ6ICVPXCIsZSksdGhpcy5sb2coXCJfd3JpdGVQYWNrZXQgOjogZW1pdHRpbmcgYHBhY2tldHNlbmRgXCIpLHRoaXMuZW1pdChcInBhY2tldHNlbmRcIixlKSx0aGlzLl9zaGlmdFBpbmdJbnRlcnZhbCgpLHRoaXMubG9nKFwiX3dyaXRlUGFja2V0IDo6IHdyaXRpbmcgdG8gc3RyZWFtXCIpO2xldCBpPURhLmRlZmF1bHQud3JpdGVUb1N0cmVhbShlLHRoaXMuc3RyZWFtLHRoaXMub3B0aW9ucyk7dGhpcy5sb2coXCJfd3JpdGVQYWNrZXQgOjogd3JpdGVUb1N0cmVhbSByZXN1bHQgJXNcIixpKSwhaSYmciYmciE9PXRoaXMubm9vcD8odGhpcy5sb2coXCJfd3JpdGVQYWNrZXQgOjogaGFuZGxlIGV2ZW50cyBvbiBgZHJhaW5gIG9uY2UgdGhyb3VnaCBjYWxsYmFjay5cIiksdGhpcy5zdHJlYW0ub25jZShcImRyYWluXCIscikpOnImJih0aGlzLmxvZyhcIl93cml0ZVBhY2tldCA6OiBpbnZva2luZyBjYlwiKSxyKCkpfV9zZW5kUGFja2V0KGUscixpLG4pe3RoaXMubG9nKFwiX3NlbmRQYWNrZXQgOjogKCVzKSA6OiAgc3RhcnRcIix0aGlzLm9wdGlvbnMuY2xpZW50SWQpLGk9aXx8dGhpcy5ub29wLHI9cnx8dGhpcy5ub29wO2xldCBvPXRoaXMuX2FwcGx5VG9waWNBbGlhcyhlKTtpZihvKXtyKG8pO3JldHVybn1pZighdGhpcy5jb25uZWN0ZWQpe2lmKGUuY21kPT09XCJhdXRoXCIpe3RoaXMuX3dyaXRlUGFja2V0KGUscik7cmV0dXJufXRoaXMubG9nKFwiX3NlbmRQYWNrZXQgOjogY2xpZW50IG5vdCBjb25uZWN0ZWQuIFN0b3JpbmcgcGFja2V0IG9mZmxpbmUuXCIpLHRoaXMuX3N0b3JlUGFja2V0KGUscixpKTtyZXR1cm59aWYobil7dGhpcy5fd3JpdGVQYWNrZXQoZSxyKTtyZXR1cm59c3dpdGNoKGUuY21kKXtjYXNlXCJwdWJsaXNoXCI6YnJlYWs7Y2FzZVwicHVicmVsXCI6dGhpcy5fc3RvcmVBbmRTZW5kKGUscixpKTtyZXR1cm47ZGVmYXVsdDp0aGlzLl93cml0ZVBhY2tldChlLHIpO3JldHVybn1zd2l0Y2goZS5xb3Mpe2Nhc2UgMjpjYXNlIDE6dGhpcy5fc3RvcmVBbmRTZW5kKGUscixpKTticmVhaztjYXNlIDA6ZGVmYXVsdDp0aGlzLl93cml0ZVBhY2tldChlLHIpO2JyZWFrfXRoaXMubG9nKFwiX3NlbmRQYWNrZXQgOjogKCVzKSA6OiAgZW5kXCIsdGhpcy5vcHRpb25zLmNsaWVudElkKX1fc3RvcmVQYWNrZXQoZSxyLGkpe3RoaXMubG9nKFwiX3N0b3JlUGFja2V0IDo6IHBhY2tldDogJW9cIixlKSx0aGlzLmxvZyhcIl9zdG9yZVBhY2tldCA6OiBjYj8gJXNcIiwhIXIpLGk9aXx8dGhpcy5ub29wO2xldCBuPWU7aWYobi5jbWQ9PT1cInB1Ymxpc2hcIil7bj0oMCxVcC5kZWZhdWx0KShlKTtsZXQgcz10aGlzLl9yZW1vdmVUb3BpY0FsaWFzQW5kUmVjb3ZlclRvcGljTmFtZShuKTtpZihzKXJldHVybiByJiZyKHMpfWxldCBvPW4ucW9zfHwwO289PT0wJiZ0aGlzLnF1ZXVlUW9TWmVyb3x8bi5jbWQhPT1cInB1Ymxpc2hcIj90aGlzLnF1ZXVlLnB1c2goe3BhY2tldDpuLGNiOnJ9KTpvPjA/KHI9dGhpcy5vdXRnb2luZ1tuLm1lc3NhZ2VJZF0/dGhpcy5vdXRnb2luZ1tuLm1lc3NhZ2VJZF0uY2I6bnVsbCx0aGlzLm91dGdvaW5nU3RvcmUucHV0KG4scz0+e2lmKHMpcmV0dXJuIHImJnIocyk7aSgpfSkpOnImJnIobmV3IEVycm9yKFwiTm8gY29ubmVjdGlvbiB0byBicm9rZXJcIikpfV9zZXR1cFBpbmdUaW1lcigpe3RoaXMubG9nKFwiX3NldHVwUGluZ1RpbWVyIDo6IGtlZXBhbGl2ZSAlZCAoc2Vjb25kcylcIix0aGlzLm9wdGlvbnMua2VlcGFsaXZlKSwhdGhpcy5waW5nVGltZXImJnRoaXMub3B0aW9ucy5rZWVwYWxpdmUmJih0aGlzLnBpbmdSZXNwPSEwLHRoaXMucGluZ1RpbWVyPW5ldyBRdi5kZWZhdWx0KHRoaXMub3B0aW9ucy5rZWVwYWxpdmUsKCk9Pnt0aGlzLl9jaGVja1BpbmcoKX0pKX1fc2hpZnRQaW5nSW50ZXJ2YWwoKXt0aGlzLnBpbmdUaW1lciYmdGhpcy5vcHRpb25zLmtlZXBhbGl2ZSYmdGhpcy5vcHRpb25zLnJlc2NoZWR1bGVQaW5ncyYmdGhpcy5waW5nVGltZXIucmVzY2hlZHVsZSgpfV9jaGVja1BpbmcoKXt0aGlzLmxvZyhcIl9jaGVja1BpbmcgOjogY2hlY2tpbmcgcGluZy4uLlwiKSx0aGlzLnBpbmdSZXNwPyh0aGlzLmxvZyhcIl9jaGVja1BpbmcgOjogcGluZyByZXNwb25zZSByZWNlaXZlZC4gQ2xlYXJpbmcgZmxhZyBhbmQgc2VuZGluZyBgcGluZ3JlcWBcIiksdGhpcy5waW5nUmVzcD0hMSx0aGlzLl9zZW5kUGFja2V0KHtjbWQ6XCJwaW5ncmVxXCJ9KSk6KHRoaXMuZW1pdChcImVycm9yXCIsbmV3IEVycm9yKFwiS2VlcGFsaXZlIHRpbWVvdXRcIikpLHRoaXMubG9nKFwiX2NoZWNrUGluZyA6OiBjYWxsaW5nIF9jbGVhblVwIHdpdGggZm9yY2UgdHJ1ZVwiKSx0aGlzLl9jbGVhblVwKCEwKSl9X3Jlc3Vic2NyaWJlKCl7dGhpcy5sb2coXCJfcmVzdWJzY3JpYmVcIik7bGV0IGU9T2JqZWN0LmtleXModGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MpO2lmKCF0aGlzLl9maXJzdENvbm5lY3Rpb24mJih0aGlzLm9wdGlvbnMuY2xlYW58fHRoaXMub3B0aW9ucy5wcm90b2NvbFZlcnNpb24+PTQmJiF0aGlzLmNvbm5hY2tQYWNrZXQuc2Vzc2lvblByZXNlbnQpJiZlLmxlbmd0aD4wKWlmKHRoaXMub3B0aW9ucy5yZXN1YnNjcmliZSlpZih0aGlzLm9wdGlvbnMucHJvdG9jb2xWZXJzaW9uPT09NSl7dGhpcy5sb2coXCJfcmVzdWJzY3JpYmU6IHByb3RvY29sVmVyc2lvbiA1XCIpO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtsZXQgaT17fTtpW2Vbcl1dPXRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzW2Vbcl1dLGkucmVzdWJzY3JpYmU9ITAsdGhpcy5zdWJzY3JpYmUoaSx7cHJvcGVydGllczppW2Vbcl1dLnByb3BlcnRpZXN9KX19ZWxzZSB0aGlzLl9yZXN1YnNjcmliZVRvcGljcy5yZXN1YnNjcmliZT0hMCx0aGlzLnN1YnNjcmliZSh0aGlzLl9yZXN1YnNjcmliZVRvcGljcyk7ZWxzZSB0aGlzLl9yZXN1YnNjcmliZVRvcGljcz17fTt0aGlzLl9maXJzdENvbm5lY3Rpb249ITF9X29uQ29ubmVjdChlKXtpZih0aGlzLmRpc2Nvbm5lY3RlZCl7dGhpcy5lbWl0KFwiY29ubmVjdFwiLGUpO3JldHVybn10aGlzLmNvbm5hY2tQYWNrZXQ9ZSx0aGlzLm1lc3NhZ2VJZFByb3ZpZGVyLmNsZWFyKCksdGhpcy5fc2V0dXBQaW5nVGltZXIoKSx0aGlzLmNvbm5lY3RlZD0hMDtsZXQgcj0oKT0+e2xldCBpPXRoaXMub3V0Z29pbmdTdG9yZS5jcmVhdGVTdHJlYW0oKSxuPSgpPT57aS5kZXN0cm95KCksaT1udWxsLHRoaXMuX2ZsdXNoU3RvcmVQcm9jZXNzaW5nUXVldWUoKSxvKCl9LG89KCk9Pnt0aGlzLl9zdG9yZVByb2Nlc3Npbmc9ITEsdGhpcy5fcGFja2V0SWRzRHVyaW5nU3RvcmVQcm9jZXNzaW5nPXt9fTt0aGlzLm9uY2UoXCJjbG9zZVwiLG4pLGkub24oXCJlcnJvclwiLGE9PntvKCksdGhpcy5fZmx1c2hTdG9yZVByb2Nlc3NpbmdRdWV1ZSgpLHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLG4pLHRoaXMuZW1pdChcImVycm9yXCIsYSl9KTtsZXQgcz0oKT0+e2lmKCFpKXJldHVybjtsZXQgYT1pLnJlYWQoMSksdTtpZighYSl7aS5vbmNlKFwicmVhZGFibGVcIixzKTtyZXR1cm59aWYodGhpcy5fc3RvcmVQcm9jZXNzaW5nPSEwLHRoaXMuX3BhY2tldElkc0R1cmluZ1N0b3JlUHJvY2Vzc2luZ1thLm1lc3NhZ2VJZF0pe3MoKTtyZXR1cm59IXRoaXMuZGlzY29ubmVjdGluZyYmIXRoaXMucmVjb25uZWN0VGltZXI/KHU9dGhpcy5vdXRnb2luZ1thLm1lc3NhZ2VJZF0/dGhpcy5vdXRnb2luZ1thLm1lc3NhZ2VJZF0uY2I6bnVsbCx0aGlzLm91dGdvaW5nW2EubWVzc2FnZUlkXT17dm9sYXRpbGU6ITEsY2IoYyxoKXt1JiZ1KGMsaCkscygpfX0sdGhpcy5fcGFja2V0SWRzRHVyaW5nU3RvcmVQcm9jZXNzaW5nW2EubWVzc2FnZUlkXT0hMCx0aGlzLm1lc3NhZ2VJZFByb3ZpZGVyLnJlZ2lzdGVyKGEubWVzc2FnZUlkKT90aGlzLl9zZW5kUGFja2V0KGEsdm9pZCAwLHZvaWQgMCwhMCk6dGhpcy5sb2coXCJtZXNzYWdlSWQ6ICVkIGhhcyBhbHJlYWR5IHVzZWQuXCIsYS5tZXNzYWdlSWQpKTppLmRlc3Ryb3kmJmkuZGVzdHJveSgpfTtpLm9uKFwiZW5kXCIsKCk9PntsZXQgYT0hMDtmb3IobGV0IHUgaW4gdGhpcy5fcGFja2V0SWRzRHVyaW5nU3RvcmVQcm9jZXNzaW5nKWlmKCF0aGlzLl9wYWNrZXRJZHNEdXJpbmdTdG9yZVByb2Nlc3NpbmdbdV0pe2E9ITE7YnJlYWt9dGhpcy5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsbiksYT8obygpLHRoaXMuX2ludm9rZUFsbFN0b3JlUHJvY2Vzc2luZ1F1ZXVlKCksdGhpcy5lbWl0KFwiY29ubmVjdFwiLGUpKTpyKCl9KSxzKCl9O3IoKX1faW52b2tlU3RvcmVQcm9jZXNzaW5nUXVldWUoKXtpZighdGhpcy5fc3RvcmVQcm9jZXNzaW5nJiZ0aGlzLl9zdG9yZVByb2Nlc3NpbmdRdWV1ZS5sZW5ndGg+MCl7bGV0IGU9dGhpcy5fc3RvcmVQcm9jZXNzaW5nUXVldWVbMF07aWYoZSYmZS5pbnZva2UoKSlyZXR1cm4gdGhpcy5fc3RvcmVQcm9jZXNzaW5nUXVldWUuc2hpZnQoKSwhMH1yZXR1cm4hMX1faW52b2tlQWxsU3RvcmVQcm9jZXNzaW5nUXVldWUoKXtmb3IoO3RoaXMuX2ludm9rZVN0b3JlUHJvY2Vzc2luZ1F1ZXVlKCk7KTt9X2ZsdXNoU3RvcmVQcm9jZXNzaW5nUXVldWUoKXtmb3IobGV0IGUgb2YgdGhpcy5fc3RvcmVQcm9jZXNzaW5nUXVldWUpZS5jYlN0b3JlUHV0JiZlLmNiU3RvcmVQdXQobmV3IEVycm9yKFwiQ29ubmVjdGlvbiBjbG9zZWRcIikpLGUuY2FsbGJhY2smJmUuY2FsbGJhY2sobmV3IEVycm9yKFwiQ29ubmVjdGlvbiBjbG9zZWRcIikpO3RoaXMuX3N0b3JlUHJvY2Vzc2luZ1F1ZXVlLnNwbGljZSgwKX1fcmVtb3ZlT3V0Z29pbmdBbmRTdG9yZU1lc3NhZ2UoZSxyKXtkZWxldGUgdGhpcy5vdXRnb2luZ1tlXSx0aGlzLm91dGdvaW5nU3RvcmUuZGVsKHttZXNzYWdlSWQ6ZX0sKGksbik9PntyKGksbiksdGhpcy5tZXNzYWdlSWRQcm92aWRlci5kZWFsbG9jYXRlKGUpLHRoaXMuX2ludm9rZVN0b3JlUHJvY2Vzc2luZ1F1ZXVlKCl9KX19O1FlLmRlZmF1bHQ9V2F9KTt2YXIgRnA9TShIYT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShIYSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgWXY9eGEoKSwkYT1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMubnVtYmVyQWxsb2NhdG9yPW5ldyBZdi5OdW1iZXJBbGxvY2F0b3IoMSw2NTUzNSl9YWxsb2NhdGUoKXtyZXR1cm4gdGhpcy5sYXN0SWQ9dGhpcy5udW1iZXJBbGxvY2F0b3IuYWxsb2MoKSx0aGlzLmxhc3RJZH1nZXRMYXN0QWxsb2NhdGVkKCl7cmV0dXJuIHRoaXMubGFzdElkfXJlZ2lzdGVyKGUpe3JldHVybiB0aGlzLm51bWJlckFsbG9jYXRvci51c2UoZSl9ZGVhbGxvY2F0ZShlKXt0aGlzLm51bWJlckFsbG9jYXRvci5mcmVlKGUpfWNsZWFyKCl7dGhpcy5udW1iZXJBbGxvY2F0b3IuY2xlYXIoKX19O0hhLmRlZmF1bHQ9JGF9KTtmdW5jdGlvbiBBcih0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihlRVt0XSl9ZnVuY3Rpb24gV3AodCxlKXtsZXQgcj10LnNwbGl0KFwiQFwiKSxpPVwiXCI7ci5sZW5ndGg+MSYmKGk9clswXStcIkBcIix0PXJbMV0pO2xldCBuPWZ1bmN0aW9uKG8scyl7bGV0IGE9W10sdT1vLmxlbmd0aDtmb3IoO3UtLTspYVt1XT1zKG9bdV0pO3JldHVybiBhfSgodD10LnJlcGxhY2UoWnYsXCIuXCIpKS5zcGxpdChcIi5cIiksZSkuam9pbihcIi5cIik7cmV0dXJuIGkrbn1mdW5jdGlvbiB6cCh0KXtsZXQgZT1bXSxyPTAsaT10Lmxlbmd0aDtmb3IoO3I8aTspe2xldCBuPXQuY2hhckNvZGVBdChyKyspO2lmKG4+PTU1Mjk2JiZuPD01NjMxOSYmcjxpKXtsZXQgbz10LmNoYXJDb2RlQXQocisrKTsoNjQ1MTImbyk9PTU2MzIwP2UucHVzaCgoKDEwMjMmbik8PDEwKSsoMTAyMyZvKSs2NTUzNik6KGUucHVzaChuKSxyLS0pfWVsc2UgZS5wdXNoKG4pfXJldHVybiBlfXZhciBKdixYdixadixlRSxodCxWYSwkcCxLcCxIcCxWcCx6dCxHcD1iZSgoKT0+e3YoKTttKCk7XygpO0p2PS9eeG4tLS8sWHY9L1teXFwwLVxceDdFXS8sWnY9L1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZyxlRT17b3ZlcmZsb3c6XCJPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2Vzc1wiLFwibm90LWJhc2ljXCI6XCJJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpXCIsXCJpbnZhbGlkLWlucHV0XCI6XCJJbnZhbGlkIGlucHV0XCJ9LGh0PU1hdGguZmxvb3IsVmE9U3RyaW5nLmZyb21DaGFyQ29kZTskcD1mdW5jdGlvbih0LGUpe3JldHVybiB0KzIyKzc1Kih0PDI2KS0oKGUhPTApPDw1KX0sS3A9ZnVuY3Rpb24odCxlLHIpe2xldCBpPTA7Zm9yKHQ9cj9odCh0LzcwMCk6dD4+MSx0Kz1odCh0L2UpO3Q+NDU1O2krPTM2KXQ9aHQodC8zNSk7cmV0dXJuIGh0KGkrMzYqdC8odCszOCkpfSxIcD1mdW5jdGlvbih0KXtsZXQgZT1bXSxyPXQubGVuZ3RoLGk9MCxuPTEyOCxvPTcyLHM9dC5sYXN0SW5kZXhPZihcIi1cIik7czwwJiYocz0wKTtmb3IobGV0IHU9MDt1PHM7Kyt1KXQuY2hhckNvZGVBdCh1KT49MTI4JiZBcihcIm5vdC1iYXNpY1wiKSxlLnB1c2godC5jaGFyQ29kZUF0KHUpKTtmb3IobGV0IHU9cz4wP3MrMTowO3U8cjspe2xldCBjPWk7Zm9yKGxldCBkPTEsZz0zNjs7Zys9MzYpe3U+PXImJkFyKFwiaW52YWxpZC1pbnB1dFwiKTtsZXQgeT0oYT10LmNoYXJDb2RlQXQodSsrKSktNDg8MTA/YS0yMjphLTY1PDI2P2EtNjU6YS05NzwyNj9hLTk3OjM2Oyh5Pj0zNnx8eT5odCgoMjE0NzQ4MzY0Ny1pKS9kKSkmJkFyKFwib3ZlcmZsb3dcIiksaSs9eSpkO2xldCB3PWc8PW8/MTpnPj1vKzI2PzI2OmctbztpZih5PHcpYnJlYWs7bGV0IEU9MzYtdztkPmh0KDIxNDc0ODM2NDcvRSkmJkFyKFwib3ZlcmZsb3dcIiksZCo9RX1sZXQgaD1lLmxlbmd0aCsxO289S3AoaS1jLGgsYz09MCksaHQoaS9oKT4yMTQ3NDgzNjQ3LW4mJkFyKFwib3ZlcmZsb3dcIiksbis9aHQoaS9oKSxpJT1oLGUuc3BsaWNlKGkrKywwLG4pfXZhciBhO3JldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5lKX0sVnA9ZnVuY3Rpb24odCl7bGV0IGU9W10scj0odD16cCh0KSkubGVuZ3RoLGk9MTI4LG49MCxvPTcyO2ZvcihsZXQgdSBvZiB0KXU8MTI4JiZlLnB1c2goVmEodSkpO2xldCBzPWUubGVuZ3RoLGE9cztmb3IocyYmZS5wdXNoKFwiLVwiKTthPHI7KXtsZXQgdT0yMTQ3NDgzNjQ3O2ZvcihsZXQgaCBvZiB0KWg+PWkmJmg8dSYmKHU9aCk7bGV0IGM9YSsxO3UtaT5odCgoMjE0NzQ4MzY0Ny1uKS9jKSYmQXIoXCJvdmVyZmxvd1wiKSxuKz0odS1pKSpjLGk9dTtmb3IobGV0IGggb2YgdClpZihoPGkmJisrbj4yMTQ3NDgzNjQ3JiZBcihcIm92ZXJmbG93XCIpLGg9PWkpe2xldCBkPW47Zm9yKGxldCBnPTM2OztnKz0zNil7bGV0IHk9Zzw9bz8xOmc+PW8rMjY/MjY6Zy1vO2lmKGQ8eSlicmVhaztsZXQgdz1kLXksRT0zNi15O2UucHVzaChWYSgkcCh5K3clRSwwKSkpLGQ9aHQody9FKX1lLnB1c2goVmEoJHAoZCwwKSkpLG89S3AobixjLGE9PXMpLG49MCwrK2F9KytuLCsraX1yZXR1cm4gZS5qb2luKFwiXCIpfSx6dD17dmVyc2lvbjpcIjIuMS4wXCIsdWNzMjp7ZGVjb2RlOnpwLGVuY29kZTp0PT5TdHJpbmcuZnJvbUNvZGVQb2ludCguLi50KX0sZGVjb2RlOkhwLGVuY29kZTpWcCx0b0FTQ0lJOmZ1bmN0aW9uKHQpe3JldHVybiBXcCh0LGZ1bmN0aW9uKGUpe3JldHVybiBYdi50ZXN0KGUpP1wieG4tLVwiK1ZwKGUpOmV9KX0sdG9Vbmljb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBXcCh0LGZ1bmN0aW9uKGUpe3JldHVybiBKdi50ZXN0KGUpP0hwKGUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSk6ZX0pfX07enQuZGVjb2RlO3p0LmVuY29kZTt6dC50b0FTQ0lJO3p0LnRvVW5pY29kZTt6dC51Y3MyO3p0LnZlcnNpb259KTtmdW5jdGlvbiB0RSh0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX12YXIgckUsa2ksaUUsZHQsUXA9YmUoKCk9Pnt2KCk7bSgpO18oKTtyRT1mdW5jdGlvbih0LGUscixpKXtlPWV8fFwiJlwiLHI9cnx8XCI9XCI7dmFyIG49e307aWYodHlwZW9mIHQhPVwic3RyaW5nXCJ8fHQubGVuZ3RoPT09MClyZXR1cm4gbjt2YXIgbz0vXFwrL2c7dD10LnNwbGl0KGUpO3ZhciBzPTFlMztpJiZ0eXBlb2YgaS5tYXhLZXlzPT1cIm51bWJlclwiJiYocz1pLm1heEtleXMpO3ZhciBhPXQubGVuZ3RoO3M+MCYmYT5zJiYoYT1zKTtmb3IodmFyIHU9MDt1PGE7Kyt1KXt2YXIgYyxoLGQsZyx5PXRbdV0ucmVwbGFjZShvLFwiJTIwXCIpLHc9eS5pbmRleE9mKHIpO3c+PTA/KGM9eS5zdWJzdHIoMCx3KSxoPXkuc3Vic3RyKHcrMSkpOihjPXksaD1cIlwiKSxkPWRlY29kZVVSSUNvbXBvbmVudChjKSxnPWRlY29kZVVSSUNvbXBvbmVudChoKSx0RShuLGQpP0FycmF5LmlzQXJyYXkobltkXSk/bltkXS5wdXNoKGcpOm5bZF09W25bZF0sZ106bltkXT1nfXJldHVybiBufSxraT1mdW5jdGlvbih0KXtzd2l0Y2godHlwZW9mIHQpe2Nhc2VcInN0cmluZ1wiOnJldHVybiB0O2Nhc2VcImJvb2xlYW5cIjpyZXR1cm4gdD9cInRydWVcIjpcImZhbHNlXCI7Y2FzZVwibnVtYmVyXCI6cmV0dXJuIGlzRmluaXRlKHQpP3Q6XCJcIjtkZWZhdWx0OnJldHVyblwiXCJ9fSxpRT1mdW5jdGlvbih0LGUscixpKXtyZXR1cm4gZT1lfHxcIiZcIixyPXJ8fFwiPVwiLHQ9PT1udWxsJiYodD12b2lkIDApLHR5cGVvZiB0PT1cIm9iamVjdFwiP09iamVjdC5rZXlzKHQpLm1hcChmdW5jdGlvbihuKXt2YXIgbz1lbmNvZGVVUklDb21wb25lbnQoa2kobikpK3I7cmV0dXJuIEFycmF5LmlzQXJyYXkodFtuXSk/dFtuXS5tYXAoZnVuY3Rpb24ocyl7cmV0dXJuIG8rZW5jb2RlVVJJQ29tcG9uZW50KGtpKHMpKX0pLmpvaW4oZSk6bytlbmNvZGVVUklDb21wb25lbnQoa2kodFtuXSkpfSkuam9pbihlKTppP2VuY29kZVVSSUNvbXBvbmVudChraShpKSkrcitlbmNvZGVVUklDb21wb25lbnQoa2kodCkpOlwiXCJ9LGR0PXt9O2R0LmRlY29kZT1kdC5wYXJzZT1yRSxkdC5lbmNvZGU9ZHQuc3RyaW5naWZ5PWlFO2R0LmRlY29kZTtkdC5lbmNvZGU7ZHQucGFyc2U7ZHQuc3RyaW5naWZ5fSk7ZnVuY3Rpb24gemEoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIEthKCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIFhwKHQpe2lmKEJ0PT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dCh0LDApO2lmKChCdD09PXphfHwhQnQpJiZzZXRUaW1lb3V0KXJldHVybiBCdD1zZXRUaW1lb3V0LHNldFRpbWVvdXQodCwwKTt0cnl7cmV0dXJuIEJ0KHQsMCl9Y2F0Y2h7dHJ5e3JldHVybiBCdC5jYWxsKG51bGwsdCwwKX1jYXRjaHtyZXR1cm4gQnQuY2FsbCh0aGlzfHxyaSx0LDApfX19ZnVuY3Rpb24gbkUoKXt0aSYmSXImJih0aT0hMSxJci5sZW5ndGg/T3Q9SXIuY29uY2F0KE90KTpzcz0tMSxPdC5sZW5ndGgmJlpwKCkpfWZ1bmN0aW9uIFpwKCl7aWYoIXRpKXt2YXIgdD1YcChuRSk7dGk9ITA7Zm9yKHZhciBlPU90Lmxlbmd0aDtlOyl7Zm9yKElyPU90LE90PVtdOysrc3M8ZTspSXImJklyW3NzXS5ydW4oKTtzcz0tMSxlPU90Lmxlbmd0aH1Jcj1udWxsLHRpPSExLGZ1bmN0aW9uKHIpe2lmKFB0PT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQocik7aWYoKFB0PT09S2F8fCFQdCkmJmNsZWFyVGltZW91dClyZXR1cm4gUHQ9Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChyKTt0cnl7UHQocil9Y2F0Y2h7dHJ5e3JldHVybiBQdC5jYWxsKG51bGwscil9Y2F0Y2h7cmV0dXJuIFB0LmNhbGwodGhpc3x8cmkscil9fX0odCl9fWZ1bmN0aW9uIFlwKHQsZSl7KHRoaXN8fHJpKS5mdW49dCwodGhpc3x8cmkpLmFycmF5PWV9ZnVuY3Rpb24gQ3QoKXt9dmFyIEpwLEJ0LFB0LHJpLGZlLElyLE90LHRpLHNzLG5lLGVnPWJlKCgpPT57digpO20oKTtfKCk7cmk9dHlwZW9mIGdsb2JhbFRoaXM8XCJ1XCI/Z2xvYmFsVGhpczp0eXBlb2Ygc2VsZjxcInVcIj9zZWxmOmdsb2JhbCxmZT1KcD17fTsoZnVuY3Rpb24oKXt0cnl7QnQ9dHlwZW9mIHNldFRpbWVvdXQ9PVwiZnVuY3Rpb25cIj9zZXRUaW1lb3V0OnphfWNhdGNoe0J0PXphfXRyeXtQdD10eXBlb2YgY2xlYXJUaW1lb3V0PT1cImZ1bmN0aW9uXCI/Y2xlYXJUaW1lb3V0OkthfWNhdGNoe1B0PUthfX0pKCk7T3Q9W10sdGk9ITEsc3M9LTE7ZmUubmV4dFRpY2s9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspZVtyLTFdPWFyZ3VtZW50c1tyXTtPdC5wdXNoKG5ldyBZcCh0LGUpKSxPdC5sZW5ndGghPT0xfHx0aXx8WHAoWnApfSxZcC5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7KHRoaXN8fHJpKS5mdW4uYXBwbHkobnVsbCwodGhpc3x8cmkpLmFycmF5KX0sZmUudGl0bGU9XCJicm93c2VyXCIsZmUuYnJvd3Nlcj0hMCxmZS5lbnY9e30sZmUuYXJndj1bXSxmZS52ZXJzaW9uPVwiXCIsZmUudmVyc2lvbnM9e30sZmUub249Q3QsZmUuYWRkTGlzdGVuZXI9Q3QsZmUub25jZT1DdCxmZS5vZmY9Q3QsZmUucmVtb3ZlTGlzdGVuZXI9Q3QsZmUucmVtb3ZlQWxsTGlzdGVuZXJzPUN0LGZlLmVtaXQ9Q3QsZmUucHJlcGVuZExpc3RlbmVyPUN0LGZlLnByZXBlbmRPbmNlTGlzdGVuZXI9Q3QsZmUubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybltdfSxmZS5iaW5kaW5nPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfSxmZS5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn0sZmUuY2hkaXI9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfSxmZS51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfTtuZT1KcDtuZS5hZGRMaXN0ZW5lcjtuZS5hcmd2O25lLmJpbmRpbmc7bmUuYnJvd3NlcjtuZS5jaGRpcjtuZS5jd2Q7bmUuZW1pdDtuZS5lbnY7bmUubGlzdGVuZXJzO25lLm5leHRUaWNrO25lLm9mZjtuZS5vbjtuZS5vbmNlO25lLnByZXBlbmRMaXN0ZW5lcjtuZS5wcmVwZW5kT25jZUxpc3RlbmVyO25lLnJlbW92ZUFsbExpc3RlbmVycztuZS5yZW1vdmVMaXN0ZW5lcjtuZS50aXRsZTtuZS51bWFzaztuZS52ZXJzaW9uO25lLnZlcnNpb25zfSk7ZnVuY3Rpb24gc0UoKXtpZih0ZylyZXR1cm4gR2E7dGc9ITA7dmFyIHQ9R2E9e30sZSxyO2Z1bmN0aW9uIGkoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIG4oKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e3R5cGVvZiBzZXRUaW1lb3V0PT1cImZ1bmN0aW9uXCI/ZT1zZXRUaW1lb3V0OmU9aX1jYXRjaHtlPWl9dHJ5e3R5cGVvZiBjbGVhclRpbWVvdXQ9PVwiZnVuY3Rpb25cIj9yPWNsZWFyVGltZW91dDpyPW59Y2F0Y2h7cj1ufX0pKCk7ZnVuY3Rpb24gbyhFKXtpZihlPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dChFLDApO2lmKChlPT09aXx8IWUpJiZzZXRUaW1lb3V0KXJldHVybiBlPXNldFRpbWVvdXQsc2V0VGltZW91dChFLDApO3RyeXtyZXR1cm4gZShFLDApfWNhdGNoe3RyeXtyZXR1cm4gZS5jYWxsKG51bGwsRSwwKX1jYXRjaHtyZXR1cm4gZS5jYWxsKHRoaXN8fGlpLEUsMCl9fX1mdW5jdGlvbiBzKEUpe2lmKHI9PT1jbGVhclRpbWVvdXQpcmV0dXJuIGNsZWFyVGltZW91dChFKTtpZigocj09PW58fCFyKSYmY2xlYXJUaW1lb3V0KXJldHVybiByPWNsZWFyVGltZW91dCxjbGVhclRpbWVvdXQoRSk7dHJ5e3JldHVybiByKEUpfWNhdGNoe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsRSl9Y2F0Y2h7cmV0dXJuIHIuY2FsbCh0aGlzfHxpaSxFKX19fXZhciBhPVtdLHU9ITEsYyxoPS0xO2Z1bmN0aW9uIGQoKXshdXx8IWN8fCh1PSExLGMubGVuZ3RoP2E9Yy5jb25jYXQoYSk6aD0tMSxhLmxlbmd0aCYmZygpKX1mdW5jdGlvbiBnKCl7aWYoIXUpe3ZhciBFPW8oZCk7dT0hMDtmb3IodmFyIFM9YS5sZW5ndGg7Uzspe2ZvcihjPWEsYT1bXTsrK2g8UzspYyYmY1toXS5ydW4oKTtoPS0xLFM9YS5sZW5ndGh9Yz1udWxsLHU9ITEscyhFKX19dC5uZXh0VGljaz1mdW5jdGlvbihFKXt2YXIgUz1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBJPTE7STxhcmd1bWVudHMubGVuZ3RoO0krKylTW0ktMV09YXJndW1lbnRzW0ldO2EucHVzaChuZXcgeShFLFMpKSxhLmxlbmd0aD09PTEmJiF1JiZvKGcpfTtmdW5jdGlvbiB5KEUsUyl7KHRoaXN8fGlpKS5mdW49RSwodGhpc3x8aWkpLmFycmF5PVN9eS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7KHRoaXN8fGlpKS5mdW4uYXBwbHkobnVsbCwodGhpc3x8aWkpLmFycmF5KX0sdC50aXRsZT1cImJyb3dzZXJcIix0LmJyb3dzZXI9ITAsdC5lbnY9e30sdC5hcmd2PVtdLHQudmVyc2lvbj1cIlwiLHQudmVyc2lvbnM9e307ZnVuY3Rpb24gdygpe31yZXR1cm4gdC5vbj13LHQuYWRkTGlzdGVuZXI9dyx0Lm9uY2U9dyx0Lm9mZj13LHQucmVtb3ZlTGlzdGVuZXI9dyx0LnJlbW92ZUFsbExpc3RlbmVycz13LHQuZW1pdD13LHQucHJlcGVuZExpc3RlbmVyPXcsdC5wcmVwZW5kT25jZUxpc3RlbmVyPXcsdC5saXN0ZW5lcnM9ZnVuY3Rpb24oRSl7cmV0dXJuW119LHQuYmluZGluZz1mdW5jdGlvbihFKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX0sdC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn0sdC5jaGRpcj1mdW5jdGlvbihFKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9LHQudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sR2F9dmFyIEdhLHRnLGlpLHJlLFFhPWJlKCgpPT57digpO20oKTtfKCk7R2E9e30sdGc9ITEsaWk9dHlwZW9mIGdsb2JhbFRoaXM8XCJ1XCI/Z2xvYmFsVGhpczp0eXBlb2Ygc2VsZjxcInVcIj9zZWxmOmdsb2JhbDtyZT1zRSgpO3JlLnBsYXRmb3JtPVwiYnJvd3NlclwiO3JlLmFkZExpc3RlbmVyO3JlLmFyZ3Y7cmUuYmluZGluZztyZS5icm93c2VyO3JlLmNoZGlyO3JlLmN3ZDtyZS5lbWl0O3JlLmVudjtyZS5saXN0ZW5lcnM7cmUubmV4dFRpY2s7cmUub2ZmO3JlLm9uO3JlLm9uY2U7cmUucHJlcGVuZExpc3RlbmVyO3JlLnByZXBlbmRPbmNlTGlzdGVuZXI7cmUucmVtb3ZlQWxsTGlzdGVuZXJzO3JlLnJlbW92ZUxpc3RlbmVyO3JlLnRpdGxlO3JlLnVtYXNrO3JlLnZlcnNpb247cmUudmVyc2lvbnN9KTtmdW5jdGlvbiBvRSgpe2lmKHJnKXJldHVybiBZYTtyZz0hMDt2YXIgdD1yZTtmdW5jdGlvbiBlKG8pe2lmKHR5cGVvZiBvIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KG8pKX1mdW5jdGlvbiByKG8scyl7Zm9yKHZhciBhPVwiXCIsdT0wLGM9LTEsaD0wLGQsZz0wO2c8PW8ubGVuZ3RoOysrZyl7aWYoZzxvLmxlbmd0aClkPW8uY2hhckNvZGVBdChnKTtlbHNle2lmKGQ9PT00NylicmVhaztkPTQ3fWlmKGQ9PT00Nyl7aWYoIShjPT09Zy0xfHxoPT09MSkpaWYoYyE9PWctMSYmaD09PTIpe2lmKGEubGVuZ3RoPDJ8fHUhPT0yfHxhLmNoYXJDb2RlQXQoYS5sZW5ndGgtMSkhPT00Nnx8YS5jaGFyQ29kZUF0KGEubGVuZ3RoLTIpIT09NDYpe2lmKGEubGVuZ3RoPjIpe3ZhciB5PWEubGFzdEluZGV4T2YoXCIvXCIpO2lmKHkhPT1hLmxlbmd0aC0xKXt5PT09LTE/KGE9XCJcIix1PTApOihhPWEuc2xpY2UoMCx5KSx1PWEubGVuZ3RoLTEtYS5sYXN0SW5kZXhPZihcIi9cIikpLGM9ZyxoPTA7Y29udGludWV9fWVsc2UgaWYoYS5sZW5ndGg9PT0yfHxhLmxlbmd0aD09PTEpe2E9XCJcIix1PTAsYz1nLGg9MDtjb250aW51ZX19cyYmKGEubGVuZ3RoPjA/YSs9XCIvLi5cIjphPVwiLi5cIix1PTIpfWVsc2UgYS5sZW5ndGg+MD9hKz1cIi9cIitvLnNsaWNlKGMrMSxnKTphPW8uc2xpY2UoYysxLGcpLHU9Zy1jLTE7Yz1nLGg9MH1lbHNlIGQ9PT00NiYmaCE9PS0xPysraDpoPS0xfXJldHVybiBhfWZ1bmN0aW9uIGkobyxzKXt2YXIgYT1zLmRpcnx8cy5yb290LHU9cy5iYXNlfHwocy5uYW1lfHxcIlwiKSsocy5leHR8fFwiXCIpO3JldHVybiBhP2E9PT1zLnJvb3Q/YSt1OmErbyt1OnV9dmFyIG49e3Jlc29sdmU6ZnVuY3Rpb24oKXtmb3IodmFyIHM9XCJcIixhPSExLHUsYz1hcmd1bWVudHMubGVuZ3RoLTE7Yz49LTEmJiFhO2MtLSl7dmFyIGg7Yz49MD9oPWFyZ3VtZW50c1tjXToodT09PXZvaWQgMCYmKHU9dC5jd2QoKSksaD11KSxlKGgpLGgubGVuZ3RoIT09MCYmKHM9aCtcIi9cIitzLGE9aC5jaGFyQ29kZUF0KDApPT09NDcpfXJldHVybiBzPXIocywhYSksYT9zLmxlbmd0aD4wP1wiL1wiK3M6XCIvXCI6cy5sZW5ndGg+MD9zOlwiLlwifSxub3JtYWxpemU6ZnVuY3Rpb24ocyl7aWYoZShzKSxzLmxlbmd0aD09PTApcmV0dXJuXCIuXCI7dmFyIGE9cy5jaGFyQ29kZUF0KDApPT09NDcsdT1zLmNoYXJDb2RlQXQocy5sZW5ndGgtMSk9PT00NztyZXR1cm4gcz1yKHMsIWEpLHMubGVuZ3RoPT09MCYmIWEmJihzPVwiLlwiKSxzLmxlbmd0aD4wJiZ1JiYocys9XCIvXCIpLGE/XCIvXCIrczpzfSxpc0Fic29sdXRlOmZ1bmN0aW9uKHMpe3JldHVybiBlKHMpLHMubGVuZ3RoPjAmJnMuY2hhckNvZGVBdCgwKT09PTQ3fSxqb2luOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuXCIuXCI7Zm9yKHZhciBzLGE9MDthPGFyZ3VtZW50cy5sZW5ndGg7KythKXt2YXIgdT1hcmd1bWVudHNbYV07ZSh1KSx1Lmxlbmd0aD4wJiYocz09PXZvaWQgMD9zPXU6cys9XCIvXCIrdSl9cmV0dXJuIHM9PT12b2lkIDA/XCIuXCI6bi5ub3JtYWxpemUocyl9LHJlbGF0aXZlOmZ1bmN0aW9uKHMsYSl7aWYoZShzKSxlKGEpLHM9PT1hfHwocz1uLnJlc29sdmUocyksYT1uLnJlc29sdmUoYSkscz09PWEpKXJldHVyblwiXCI7Zm9yKHZhciB1PTE7dTxzLmxlbmd0aCYmcy5jaGFyQ29kZUF0KHUpPT09NDc7Kyt1KTtmb3IodmFyIGM9cy5sZW5ndGgsaD1jLXUsZD0xO2Q8YS5sZW5ndGgmJmEuY2hhckNvZGVBdChkKT09PTQ3OysrZCk7Zm9yKHZhciBnPWEubGVuZ3RoLHk9Zy1kLHc9aDx5P2g6eSxFPS0xLFM9MDtTPD13OysrUyl7aWYoUz09PXcpe2lmKHk+dyl7aWYoYS5jaGFyQ29kZUF0KGQrUyk9PT00NylyZXR1cm4gYS5zbGljZShkK1MrMSk7aWYoUz09PTApcmV0dXJuIGEuc2xpY2UoZCtTKX1lbHNlIGg+dyYmKHMuY2hhckNvZGVBdCh1K1MpPT09NDc/RT1TOlM9PT0wJiYoRT0wKSk7YnJlYWt9dmFyIEk9cy5jaGFyQ29kZUF0KHUrUyksQz1hLmNoYXJDb2RlQXQoZCtTKTtpZihJIT09QylicmVhaztJPT09NDcmJihFPVMpfXZhciBSPVwiXCI7Zm9yKFM9dStFKzE7Uzw9YzsrK1MpKFM9PT1jfHxzLmNoYXJDb2RlQXQoUyk9PT00NykmJihSLmxlbmd0aD09PTA/Uis9XCIuLlwiOlIrPVwiLy4uXCIpO3JldHVybiBSLmxlbmd0aD4wP1IrYS5zbGljZShkK0UpOihkKz1FLGEuY2hhckNvZGVBdChkKT09PTQ3JiYrK2QsYS5zbGljZShkKSl9LF9tYWtlTG9uZzpmdW5jdGlvbihzKXtyZXR1cm4gc30sZGlybmFtZTpmdW5jdGlvbihzKXtpZihlKHMpLHMubGVuZ3RoPT09MClyZXR1cm5cIi5cIjtmb3IodmFyIGE9cy5jaGFyQ29kZUF0KDApLHU9YT09PTQ3LGM9LTEsaD0hMCxkPXMubGVuZ3RoLTE7ZD49MTstLWQpaWYoYT1zLmNoYXJDb2RlQXQoZCksYT09PTQ3KXtpZighaCl7Yz1kO2JyZWFrfX1lbHNlIGg9ITE7cmV0dXJuIGM9PT0tMT91P1wiL1wiOlwiLlwiOnUmJmM9PT0xP1wiLy9cIjpzLnNsaWNlKDAsYyl9LGJhc2VuYW1lOmZ1bmN0aW9uKHMsYSl7aWYoYSE9PXZvaWQgMCYmdHlwZW9mIGEhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7ZShzKTt2YXIgdT0wLGM9LTEsaD0hMCxkO2lmKGEhPT12b2lkIDAmJmEubGVuZ3RoPjAmJmEubGVuZ3RoPD1zLmxlbmd0aCl7aWYoYS5sZW5ndGg9PT1zLmxlbmd0aCYmYT09PXMpcmV0dXJuXCJcIjt2YXIgZz1hLmxlbmd0aC0xLHk9LTE7Zm9yKGQ9cy5sZW5ndGgtMTtkPj0wOy0tZCl7dmFyIHc9cy5jaGFyQ29kZUF0KGQpO2lmKHc9PT00Nyl7aWYoIWgpe3U9ZCsxO2JyZWFrfX1lbHNlIHk9PT0tMSYmKGg9ITEseT1kKzEpLGc+PTAmJih3PT09YS5jaGFyQ29kZUF0KGcpPy0tZz09PS0xJiYoYz1kKTooZz0tMSxjPXkpKX1yZXR1cm4gdT09PWM/Yz15OmM9PT0tMSYmKGM9cy5sZW5ndGgpLHMuc2xpY2UodSxjKX1lbHNle2ZvcihkPXMubGVuZ3RoLTE7ZD49MDstLWQpaWYocy5jaGFyQ29kZUF0KGQpPT09NDcpe2lmKCFoKXt1PWQrMTticmVha319ZWxzZSBjPT09LTEmJihoPSExLGM9ZCsxKTtyZXR1cm4gYz09PS0xP1wiXCI6cy5zbGljZSh1LGMpfX0sZXh0bmFtZTpmdW5jdGlvbihzKXtlKHMpO2Zvcih2YXIgYT0tMSx1PTAsYz0tMSxoPSEwLGQ9MCxnPXMubGVuZ3RoLTE7Zz49MDstLWcpe3ZhciB5PXMuY2hhckNvZGVBdChnKTtpZih5PT09NDcpe2lmKCFoKXt1PWcrMTticmVha31jb250aW51ZX1jPT09LTEmJihoPSExLGM9ZysxKSx5PT09NDY/YT09PS0xP2E9ZzpkIT09MSYmKGQ9MSk6YSE9PS0xJiYoZD0tMSl9cmV0dXJuIGE9PT0tMXx8Yz09PS0xfHxkPT09MHx8ZD09PTEmJmE9PT1jLTEmJmE9PT11KzE/XCJcIjpzLnNsaWNlKGEsYyl9LGZvcm1hdDpmdW5jdGlvbihzKXtpZihzPT09bnVsbHx8dHlwZW9mIHMhPVwib2JqZWN0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2Ygcyk7cmV0dXJuIGkoXCIvXCIscyl9LHBhcnNlOmZ1bmN0aW9uKHMpe2Uocyk7dmFyIGE9e3Jvb3Q6XCJcIixkaXI6XCJcIixiYXNlOlwiXCIsZXh0OlwiXCIsbmFtZTpcIlwifTtpZihzLmxlbmd0aD09PTApcmV0dXJuIGE7dmFyIHU9cy5jaGFyQ29kZUF0KDApLGM9dT09PTQ3LGg7Yz8oYS5yb290PVwiL1wiLGg9MSk6aD0wO2Zvcih2YXIgZD0tMSxnPTAseT0tMSx3PSEwLEU9cy5sZW5ndGgtMSxTPTA7RT49aDstLUUpe2lmKHU9cy5jaGFyQ29kZUF0KEUpLHU9PT00Nyl7aWYoIXcpe2c9RSsxO2JyZWFrfWNvbnRpbnVlfXk9PT0tMSYmKHc9ITEseT1FKzEpLHU9PT00Nj9kPT09LTE/ZD1FOlMhPT0xJiYoUz0xKTpkIT09LTEmJihTPS0xKX1yZXR1cm4gZD09PS0xfHx5PT09LTF8fFM9PT0wfHxTPT09MSYmZD09PXktMSYmZD09PWcrMT95IT09LTEmJihnPT09MCYmYz9hLmJhc2U9YS5uYW1lPXMuc2xpY2UoMSx5KTphLmJhc2U9YS5uYW1lPXMuc2xpY2UoZyx5KSk6KGc9PT0wJiZjPyhhLm5hbWU9cy5zbGljZSgxLGQpLGEuYmFzZT1zLnNsaWNlKDEseSkpOihhLm5hbWU9cy5zbGljZShnLGQpLGEuYmFzZT1zLnNsaWNlKGcseSkpLGEuZXh0PXMuc2xpY2UoZCx5KSksZz4wP2EuZGlyPXMuc2xpY2UoMCxnLTEpOmMmJihhLmRpcj1cIi9cIiksYX0sc2VwOlwiL1wiLGRlbGltaXRlcjpcIjpcIix3aW4zMjpudWxsLHBvc2l4Om51bGx9O3JldHVybiBuLnBvc2l4PW4sWWE9bixZYX12YXIgWWEscmcsSmEsaWc9YmUoKCk9Pnt2KCk7bSgpO18oKTtRYSgpO1lhPXt9LHJnPSExO0phPW9FKCl9KTt2YXIgY2c9e307UXQoY2cse1VSTDooKT0+VUUsVXJsOigpPT5PRSxkZWZhdWx0OigpPT5YLGZpbGVVUkxUb1BhdGg6KCk9PnVnLGZvcm1hdDooKT0+a0UscGFyc2U6KCk9PkxFLHBhdGhUb0ZpbGVVUkw6KCk9PmZnLHJlc29sdmU6KCk9PnhFLHJlc29sdmVPYmplY3Q6KCk9Pk1FfSk7ZnVuY3Rpb24gRmUoKXt0aGlzLnByb3RvY29sPW51bGwsdGhpcy5zbGFzaGVzPW51bGwsdGhpcy5hdXRoPW51bGwsdGhpcy5ob3N0PW51bGwsdGhpcy5wb3J0PW51bGwsdGhpcy5ob3N0bmFtZT1udWxsLHRoaXMuaGFzaD1udWxsLHRoaXMuc2VhcmNoPW51bGwsdGhpcy5xdWVyeT1udWxsLHRoaXMucGF0aG5hbWU9bnVsbCx0aGlzLnBhdGg9bnVsbCx0aGlzLmhyZWY9bnVsbH1mdW5jdGlvbiB4aSh0LGUscil7aWYodCYmcHQuaXNPYmplY3QodCkmJnQgaW5zdGFuY2VvZiBGZSlyZXR1cm4gdDt2YXIgaT1uZXcgRmU7cmV0dXJuIGkucGFyc2UodCxlLHIpLGl9ZnVuY3Rpb24gcEUoKXtpZihhZylyZXR1cm4gZWw7YWc9ITA7dmFyIHQ9bmU7ZnVuY3Rpb24gZShvKXtpZih0eXBlb2YgbyE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShvKSl9ZnVuY3Rpb24gcihvLHMpe2Zvcih2YXIgYT1cIlwiLHU9MCxjPS0xLGg9MCxkLGc9MDtnPD1vLmxlbmd0aDsrK2cpe2lmKGc8by5sZW5ndGgpZD1vLmNoYXJDb2RlQXQoZyk7ZWxzZXtpZihkPT09NDcpYnJlYWs7ZD00N31pZihkPT09NDcpe2lmKCEoYz09PWctMXx8aD09PTEpKWlmKGMhPT1nLTEmJmg9PT0yKXtpZihhLmxlbmd0aDwyfHx1IT09Mnx8YS5jaGFyQ29kZUF0KGEubGVuZ3RoLTEpIT09NDZ8fGEuY2hhckNvZGVBdChhLmxlbmd0aC0yKSE9PTQ2KXtpZihhLmxlbmd0aD4yKXt2YXIgeT1hLmxhc3RJbmRleE9mKFwiL1wiKTtpZih5IT09YS5sZW5ndGgtMSl7eT09PS0xPyhhPVwiXCIsdT0wKTooYT1hLnNsaWNlKDAseSksdT1hLmxlbmd0aC0xLWEubGFzdEluZGV4T2YoXCIvXCIpKSxjPWcsaD0wO2NvbnRpbnVlfX1lbHNlIGlmKGEubGVuZ3RoPT09Mnx8YS5sZW5ndGg9PT0xKXthPVwiXCIsdT0wLGM9ZyxoPTA7Y29udGludWV9fXMmJihhLmxlbmd0aD4wP2ErPVwiLy4uXCI6YT1cIi4uXCIsdT0yKX1lbHNlIGEubGVuZ3RoPjA/YSs9XCIvXCIrby5zbGljZShjKzEsZyk6YT1vLnNsaWNlKGMrMSxnKSx1PWctYy0xO2M9ZyxoPTB9ZWxzZSBkPT09NDYmJmghPT0tMT8rK2g6aD0tMX1yZXR1cm4gYX1mdW5jdGlvbiBpKG8scyl7dmFyIGE9cy5kaXJ8fHMucm9vdCx1PXMuYmFzZXx8KHMubmFtZXx8XCJcIikrKHMuZXh0fHxcIlwiKTtyZXR1cm4gYT9hPT09cy5yb290P2ErdTphK28rdTp1fXZhciBuPXtyZXNvbHZlOmZ1bmN0aW9uKCl7Zm9yKHZhciBzPVwiXCIsYT0hMSx1LGM9YXJndW1lbnRzLmxlbmd0aC0xO2M+PS0xJiYhYTtjLS0pe3ZhciBoO2M+PTA/aD1hcmd1bWVudHNbY106KHU9PT12b2lkIDAmJih1PXQuY3dkKCkpLGg9dSksZShoKSxoLmxlbmd0aCE9PTAmJihzPWgrXCIvXCIrcyxhPWguY2hhckNvZGVBdCgwKT09PTQ3KX1yZXR1cm4gcz1yKHMsIWEpLGE/cy5sZW5ndGg+MD9cIi9cIitzOlwiL1wiOnMubGVuZ3RoPjA/czpcIi5cIn0sbm9ybWFsaXplOmZ1bmN0aW9uKHMpe2lmKGUocykscy5sZW5ndGg9PT0wKXJldHVyblwiLlwiO3ZhciBhPXMuY2hhckNvZGVBdCgwKT09PTQ3LHU9cy5jaGFyQ29kZUF0KHMubGVuZ3RoLTEpPT09NDc7cmV0dXJuIHM9cihzLCFhKSxzLmxlbmd0aD09PTAmJiFhJiYocz1cIi5cIikscy5sZW5ndGg+MCYmdSYmKHMrPVwiL1wiKSxhP1wiL1wiK3M6c30saXNBYnNvbHV0ZTpmdW5jdGlvbihzKXtyZXR1cm4gZShzKSxzLmxlbmd0aD4wJiZzLmNoYXJDb2RlQXQoMCk9PT00N30sam9pbjpmdW5jdGlvbigpe2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVyblwiLlwiO2Zvcih2YXIgcyxhPTA7YTxhcmd1bWVudHMubGVuZ3RoOysrYSl7dmFyIHU9YXJndW1lbnRzW2FdO2UodSksdS5sZW5ndGg+MCYmKHM9PT12b2lkIDA/cz11OnMrPVwiL1wiK3UpfXJldHVybiBzPT09dm9pZCAwP1wiLlwiOm4ubm9ybWFsaXplKHMpfSxyZWxhdGl2ZTpmdW5jdGlvbihzLGEpe2lmKGUocyksZShhKSxzPT09YXx8KHM9bi5yZXNvbHZlKHMpLGE9bi5yZXNvbHZlKGEpLHM9PT1hKSlyZXR1cm5cIlwiO2Zvcih2YXIgdT0xO3U8cy5sZW5ndGgmJnMuY2hhckNvZGVBdCh1KT09PTQ3OysrdSk7Zm9yKHZhciBjPXMubGVuZ3RoLGg9Yy11LGQ9MTtkPGEubGVuZ3RoJiZhLmNoYXJDb2RlQXQoZCk9PT00NzsrK2QpO2Zvcih2YXIgZz1hLmxlbmd0aCx5PWctZCx3PWg8eT9oOnksRT0tMSxTPTA7Uzw9dzsrK1Mpe2lmKFM9PT13KXtpZih5Pncpe2lmKGEuY2hhckNvZGVBdChkK1MpPT09NDcpcmV0dXJuIGEuc2xpY2UoZCtTKzEpO2lmKFM9PT0wKXJldHVybiBhLnNsaWNlKGQrUyl9ZWxzZSBoPncmJihzLmNoYXJDb2RlQXQodStTKT09PTQ3P0U9UzpTPT09MCYmKEU9MCkpO2JyZWFrfXZhciBJPXMuY2hhckNvZGVBdCh1K1MpLEM9YS5jaGFyQ29kZUF0KGQrUyk7aWYoSSE9PUMpYnJlYWs7ST09PTQ3JiYoRT1TKX12YXIgUj1cIlwiO2ZvcihTPXUrRSsxO1M8PWM7KytTKShTPT09Y3x8cy5jaGFyQ29kZUF0KFMpPT09NDcpJiYoUi5sZW5ndGg9PT0wP1IrPVwiLi5cIjpSKz1cIi8uLlwiKTtyZXR1cm4gUi5sZW5ndGg+MD9SK2Euc2xpY2UoZCtFKTooZCs9RSxhLmNoYXJDb2RlQXQoZCk9PT00NyYmKytkLGEuc2xpY2UoZCkpfSxfbWFrZUxvbmc6ZnVuY3Rpb24ocyl7cmV0dXJuIHN9LGRpcm5hbWU6ZnVuY3Rpb24ocyl7aWYoZShzKSxzLmxlbmd0aD09PTApcmV0dXJuXCIuXCI7Zm9yKHZhciBhPXMuY2hhckNvZGVBdCgwKSx1PWE9PT00NyxjPS0xLGg9ITAsZD1zLmxlbmd0aC0xO2Q+PTE7LS1kKWlmKGE9cy5jaGFyQ29kZUF0KGQpLGE9PT00Nyl7aWYoIWgpe2M9ZDticmVha319ZWxzZSBoPSExO3JldHVybiBjPT09LTE/dT9cIi9cIjpcIi5cIjp1JiZjPT09MT9cIi8vXCI6cy5zbGljZSgwLGMpfSxiYXNlbmFtZTpmdW5jdGlvbihzLGEpe2lmKGEhPT12b2lkIDAmJnR5cGVvZiBhIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO2Uocyk7dmFyIHU9MCxjPS0xLGg9ITAsZDtpZihhIT09dm9pZCAwJiZhLmxlbmd0aD4wJiZhLmxlbmd0aDw9cy5sZW5ndGgpe2lmKGEubGVuZ3RoPT09cy5sZW5ndGgmJmE9PT1zKXJldHVyblwiXCI7dmFyIGc9YS5sZW5ndGgtMSx5PS0xO2ZvcihkPXMubGVuZ3RoLTE7ZD49MDstLWQpe3ZhciB3PXMuY2hhckNvZGVBdChkKTtpZih3PT09NDcpe2lmKCFoKXt1PWQrMTticmVha319ZWxzZSB5PT09LTEmJihoPSExLHk9ZCsxKSxnPj0wJiYodz09PWEuY2hhckNvZGVBdChnKT8tLWc9PT0tMSYmKGM9ZCk6KGc9LTEsYz15KSl9cmV0dXJuIHU9PT1jP2M9eTpjPT09LTEmJihjPXMubGVuZ3RoKSxzLnNsaWNlKHUsYyl9ZWxzZXtmb3IoZD1zLmxlbmd0aC0xO2Q+PTA7LS1kKWlmKHMuY2hhckNvZGVBdChkKT09PTQ3KXtpZighaCl7dT1kKzE7YnJlYWt9fWVsc2UgYz09PS0xJiYoaD0hMSxjPWQrMSk7cmV0dXJuIGM9PT0tMT9cIlwiOnMuc2xpY2UodSxjKX19LGV4dG5hbWU6ZnVuY3Rpb24ocyl7ZShzKTtmb3IodmFyIGE9LTEsdT0wLGM9LTEsaD0hMCxkPTAsZz1zLmxlbmd0aC0xO2c+PTA7LS1nKXt2YXIgeT1zLmNoYXJDb2RlQXQoZyk7aWYoeT09PTQ3KXtpZighaCl7dT1nKzE7YnJlYWt9Y29udGludWV9Yz09PS0xJiYoaD0hMSxjPWcrMSkseT09PTQ2P2E9PT0tMT9hPWc6ZCE9PTEmJihkPTEpOmEhPT0tMSYmKGQ9LTEpfXJldHVybiBhPT09LTF8fGM9PT0tMXx8ZD09PTB8fGQ9PT0xJiZhPT09Yy0xJiZhPT09dSsxP1wiXCI6cy5zbGljZShhLGMpfSxmb3JtYXQ6ZnVuY3Rpb24ocyl7aWYocz09PW51bGx8fHR5cGVvZiBzIT1cIm9iamVjdFwiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInBhdGhPYmplY3RcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIHMpO3JldHVybiBpKFwiL1wiLHMpfSxwYXJzZTpmdW5jdGlvbihzKXtlKHMpO3ZhciBhPXtyb290OlwiXCIsZGlyOlwiXCIsYmFzZTpcIlwiLGV4dDpcIlwiLG5hbWU6XCJcIn07aWYocy5sZW5ndGg9PT0wKXJldHVybiBhO3ZhciB1PXMuY2hhckNvZGVBdCgwKSxjPXU9PT00NyxoO2M/KGEucm9vdD1cIi9cIixoPTEpOmg9MDtmb3IodmFyIGQ9LTEsZz0wLHk9LTEsdz0hMCxFPXMubGVuZ3RoLTEsUz0wO0U+PWg7LS1FKXtpZih1PXMuY2hhckNvZGVBdChFKSx1PT09NDcpe2lmKCF3KXtnPUUrMTticmVha31jb250aW51ZX15PT09LTEmJih3PSExLHk9RSsxKSx1PT09NDY/ZD09PS0xP2Q9RTpTIT09MSYmKFM9MSk6ZCE9PS0xJiYoUz0tMSl9cmV0dXJuIGQ9PT0tMXx8eT09PS0xfHxTPT09MHx8Uz09PTEmJmQ9PT15LTEmJmQ9PT1nKzE/eSE9PS0xJiYoZz09PTAmJmM/YS5iYXNlPWEubmFtZT1zLnNsaWNlKDEseSk6YS5iYXNlPWEubmFtZT1zLnNsaWNlKGcseSkpOihnPT09MCYmYz8oYS5uYW1lPXMuc2xpY2UoMSxkKSxhLmJhc2U9cy5zbGljZSgxLHkpKTooYS5uYW1lPXMuc2xpY2UoZyxkKSxhLmJhc2U9cy5zbGljZShnLHkpKSxhLmV4dD1zLnNsaWNlKGQseSkpLGc+MD9hLmRpcj1zLnNsaWNlKDAsZy0xKTpjJiYoYS5kaXI9XCIvXCIpLGF9LHNlcDpcIi9cIixkZWxpbWl0ZXI6XCI6XCIsd2luMzI6bnVsbCxwb3NpeDpudWxsfTtyZXR1cm4gbi5wb3NpeD1uLGVsPW4sZWx9ZnVuY3Rpb24gVEUodCl7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpdD1uZXcgVVJMKHQpO2Vsc2UgaWYoISh0IGluc3RhbmNlb2YgVVJMKSl0aHJvdyBuZXcgRGVuby5lcnJvcnMuSW52YWxpZERhdGEoXCJpbnZhbGlkIGFyZ3VtZW50IHBhdGggLCBtdXN0IGJlIGEgc3RyaW5nIG9yIFVSTFwiKTtpZih0LnByb3RvY29sIT09XCJmaWxlOlwiKXRocm93IG5ldyBEZW5vLmVycm9ycy5JbnZhbGlkRGF0YShcImludmFsaWQgdXJsIHNjaGVtZVwiKTtyZXR1cm4gcmw/UkUodCk6Q0UodCl9ZnVuY3Rpb24gUkUodCl7bGV0IGU9dC5ob3N0bmFtZSxyPXQucGF0aG5hbWU7Zm9yKGxldCBpPTA7aTxyLmxlbmd0aDtpKyspaWYocltpXT09PVwiJVwiKXtsZXQgbj1yLmNvZGVQb2ludEF0KGkrMil8fDMyO2lmKHJbaSsxXT09PVwiMlwiJiZuPT09MTAyfHxyW2krMV09PT1cIjVcIiYmbj09PTk5KXRocm93IG5ldyBEZW5vLmVycm9ycy5JbnZhbGlkRGF0YShcIm11c3Qgbm90IGluY2x1ZGUgZW5jb2RlZCBcXFxcIG9yIC8gY2hhcmFjdGVyc1wiKX1pZihyPXIucmVwbGFjZShtRSxcIlxcXFxcIikscj1kZWNvZGVVUklDb21wb25lbnQociksZSE9PVwiXCIpcmV0dXJuYFxcXFxcXFxcJHtlfSR7cn1gO3tsZXQgaT1yLmNvZGVQb2ludEF0KDEpfDMyLG49clsyXTtpZihpPHdFfHxpPl9FfHxuIT09XCI6XCIpdGhyb3cgbmV3IERlbm8uZXJyb3JzLkludmFsaWREYXRhKFwiZmlsZSB1cmwgcGF0aCBtdXN0IGJlIGFic29sdXRlXCIpO3JldHVybiByLnNsaWNlKDEpfX1mdW5jdGlvbiBDRSh0KXtpZih0Lmhvc3RuYW1lIT09XCJcIil0aHJvdyBuZXcgRGVuby5lcnJvcnMuSW52YWxpZERhdGEoXCJpbnZhbGlkIGZpbGUgdXJsIGhvc3RuYW1lXCIpO2xldCBlPXQucGF0aG5hbWU7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspaWYoZVtyXT09PVwiJVwiKXtsZXQgaT1lLmNvZGVQb2ludEF0KHIrMil8fDMyO2lmKGVbcisxXT09PVwiMlwiJiZpPT09MTAyKXRocm93IG5ldyBEZW5vLmVycm9ycy5JbnZhbGlkRGF0YShcIm11c3Qgbm90IGluY2x1ZGUgZW5jb2RlZCAvIGNoYXJhY3RlcnNcIil9cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlKX1mdW5jdGlvbiBCRSh0KXtsZXQgZT1sZy5yZXNvbHZlKHQpLHI9dC5jaGFyQ29kZUF0KHQubGVuZ3RoLTEpOyhyPT09YkV8fHJsJiZyPT09eUUpJiZlW2UubGVuZ3RoLTFdIT09bGcuc2VwJiYoZSs9XCIvXCIpO2xldCBpPW5ldyBVUkwoXCJmaWxlOi8vXCIpO3JldHVybiBlLmluY2x1ZGVzKFwiJVwiKSYmKGU9ZS5yZXBsYWNlKHZFLFwiJTI1XCIpKSwhcmwmJmUuaW5jbHVkZXMoXCJcXFxcXCIpJiYoZT1lLnJlcGxhY2UoRUUsXCIlNUNcIikpLGUuaW5jbHVkZXMoYFxuYCkmJihlPWUucmVwbGFjZShTRSxcIiUwQVwiKSksZS5pbmNsdWRlcyhcIlxcclwiKSYmKGU9ZS5yZXBsYWNlKEFFLFwiJTBEXCIpKSxlLmluY2x1ZGVzKFwiXHRcIikmJihlPWUucmVwbGFjZShJRSxcIiUwOVwiKSksaS5wYXRobmFtZT1lLGl9ZnVuY3Rpb24gdWcodCl7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpdD1uZXcgVVJMKHQpO2Vsc2UgaWYoISh0IGluc3RhbmNlb2YgVVJMKSl0aHJvdyBuZXcgRGVuby5lcnJvcnMuSW52YWxpZERhdGEoXCJpbnZhbGlkIGFyZ3VtZW50IHBhdGggLCBtdXN0IGJlIGEgc3RyaW5nIG9yIFVSTFwiKTtpZih0LnByb3RvY29sIT09XCJmaWxlOlwiKXRocm93IG5ldyBEZW5vLmVycm9ycy5JbnZhbGlkRGF0YShcImludmFsaWQgdXJsIHNjaGVtZVwiKTtyZXR1cm4gaWw/S0UodCk6R0UodCl9ZnVuY3Rpb24gS0UodCl7bGV0IGU9dC5ob3N0bmFtZSxyPXQucGF0aG5hbWU7Zm9yKGxldCBpPTA7aTxyLmxlbmd0aDtpKyspaWYocltpXT09PVwiJVwiKXtsZXQgbj1yLmNvZGVQb2ludEF0KGkrMil8fDMyO2lmKHJbaSsxXT09PVwiMlwiJiZuPT09MTAyfHxyW2krMV09PT1cIjVcIiYmbj09PTk5KXRocm93IG5ldyBEZW5vLmVycm9ycy5JbnZhbGlkRGF0YShcIm11c3Qgbm90IGluY2x1ZGUgZW5jb2RlZCBcXFxcIG9yIC8gY2hhcmFjdGVyc1wiKX1pZihyPXIucmVwbGFjZShGRSxcIlxcXFxcIikscj1kZWNvZGVVUklDb21wb25lbnQociksZSE9PVwiXCIpcmV0dXJuYFxcXFxcXFxcJHtlfSR7cn1gO3tsZXQgaT1yLmNvZGVQb2ludEF0KDEpfDMyLG49clsyXTtpZihpPERFfHxpPmpFfHxuIT09XCI6XCIpdGhyb3cgbmV3IERlbm8uZXJyb3JzLkludmFsaWREYXRhKFwiZmlsZSB1cmwgcGF0aCBtdXN0IGJlIGFic29sdXRlXCIpO3JldHVybiByLnNsaWNlKDEpfX1mdW5jdGlvbiBHRSh0KXtpZih0Lmhvc3RuYW1lIT09XCJcIil0aHJvdyBuZXcgRGVuby5lcnJvcnMuSW52YWxpZERhdGEoXCJpbnZhbGlkIGZpbGUgdXJsIGhvc3RuYW1lXCIpO2xldCBlPXQucGF0aG5hbWU7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspaWYoZVtyXT09PVwiJVwiKXtsZXQgaT1lLmNvZGVQb2ludEF0KHIrMil8fDMyO2lmKGVbcisxXT09PVwiMlwiJiZpPT09MTAyKXRocm93IG5ldyBEZW5vLmVycm9ycy5JbnZhbGlkRGF0YShcIm11c3Qgbm90IGluY2x1ZGUgZW5jb2RlZCAvIGNoYXJhY3RlcnNcIil9cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlKX1mdW5jdGlvbiBmZyh0KXtsZXQgZT1KYS5yZXNvbHZlKHQpLHI9dC5jaGFyQ29kZUF0KHQubGVuZ3RoLTEpOyhyPT09cUV8fGlsJiZyPT09TkUpJiZlW2UubGVuZ3RoLTFdIT09SmEuc2VwJiYoZSs9XCIvXCIpO2xldCBpPW5ldyBVUkwoXCJmaWxlOi8vXCIpO3JldHVybiBlLmluY2x1ZGVzKFwiJVwiKSYmKGU9ZS5yZXBsYWNlKFdFLFwiJTI1XCIpKSwhaWwmJmUuaW5jbHVkZXMoXCJcXFxcXCIpJiYoZT1lLnJlcGxhY2UoJEUsXCIlNUNcIikpLGUuaW5jbHVkZXMoYFxuYCkmJihlPWUucmVwbGFjZShIRSxcIiUwQVwiKSksZS5pbmNsdWRlcyhcIlxcclwiKSYmKGU9ZS5yZXBsYWNlKFZFLFwiJTBEXCIpKSxlLmluY2x1ZGVzKFwiXHRcIikmJihlPWUucmVwbGFjZSh6RSxcIiUwOVwiKSksaS5wYXRobmFtZT1lLGl9dmFyIFgsYUUscHQsbEUsdUUsZkUsY0UsdGwsbmcsc2csb2csaEUsZEUsWGEsbmksWmEsZWwsYWcsbGcsZ0UseUUsYkUsd0UsX0UscmwsbUUsdkUsRUUsU0UsQUUsSUUsUEUsT0Usa0UseEUsTUUsTEUsVUUsTkUscUUsREUsakUsaWwsRkUsV0UsJEUsSEUsVkUsekUsaGc9YmUoKCk9Pnt2KCk7bSgpO18oKTtHcCgpO1FwKCk7ZWcoKTtpZygpO1FhKCk7WD17fSxhRT16dCxwdD17aXNTdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT1cInN0cmluZ1wifSxpc09iamVjdDpmdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PVwib2JqZWN0XCImJnQhPT1udWxsfSxpc051bGw6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1udWxsfSxpc051bGxPclVuZGVmaW5lZDpmdW5jdGlvbih0KXtyZXR1cm4gdD09bnVsbH19O1gucGFyc2U9eGksWC5yZXNvbHZlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHhpKHQsITEsITApLnJlc29sdmUoZSl9LFgucmVzb2x2ZU9iamVjdD1mdW5jdGlvbih0LGUpe3JldHVybiB0P3hpKHQsITEsITApLnJlc29sdmVPYmplY3QoZSk6ZX0sWC5mb3JtYXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHB0LmlzU3RyaW5nKHQpJiYodD14aSh0KSksdCBpbnN0YW5jZW9mIEZlP3QuZm9ybWF0KCk6RmUucHJvdG90eXBlLmZvcm1hdC5jYWxsKHQpfSxYLlVybD1GZTtsRT0vXihbYS16MC05ListXSs6KS9pLHVFPS86WzAtOV0qJC8sZkU9L14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxjRT1bXCJ7XCIsXCJ9XCIsXCJ8XCIsXCJcXFxcXCIsXCJeXCIsXCJgXCJdLmNvbmNhdChbXCI8XCIsXCI+XCIsJ1wiJyxcImBcIixcIiBcIixcIlxcclwiLGBcbmAsXCJcdFwiXSksdGw9W1wiJ1wiXS5jb25jYXQoY0UpLG5nPVtcIiVcIixcIi9cIixcIj9cIixcIjtcIixcIiNcIl0uY29uY2F0KHRsKSxzZz1bXCIvXCIsXCI/XCIsXCIjXCJdLG9nPS9eWythLXowLTlBLVpfLV17MCw2M30kLyxoRT0vXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sZEU9e2phdmFzY3JpcHQ6ITAsXCJqYXZhc2NyaXB0OlwiOiEwfSxYYT17amF2YXNjcmlwdDohMCxcImphdmFzY3JpcHQ6XCI6ITB9LG5pPXtodHRwOiEwLGh0dHBzOiEwLGZ0cDohMCxnb3BoZXI6ITAsZmlsZTohMCxcImh0dHA6XCI6ITAsXCJodHRwczpcIjohMCxcImZ0cDpcIjohMCxcImdvcGhlcjpcIjohMCxcImZpbGU6XCI6ITB9LFphPWR0O0ZlLnByb3RvdHlwZS5wYXJzZT1mdW5jdGlvbih0LGUscil7aWYoIXB0LmlzU3RyaW5nKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiK3R5cGVvZiB0KTt2YXIgaT10LmluZGV4T2YoXCI/XCIpLG49aSE9PS0xJiZpPHQuaW5kZXhPZihcIiNcIik/XCI/XCI6XCIjXCIsbz10LnNwbGl0KG4pO29bMF09b1swXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpO3ZhciBzPXQ9by5qb2luKG4pO2lmKHM9cy50cmltKCksIXImJnQuc3BsaXQoXCIjXCIpLmxlbmd0aD09PTEpe3ZhciBhPWZFLmV4ZWMocyk7aWYoYSlyZXR1cm4gdGhpcy5wYXRoPXMsdGhpcy5ocmVmPXMsdGhpcy5wYXRobmFtZT1hWzFdLGFbMl0/KHRoaXMuc2VhcmNoPWFbMl0sdGhpcy5xdWVyeT1lP1phLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk6dGhpcy5zZWFyY2guc3Vic3RyKDEpKTplJiYodGhpcy5zZWFyY2g9XCJcIix0aGlzLnF1ZXJ5PXt9KSx0aGlzfXZhciB1PWxFLmV4ZWMocyk7aWYodSl7dmFyIGM9KHU9dVswXSkudG9Mb3dlckNhc2UoKTt0aGlzLnByb3RvY29sPWMscz1zLnN1YnN0cih1Lmxlbmd0aCl9aWYocnx8dXx8cy5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpe3ZhciBoPXMuc3Vic3RyKDAsMik9PT1cIi8vXCI7IWh8fHUmJlhhW3VdfHwocz1zLnN1YnN0cigyKSx0aGlzLnNsYXNoZXM9ITApfWlmKCFYYVt1XSYmKGh8fHUmJiFuaVt1XSkpe2Zvcih2YXIgZCxnLHk9LTEsdz0wO3c8c2cubGVuZ3RoO3crKykoRT1zLmluZGV4T2Yoc2dbd10pKSE9PS0xJiYoeT09PS0xfHxFPHkpJiYoeT1FKTtmb3IoKGc9eT09PS0xP3MubGFzdEluZGV4T2YoXCJAXCIpOnMubGFzdEluZGV4T2YoXCJAXCIseSkpIT09LTEmJihkPXMuc2xpY2UoMCxnKSxzPXMuc2xpY2UoZysxKSx0aGlzLmF1dGg9ZGVjb2RlVVJJQ29tcG9uZW50KGQpKSx5PS0xLHc9MDt3PG5nLmxlbmd0aDt3Kyspe3ZhciBFOyhFPXMuaW5kZXhPZihuZ1t3XSkpIT09LTEmJih5PT09LTF8fEU8eSkmJih5PUUpfXk9PT0tMSYmKHk9cy5sZW5ndGgpLHRoaXMuaG9zdD1zLnNsaWNlKDAseSkscz1zLnNsaWNlKHkpLHRoaXMucGFyc2VIb3N0KCksdGhpcy5ob3N0bmFtZT10aGlzLmhvc3RuYW1lfHxcIlwiO3ZhciBTPXRoaXMuaG9zdG5hbWVbMF09PT1cIltcIiYmdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aC0xXT09PVwiXVwiO2lmKCFTKWZvcih2YXIgST10aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKSxDPSh3PTAsSS5sZW5ndGgpO3c8Qzt3Kyspe3ZhciBSPUlbd107aWYoUiYmIVIubWF0Y2gob2cpKXtmb3IodmFyIFU9XCJcIixOPTAsVz1SLmxlbmd0aDtOPFc7TisrKVIuY2hhckNvZGVBdChOKT4xMjc/VSs9XCJ4XCI6VSs9UltOXTtpZighVS5tYXRjaChvZykpe3ZhciBLPUkuc2xpY2UoMCx3KSx6PUkuc2xpY2UodysxKSxRPVIubWF0Y2goaEUpO1EmJihLLnB1c2goUVsxXSksei51bnNoaWZ0KFFbMl0pKSx6Lmxlbmd0aCYmKHM9XCIvXCIrei5qb2luKFwiLlwiKStzKSx0aGlzLmhvc3RuYW1lPUsuam9pbihcIi5cIik7YnJlYWt9fX10aGlzLmhvc3RuYW1lLmxlbmd0aD4yNTU/dGhpcy5ob3N0bmFtZT1cIlwiOnRoaXMuaG9zdG5hbWU9dGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpLFN8fCh0aGlzLmhvc3RuYW1lPWFFLnRvQVNDSUkodGhpcy5ob3N0bmFtZSkpO3ZhciBkZT10aGlzLnBvcnQ/XCI6XCIrdGhpcy5wb3J0OlwiXCIsR3Q9dGhpcy5ob3N0bmFtZXx8XCJcIjt0aGlzLmhvc3Q9R3QrZGUsdGhpcy5ocmVmKz10aGlzLmhvc3QsUyYmKHRoaXMuaG9zdG5hbWU9dGhpcy5ob3N0bmFtZS5zdWJzdHIoMSx0aGlzLmhvc3RuYW1lLmxlbmd0aC0yKSxzWzBdIT09XCIvXCImJihzPVwiL1wiK3MpKX1pZighZEVbY10pZm9yKHc9MCxDPXRsLmxlbmd0aDt3PEM7dysrKXt2YXIgcGU9dGxbd107aWYocy5pbmRleE9mKHBlKSE9PS0xKXt2YXIgUnI9ZW5jb2RlVVJJQ29tcG9uZW50KHBlKTtScj09PXBlJiYoUnI9ZXNjYXBlKHBlKSkscz1zLnNwbGl0KHBlKS5qb2luKFJyKX19dmFyIENyPXMuaW5kZXhPZihcIiNcIik7Q3IhPT0tMSYmKHRoaXMuaGFzaD1zLnN1YnN0cihDcikscz1zLnNsaWNlKDAsQ3IpKTt2YXIgQnI9cy5pbmRleE9mKFwiP1wiKTtpZihCciE9PS0xPyh0aGlzLnNlYXJjaD1zLnN1YnN0cihCciksdGhpcy5xdWVyeT1zLnN1YnN0cihCcisxKSxlJiYodGhpcy5xdWVyeT1aYS5wYXJzZSh0aGlzLnF1ZXJ5KSkscz1zLnNsaWNlKDAsQnIpKTplJiYodGhpcy5zZWFyY2g9XCJcIix0aGlzLnF1ZXJ5PXt9KSxzJiYodGhpcy5wYXRobmFtZT1zKSxuaVtjXSYmdGhpcy5ob3N0bmFtZSYmIXRoaXMucGF0aG5hbWUmJih0aGlzLnBhdGhuYW1lPVwiL1wiKSx0aGlzLnBhdGhuYW1lfHx0aGlzLnNlYXJjaCl7ZGU9dGhpcy5wYXRobmFtZXx8XCJcIjt2YXIgdXM9dGhpcy5zZWFyY2h8fFwiXCI7dGhpcy5wYXRoPWRlK3VzfXJldHVybiB0aGlzLmhyZWY9dGhpcy5mb3JtYXQoKSx0aGlzfSxGZS5wcm90b3R5cGUuZm9ybWF0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5hdXRofHxcIlwiO3QmJih0PSh0PWVuY29kZVVSSUNvbXBvbmVudCh0KSkucmVwbGFjZSgvJTNBL2ksXCI6XCIpLHQrPVwiQFwiKTt2YXIgZT10aGlzLnByb3RvY29sfHxcIlwiLHI9dGhpcy5wYXRobmFtZXx8XCJcIixpPXRoaXMuaGFzaHx8XCJcIixuPSExLG89XCJcIjt0aGlzLmhvc3Q/bj10K3RoaXMuaG9zdDp0aGlzLmhvc3RuYW1lJiYobj10Kyh0aGlzLmhvc3RuYW1lLmluZGV4T2YoXCI6XCIpPT09LTE/dGhpcy5ob3N0bmFtZTpcIltcIit0aGlzLmhvc3RuYW1lK1wiXVwiKSx0aGlzLnBvcnQmJihuKz1cIjpcIit0aGlzLnBvcnQpKSx0aGlzLnF1ZXJ5JiZwdC5pc09iamVjdCh0aGlzLnF1ZXJ5KSYmT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoJiYobz1aYS5zdHJpbmdpZnkodGhpcy5xdWVyeSkpO3ZhciBzPXRoaXMuc2VhcmNofHxvJiZcIj9cIitvfHxcIlwiO3JldHVybiBlJiZlLnN1YnN0cigtMSkhPT1cIjpcIiYmKGUrPVwiOlwiKSx0aGlzLnNsYXNoZXN8fCghZXx8bmlbZV0pJiZuIT09ITE/KG49XCIvL1wiKyhufHxcIlwiKSxyJiZyLmNoYXJBdCgwKSE9PVwiL1wiJiYocj1cIi9cIityKSk6bnx8KG49XCJcIiksaSYmaS5jaGFyQXQoMCkhPT1cIiNcIiYmKGk9XCIjXCIraSkscyYmcy5jaGFyQXQoMCkhPT1cIj9cIiYmKHM9XCI/XCIrcyksZStuKyhyPXIucmVwbGFjZSgvWz8jXS9nLGZ1bmN0aW9uKGEpe3JldHVybiBlbmNvZGVVUklDb21wb25lbnQoYSl9KSkrKHM9cy5yZXBsYWNlKFwiI1wiLFwiJTIzXCIpKStpfSxGZS5wcm90b3R5cGUucmVzb2x2ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHhpKHQsITEsITApKS5mb3JtYXQoKX0sRmUucHJvdG90eXBlLnJlc29sdmVPYmplY3Q9ZnVuY3Rpb24odCl7aWYocHQuaXNTdHJpbmcodCkpe3ZhciBlPW5ldyBGZTtlLnBhcnNlKHQsITEsITApLHQ9ZX1mb3IodmFyIHI9bmV3IEZlLGk9T2JqZWN0LmtleXModGhpcyksbj0wO248aS5sZW5ndGg7bisrKXt2YXIgbz1pW25dO3Jbb109dGhpc1tvXX1pZihyLmhhc2g9dC5oYXNoLHQuaHJlZj09PVwiXCIpcmV0dXJuIHIuaHJlZj1yLmZvcm1hdCgpLHI7aWYodC5zbGFzaGVzJiYhdC5wcm90b2NvbCl7Zm9yKHZhciBzPU9iamVjdC5rZXlzKHQpLGE9MDthPHMubGVuZ3RoO2ErKyl7dmFyIHU9c1thXTt1IT09XCJwcm90b2NvbFwiJiYoclt1XT10W3VdKX1yZXR1cm4gbmlbci5wcm90b2NvbF0mJnIuaG9zdG5hbWUmJiFyLnBhdGhuYW1lJiYoci5wYXRoPXIucGF0aG5hbWU9XCIvXCIpLHIuaHJlZj1yLmZvcm1hdCgpLHJ9aWYodC5wcm90b2NvbCYmdC5wcm90b2NvbCE9PXIucHJvdG9jb2wpe2lmKCFuaVt0LnByb3RvY29sXSl7Zm9yKHZhciBjPU9iamVjdC5rZXlzKHQpLGg9MDtoPGMubGVuZ3RoO2grKyl7dmFyIGQ9Y1toXTtyW2RdPXRbZF19cmV0dXJuIHIuaHJlZj1yLmZvcm1hdCgpLHJ9aWYoci5wcm90b2NvbD10LnByb3RvY29sLHQuaG9zdHx8WGFbdC5wcm90b2NvbF0pci5wYXRobmFtZT10LnBhdGhuYW1lO2Vsc2V7Zm9yKHZhciBnPSh0LnBhdGhuYW1lfHxcIlwiKS5zcGxpdChcIi9cIik7Zy5sZW5ndGgmJiEodC5ob3N0PWcuc2hpZnQoKSk7KTt0Lmhvc3R8fCh0Lmhvc3Q9XCJcIiksdC5ob3N0bmFtZXx8KHQuaG9zdG5hbWU9XCJcIiksZ1swXSE9PVwiXCImJmcudW5zaGlmdChcIlwiKSxnLmxlbmd0aDwyJiZnLnVuc2hpZnQoXCJcIiksci5wYXRobmFtZT1nLmpvaW4oXCIvXCIpfWlmKHIuc2VhcmNoPXQuc2VhcmNoLHIucXVlcnk9dC5xdWVyeSxyLmhvc3Q9dC5ob3N0fHxcIlwiLHIuYXV0aD10LmF1dGgsci5ob3N0bmFtZT10Lmhvc3RuYW1lfHx0Lmhvc3Qsci5wb3J0PXQucG9ydCxyLnBhdGhuYW1lfHxyLnNlYXJjaCl7dmFyIHk9ci5wYXRobmFtZXx8XCJcIix3PXIuc2VhcmNofHxcIlwiO3IucGF0aD15K3d9cmV0dXJuIHIuc2xhc2hlcz1yLnNsYXNoZXN8fHQuc2xhc2hlcyxyLmhyZWY9ci5mb3JtYXQoKSxyfXZhciBFPXIucGF0aG5hbWUmJnIucGF0aG5hbWUuY2hhckF0KDApPT09XCIvXCIsUz10Lmhvc3R8fHQucGF0aG5hbWUmJnQucGF0aG5hbWUuY2hhckF0KDApPT09XCIvXCIsST1TfHxFfHxyLmhvc3QmJnQucGF0aG5hbWUsQz1JLFI9ci5wYXRobmFtZSYmci5wYXRobmFtZS5zcGxpdChcIi9cIil8fFtdLFU9KGc9dC5wYXRobmFtZSYmdC5wYXRobmFtZS5zcGxpdChcIi9cIil8fFtdLHIucHJvdG9jb2wmJiFuaVtyLnByb3RvY29sXSk7aWYoVSYmKHIuaG9zdG5hbWU9XCJcIixyLnBvcnQ9bnVsbCxyLmhvc3QmJihSWzBdPT09XCJcIj9SWzBdPXIuaG9zdDpSLnVuc2hpZnQoci5ob3N0KSksci5ob3N0PVwiXCIsdC5wcm90b2NvbCYmKHQuaG9zdG5hbWU9bnVsbCx0LnBvcnQ9bnVsbCx0Lmhvc3QmJihnWzBdPT09XCJcIj9nWzBdPXQuaG9zdDpnLnVuc2hpZnQodC5ob3N0KSksdC5ob3N0PW51bGwpLEk9SSYmKGdbMF09PT1cIlwifHxSWzBdPT09XCJcIikpLFMpci5ob3N0PXQuaG9zdHx8dC5ob3N0PT09XCJcIj90Lmhvc3Q6ci5ob3N0LHIuaG9zdG5hbWU9dC5ob3N0bmFtZXx8dC5ob3N0bmFtZT09PVwiXCI/dC5ob3N0bmFtZTpyLmhvc3RuYW1lLHIuc2VhcmNoPXQuc2VhcmNoLHIucXVlcnk9dC5xdWVyeSxSPWc7ZWxzZSBpZihnLmxlbmd0aClSfHwoUj1bXSksUi5wb3AoKSxSPVIuY29uY2F0KGcpLHIuc2VhcmNoPXQuc2VhcmNoLHIucXVlcnk9dC5xdWVyeTtlbHNlIGlmKCFwdC5pc051bGxPclVuZGVmaW5lZCh0LnNlYXJjaCkpcmV0dXJuIFUmJihyLmhvc3RuYW1lPXIuaG9zdD1SLnNoaWZ0KCksKFE9ISEoci5ob3N0JiZyLmhvc3QuaW5kZXhPZihcIkBcIik+MCkmJnIuaG9zdC5zcGxpdChcIkBcIikpJiYoci5hdXRoPVEuc2hpZnQoKSxyLmhvc3Q9ci5ob3N0bmFtZT1RLnNoaWZ0KCkpKSxyLnNlYXJjaD10LnNlYXJjaCxyLnF1ZXJ5PXQucXVlcnkscHQuaXNOdWxsKHIucGF0aG5hbWUpJiZwdC5pc051bGwoci5zZWFyY2gpfHwoci5wYXRoPShyLnBhdGhuYW1lP3IucGF0aG5hbWU6XCJcIikrKHIuc2VhcmNoP3Iuc2VhcmNoOlwiXCIpKSxyLmhyZWY9ci5mb3JtYXQoKSxyO2lmKCFSLmxlbmd0aClyZXR1cm4gci5wYXRobmFtZT1udWxsLHIuc2VhcmNoP3IucGF0aD1cIi9cIityLnNlYXJjaDpyLnBhdGg9bnVsbCxyLmhyZWY9ci5mb3JtYXQoKSxyO2Zvcih2YXIgTj1SLnNsaWNlKC0xKVswXSxXPShyLmhvc3R8fHQuaG9zdHx8Ui5sZW5ndGg+MSkmJihOPT09XCIuXCJ8fE49PT1cIi4uXCIpfHxOPT09XCJcIixLPTAsej1SLmxlbmd0aDt6Pj0wO3otLSkoTj1SW3pdKT09PVwiLlwiP1Iuc3BsaWNlKHosMSk6Tj09PVwiLi5cIj8oUi5zcGxpY2UoeiwxKSxLKyspOksmJihSLnNwbGljZSh6LDEpLEstLSk7aWYoIUkmJiFDKWZvcig7Sy0tO0spUi51bnNoaWZ0KFwiLi5cIik7IUl8fFJbMF09PT1cIlwifHxSWzBdJiZSWzBdLmNoYXJBdCgwKT09PVwiL1wifHxSLnVuc2hpZnQoXCJcIiksVyYmUi5qb2luKFwiL1wiKS5zdWJzdHIoLTEpIT09XCIvXCImJlIucHVzaChcIlwiKTt2YXIgUSxkZT1SWzBdPT09XCJcInx8UlswXSYmUlswXS5jaGFyQXQoMCk9PT1cIi9cIjtyZXR1cm4gVSYmKHIuaG9zdG5hbWU9ci5ob3N0PWRlP1wiXCI6Ui5sZW5ndGg/Ui5zaGlmdCgpOlwiXCIsKFE9ISEoci5ob3N0JiZyLmhvc3QuaW5kZXhPZihcIkBcIik+MCkmJnIuaG9zdC5zcGxpdChcIkBcIikpJiYoci5hdXRoPVEuc2hpZnQoKSxyLmhvc3Q9ci5ob3N0bmFtZT1RLnNoaWZ0KCkpKSwoST1JfHxyLmhvc3QmJlIubGVuZ3RoKSYmIWRlJiZSLnVuc2hpZnQoXCJcIiksUi5sZW5ndGg/ci5wYXRobmFtZT1SLmpvaW4oXCIvXCIpOihyLnBhdGhuYW1lPW51bGwsci5wYXRoPW51bGwpLHB0LmlzTnVsbChyLnBhdGhuYW1lKSYmcHQuaXNOdWxsKHIuc2VhcmNoKXx8KHIucGF0aD0oci5wYXRobmFtZT9yLnBhdGhuYW1lOlwiXCIpKyhyLnNlYXJjaD9yLnNlYXJjaDpcIlwiKSksci5hdXRoPXQuYXV0aHx8ci5hdXRoLHIuc2xhc2hlcz1yLnNsYXNoZXN8fHQuc2xhc2hlcyxyLmhyZWY9ci5mb3JtYXQoKSxyfSxGZS5wcm90b3R5cGUucGFyc2VIb3N0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ob3N0LGU9dUUuZXhlYyh0KTtlJiYoKGU9ZVswXSkhPT1cIjpcIiYmKHRoaXMucG9ydD1lLnN1YnN0cigxKSksdD10LnN1YnN0cigwLHQubGVuZ3RoLWUubGVuZ3RoKSksdCYmKHRoaXMuaG9zdG5hbWU9dCl9O1guVXJsO1guZm9ybWF0O1gucmVzb2x2ZTtYLnJlc29sdmVPYmplY3Q7ZWw9e30sYWc9ITE7bGc9cEUoKSxnRT10eXBlb2YgRGVubzxcInVcIj9EZW5vLmJ1aWxkLm9zPT09XCJ3aW5kb3dzXCI/XCJ3aW4zMlwiOkRlbm8uYnVpbGQub3M6dm9pZCAwO1guVVJMPXR5cGVvZiBVUkw8XCJ1XCI/VVJMOm51bGw7WC5wYXRoVG9GaWxlVVJMPUJFO1guZmlsZVVSTFRvUGF0aD1URTtYLlVybDtYLmZvcm1hdDtYLnJlc29sdmU7WC5yZXNvbHZlT2JqZWN0O1guVVJMO3lFPTkyLGJFPTQ3LHdFPTk3LF9FPTEyMixybD1nRT09PVwid2luMzJcIixtRT0vXFwvL2csdkU9LyUvZyxFRT0vXFxcXC9nLFNFPS9cXG4vZyxBRT0vXFxyL2csSUU9L1xcdC9nO1BFPXR5cGVvZiBEZW5vPFwidVwiP0Rlbm8uYnVpbGQub3M9PT1cIndpbmRvd3NcIj9cIndpbjMyXCI6RGVuby5idWlsZC5vczp2b2lkIDA7WC5VUkw9dHlwZW9mIFVSTDxcInVcIj9VUkw6bnVsbDtYLnBhdGhUb0ZpbGVVUkw9Zmc7WC5maWxlVVJMVG9QYXRoPXVnO09FPVguVXJsLGtFPVguZm9ybWF0LHhFPVgucmVzb2x2ZSxNRT1YLnJlc29sdmVPYmplY3QsTEU9WC5wYXJzZSxVRT1YLlVSTCxORT05MixxRT00NyxERT05NyxqRT0xMjIsaWw9UEU9PT1cIndpbjMyXCIsRkU9L1xcLy9nLFdFPS8lL2csJEU9L1xcXFwvZyxIRT0vXFxuL2csVkU9L1xcci9nLHpFPS9cXHQvZ30pO3ZhciBubD17fTtRdChubCx7U2VydmVyOigpPT5NZSxTb2NrZXQ6KCk9Pk1lLFN0cmVhbTooKT0+TWUsX2NyZWF0ZVNlcnZlckhhbmRsZTooKT0+TWUsX25vcm1hbGl6ZUFyZ3M6KCk9Pk1lLF9zZXRTaW11bHRhbmVvdXNBY2NlcHRzOigpPT5NZSxjb25uZWN0OigpPT5NZSxjcmVhdGVDb25uZWN0aW9uOigpPT5NZSxjcmVhdGVTZXJ2ZXI6KCk9Pk1lLGRlZmF1bHQ6KCk9PlFFLGlzSVA6KCk9Pk1lLGlzSVB2NDooKT0+TWUsaXNJUHY2OigpPT5NZX0pO2Z1bmN0aW9uIE1lKCl7dGhyb3cgbmV3IEVycm9yKFwiTm9kZS5qcyBuZXQgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSlNQTSBjb3JlIG91dHNpZGUgb2YgTm9kZS5qc1wiKX12YXIgUUUsc2w9YmUoKCk9Pnt2KCk7bSgpO18oKTtRRT17X2NyZWF0ZVNlcnZlckhhbmRsZTpNZSxfbm9ybWFsaXplQXJnczpNZSxfc2V0U2ltdWx0YW5lb3VzQWNjZXB0czpNZSxjb25uZWN0Ok1lLGNyZWF0ZUNvbm5lY3Rpb246TWUsY3JlYXRlU2VydmVyOk1lLGlzSVA6TWUsaXNJUHY0Ok1lLGlzSVB2NjpNZSxTZXJ2ZXI6TWUsU29ja2V0Ok1lLFN0cmVhbTpNZX19KTt2YXIgb2w9TShNaT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhciBkZz1NaSYmTWkuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShNaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgWUU9ZGcoKHNsKCksWihubCkpKSxKRT1kZyhvdCgpKSxYRT0oMCxKRS5kZWZhdWx0KShcIm1xdHRqczp0Y3BcIiksWkU9KHQsZSk9PntlLnBvcnQ9ZS5wb3J0fHwxODgzLGUuaG9zdG5hbWU9ZS5ob3N0bmFtZXx8ZS5ob3N0fHxcImxvY2FsaG9zdFwiO2xldHtwb3J0OnJ9PWUsaT1lLmhvc3RuYW1lO3JldHVybiBYRShcInBvcnQgJWQgYW5kIGhvc3QgJXNcIixyLGkpLFlFLmRlZmF1bHQuY3JlYXRlQ29ubmVjdGlvbihyLGkpfTtNaS5kZWZhdWx0PVpFfSk7dmFyIHBnPXt9O1F0KHBnLHtkZWZhdWx0OigpPT5lU30pO3ZhciBlUyxnZz1iZSgoKT0+e3YoKTttKCk7XygpO2VTPXt9fSk7dmFyIGxsPU0oTGk9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTt2YXIgYWw9TGkmJkxpLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTGksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHRTPWFsKChnZygpLFoocGcpKSksclM9YWwoKHNsKCksWihubCkpKSxpUz1hbChvdCgpKSxuUz0oMCxpUy5kZWZhdWx0KShcIm1xdHRqczp0bHNcIiksc1M9KHQsZSk9PntlLnBvcnQ9ZS5wb3J0fHw4ODgzLGUuaG9zdD1lLmhvc3RuYW1lfHxlLmhvc3R8fFwibG9jYWxob3N0XCIsclMuZGVmYXVsdC5pc0lQKGUuaG9zdCk9PT0wJiYoZS5zZXJ2ZXJuYW1lPWUuaG9zdCksZS5yZWplY3RVbmF1dGhvcml6ZWQ9ZS5yZWplY3RVbmF1dGhvcml6ZWQhPT0hMSxkZWxldGUgZS5wYXRoLG5TKFwicG9ydCAlZCBob3N0ICVzIHJlamVjdFVuYXV0aG9yaXplZCAlYlwiLGUucG9ydCxlLmhvc3QsZS5yZWplY3RVbmF1dGhvcml6ZWQpO2xldCByPXRTLmRlZmF1bHQuY29ubmVjdChlKTtyLm9uKFwic2VjdXJlQ29ubmVjdFwiLCgpPT57ZS5yZWplY3RVbmF1dGhvcml6ZWQmJiFyLmF1dGhvcml6ZWQ/ci5lbWl0KFwiZXJyb3JcIixuZXcgRXJyb3IoXCJUTFMgbm90IGF1dGhvcml6ZWRcIikpOnIucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLGkpfSk7ZnVuY3Rpb24gaShuKXtlLnJlamVjdFVuYXV0aG9yaXplZCYmdC5lbWl0KFwiZXJyb3JcIixuKSxyLmVuZCgpfXJldHVybiByLm9uKFwiZXJyb3JcIixpKSxyfTtMaS5kZWZhdWx0PXNTfSk7dmFyIG9zPU0oc2k9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoc2ksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7c2kuQnVmZmVyZWREdXBsZXg9c2kud3JpdGV2PXZvaWQgMDt2YXIgb1M9RHQoKTtmdW5jdGlvbiB5Zyh0LGUpe2xldCByPW5ldyBBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspdHlwZW9mIHRbaV0uY2h1bms9PVwic3RyaW5nXCI/cltpXT1rLmZyb20odFtpXS5jaHVuayxcInV0ZjhcIik6cltpXT10W2ldLmNodW5rO3RoaXMuX3dyaXRlKGsuY29uY2F0KHIpLFwiYmluYXJ5XCIsZSl9c2kud3JpdGV2PXlnO3ZhciB1bD1jbGFzcyBleHRlbmRzIG9TLkR1cGxleHtjb25zdHJ1Y3RvcihlLHIsaSl7c3VwZXIoe29iamVjdE1vZGU6ITB9KSx0aGlzLnByb3h5PXIsdGhpcy5zb2NrZXQ9aSx0aGlzLndyaXRlUXVldWU9W10sZS5vYmplY3RNb2RlfHwodGhpcy5fd3JpdGV2PXlnLmJpbmQodGhpcykpLHRoaXMuaXNTb2NrZXRPcGVuPSExLHRoaXMucHJveHkub24oXCJkYXRhXCIsbj0+e3RoaXMucHVzaChuKX0pfV9yZWFkKGUpe3RoaXMucHJveHkucmVhZChlKX1fd3JpdGUoZSxyLGkpe3RoaXMuaXNTb2NrZXRPcGVuP3RoaXMud3JpdGVUb1Byb3h5KGUscixpKTp0aGlzLndyaXRlUXVldWUucHVzaCh7Y2h1bms6ZSxlbmNvZGluZzpyLGNiOml9KX1fZmluYWwoZSl7dGhpcy53cml0ZVF1ZXVlPVtdLHRoaXMucHJveHkuZW5kKGUpfXNvY2tldFJlYWR5KCl7dGhpcy5lbWl0KFwiY29ubmVjdFwiKSx0aGlzLmlzU29ja2V0T3Blbj0hMCx0aGlzLnByb2Nlc3NXcml0ZVF1ZXVlKCl9d3JpdGVUb1Byb3h5KGUscixpKXt0aGlzLnByb3h5LndyaXRlKGUscik9PT0hMT90aGlzLnByb3h5Lm9uY2UoXCJkcmFpblwiLGkpOmkoKX1wcm9jZXNzV3JpdGVRdWV1ZSgpe2Zvcig7dGhpcy53cml0ZVF1ZXVlLmxlbmd0aD4wOyl7bGV0e2NodW5rOmUsZW5jb2Rpbmc6cixjYjppfT10aGlzLndyaXRlUXVldWUuc2hpZnQoKTt0aGlzLndyaXRlVG9Qcm94eShlLHIsaSl9fX07c2kuQnVmZmVyZWREdXBsZXg9dWx9KTt2YXIgaGw9TShjbD0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShjbCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYmc9KHdlKCksWih2ZSkpLGFTPUR0KCksbFM9b3MoKSxndCxmbCxMZTtmdW5jdGlvbiB1Uygpe2xldCB0PW5ldyBhUy5UcmFuc2Zvcm07cmV0dXJuIHQuX3dyaXRlPShlLHIsaSk9PntndC5zZW5kKHtkYXRhOmUuYnVmZmVyLHN1Y2Nlc3MoKXtpKCl9LGZhaWwobil7aShuZXcgRXJyb3IobikpfX0pfSx0Ll9mbHVzaD1lPT57Z3QuY2xvc2Uoe3N1Y2Nlc3MoKXtlKCl9fSl9LHR9ZnVuY3Rpb24gZlModCl7dC5ob3N0bmFtZXx8KHQuaG9zdG5hbWU9XCJsb2NhbGhvc3RcIiksdC5wYXRofHwodC5wYXRoPVwiL1wiKSx0LndzT3B0aW9uc3x8KHQud3NPcHRpb25zPXt9KX1mdW5jdGlvbiBjUyh0LGUpe2xldCByPXQucHJvdG9jb2w9PT1cInd4c1wiP1wid3NzXCI6XCJ3c1wiLGk9YCR7cn06Ly8ke3QuaG9zdG5hbWV9JHt0LnBhdGh9YDtyZXR1cm4gdC5wb3J0JiZ0LnBvcnQhPT04MCYmdC5wb3J0IT09NDQzJiYoaT1gJHtyfTovLyR7dC5ob3N0bmFtZX06JHt0LnBvcnR9JHt0LnBhdGh9YCksdHlwZW9mIHQudHJhbnNmb3JtV3NVcmw9PVwiZnVuY3Rpb25cIiYmKGk9dC50cmFuc2Zvcm1Xc1VybChpLHQsZSkpLGl9ZnVuY3Rpb24gaFMoKXtndC5vbk9wZW4oKCk9PntMZS5zb2NrZXRSZWFkeSgpfSksZ3Qub25NZXNzYWdlKHQ9PntsZXR7ZGF0YTplfT10O2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9lPWJnLkJ1ZmZlci5mcm9tKGUpOmU9YmcuQnVmZmVyLmZyb20oZSxcInV0ZjhcIiksZmwucHVzaChlKX0pLGd0Lm9uQ2xvc2UoKCk9PntMZS5lbWl0KFwiY2xvc2VcIiksTGUuZW5kKCksTGUuZGVzdHJveSgpfSksZ3Qub25FcnJvcih0PT57bGV0IGU9bmV3IEVycm9yKHQuZXJyTXNnKTtMZS5kZXN0cm95KGUpfSl9dmFyIGRTPSh0LGUpPT57aWYoZS5ob3N0bmFtZT1lLmhvc3RuYW1lfHxlLmhvc3QsIWUuaG9zdG5hbWUpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGRldGVybWluZSBob3N0LiBTcGVjaWZ5IGhvc3QgbWFudWFsbHkuXCIpO2xldCByPWUucHJvdG9jb2xJZD09PVwiTVFJc2RwXCImJmUucHJvdG9jb2xWZXJzaW9uPT09Mz9cIm1xdHR2My4xXCI6XCJtcXR0XCI7ZlMoZSk7bGV0IGk9Y1MoZSx0KTtndD13eC5jb25uZWN0U29ja2V0KHt1cmw6aSxwcm90b2NvbHM6W3JdfSksZmw9dVMoKSxMZT1uZXcgbFMuQnVmZmVyZWREdXBsZXgoZSxmbCxndCksTGUuX2Rlc3Ryb3k9KG8scyk9PntndC5jbG9zZSh7c3VjY2Vzcygpe3MmJnMobyl9fSl9O2xldCBuPUxlLmRlc3Ryb3k7cmV0dXJuIExlLmRlc3Ryb3k9KG8scyk9PihMZS5kZXN0cm95PW4sc2V0VGltZW91dCgoKT0+e2d0LmNsb3NlKHtmYWlsKCl7TGUuX2Rlc3Ryb3kobyxzKX19KX0sMCksTGUpLGhTKCksTGV9O2NsLmRlZmF1bHQ9ZFN9KTt2YXIgZ2w9TShwbD0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShwbCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgZGw9KHdlKCksWih2ZSkpLHBTPUR0KCksZ1M9b3MoKSxrdCxhcyxvaSx3Zz0hMTtmdW5jdGlvbiB5Uygpe2xldCB0PW5ldyBwUy5UcmFuc2Zvcm07cmV0dXJuIHQuX3dyaXRlPShlLHIsaSk9PntrdC5zZW5kU29ja2V0TWVzc2FnZSh7ZGF0YTplLmJ1ZmZlcixzdWNjZXNzKCl7aSgpfSxmYWlsKCl7aShuZXcgRXJyb3IpfX0pfSx0Ll9mbHVzaD1lPT57a3QuY2xvc2VTb2NrZXQoe3N1Y2Nlc3MoKXtlKCl9fSl9LHR9ZnVuY3Rpb24gYlModCl7dC5ob3N0bmFtZXx8KHQuaG9zdG5hbWU9XCJsb2NhbGhvc3RcIiksdC5wYXRofHwodC5wYXRoPVwiL1wiKSx0LndzT3B0aW9uc3x8KHQud3NPcHRpb25zPXt9KX1mdW5jdGlvbiB3Uyh0LGUpe2xldCByPXQucHJvdG9jb2w9PT1cImFsaXNcIj9cIndzc1wiOlwid3NcIixpPWAke3J9Oi8vJHt0Lmhvc3RuYW1lfSR7dC5wYXRofWA7cmV0dXJuIHQucG9ydCYmdC5wb3J0IT09ODAmJnQucG9ydCE9PTQ0MyYmKGk9YCR7cn06Ly8ke3QuaG9zdG5hbWV9OiR7dC5wb3J0fSR7dC5wYXRofWApLHR5cGVvZiB0LnRyYW5zZm9ybVdzVXJsPT1cImZ1bmN0aW9uXCImJihpPXQudHJhbnNmb3JtV3NVcmwoaSx0LGUpKSxpfWZ1bmN0aW9uIF9TKCl7d2d8fCh3Zz0hMCxrdC5vblNvY2tldE9wZW4oKCk9PntvaS5zb2NrZXRSZWFkeSgpfSksa3Qub25Tb2NrZXRNZXNzYWdlKHQ9PntpZih0eXBlb2YgdC5kYXRhPT1cInN0cmluZ1wiKXtsZXQgZT1kbC5CdWZmZXIuZnJvbSh0LmRhdGEsXCJiYXNlNjRcIik7YXMucHVzaChlKX1lbHNle2xldCBlPW5ldyBGaWxlUmVhZGVyO2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoKT0+e2xldCByPWUucmVzdWx0O3IgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9yPWRsLkJ1ZmZlci5mcm9tKHIpOnI9ZGwuQnVmZmVyLmZyb20ocixcInV0ZjhcIiksYXMucHVzaChyKX0pLGUucmVhZEFzQXJyYXlCdWZmZXIodC5kYXRhKX19KSxrdC5vblNvY2tldENsb3NlKCgpPT57b2kuZW5kKCksb2kuZGVzdHJveSgpfSksa3Qub25Tb2NrZXRFcnJvcih0PT57b2kuZGVzdHJveSh0KX0pKX12YXIgbVM9KHQsZSk9PntpZihlLmhvc3RuYW1lPWUuaG9zdG5hbWV8fGUuaG9zdCwhZS5ob3N0bmFtZSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIGhvc3QuIFNwZWNpZnkgaG9zdCBtYW51YWxseS5cIik7bGV0IHI9ZS5wcm90b2NvbElkPT09XCJNUUlzZHBcIiYmZS5wcm90b2NvbFZlcnNpb249PT0zP1wibXF0dHYzLjFcIjpcIm1xdHRcIjtiUyhlKTtsZXQgaT13UyhlLHQpO3JldHVybiBrdD1lLm15LGt0LmNvbm5lY3RTb2NrZXQoe3VybDppLHByb3RvY29sczpyfSksYXM9eVMoKSxvaT1uZXcgZ1MuQnVmZmVyZWREdXBsZXgoZSxhcyxrdCksX1MoKSxvaX07cGwuZGVmYXVsdD1tU30pO3ZhciBtZz1NKChSRCxfZyk9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTtfZy5leHBvcnRzPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwid3MgZG9lcyBub3Qgd29yayBpbiB0aGUgYnJvd3Nlci4gQnJvd3NlciBjbGllbnRzIG11c3QgdXNlIHRoZSBuYXRpdmUgV2ViU29ja2V0IG9iamVjdFwiKX19KTt2YXIgX2w9TShVaT0+e1widXNlIHN0cmljdFwiO3YoKTttKCk7XygpO3ZhciB3bD1VaSYmVWkuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShVaSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgeWw9KHdlKCksWih2ZSkpLHZnPXdsKG1nKCkpLHZTPXdsKG90KCkpLEVTPUR0KCksRWc9d2woUGkoKSksYmw9b3MoKSxLdD0oMCx2Uy5kZWZhdWx0KShcIm1xdHRqczp3c1wiKSxTUz1bXCJyZWplY3RVbmF1dGhvcml6ZWRcIixcImNhXCIsXCJjZXJ0XCIsXCJrZXlcIixcInBmeFwiLFwicGFzc3BocmFzZVwiXTtmdW5jdGlvbiBTZyh0LGUpe2xldCByPWAke3QucHJvdG9jb2x9Oi8vJHt0Lmhvc3RuYW1lfToke3QucG9ydH0ke3QucGF0aH1gO3JldHVybiB0eXBlb2YgdC50cmFuc2Zvcm1Xc1VybD09XCJmdW5jdGlvblwiJiYocj10LnRyYW5zZm9ybVdzVXJsKHIsdCxlKSkscn1mdW5jdGlvbiBBZyh0KXtsZXQgZT10O3JldHVybiB0Lmhvc3RuYW1lfHwoZS5ob3N0bmFtZT1cImxvY2FsaG9zdFwiKSx0LnBvcnR8fCh0LnByb3RvY29sPT09XCJ3c3NcIj9lLnBvcnQ9NDQzOmUucG9ydD04MCksdC5wYXRofHwoZS5wYXRoPVwiL1wiKSx0LndzT3B0aW9uc3x8KGUud3NPcHRpb25zPXt9KSwhRWcuZGVmYXVsdCYmdC5wcm90b2NvbD09PVwid3NzXCImJlNTLmZvckVhY2gocj0+e09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiYhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQud3NPcHRpb25zLHIpJiYoZS53c09wdGlvbnNbcl09dFtyXSl9KSxlfWZ1bmN0aW9uIEFTKHQpe2xldCBlPUFnKHQpO2lmKGUuaG9zdG5hbWV8fChlLmhvc3RuYW1lPWUuaG9zdCksIWUuaG9zdG5hbWUpe2lmKHR5cGVvZiBkb2N1bWVudD5cInVcIil0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIGhvc3QuIFNwZWNpZnkgaG9zdCBtYW51YWxseS5cIik7bGV0IHI9bmV3IFVSTChkb2N1bWVudC5VUkwpO2UuaG9zdG5hbWU9ci5ob3N0bmFtZSxlLnBvcnR8fChlLnBvcnQ9TnVtYmVyKHIucG9ydCkpfXJldHVybiBlLm9iamVjdE1vZGU9PT12b2lkIDAmJihlLm9iamVjdE1vZGU9IShlLmJpbmFyeT09PSEwfHxlLmJpbmFyeT09PXZvaWQgMCkpLGV9ZnVuY3Rpb24gSVModCxlLHIpe0t0KFwiY3JlYXRlV2ViU29ja2V0XCIpLEt0KGBwcm90b2NvbDogJHtyLnByb3RvY29sSWR9ICR7ci5wcm90b2NvbFZlcnNpb259YCk7bGV0IGk9ci5wcm90b2NvbElkPT09XCJNUUlzZHBcIiYmci5wcm90b2NvbFZlcnNpb249PT0zP1wibXF0dHYzLjFcIjpcIm1xdHRcIjtLdChgY3JlYXRpbmcgbmV3IFdlYnNvY2tldCBmb3IgdXJsOiAke2V9IGFuZCBwcm90b2NvbDogJHtpfWApO2xldCBuO3JldHVybiByLmNyZWF0ZVdlYnNvY2tldD9uPXIuY3JlYXRlV2Vic29ja2V0KGUsW2ldLHIpOm49bmV3IHZnLmRlZmF1bHQoZSxbaV0sci53c09wdGlvbnMpLG59ZnVuY3Rpb24gVFModCxlKXtsZXQgcj1lLnByb3RvY29sSWQ9PT1cIk1RSXNkcFwiJiZlLnByb3RvY29sVmVyc2lvbj09PTM/XCJtcXR0djMuMVwiOlwibXF0dFwiLGk9U2coZSx0KSxuO3JldHVybiBlLmNyZWF0ZVdlYnNvY2tldD9uPWUuY3JlYXRlV2Vic29ja2V0KGksW3JdLGUpOm49bmV3IFdlYlNvY2tldChpLFtyXSksbi5iaW5hcnlUeXBlPVwiYXJyYXlidWZmZXJcIixufXZhciBSUz0odCxlKT0+e0t0KFwic3RyZWFtQnVpbGRlclwiKTtsZXQgcj1BZyhlKSxpPVNnKHIsdCksbj1JUyh0LGksciksbz12Zy5kZWZhdWx0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbShuLHIud3NPcHRpb25zKTtyZXR1cm4gby51cmw9aSxuLm9uKFwiY2xvc2VcIiwoKT0+e28uZGVzdHJveSgpfSksb30sQ1M9KHQsZSk9PntLdChcImJyb3dzZXJTdHJlYW1CdWlsZGVyXCIpO2xldCByLG49QVMoZSkuYnJvd3NlckJ1ZmZlclNpemV8fDEwMjQqNTEyLG89ZS5icm93c2VyQnVmZmVyVGltZW91dHx8MWUzLHM9IWUub2JqZWN0TW9kZSxhPVRTKHQsZSksdT1oKGUsRSxTKTtlLm9iamVjdE1vZGV8fCh1Ll93cml0ZXY9Ymwud3JpdGV2LmJpbmQodSkpLHUub24oXCJjbG9zZVwiLCgpPT57YS5jbG9zZSgpfSk7bGV0IGM9dHlwZW9mIGEuYWRkRXZlbnRMaXN0ZW5lcjxcInVcIjthLnJlYWR5U3RhdGU9PT1hLk9QRU4/KHI9dSxyLnNvY2tldD1hKToocj1uZXcgYmwuQnVmZmVyZWREdXBsZXgoZSx1LGEpLGM/YS5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLGQpOmEub25vcGVuPWQpLGM/KGEuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsZyksYS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIix5KSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdykpOihhLm9uY2xvc2U9ZyxhLm9uZXJyb3I9eSxhLm9ubWVzc2FnZT13KTtmdW5jdGlvbiBoKEksQyxSKXtsZXQgVT1uZXcgRVMuVHJhbnNmb3JtKHtvYmplY3RNb2RlOkkub2JqZWN0TW9kZX0pO3JldHVybiBVLl93cml0ZT1DLFUuX2ZsdXNoPVIsVX1mdW5jdGlvbiBkKCl7S3QoXCJXZWJTb2NrZXQgb25PcGVuXCIpLHIgaW5zdGFuY2VvZiBibC5CdWZmZXJlZER1cGxleCYmci5zb2NrZXRSZWFkeSgpfWZ1bmN0aW9uIGcoSSl7S3QoXCJXZWJTb2NrZXQgb25DbG9zZVwiLEkpLHIuZW5kKCksci5kZXN0cm95KCl9ZnVuY3Rpb24geShJKXtLdChcIldlYlNvY2tldCBvbkVycm9yXCIsSSk7bGV0IEM9bmV3IEVycm9yKFwiV2ViU29ja2V0IGVycm9yXCIpO0MuZXZlbnQ9SSxyLmRlc3Ryb3koQyl9ZnVuY3Rpb24gdyhJKXtsZXR7ZGF0YTpDfT1JO0MgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9DPXlsLkJ1ZmZlci5mcm9tKEMpOkM9eWwuQnVmZmVyLmZyb20oQyxcInV0ZjhcIiksdS5wdXNoKEMpfWZ1bmN0aW9uIEUoSSxDLFIpe2lmKGEuYnVmZmVyZWRBbW91bnQ+bil7c2V0VGltZW91dChFLG8sSSxDLFIpO3JldHVybn1zJiZ0eXBlb2YgST09XCJzdHJpbmdcIiYmKEk9eWwuQnVmZmVyLmZyb20oSSxcInV0ZjhcIikpO3RyeXthLnNlbmQoSSl9Y2F0Y2goVSl7cmV0dXJuIFIoVSl9UigpfWZ1bmN0aW9uIFMoSSl7YS5jbG9zZSgpLEkoKX1yZXR1cm4gcn07VWkuZGVmYXVsdD1FZy5kZWZhdWx0P0NTOlJTfSk7dmFyIFJnPU0oVHI9PntcInVzZSBzdHJpY3RcIjt2KCk7bSgpO18oKTt2YXIgbHM9VHImJlRyLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoVHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7VHIuY29ubmVjdEFzeW5jPXZvaWQgMDt2YXIgQlM9bHMob3QoKSksUFM9bHMoKGhnKCksWihjZykpKSxPUz1scyhucygpKSxrUz1scyhQaSgpKSxJZz0oMCxCUy5kZWZhdWx0KShcIm1xdHRqc1wiKSxSZT17fTtrUy5kZWZhdWx0PyhSZS53eD1obCgpLmRlZmF1bHQsUmUud3hzPWhsKCkuZGVmYXVsdCxSZS5hbGk9Z2woKS5kZWZhdWx0LFJlLmFsaXM9Z2woKS5kZWZhdWx0KTooUmUubXF0dD1vbCgpLmRlZmF1bHQsUmUudGNwPW9sKCkuZGVmYXVsdCxSZS5zc2w9bGwoKS5kZWZhdWx0LFJlLnRscz1SZS5zc2wsUmUubXF0dHM9bGwoKS5kZWZhdWx0KTtSZS53cz1fbCgpLmRlZmF1bHQ7UmUud3NzPV9sKCkuZGVmYXVsdDtmdW5jdGlvbiB4Uyh0KXtsZXQgZTt0LmF1dGgmJihlPXQuYXV0aC5tYXRjaCgvXiguKyk6KC4rKSQvKSxlPyh0LnVzZXJuYW1lPWVbMV0sdC5wYXNzd29yZD1lWzJdKTp0LnVzZXJuYW1lPXQuYXV0aCl9ZnVuY3Rpb24gVGcodCxlKXtpZihJZyhcImNvbm5lY3RpbmcgdG8gYW4gTVFUVCBicm9rZXIuLi5cIiksdHlwZW9mIHQ9PVwib2JqZWN0XCImJiFlJiYoZT10LHQ9XCJcIiksZT1lfHx7fSx0JiZ0eXBlb2YgdD09XCJzdHJpbmdcIil7bGV0IG49UFMuZGVmYXVsdC5wYXJzZSh0LCEwKTtpZihuLnBvcnQhPW51bGwmJihuLnBvcnQ9TnVtYmVyKG4ucG9ydCkpLGU9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLGUpLGUucHJvdG9jb2w9PT1udWxsKXRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcHJvdG9jb2xcIik7ZS5wcm90b2NvbD1lLnByb3RvY29sLnJlcGxhY2UoLzokLyxcIlwiKX1pZih4UyhlKSxlLnF1ZXJ5JiZ0eXBlb2YgZS5xdWVyeS5jbGllbnRJZD09XCJzdHJpbmdcIiYmKGUuY2xpZW50SWQ9ZS5xdWVyeS5jbGllbnRJZCksZS5jZXJ0JiZlLmtleSlpZihlLnByb3RvY29sKXtpZihbXCJtcXR0c1wiLFwid3NzXCIsXCJ3eHNcIixcImFsaXNcIl0uaW5kZXhPZihlLnByb3RvY29sKT09PS0xKXN3aXRjaChlLnByb3RvY29sKXtjYXNlXCJtcXR0XCI6ZS5wcm90b2NvbD1cIm1xdHRzXCI7YnJlYWs7Y2FzZVwid3NcIjplLnByb3RvY29sPVwid3NzXCI7YnJlYWs7Y2FzZVwid3hcIjplLnByb3RvY29sPVwid3hzXCI7YnJlYWs7Y2FzZVwiYWxpXCI6ZS5wcm90b2NvbD1cImFsaXNcIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBwcm90b2NvbCBmb3Igc2VjdXJlIGNvbm5lY3Rpb246IFwiJHtlLnByb3RvY29sfVwiIWApfX1lbHNlIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc2VjdXJlIHByb3RvY29sIGtleVwiKTtpZighUmVbZS5wcm90b2NvbF0pe2xldCBuPVtcIm1xdHRzXCIsXCJ3c3NcIl0uaW5kZXhPZihlLnByb3RvY29sKSE9PS0xO2UucHJvdG9jb2w9W1wibXF0dFwiLFwibXF0dHNcIixcIndzXCIsXCJ3c3NcIixcInd4XCIsXCJ3eHNcIixcImFsaVwiLFwiYWxpc1wiXS5maWx0ZXIoKG8scyk9Pm4mJnMlMj09PTA/ITE6dHlwZW9mIFJlW29dPT1cImZ1bmN0aW9uXCIpWzBdfWlmKGUuY2xlYW49PT0hMSYmIWUuY2xpZW50SWQpdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBjbGllbnRJZCBmb3IgdW5jbGVhbiBjbGllbnRzXCIpO2UucHJvdG9jb2wmJihlLmRlZmF1bHRQcm90b2NvbD1lLnByb3RvY29sKTtmdW5jdGlvbiByKG4pe3JldHVybiBlLnNlcnZlcnMmJigoIW4uX3JlY29ubmVjdENvdW50fHxuLl9yZWNvbm5lY3RDb3VudD09PWUuc2VydmVycy5sZW5ndGgpJiYobi5fcmVjb25uZWN0Q291bnQ9MCksZS5ob3N0PWUuc2VydmVyc1tuLl9yZWNvbm5lY3RDb3VudF0uaG9zdCxlLnBvcnQ9ZS5zZXJ2ZXJzW24uX3JlY29ubmVjdENvdW50XS5wb3J0LGUucHJvdG9jb2w9ZS5zZXJ2ZXJzW24uX3JlY29ubmVjdENvdW50XS5wcm90b2NvbD9lLnNlcnZlcnNbbi5fcmVjb25uZWN0Q291bnRdLnByb3RvY29sOmUuZGVmYXVsdFByb3RvY29sLGUuaG9zdG5hbWU9ZS5ob3N0LG4uX3JlY29ubmVjdENvdW50KyspLElnKFwiY2FsbGluZyBzdHJlYW1idWlsZGVyIGZvclwiLGUucHJvdG9jb2wpLFJlW2UucHJvdG9jb2xdKG4sZSl9bGV0IGk9bmV3IE9TLmRlZmF1bHQocixlKTtyZXR1cm4gaS5vbihcImVycm9yXCIsKCk9Pnt9KSxpfWZ1bmN0aW9uIE1TKHQsZSxyPSEwKXtyZXR1cm4gbmV3IFByb21pc2UoKGksbik9PntsZXQgbz1UZyh0LGUpLHM9e2Nvbm5lY3Q6dT0+e2EoKSxpKG8pfSxlbmQ6KCk9PnthKCksaShvKX0sZXJyb3I6dT0+e2EoKSxvLmVuZCgpLG4odSl9fTtyPT09ITEmJihzLmNsb3NlPSgpPT57cy5lcnJvcihuZXcgRXJyb3IoXCJDb3VsZG4ndCBjb25uZWN0IHRvIHNlcnZlclwiKSl9KTtmdW5jdGlvbiBhKCl7T2JqZWN0LmtleXMocykuZm9yRWFjaCh1PT57by5vZmYodSxzW3VdKX0pfU9iamVjdC5rZXlzKHMpLmZvckVhY2godT0+e28ub24odSxzW3VdKX0pfSl9VHIuY29ubmVjdEFzeW5jPU1TO1RyLmRlZmF1bHQ9VGd9KTt2YXIgbWw9TShHPT57XCJ1c2Ugc3RyaWN0XCI7digpO20oKTtfKCk7dmFyIENnPUcmJkcuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUscixpKXtpPT09dm9pZCAwJiYoaT1yKTt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUscik7KCFufHwoXCJnZXRcImluIG4/IWUuX19lc01vZHVsZTpuLndyaXRhYmxlfHxuLmNvbmZpZ3VyYWJsZSkpJiYobj17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtyXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLG4pfTpmdW5jdGlvbih0LGUscixpKXtpPT09dm9pZCAwJiYoaT1yKSx0W2ldPWVbcl19KSxMUz1HJiZHLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTplfSl9OmZ1bmN0aW9uKHQsZSl7dC5kZWZhdWx0PWV9KSxVUz1HJiZHLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKHQhPW51bGwpZm9yKHZhciByIGluIHQpciE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmQ2coZSx0LHIpO3JldHVybiBMUyhlLHQpLGV9LEJnPUcmJkcuX19leHBvcnRTdGFyfHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgciBpbiB0KXIhPT1cImRlZmF1bHRcIiYmIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiZDZyhlLHQscil9LE5pPUcmJkcuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShHLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO0cuUmVhc29uQ29kZXM9Ry5QaW5nVGltZXI9Ry5VbmlxdWVNZXNzYWdlSWRQcm92aWRlcj1HLkRlZmF1bHRNZXNzYWdlSWRQcm92aWRlcj1HLlN0b3JlPUcuTXF0dENsaWVudD1HLmNvbm5lY3RBc3luYz1HLmNvbm5lY3Q9Ry5DbGllbnQ9dm9pZCAwO3ZhciBQZz1OaShucygpKTtHLk1xdHRDbGllbnQ9UGcuZGVmYXVsdDt2YXIgTlM9TmkoWW8oKSk7Ry5EZWZhdWx0TWVzc2FnZUlkUHJvdmlkZXI9TlMuZGVmYXVsdDt2YXIgcVM9TmkoRnAoKSk7Ry5VbmlxdWVNZXNzYWdlSWRQcm92aWRlcj1xUy5kZWZhdWx0O3ZhciBEUz1OaShabygpKTtHLlN0b3JlPURTLmRlZmF1bHQ7dmFyIE9nPVVTKFJnKCkpO0cuY29ubmVjdD1PZy5kZWZhdWx0O09iamVjdC5kZWZpbmVQcm9wZXJ0eShHLFwiY29ubmVjdEFzeW5jXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIE9nLmNvbm5lY3RBc3luY319KTt2YXIgalM9TmkocWEoKSk7Ry5QaW5nVGltZXI9alMuZGVmYXVsdDtHLkNsaWVudD1QZy5kZWZhdWx0O0JnKG5zKCksRyk7QmcoWXIoKSxHKTt2YXIgRlM9U2koKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRyxcIlJlYXNvbkNvZGVzXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEZTLlJlYXNvbkNvZGVzfX0pfSk7dmFyIHpTPU0oV2U9Pnt2KCk7bSgpO18oKTt2YXIga2c9V2UmJldlLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLHIsaSl7aT09PXZvaWQgMCYmKGk9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHIpOyghbnx8KFwiZ2V0XCJpbiBuPyFlLl9fZXNNb2R1bGU6bi53cml0YWJsZXx8bi5jb25maWd1cmFibGUpKSYmKG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaSxuKX06ZnVuY3Rpb24odCxlLHIsaSl7aT09PXZvaWQgMCYmKGk9ciksdFtpXT1lW3JdfSksV1M9V2UmJldlLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTplfSl9OmZ1bmN0aW9uKHQsZSl7dC5kZWZhdWx0PWV9KSwkUz1XZSYmV2UuX19pbXBvcnRTdGFyfHxmdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGU9e307aWYodCE9bnVsbClmb3IodmFyIHIgaW4gdClyIT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiZrZyhlLHQscik7cmV0dXJuIFdTKGUsdCksZX0sSFM9V2UmJldlLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIHIgaW4gdClyIT09XCJkZWZhdWx0XCImJiFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYma2coZSx0LHIpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoV2UsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIFZTPSRTKG1sKCkpO1dlLmRlZmF1bHQ9VlM7SFMobWwoKSxXZSl9KTtleHBvcnQgZGVmYXVsdCB6UygpO1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxuQGpzcG0vY29yZS9ub2RlbGlicy9icm93c2VyL2J1ZmZlci5qczpcbiAgKCohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKilcbiovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/mqtt/dist/mqtt.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.module.css":
/*!*********************************!*\
  !*** ./src/app/page.module.css ***!
  \*********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"box\":\"page_box__nSTsO\",\"btn\":\"page_btn__VzVq_\",\"title\":\"page_title__3jonF\",\"connect\":\"page_connect__W9zSv\",\"disconnect\":\"page_disconnect__FlW6i\",\"topic\":\"page_topic__RNHkZ\",\"input\":\"page_input___cVLA\",\"message\":\"page_message__abnJo\",\"link\":\"page_link__36MaQ\",\"divbtn\":\"page_divbtn__ASoXp\",\"continer\":\"page_continer__O6651\",\"checkboxwrapper\":\"page_checkboxwrapper__VlrGU\",\"tgl\":\"page_tgl___ZUev\",\"tglbtn\":\"page_tglbtn__73psi\",\"tglskewed\":\"page_tglskewed__PIFaV\",\"btnbordar\":\"page_btnbordar__yH7tR\",\"icon\":\"page_icon__AYuK3\"};\n    if(true) {\n      // 1711283447536\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"714445b06615\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZS5tb2R1bGUuY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdNQUE2SCxjQUFjLHNEQUFzRDtBQUMvTixNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvcGFnZS5tb2R1bGUuY3NzP2FjNmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcImJveFwiOlwicGFnZV9ib3hfX25TVHNPXCIsXCJidG5cIjpcInBhZ2VfYnRuX19WelZxX1wiLFwidGl0bGVcIjpcInBhZ2VfdGl0bGVfXzNqb25GXCIsXCJjb25uZWN0XCI6XCJwYWdlX2Nvbm5lY3RfX1c5elN2XCIsXCJkaXNjb25uZWN0XCI6XCJwYWdlX2Rpc2Nvbm5lY3RfX0ZsVzZpXCIsXCJ0b3BpY1wiOlwicGFnZV90b3BpY19fUk5Ia1pcIixcImlucHV0XCI6XCJwYWdlX2lucHV0X19fY1ZMQVwiLFwibWVzc2FnZVwiOlwicGFnZV9tZXNzYWdlX19hYm5Kb1wiLFwibGlua1wiOlwicGFnZV9saW5rX18zNk1hUVwiLFwiZGl2YnRuXCI6XCJwYWdlX2RpdmJ0bl9fQVNvWHBcIixcImNvbnRpbmVyXCI6XCJwYWdlX2NvbnRpbmVyX19PNjY1MVwiLFwiY2hlY2tib3h3cmFwcGVyXCI6XCJwYWdlX2NoZWNrYm94d3JhcHBlcl9fVmxyR1VcIixcInRnbFwiOlwicGFnZV90Z2xfX19aVWV2XCIsXCJ0Z2xidG5cIjpcInBhZ2VfdGdsYnRuX183M3BzaVwiLFwidGdsc2tld2VkXCI6XCJwYWdlX3RnbHNrZXdlZF9fUElGYVZcIixcImJ0bmJvcmRhclwiOlwicGFnZV9idG5ib3JkYXJfX3lIN3RSXCIsXCJpY29uXCI6XCJwYWdlX2ljb25fX0FZdUszXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTEyODM0NDc1MzZcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiL2hvbWUvam9uL0lPVC9JT1QvZnJvbnRlbmQvViAxLjAvbXktYXBwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICBcbm1vZHVsZS5leHBvcnRzLl9fY2hlY2tzdW0gPSBcIjcxNDQ0NWIwNjYxNVwiXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.module.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/add-locale.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/client/add-locale.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDZDQUE0QztJQUN4Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDBCQUEwQkMsbUJBQU9BLENBQUMsbUhBQTRCO0FBQ3BFLE1BQU1GLFlBQVksU0FBU0csSUFBSTtJQUMzQixJQUFJLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQU87UUFDdEdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztJQUNwQztJQUNBLElBQUlDLEtBQStCLEVBQUUsRUFFcEM7SUFDRCxPQUFPUDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9QLFFBQVFrQixPQUFPLEtBQUssY0FBZSxPQUFPbEIsUUFBUWtCLE9BQU8sS0FBSyxZQUFZbEIsUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xCLFFBQVFrQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0IsT0FBTyxFQUFFLGNBQWM7UUFBRWpCLE9BQU87SUFBSztJQUNuRUgsT0FBT3NCLE1BQU0sQ0FBQ3BCLFFBQVFrQixPQUFPLEVBQUVsQjtJQUMvQnFCLE9BQU9yQixPQUFPLEdBQUdBLFFBQVFrQixPQUFPO0FBQ2xDLEVBRUEsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanM/ZTJkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZExvY2FsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkTG9jYWxlO1xuICAgIH1cbn0pO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBhZGRMb2NhbGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtbG9jYWxlXCIpLmFkZExvY2FsZShwYXRoLCAuLi5hcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYWRkTG9jYWxlIiwiX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2giLCJyZXF1aXJlIiwicGF0aCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywwQkFBMEJDLG1CQUFPQSxDQUFDLG1IQUE0QjtBQUNwRSxNQUFNQyxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNKLGdCQUFnQk8sSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsYUFBYTtJQUN6RCxJQUFJTixLQUErQixFQUFFLEVBV3BDLE1BQU07UUFDSCxPQUFPO0lBQ1g7QUFDSjtBQUVBLElBQUksQ0FBQyxPQUFPUixRQUFRMkIsT0FBTyxLQUFLLGNBQWUsT0FBTzNCLFFBQVEyQixPQUFPLEtBQUssWUFBWTNCLFFBQVEyQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU8zQixRQUFRMkIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzlCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTJCLE9BQU8sRUFBRSxjQUFjO1FBQUUxQixPQUFPO0lBQUs7SUFDbkVILE9BQU8rQixNQUFNLENBQUM3QixRQUFRMkIsT0FBTyxFQUFFM0I7SUFDL0I4QixPQUFPOUIsT0FBTyxHQUFHQSxRQUFRMkIsT0FBTztBQUNsQyxFQUVBLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcz81YzI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RG9tYWluTG9jYWxlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXREb21haW5Mb2NhbGU7XG4gICAgfVxufSk7XG5jb25zdCBfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIikubm9ybWFsaXplTG9jYWxlUGF0aDtcbiAgICAgICAgY29uc3QgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4vZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIikuZGV0ZWN0RG9tYWluTG9jYWxlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhbGUgfHwgbm9ybWFsaXplTG9jYWxlUGF0aChwYXRoLCBsb2NhbGVzKS5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgY29uc3QgZG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBcImh0dHBcIiArIChkb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiO1xuICAgICAgICAgICAgY29uc3QgZmluYWxMb2NhbGUgPSB0YXJnZXQgPT09IGRvbWFpbi5kZWZhdWx0TG9jYWxlID8gXCJcIiA6IFwiL1wiICsgdGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBwcm90byArIGRvbWFpbi5kb21haW4gKyAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKFwiXCIgKyBiYXNlUGF0aCArIGZpbmFsTG9jYWxlICsgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1kb21haW4tbG9jYWxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJnZXREb21haW5Mb2NhbGUiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsInJlcXVpcmUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJ0YXJnZXQiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsInVuZGVmaW5lZCIsInByb3RvIiwiaHR0cCIsImZpbmFsTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"};\nif (typeof window === \"undefined\") {\n    globalThis.__NEXT_IMAGE_IMPORTED = true;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== \"empty\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, \"http://n\").searchParams.get(\"url\") || src;\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!img.getAttribute(\"sizes\") || img.getAttribute(\"sizes\") === \"100vw\")) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            const widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    const [majorStr, minorStr] = _react.version.split(\".\", 2);\n    const major = parseInt(majorStr, 10);\n    const minor = parseInt(minorStr, 10);\n    if (major > 18 || major === 18 && minor >= 3) {\n        // In React 18.3.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, onLoad, onError, ...rest } = param;\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: (0, _react.useCallback)((img)=>{\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!src) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n            }\n        }, [\n            src,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            forwardedRef\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== \"empty\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: \"image\",\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHlDQUF3QztJQUNwQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLDRCQUE0QkQsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxNQUFNRyxTQUFTLFdBQVcsR0FBR0YsMEJBQTBCRyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLG1GQUFPO0FBQ3hFLE1BQU1LLFlBQVksV0FBVyxHQUFHTix5QkFBeUJLLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsMkZBQVc7QUFDOUUsTUFBTU0sUUFBUSxXQUFXLEdBQUdQLHlCQUF5QkssQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDbkYsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsNkdBQTZCO0FBQzFELE1BQU1RLGVBQWVSLG1CQUFPQSxDQUFDLDJHQUE0QjtBQUN6RCxNQUFNUyxtQ0FBbUNULG1CQUFPQSxDQUFDLHlKQUFtRDtBQUNwRyxNQUFNVSxZQUFZVixtQkFBT0EsQ0FBQyxpSEFBK0I7QUFDekQsTUFBTVcsOEJBQThCWCxtQkFBT0EsQ0FBQyw2SUFBNkM7QUFDekYsTUFBTVksZUFBZSxXQUFXLEdBQUdiLHlCQUF5QkssQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQyxrSEFBbUM7QUFDekcsNENBQTRDO0FBQzVDLE1BQU1hLFlBQVlDLDRPQUE2QjtBQUMvQyxJQUFJLE9BQU9HLFdBQVcsYUFBYTtJQUMvQkMsV0FBV0MscUJBQXFCLEdBQUc7QUFDdkM7QUFDQSwwRUFBMEU7QUFDMUUsaURB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LFlBQVlwSCxRQUFRb0gsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPcEgsUUFBUW9ILE9BQU8sQ0FBQ21DLFVBQVUsS0FBSyxhQUFhO0lBQ3JLekosT0FBT0MsY0FBYyxDQUFDQyxRQUFRb0gsT0FBTyxFQUFFLGNBQWM7UUFBRW5ILE9BQU87SUFBSztJQUNuRUgsT0FBTzBKLE1BQU0sQ0FBQ3hKLFFBQVFvSCxPQUFPLEVBQUVwSDtJQUMvQnlKLE9BQU96SixPQUFPLEdBQUdBLFFBQVFvSCxPQUFPO0FBQ2xDLEVBRUEsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcz9hYzQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltYWdlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBJbWFnZTtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfanN4cnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfcmVhY3Rkb20gPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xuY29uc3QgX2hlYWQgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWRcIikpO1xuY29uc3QgX2dldGltZ3Byb3BzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wc1wiKTtcbmNvbnN0IF9pbWFnZWNvbmZpZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZ1wiKTtcbmNvbnN0IF9pbWFnZWNvbmZpZ2NvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfd2Fybm9uY2UgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlscy93YXJuLW9uY2VcIik7XG5jb25zdCBfcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9pbWFnZWxvYWRlciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIm5leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWxvYWRlclwiKSk7XG4vLyBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgZGVmaW5lIHBsdWdpblxuY29uc3QgY29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFM7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGdsb2JhbFRoaXMuX19ORVhUX0lNQUdFX0lNUE9SVEVEID0gdHJ1ZTtcbn1cbi8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzk3Nzc4MzMvMjY2NTM1IGZvciB3aHkgd2UgdXNlIHRoaXMgcmVmXG4vLyBoYW5kbGVyIGluc3RlYWQgb2YgdGhlIGltZydzIG9uTG9hZCBhdHRyaWJ1dGUuXG5mdW5jdGlvbiBoYW5kbGVMb2FkaW5nKGltZywgcGxhY2Vob2xkZXIsIG9uTG9hZFJlZiwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSwgdW5vcHRpbWl6ZWQpIHtcbiAgICBjb25zdCBzcmMgPSBpbWcgPT0gbnVsbCA/IHZvaWQgMCA6IGltZy5zcmM7XG4gICAgaWYgKCFpbWcgfHwgaW1nW1wiZGF0YS1sb2FkZWQtc3JjXCJdID09PSBzcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbWdbXCJkYXRhLWxvYWRlZC1zcmNcIl0gPSBzcmM7XG4gICAgY29uc3QgcCA9IFwiZGVjb2RlXCIgaW4gaW1nID8gaW1nLmRlY29kZSgpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgcC5jYXRjaCgoKT0+e30pLnRoZW4oKCk9PntcbiAgICAgICAgaWYgKCFpbWcucGFyZW50RWxlbWVudCB8fCAhaW1nLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGluIGNhc2Ugb2YgcmFjZSBjb25kaXRpb246XG4gICAgICAgICAgICAvLyAtIG9ubG9hZCgpIGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBpcyBjYWxsZWQgYnV0IGluY29tcGxldGVcbiAgICAgICAgICAgIC8vIC0gdW5tb3VudCBpcyBjYWxsZWRcbiAgICAgICAgICAgIC8vIC0gZGVjb2RlKCkgY29tcGxldGVzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyICE9PSBcImVtcHR5XCIpIHtcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkUmVmID09IG51bGwgPyB2b2lkIDAgOiBvbkxvYWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3QgaGF2ZSB0aGUgU3ludGhldGljRXZlbnQgaGVyZSxcbiAgICAgICAgICAgIC8vIHdlIG11c3QgY3JlYXRlIG9uZSB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ldmVudHMuaHRtbFxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoXCJsb2FkXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCBcInRhcmdldFwiLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG9uTG9hZFJlZi5jdXJyZW50KHtcbiAgICAgICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogaW1nLFxuICAgICAgICAgICAgICAgIHRhcmdldDogaW1nLFxuICAgICAgICAgICAgICAgIGlzRGVmYXVsdFByZXZlbnRlZDogKCk9PnByZXZlbnRlZCxcbiAgICAgICAgICAgICAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogKCk9PnN0b3BwZWQsXG4gICAgICAgICAgICAgICAgcGVyc2lzdDogKCk9Pnt9LFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiAoKT0+e1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAoKT0+e1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlUmVmID09IG51bGwgPyB2b2lkIDAgOiBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KGltZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ1NyYyA9IG5ldyBVUkwoc3JjLCBcImh0dHA6Ly9uXCIpLnNlYXJjaFBhcmFtcy5nZXQoXCJ1cmxcIikgfHwgc3JjO1xuICAgICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5pbWdcIikgPT09IFwiZmlsbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bm9wdGltaXplZCAmJiAoIWltZy5nZXRBdHRyaWJ1dGUoXCJzaXplc1wiKSB8fCBpbWcuZ2V0QXR0cmlidXRlKFwic2l6ZXNcIikgPT09IFwiMTAwdndcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoVmlld3BvcnRSYXRpbyA9IGltZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGhWaWV3cG9ydFJhdGlvIDwgMC42KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgb3JpZ1NyYyArICdcIiBoYXMgXCJmaWxsXCIgYnV0IGlzIG1pc3NpbmcgXCJzaXplc1wiIHByb3AuIFBsZWFzZSBhZGQgaXQgdG8gaW1wcm92ZSBwYWdlIHBlcmZvcm1hbmNlLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNzaXplcycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWcucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbWcucGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaXhlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWxhdGl2ZVwiXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQuaW5jbHVkZXMocG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgb3JpZ1NyYyArICdcIiBoYXMgXCJmaWxsXCIgYW5kIHBhcmVudCBlbGVtZW50IHdpdGggaW52YWxpZCBcInBvc2l0aW9uXCIuIFByb3ZpZGVkIFwiJyArIHBvc2l0aW9uICsgJ1wiIHNob3VsZCBiZSBvbmUgb2YgJyArIHZhbGlkLm1hcChTdHJpbmcpLmpvaW4oXCIsXCIpICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWcuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBvcmlnU3JjICsgJ1wiIGhhcyBcImZpbGxcIiBhbmQgYSBoZWlnaHQgdmFsdWUgb2YgMC4gVGhpcyBpcyBsaWtlbHkgYmVjYXVzZSB0aGUgcGFyZW50IGVsZW1lbnQgb2YgdGhlIGltYWdlIGhhcyBub3QgYmVlbiBzdHlsZWQgdG8gaGF2ZSBhIHNldCBoZWlnaHQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0TW9kaWZpZWQgPSBpbWcuaGVpZ2h0LnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIik7XG4gICAgICAgICAgICBjb25zdCB3aWR0aE1vZGlmaWVkID0gaW1nLndpZHRoLnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKTtcbiAgICAgICAgICAgIGlmIChoZWlnaHRNb2RpZmllZCAmJiAhd2lkdGhNb2RpZmllZCB8fCAhaGVpZ2h0TW9kaWZpZWQgJiYgd2lkdGhNb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBvcmlnU3JjICsgJ1wiIGhhcyBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IG1vZGlmaWVkLCBidXQgbm90IHRoZSBvdGhlci4gSWYgeW91IHVzZSBDU1MgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHlvdXIgaW1hZ2UsIGFsc28gaW5jbHVkZSB0aGUgc3R5bGVzIFxcJ3dpZHRoOiBcImF1dG9cIlxcJyBvciBcXCdoZWlnaHQ6IFwiYXV0b1wiXFwnIHRvIG1haW50YWluIHRoZSBhc3BlY3QgcmF0aW8uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldER5bmFtaWNQcm9wcyhmZXRjaFByaW9yaXR5KSB7XG4gICAgY29uc3QgW21ham9yU3RyLCBtaW5vclN0cl0gPSBfcmVhY3QudmVyc2lvbi5zcGxpdChcIi5cIiwgMik7XG4gICAgY29uc3QgbWFqb3IgPSBwYXJzZUludChtYWpvclN0ciwgMTApO1xuICAgIGNvbnN0IG1pbm9yID0gcGFyc2VJbnQobWlub3JTdHIsIDEwKTtcbiAgICBpZiAobWFqb3IgPiAxOCB8fCBtYWpvciA9PT0gMTggJiYgbWlub3IgPj0gMykge1xuICAgICAgICAvLyBJbiBSZWFjdCAxOC4zLjAgb3IgbmV3ZXIsIHdlIG11c3QgdXNlIGNhbWVsQ2FzZVxuICAgICAgICAvLyBwcm9wIHRvIGF2b2lkIFwiV2FybmluZzogSW52YWxpZCBET00gcHJvcGVydHlcIi5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI1OTI3XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmZXRjaFByaW9yaXR5XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEluIFJlYWN0IDE4LjIuMCBvciBvbGRlciwgd2UgbXVzdCB1c2UgbG93ZXJjYXNlIHByb3BcbiAgICAvLyB0byBhdm9pZCBcIldhcm5pbmc6IEludmFsaWQgRE9NIHByb3BlcnR5XCIuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmV0Y2hwcmlvcml0eTogZmV0Y2hQcmlvcml0eVxuICAgIH07XG59XG5jb25zdCBJbWFnZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovICgwLCBfcmVhY3QuZm9yd2FyZFJlZikoKHBhcmFtLCBmb3J3YXJkZWRSZWYpPT57XG4gICAgbGV0IHsgc3JjLCBzcmNTZXQsIHNpemVzLCBoZWlnaHQsIHdpZHRoLCBkZWNvZGluZywgY2xhc3NOYW1lLCBzdHlsZSwgZmV0Y2hQcmlvcml0eSwgcGxhY2Vob2xkZXIsIGxvYWRpbmcsIHVub3B0aW1pemVkLCBmaWxsLCBvbkxvYWRSZWYsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUsIHNldFNob3dBbHRUZXh0LCBvbkxvYWQsIG9uRXJyb3IsIC4uLnJlc3QgfSA9IHBhcmFtO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwiaW1nXCIsIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgLi4uZ2V0RHluYW1pY1Byb3BzKGZldGNoUHJpb3JpdHkpLFxuICAgICAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYGxvYWRpbmdgIGJlZm9yZSBgc3JjYCBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gcHJvcHMgaW4gb3JkZXIgd2hpY2ggY2F1c2VzIFNhZmFyaS9GaXJlZm94IHRvIG5vdCBsYXp5IGxvYWQgcHJvcGVybHkuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzI1ODgzXG4gICAgICAgIGxvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGRlY29kaW5nOiBkZWNvZGluZyxcbiAgICAgICAgXCJkYXRhLW5pbWdcIjogZmlsbCA/IFwiZmlsbFwiIDogXCIxXCIsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgICAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgICAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAgICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgICAgIHNpemVzOiBzaXplcyxcbiAgICAgICAgc3JjU2V0OiBzcmNTZXQsXG4gICAgICAgIHNyYzogc3JjLFxuICAgICAgICByZWY6ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKChpbWcpPT57XG4gICAgICAgICAgICBpZiAoZm9yd2FyZGVkUmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3J3YXJkZWRSZWYgPT09IFwiZnVuY3Rpb25cIikgZm9yd2FyZGVkUmVmKGltZyk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gLmN1cnJlbnQgaXMgcmVhZCBvbmx5IGl0J3MgdXN1YWxseSBhc3NpZ25lZCBieSByZWFjdCBpbnRlcm5hbGx5XG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmRlZFJlZi5jdXJyZW50ID0gaW1nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW1nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW1hZ2UgaGFzIGFuIGVycm9yIGJlZm9yZSByZWFjdCBoeWRyYXRlcywgdGhlbiB0aGUgZXJyb3IgaXMgbG9zdC5cbiAgICAgICAgICAgICAgICAvLyBUaGUgd29ya2Fyb3VuZCBpcyB0byB3YWl0IHVudGlsIHRoZSBpbWFnZSBpcyBtb3VudGVkIHdoaWNoIGlzIGFmdGVyIGh5ZHJhdGlvbixcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIHNldCB0aGUgc3JjIGFnYWluIHRvIHRyaWdnZXIgdGhlIGVycm9yIGhhbmRsZXIgKGlmIHRoZXJlIHdhcyBhbiBlcnJvcikuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IGltZy5zcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5OicsIGltZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWcuZ2V0QXR0cmlidXRlKFwiYWx0XCIpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ltYWdlIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJhbHRcIiBwcm9wZXJ0eS4gUGxlYXNlIGFkZCBBbHRlcm5hdGl2ZSBUZXh0IHRvIGRlc2NyaWJlIHRoZSBpbWFnZSBmb3Igc2NyZWVuIHJlYWRlcnMgYW5kIHNlYXJjaCBlbmdpbmVzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbWcuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVMb2FkaW5nKGltZywgcGxhY2Vob2xkZXIsIG9uTG9hZFJlZiwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSwgdW5vcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgIG9uTG9hZFJlZixcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlLFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICAgICAgZm9yd2FyZGVkUmVmXG4gICAgICAgIF0pLFxuICAgICAgICBvbkxvYWQ6IChldmVudCk9PntcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBoYW5kbGVMb2FkaW5nKGltZywgcGxhY2Vob2xkZXIsIG9uTG9hZFJlZiwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSwgdW5vcHRpbWl6ZWQpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAoZXZlbnQpPT57XG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVhbCBpbWFnZSBmYWlscyB0byBsb2FkLCB0aGlzIHdpbGwgZW5zdXJlIFwiYWx0XCIgaXMgdmlzaWJsZVxuICAgICAgICAgICAgc2V0U2hvd0FsdFRleHQodHJ1ZSk7XG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT09IFwiZW1wdHlcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBzdGlsbCByZW1vdmUgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuZnVuY3Rpb24gSW1hZ2VQcmVsb2FkKHBhcmFtKSB7XG4gICAgbGV0IHsgaXNBcHBSb3V0ZXIsIGltZ0F0dHJpYnV0ZXMgfSA9IHBhcmFtO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGFzOiBcImltYWdlXCIsXG4gICAgICAgIGltYWdlU3JjU2V0OiBpbWdBdHRyaWJ1dGVzLnNyY1NldCxcbiAgICAgICAgaW1hZ2VTaXplczogaW1nQXR0cmlidXRlcy5zaXplcyxcbiAgICAgICAgY3Jvc3NPcmlnaW46IGltZ0F0dHJpYnV0ZXMuY3Jvc3NPcmlnaW4sXG4gICAgICAgIHJlZmVycmVyUG9saWN5OiBpbWdBdHRyaWJ1dGVzLnJlZmVycmVyUG9saWN5LFxuICAgICAgICAuLi5nZXREeW5hbWljUHJvcHMoaW1nQXR0cmlidXRlcy5mZXRjaFByaW9yaXR5KVxuICAgIH07XG4gICAgaWYgKGlzQXBwUm91dGVyICYmIF9yZWFjdGRvbS5kZWZhdWx0LnByZWxvYWQpIHtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2OTQwXG4gICAgICAgIF9yZWFjdGRvbS5kZWZhdWx0LnByZWxvYWQoaW1nQXR0cmlidXRlcy5zcmMsIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogdXBncmFkZSB0byBgQHR5cGVzL3JlYWN0LWRvbUAxOC4zLnhgXG4gICAgICAgIG9wdHMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2hlYWQuZGVmYXVsdCwge1xuICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShcImxpbmtcIiwge1xuICAgICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICAgIC8vIE5vdGUgaG93IHdlIG9taXQgdGhlIGBocmVmYCBhdHRyaWJ1dGUsIGFzIGl0IHdvdWxkIG9ubHkgYmUgcmVsZXZhbnRcbiAgICAgICAgICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xuICAgICAgICAgICAgLy8gaXQgd291bGQgY2F1c2UgdGhlIGluY29ycmVjdCBpbWFnZSB0byBiZSBwcmVsb2FkZWQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjYXR0ci1saW5rLWltYWdlc3Jjc2V0XG4gICAgICAgICAgICBocmVmOiBpbWdBdHRyaWJ1dGVzLnNyY1NldCA/IHVuZGVmaW5lZCA6IGltZ0F0dHJpYnV0ZXMuc3JjLFxuICAgICAgICAgICAgLi4ub3B0c1xuICAgICAgICB9LCBcIl9fbmltZy1cIiArIGltZ0F0dHJpYnV0ZXMuc3JjICsgaW1nQXR0cmlidXRlcy5zcmNTZXQgKyBpbWdBdHRyaWJ1dGVzLnNpemVzKVxuICAgIH0pO1xufVxuY29uc3QgSW1hZ2UgPSAvKiNfX1BVUkVfXyovICgwLCBfcmVhY3QuZm9yd2FyZFJlZikoKHByb3BzLCBmb3J3YXJkZWRSZWYpPT57XG4gICAgY29uc3QgcGFnZXNSb3V0ZXIgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5Sb3V0ZXJDb250ZXh0KTtcbiAgICAvLyBXZSdyZSBpbiB0aGUgYXBwIGRpcmVjdG9yeSBpZiB0aGVyZSBpcyBubyBwYWdlcyByb3V0ZXIuXG4gICAgY29uc3QgaXNBcHBSb3V0ZXIgPSAhcGFnZXNSb3V0ZXI7XG4gICAgY29uc3QgY29uZmlnQ29udGV4dCA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2ltYWdlY29uZmlnY29udGV4dHNoYXJlZHJ1bnRpbWUuSW1hZ2VDb25maWdDb250ZXh0KTtcbiAgICBjb25zdCBjb25maWcgPSAoMCwgX3JlYWN0LnVzZU1lbW8pKCgpPT57XG4gICAgICAgIGNvbnN0IGMgPSBjb25maWdFbnYgfHwgY29uZmlnQ29udGV4dCB8fCBfaW1hZ2Vjb25maWcuaW1hZ2VDb25maWdEZWZhdWx0O1xuICAgICAgICBjb25zdCBhbGxTaXplcyA9IFtcbiAgICAgICAgICAgIC4uLmMuZGV2aWNlU2l6ZXMsXG4gICAgICAgICAgICAuLi5jLmltYWdlU2l6ZXNcbiAgICAgICAgXS5zb3J0KChhLCBiKT0+YSAtIGIpO1xuICAgICAgICBjb25zdCBkZXZpY2VTaXplcyA9IGMuZGV2aWNlU2l6ZXMuc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICBhbGxTaXplcyxcbiAgICAgICAgICAgIGRldmljZVNpemVzXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjb25maWdDb250ZXh0XG4gICAgXSk7XG4gICAgY29uc3QgeyBvbkxvYWQsIG9uTG9hZGluZ0NvbXBsZXRlIH0gPSBwcm9wcztcbiAgICBjb25zdCBvbkxvYWRSZWYgPSAoMCwgX3JlYWN0LnVzZVJlZikob25Mb2FkKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgb25Mb2FkUmVmLmN1cnJlbnQgPSBvbkxvYWQ7XG4gICAgfSwgW1xuICAgICAgICBvbkxvYWRcbiAgICBdKTtcbiAgICBjb25zdCBvbkxvYWRpbmdDb21wbGV0ZVJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShvbkxvYWRpbmdDb21wbGV0ZSk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQgPSBvbkxvYWRpbmdDb21wbGV0ZTtcbiAgICB9LCBbXG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlXG4gICAgXSk7XG4gICAgY29uc3QgW2JsdXJDb21wbGV0ZSwgc2V0Qmx1ckNvbXBsZXRlXSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBbc2hvd0FsdFRleHQsIHNldFNob3dBbHRUZXh0XSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCB7IHByb3BzOiBpbWdBdHRyaWJ1dGVzLCBtZXRhOiBpbWdNZXRhIH0gPSAoMCwgX2dldGltZ3Byb3BzLmdldEltZ1Byb3BzKShwcm9wcywge1xuICAgICAgICBkZWZhdWx0TG9hZGVyOiBfaW1hZ2Vsb2FkZXIuZGVmYXVsdCxcbiAgICAgICAgaW1nQ29uZjogY29uZmlnLFxuICAgICAgICBibHVyQ29tcGxldGUsXG4gICAgICAgIHNob3dBbHRUZXh0XG4gICAgfSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeHMpKF9qc3hydW50aW1lLkZyYWdtZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKEltYWdlRWxlbWVudCwge1xuICAgICAgICAgICAgICAgIC4uLmltZ0F0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgdW5vcHRpbWl6ZWQ6IGltZ01ldGEudW5vcHRpbWl6ZWQsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGltZ01ldGEucGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgZmlsbDogaW1nTWV0YS5maWxsLFxuICAgICAgICAgICAgICAgIG9uTG9hZFJlZjogb25Mb2FkUmVmLFxuICAgICAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmOiBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgICAgICAgICBzZXRCbHVyQ29tcGxldGU6IHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgICAgICAgICBzZXRTaG93QWx0VGV4dDogc2V0U2hvd0FsdFRleHQsXG4gICAgICAgICAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWZcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW1nTWV0YS5wcmlvcml0eSA/IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoSW1hZ2VQcmVsb2FkLCB7XG4gICAgICAgICAgICAgICAgaXNBcHBSb3V0ZXI6IGlzQXBwUm91dGVyLFxuICAgICAgICAgICAgICAgIGltZ0F0dHJpYnV0ZXM6IGltZ0F0dHJpYnV0ZXNcbiAgICAgICAgICAgIH0pIDogbnVsbFxuICAgICAgICBdXG4gICAgfSk7XG59KTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtY29tcG9uZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJJbWFnZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX2pzeHJ1bnRpbWUiLCJfcmVhY3QiLCJfIiwiX3JlYWN0ZG9tIiwiX2hlYWQiLCJfZ2V0aW1ncHJvcHMiLCJfaW1hZ2Vjb25maWciLCJfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZSIsIl93YXJub25jZSIsIl9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9pbWFnZWxvYWRlciIsImNvbmZpZ0VudiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSU1BR0VfT1BUUyIsIndpbmRvdyIsImdsb2JhbFRoaXMiLCJfX05FWFRfSU1BR0VfSU1QT1JURUQiLCJoYW5kbGVMb2FkaW5nIiwiaW1nIiwicGxhY2Vob2xkZXIiLCJvbkxvYWRSZWYiLCJvbkxvYWRpbmdDb21wbGV0ZVJlZiIsInNldEJsdXJDb21wbGV0ZSIsInVub3B0aW1pemVkIiwic3JjIiwicCIsImRlY29kZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2F0Y2giLCJ0aGVuIiwicGFyZW50RWxlbWVudCIsImlzQ29ubmVjdGVkIiwiY3VycmVudCIsImV2ZW50IiwiRXZlbnQiLCJ3cml0YWJsZSIsInByZXZlbnRlZCIsInN0b3BwZWQiLCJuYXRpdmVFdmVudCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsInBlcnNpc3QiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIm9yaWdTcmMiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJnZXRBdHRyaWJ1dGUiLCJ3aWR0aFZpZXdwb3J0UmF0aW8iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImlubmVyV2lkdGgiLCJ3YXJuT25jZSIsInBvc2l0aW9uIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZhbGlkIiwiaW5jbHVkZXMiLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiaGVpZ2h0IiwiaGVpZ2h0TW9kaWZpZWQiLCJ0b1N0cmluZyIsIndpZHRoTW9kaWZpZWQiLCJnZXREeW5hbWljUHJvcHMiLCJmZXRjaFByaW9yaXR5IiwibWFqb3JTdHIiLCJtaW5vclN0ciIsInZlcnNpb24iLCJzcGxpdCIsIm1ham9yIiwicGFyc2VJbnQiLCJtaW5vciIsImZldGNocHJpb3JpdHkiLCJJbWFnZUVsZW1lbnQiLCJmb3J3YXJkUmVmIiwicGFyYW0iLCJmb3J3YXJkZWRSZWYiLCJzcmNTZXQiLCJzaXplcyIsImRlY29kaW5nIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJsb2FkaW5nIiwiZmlsbCIsInNldFNob3dBbHRUZXh0Iiwib25Mb2FkIiwib25FcnJvciIsInJlc3QiLCJqc3giLCJyZWYiLCJ1c2VDYWxsYmFjayIsImNvbnNvbGUiLCJlcnJvciIsImNvbXBsZXRlIiwiSW1hZ2VQcmVsb2FkIiwiaXNBcHBSb3V0ZXIiLCJpbWdBdHRyaWJ1dGVzIiwib3B0cyIsImFzIiwiaW1hZ2VTcmNTZXQiLCJpbWFnZVNpemVzIiwiY3Jvc3NPcmlnaW4iLCJyZWZlcnJlclBvbGljeSIsImRlZmF1bHQiLCJwcmVsb2FkIiwiY2hpbGRyZW4iLCJyZWwiLCJocmVmIiwidW5kZWZpbmVkIiwicHJvcHMiLCJwYWdlc1JvdXRlciIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiY29uZmlnQ29udGV4dCIsIkltYWdlQ29uZmlnQ29udGV4dCIsImNvbmZpZyIsInVzZU1lbW8iLCJjIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiYWxsU2l6ZXMiLCJkZXZpY2VTaXplcyIsInNvcnQiLCJhIiwiYiIsIm9uTG9hZGluZ0NvbXBsZXRlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiYmx1ckNvbXBsZXRlIiwidXNlU3RhdGUiLCJzaG93QWx0VGV4dCIsIm1ldGEiLCJpbWdNZXRhIiwiZ2V0SW1nUHJvcHMiLCJkZWZhdWx0TG9hZGVyIiwiaW1nQ29uZiIsImpzeHMiLCJGcmFnbWVudCIsInByaW9yaXR5IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (typeof window === \"undefined\") {\n        return;\n    }\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    const prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options);\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(prefetchPromise).catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browser’s default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const pagesRouter = _react.default.useContext(_routercontextsharedruntime.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + (typeof window !== \"undefined\" ? \"\\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + (typeof window !== \"undefined\" ? \" \\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n        ...restProps,\n        ...childProps,\n        children: children\n    });\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMscUdBQW1CO0FBQy9DLE1BQU1FLFNBQVMsV0FBVyxHQUFHSCx5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsbUZBQU87QUFDdkUsTUFBTUksZUFBZUosbUJBQU9BLENBQUMsMkZBQWdCO0FBQzdDLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLHFJQUF5QztBQUNyRSxNQUFNTSxhQUFhTixtQkFBT0EsQ0FBQyxpSUFBdUM7QUFDbEUsTUFBTU8sU0FBU1AsbUJBQU9BLENBQUMsNkZBQXFCO0FBQzVDLE1BQU1RLGFBQWFSLG1CQUFPQSxDQUFDLHVGQUFjO0FBQ3pDLE1BQU1TLDhCQUE4QlQsbUJBQU9BLENBQUMsNklBQTZDO0FBQ3pGLE1BQU1VLGlDQUFpQ1YsbUJBQU9BLENBQUMscUpBQWlEO0FBQ2hHLE1BQU1XLG1CQUFtQlgsbUJBQU9BLENBQUMsbUdBQW9CO0FBQ3JELE1BQU1ZLG1CQUFtQlosbUJBQU9BLENBQUMscUdBQXFCO0FBQ3RELE1BQU1hLGVBQWViLG1CQUFPQSxDQUFDLDZGQUFpQjtBQUM5QyxNQUFNYyxzQkFBc0JkLG1CQUFPQSxDQUFDLCtKQUFrRDtBQUN0RixNQUFNZSxhQUFhLElBQUlDO0FBQ3ZCLFNBQVNDLFNBQVNDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQ2hFLElBQUksT0FBT0MsV0FBVyxhQUFhO1FBQy9CO0lB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T0FBT0MsY0FBYyxDQUFDQyxRQUFRbUUsT0FBTyxFQUFFLGNBQWM7UUFBRWxFLE9BQU87SUFBSztJQUNuRUgsT0FBT3FLLE1BQU0sQ0FBQ25LLFFBQVFtRSxPQUFPLEVBQUVuRTtJQUMvQm9LLE9BQU9wSyxPQUFPLEdBQUdBLFFBQVFtRSxPQUFPO0FBQ2xDLEVBRUEsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanM/ZTRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfanN4cnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9yZXNvbHZlaHJlZiA9IHJlcXVpcmUoXCIuL3Jlc29sdmUtaHJlZlwiKTtcbmNvbnN0IF9pc2xvY2FsdXJsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybFwiKTtcbmNvbnN0IF9mb3JtYXR1cmwgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybFwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xuY29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmUoXCIuL2FkZC1sb2NhbGVcIik7XG5jb25zdCBfcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF91c2VpbnRlcnNlY3Rpb24gPSByZXF1aXJlKFwiLi91c2UtaW50ZXJzZWN0aW9uXCIpO1xuY29uc3QgX2dldGRvbWFpbmxvY2FsZSA9IHJlcXVpcmUoXCIuL2dldC1kb21haW4tbG9jYWxlXCIpO1xuY29uc3QgX2FkZGJhc2VwYXRoID0gcmVxdWlyZShcIi4vYWRkLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9yb3V0ZXJyZWR1Y2VydHlwZXMgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzXCIpO1xuY29uc3QgcHJlZmV0Y2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIG9wdGlvbnMsIGFwcE9wdGlvbnMsIGlzQXBwUm91dGVyKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhcHAtcm91dGVyIHN1cHBvcnRzIGV4dGVybmFsIHVybHMgb3V0IG9mIHRoZSBib3ggc28gaXQgc2hvdWxkbid0IHNob3J0LWNpcmN1aXQgaGVyZSBhcyBzdXBwb3J0IGZvciBlLmcuIGByZXBsYWNlYCBpcyBhZGRlZCBpbiB0aGUgYXBwLXJvdXRlci5cbiAgICBpZiAoIWlzQXBwUm91dGVyICYmICEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoaHJlZikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXZSBzaG91bGQgb25seSBkZWR1cGUgcmVxdWVzdHMgd2hlbiBleHBlcmltZW50YWwub3B0aW1pc3RpY0NsaWVudENhY2hlIGlzXG4gICAgLy8gZGlzYWJsZWQuXG4gICAgaWYgKCFvcHRpb25zLmJ5cGFzc1ByZWZldGNoZWRDaGVjaykge1xuICAgICAgICBjb25zdCBsb2NhbGUgPSAvLyBMZXQgdGhlIGxpbmsncyBsb2NhbGUgcHJvcCBvdmVycmlkZSB0aGUgZGVmYXVsdCByb3V0ZXIgbG9jYWxlLlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmxvY2FsZSA6IFwibG9jYWxlXCIgaW4gcm91dGVyID8gcm91dGVyLmxvY2FsZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcHJlZmV0Y2hlZEtleSA9IGhyZWYgKyBcIiVcIiArIGFzICsgXCIlXCIgKyBsb2NhbGU7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZmV0Y2hlZCB0aGUga2V5LCB0aGVuIGRvbid0IHByZWZldGNoIGl0IGFnYWluIVxuICAgICAgICBpZiAocHJlZmV0Y2hlZC5oYXMocHJlZmV0Y2hlZEtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXJrIHRoaXMgVVJMIGFzIHByZWZldGNoZWQuXG4gICAgICAgIHByZWZldGNoZWQuYWRkKHByZWZldGNoZWRLZXkpO1xuICAgIH1cbiAgICBjb25zdCBwcmVmZXRjaFByb21pc2UgPSBpc0FwcFJvdXRlciA/IHJvdXRlci5wcmVmZXRjaChocmVmLCBhcHBPcHRpb25zKSA6IHJvdXRlci5wcmVmZXRjaChocmVmLCBhcywgb3B0aW9ucyk7XG4gICAgLy8gUHJlZmV0Y2ggdGhlIEpTT04gcGFnZSBpZiBhc2tlZCAob25seSBpbiB0aGUgY2xpZW50KVxuICAgIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcbiAgICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIGZvcmNlIG5hdmlnYXRpb24gc2luY2UgdGhpcyBpcyBvbmx5IGEgcHJlZmV0Y2hcbiAgICBQcm9taXNlLnJlc29sdmUocHJlZmV0Y2hQcm9taXNlKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7XG4gICAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQgIT09IFwiX3NlbGZcIiB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IC8vIHRyaWdnZXJzIHJlc291cmNlIGRvd25sb2FkXG4gICAgZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDI7XG59XG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSwgaXNBcHBSb3V0ZXIpIHtcbiAgICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgLy8gYW5jaG9ycyBpbnNpZGUgYW4gc3ZnIGhhdmUgYSBsb3dlcmNhc2Ugbm9kZU5hbWVcbiAgICBjb25zdCBpc0FuY2hvck5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJBXCI7XG4gICAgaWYgKGlzQW5jaG9yTm9kZU5hbWUgJiYgKGlzTW9kaWZpZWRFdmVudChlKSB8fCAvLyBhcHAtcm91dGVyIHN1cHBvcnRzIGV4dGVybmFsIHVybHMgb3V0IG9mIHRoZSBib3ggc28gaXQgc2hvdWxkbid0IHNob3J0LWNpcmN1aXQgaGVyZSBhcyBzdXBwb3J0IGZvciBlLmcuIGByZXBsYWNlYCBpcyBhZGRlZCBpbiB0aGUgYXBwLXJvdXRlci5cbiAgICAhaXNBcHBSb3V0ZXIgJiYgISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKShocmVmKSkpIHtcbiAgICAgICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IG5hdmlnYXRlID0gKCk9PntcbiAgICAgICAgLy8gSWYgdGhlIHJvdXRlciBpcyBhbiBOZXh0Um91dGVyIGluc3RhbmNlIGl0IHdpbGwgaGF2ZSBgYmVmb3JlUG9wU3RhdGVgXG4gICAgICAgIGNvbnN0IHJvdXRlclNjcm9sbCA9IHNjcm9sbCAhPSBudWxsID8gc2Nyb2xsIDogdHJ1ZTtcbiAgICAgICAgaWYgKFwiYmVmb3JlUG9wU3RhdGVcIiBpbiByb3V0ZXIpIHtcbiAgICAgICAgICAgIHJvdXRlcltyZXBsYWNlID8gXCJyZXBsYWNlXCIgOiBcInB1c2hcIl0oaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93LFxuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBzY3JvbGw6IHJvdXRlclNjcm9sbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3V0ZXJbcmVwbGFjZSA/IFwicmVwbGFjZVwiIDogXCJwdXNoXCJdKGFzIHx8IGhyZWYsIHtcbiAgICAgICAgICAgICAgICBzY3JvbGw6IHJvdXRlclNjcm9sbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0FwcFJvdXRlcikge1xuICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24obmF2aWdhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5hdmlnYXRlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0U3RyaW5nT3JVcmwodXJsT2JqT3JTdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHVybE9iak9yU3RyaW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB1cmxPYmpPclN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfZm9ybWF0dXJsLmZvcm1hdFVybCkodXJsT2JqT3JTdHJpbmcpO1xufVxuLyoqXG4gKiBSZWFjdCBDb21wb25lbnQgdGhhdCBlbmFibGVzIGNsaWVudC1zaWRlIHRyYW5zaXRpb25zIGJldHdlZW4gcm91dGVzLlxuICovIGNvbnN0IExpbmsgPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24gTGlua0NvbXBvbmVudChwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIGNvbnN0IHsgaHJlZjogaHJlZlByb3AsIGFzOiBhc1Byb3AsIGNoaWxkcmVuOiBjaGlsZHJlblByb3AsIHByZWZldGNoOiBwcmVmZXRjaFByb3AgPSBudWxsLCBwYXNzSHJlZiwgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIG9uQ2xpY2ssIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyUHJvcCwgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnRQcm9wLCBsZWdhY3lCZWhhdmlvciA9IGZhbHNlLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICAgIGNoaWxkcmVuID0gY2hpbGRyZW5Qcm9wO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiAodHlwZW9mIGNoaWxkcmVuID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwiYVwiLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhZ2VzUm91dGVyID0gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuUm91dGVyQ29udGV4dCk7XG4gICAgY29uc3QgYXBwUm91dGVyID0gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuQXBwUm91dGVyQ29udGV4dCk7XG4gICAgY29uc3Qgcm91dGVyID0gcGFnZXNSb3V0ZXIgIT0gbnVsbCA/IHBhZ2VzUm91dGVyIDogYXBwUm91dGVyO1xuICAgIC8vIFdlJ3JlIGluIHRoZSBhcHAgZGlyZWN0b3J5IGlmIHRoZXJlIGlzIG5vIHBhZ2VzIHJvdXRlci5cbiAgICBjb25zdCBpc0FwcFJvdXRlciA9ICFwYWdlc1JvdXRlcjtcbiAgICBjb25zdCBwcmVmZXRjaEVuYWJsZWQgPSBwcmVmZXRjaFByb3AgIT09IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBwb3NzaWJsZSBzdGF0ZXMgZm9yIHByZWZldGNoIGFyZTpcbiAgICAgKiAtIG51bGw6IHRoaXMgaXMgdGhlIGRlZmF1bHQgXCJhdXRvXCIgbW9kZSwgd2hlcmUgd2Ugd2lsbCBwcmVmZXRjaCBwYXJ0aWFsbHkgaWYgdGhlIGxpbmsgaXMgaW4gdGhlIHZpZXdwb3J0XG4gICAgICogLSB0cnVlOiB3ZSB3aWxsIHByZWZldGNoIGlmIHRoZSBsaW5rIGlzIHZpc2libGUgYW5kIHByZWZldGNoIHRoZSBmdWxsIHBhZ2UsIG5vdCBqdXN0IHBhcnRpYWxseVxuICAgICAqIC0gZmFsc2U6IHdlIHdpbGwgbm90IHByZWZldGNoIGlmIGluIHRoZSB2aWV3cG9ydCBhdCBhbGxcbiAgICAgKi8gY29uc3QgYXBwUHJlZmV0Y2hLaW5kID0gcHJlZmV0Y2hQcm9wID09PSBudWxsID8gX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuQVVUTyA6IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkZVTEw7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIGBcIiArIGFyZ3Mua2V5ICsgXCJgIGV4cGVjdHMgYSBcIiArIGFyZ3MuZXhwZWN0ZWQgKyBcIiBpbiBgPExpbms+YCwgYnV0IGdvdCBgXCIgKyBhcmdzLmFjdHVhbCArIFwiYCBpbnN0ZWFkLlwiICsgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wc0d1YXJkID0ge1xuICAgICAgICAgICAgaHJlZjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXF1aXJlZFByb3BzID0gT2JqZWN0LmtleXMocmVxdWlyZWRQcm9wc0d1YXJkKTtcbiAgICAgICAgcmVxdWlyZWRQcm9wcy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImhyZWZcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldID09IG51bGwgfHwgdHlwZW9mIHByb3BzW2tleV0gIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBzdHJpbmdgIG9yIGBvYmplY3RgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHByb3BzW2tleV0gPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBwcm9wc1trZXldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGFzOiB0cnVlLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICAgICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgICAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgbG9jYWxlOiB0cnVlLFxuICAgICAgICAgICAgb25DbGljazogdHJ1ZSxcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydDogdHJ1ZSxcbiAgICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSBPYmplY3Qua2V5cyhvcHRpb25hbFByb3BzR3VhcmQpO1xuICAgICAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiYXNcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09IFwic3RyaW5nXCIgJiYgdmFsVHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYHN0cmluZ2Agb3IgYG9iamVjdGBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJsb2NhbGVcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBzdHJpbmdgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwib25DbGlja1wiIHx8IGtleSA9PT0gXCJvbk1vdXNlRW50ZXJcIiB8fCBrZXkgPT09IFwib25Ub3VjaFN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBmdW5jdGlvbmBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJyZXBsYWNlXCIgfHwga2V5ID09PSBcInNjcm9sbFwiIHx8IGtleSA9PT0gXCJzaGFsbG93XCIgfHwga2V5ID09PSBcInBhc3NIcmVmXCIgfHwga2V5ID09PSBcInByZWZldGNoXCIgfHwga2V5ID09PSBcImxlZ2FjeUJlaGF2aW9yXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgYm9vbGVhbmBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgY29uc3QgaGFzV2FybmVkID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgICAgICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCAmJiAhaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5leHQuanMgYXV0by1wcmVmZXRjaGVzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdmlld3BvcnQuIFRoZSBwcmVmZXRjaCBhdHRyaWJ1dGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gTW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHJlZmV0Y2gtdHJ1ZS1kZXByZWNhdGVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGlzQXBwUm91dGVyICYmICFhc1Byb3ApIHtcbiAgICAgICAgICAgIGxldCBocmVmO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBocmVmUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmUHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhyZWZQcm9wID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBocmVmUHJvcC5wYXRobmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmUHJvcC5wYXRobmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRHluYW1pY1NlZ21lbnQgPSBocmVmLnNwbGl0KFwiL1wiKS5zb21lKChzZWdtZW50KT0+c2VnbWVudC5zdGFydHNXaXRoKFwiW1wiKSAmJiBzZWdtZW50LmVuZHNXaXRoKFwiXVwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgaHJlZiBgXCIgKyBocmVmICsgXCJgIGZvdW5kIGluIDxMaW5rPiB3aGlsZSB1c2luZyB0aGUgYC9hcHBgIHJvdXRlciwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2FwcC1kaXItZHluYW1pYy1ocmVmXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGhyZWYsIGFzIH0gPSBfcmVhY3QuZGVmYXVsdC51c2VNZW1vKCgpPT57XG4gICAgICAgIGlmICghcGFnZXNSb3V0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9IGZvcm1hdFN0cmluZ09yVXJsKGhyZWZQcm9wKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgICAgIGFzOiBhc1Byb3AgPyBmb3JtYXRTdHJpbmdPclVybChhc1Byb3ApIDogcmVzb2x2ZWRIcmVmXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocGFnZXNSb3V0ZXIsIGhyZWZQcm9wLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgIGFzOiBhc1Byb3AgPyAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShwYWdlc1JvdXRlciwgYXNQcm9wKSA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBwYWdlc1JvdXRlcixcbiAgICAgICAgaHJlZlByb3AsXG4gICAgICAgIGFzUHJvcFxuICAgIF0pO1xuICAgIGNvbnN0IHByZXZpb3VzSHJlZiA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihocmVmKTtcbiAgICBjb25zdCBwcmV2aW91c0FzID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGFzKTtcbiAgICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICBsZXQgY2hpbGQ7XG4gICAgaWYgKGxlZ2FjeUJlaGF2aW9yKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignXCJvbkNsaWNrXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBgaHJlZmAgb2YgYCcgKyBocmVmUHJvcCArICdgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbkNsaWNrIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Nb3VzZUVudGVyUHJvcCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignXCJvbk1vdXNlRW50ZXJcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgJyArIGhyZWZQcm9wICsgJ2AgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uTW91c2VFbnRlciBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGluaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBgaHJlZmAgb2YgYFwiICsgaHJlZlByb3AgKyBcImAgYnV0IG9uZSBjaGlsZCBpcyByZXF1aXJlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW5vLWNoaWxkcmVuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBgaHJlZmAgb2YgYFwiICsgaHJlZlByb3AgKyBcImAgYnV0IG9ubHkgb25lIGNoaWxkIGlzIHN1cHBvcnRlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW11bHRpcGxlLWNoaWxkcmVuXCIgKyAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IFwiIFxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hpbGRyZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNoaWxkcmVuLnR5cGUpID09PSBcImFcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgPExpbms+IHdpdGggPGE+IGNoaWxkLiBQbGVhc2UgcmVtb3ZlIDxhPiBvciB1c2UgPExpbmsgbGVnYWN5QmVoYXZpb3I+LlxcbkxlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtbmV3LWxpbmstd2l0aC1leHRyYS1hbmNob3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hpbGRSZWYgPSBsZWdhY3lCZWhhdmlvciA/IGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIiAmJiBjaGlsZC5yZWYgOiBmb3J3YXJkZWRSZWY7XG4gICAgY29uc3QgW3NldEludGVyc2VjdGlvblJlZiwgaXNWaXNpYmxlLCByZXNldFZpc2libGVdID0gKDAsIF91c2VpbnRlcnNlY3Rpb24udXNlSW50ZXJzZWN0aW9uKSh7XG4gICAgICAgIHJvb3RNYXJnaW46IFwiMjAwcHhcIlxuICAgIH0pO1xuICAgIGNvbnN0IHNldFJlZiA9IF9yZWFjdC5kZWZhdWx0LnVzZUNhbGxiYWNrKChlbCk9PntcbiAgICAgICAgLy8gQmVmb3JlIHRoZSBsaW5rIGdldHRpbmcgb2JzZXJ2ZWQsIGNoZWNrIGlmIHZpc2libGUgc3RhdGUgbmVlZCB0byBiZSByZXNldFxuICAgICAgICBpZiAocHJldmlvdXNBcy5jdXJyZW50ICE9PSBhcyB8fCBwcmV2aW91c0hyZWYuY3VycmVudCAhPT0gaHJlZikge1xuICAgICAgICAgICAgcmVzZXRWaXNpYmxlKCk7XG4gICAgICAgICAgICBwcmV2aW91c0FzLmN1cnJlbnQgPSBhcztcbiAgICAgICAgICAgIHByZXZpb3VzSHJlZi5jdXJyZW50ID0gaHJlZjtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWYoZWwpO1xuICAgICAgICBpZiAoY2hpbGRSZWYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09IFwiZnVuY3Rpb25cIikgY2hpbGRSZWYoZWwpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkUmVmID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRSZWYuY3VycmVudCA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBhcyxcbiAgICAgICAgY2hpbGRSZWYsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHJlc2V0VmlzaWJsZSxcbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmXG4gICAgXSk7XG4gICAgLy8gUHJlZmV0Y2ggdGhlIFVSTCBpZiB3ZSBoYXZlbid0IGFscmVhZHkgYW5kIGl0J3MgdmlzaWJsZS5cbiAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgLy8gaW4gZGV2LCB3ZSBvbmx5IHByZWZldGNoIG9uIGhvdmVyIHRvIGF2b2lkIHdhc3RpbmcgcmVzb3VyY2VzIGFzIHRoZSBwcmVmZXRjaCB3aWxsIHRyaWdnZXIgY29tcGlsaW5nIHRoZSBwYWdlLlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBuZWVkIHRvIHByZWZldGNoIHRoZSBVUkwsIGRvbid0IGRvIHByZWZldGNoLlxuICAgICAgICBpZiAoIWlzVmlzaWJsZSB8fCAhcHJlZmV0Y2hFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlZmV0Y2ggdGhlIFVSTC5cbiAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtpbmQ6IGFwcFByZWZldGNoS2luZFxuICAgICAgICB9LCBpc0FwcFJvdXRlcik7XG4gICAgfSwgW1xuICAgICAgICBhcyxcbiAgICAgICAgaHJlZixcbiAgICAgICAgaXNWaXNpYmxlLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIHByZWZldGNoRW5hYmxlZCxcbiAgICAgICAgcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmxvY2FsZSxcbiAgICAgICAgcm91dGVyLFxuICAgICAgICBpc0FwcFJvdXRlcixcbiAgICAgICAgYXBwUHJlZmV0Y2hLaW5kXG4gICAgXSk7XG4gICAgY29uc3QgY2hpbGRQcm9wcyA9IHtcbiAgICAgICAgcmVmOiBzZXRSZWYsXG4gICAgICAgIG9uQ2xpY2sgKGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgcmVuZGVyZWQgaW5zaWRlIG5leHQvbGluayBoYXMgdG8gcGFzcyBjbGljayBldmVudCB0byBcIm9uQ2xpY2tcIiBwcm9wLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uQ2xpY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uQ2xpY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSwgaXNBcHBSb3V0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRW50ZXIgKGUpIHtcbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uTW91c2VFbnRlclByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlclByb3AoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKCFwcmVmZXRjaEVuYWJsZWQgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikgJiYgaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIEBzZWUge2h0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9kaXNjdXNzaW9ucy80MDI2OD9zb3J0PXRvcCNkaXNjdXNzaW9uY29tbWVudC0zNTcyNjQyfVxuICAgICAgICAgICAgICAgIGJ5cGFzc1ByZWZldGNoZWRDaGVjazogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGFwcFByZWZldGNoS2luZFxuICAgICAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBvblRvdWNoU3RhcnQgKGUpIHtcbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uVG91Y2hTdGFydFByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9uVG91Y2hTdGFydFByb3AoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZWZldGNoRW5hYmxlZCAmJiBpc0FwcFJvdXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gQHNlZSB7aHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2Rpc2N1c3Npb25zLzQwMjY4P3NvcnQ9dG9wI2Rpc2N1c3Npb25jb21tZW50LTM1NzI2NDJ9XG4gICAgICAgICAgICAgICAgYnlwYXNzUHJlZmV0Y2hlZENoZWNrOiB0cnVlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2luZDogYXBwUHJlZmV0Y2hLaW5kXG4gICAgICAgICAgICB9LCBpc0FwcFJvdXRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAgIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlci5cbiAgICAvLyBJZiB0aGUgdXJsIGlzIGFic29sdXRlLCB3ZSBjYW4gYnlwYXNzIHRoZSBsb2dpYyB0byBwcmVwZW5kIHRoZSBkb21haW4gYW5kIGxvY2FsZS5cbiAgICBpZiAoKDAsIF91dGlscy5pc0Fic29sdXRlVXJsKShhcykpIHtcbiAgICAgICAgY2hpbGRQcm9wcy5ocmVmID0gYXM7XG4gICAgfSBlbHNlIGlmICghbGVnYWN5QmVoYXZpb3IgfHwgcGFzc0hyZWYgfHwgY2hpbGQudHlwZSA9PT0gXCJhXCIgJiYgIShcImhyZWZcIiBpbiBjaGlsZC5wcm9wcykpIHtcbiAgICAgICAgY29uc3QgY3VyTG9jYWxlID0gdHlwZW9mIGxvY2FsZSAhPT0gXCJ1bmRlZmluZWRcIiA/IGxvY2FsZSA6IHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGU7XG4gICAgICAgIC8vIHdlIG9ubHkgcmVuZGVyIGRvbWFpbiBsb2NhbGVzIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gYSBkb21haW4gbG9jYWxlXG4gICAgICAgIC8vIHNvIHRoYXQgbG9jYWxlIGxpbmtzIGFyZSBzdGlsbCB2aXNpdGFibGUgaW4gZGV2ZWxvcG1lbnQvcHJldmlldyBlbnZzXG4gICAgICAgIGNvbnN0IGxvY2FsZURvbWFpbiA9IChwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuaXNMb2NhbGVEb21haW4pICYmICgwLCBfZ2V0ZG9tYWlubG9jYWxlLmdldERvbWFpbkxvY2FsZSkoYXMsIGN1ckxvY2FsZSwgcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmxvY2FsZXMsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5kb21haW5Mb2NhbGVzKTtcbiAgICAgICAgY2hpbGRQcm9wcy5ocmVmID0gbG9jYWxlRG9tYWluIHx8ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXMsIGN1ckxvY2FsZSwgcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmRlZmF1bHRMb2NhbGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2FjeUJlaGF2aW9yID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpIDogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShcImFcIiwge1xuICAgICAgICAuLi5yZXN0UHJvcHMsXG4gICAgICAgIC4uLmNoaWxkUHJvcHMsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pO1xufSk7XG5jb25zdCBfZGVmYXVsdCA9IExpbms7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmsuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIl9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9qc3hydW50aW1lIiwiX3JlYWN0IiwiXyIsIl9yZXNvbHZlaHJlZiIsIl9pc2xvY2FsdXJsIiwiX2Zvcm1hdHVybCIsIl91dGlscyIsIl9hZGRsb2NhbGUiLCJfcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfdXNlaW50ZXJzZWN0aW9uIiwiX2dldGRvbWFpbmxvY2FsZSIsIl9hZGRiYXNlcGF0aCIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJwcmVmZXRjaGVkIiwiU2V0IiwicHJlZmV0Y2giLCJyb3V0ZXIiLCJocmVmIiwiYXMiLCJvcHRpb25zIiwiYXBwT3B0aW9ucyIsImlzQXBwUm91dGVyIiwid2luZG93IiwiaXNMb2NhbFVSTCIsImJ5cGFzc1ByZWZldGNoZWRDaGVjayIsImxvY2FsZSIsInVuZGVmaW5lZCIsInByZWZldGNoZWRLZXkiLCJoYXMiLCJhZGQiLCJwcmVmZXRjaFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwiZXJyIiwicHJvY2VzcyIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiZXZlbnRUYXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwibWV0YUtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsIm5hdGl2ZUV2ZW50Iiwid2hpY2giLCJsaW5rQ2xpY2tlZCIsImUiLCJyZXBsYWNlIiwic2hhbGxvdyIsInNjcm9sbCIsIm5vZGVOYW1lIiwiaXNBbmNob3JOb2RlTmFtZSIsInRvVXBwZXJDYXNlIiwicHJldmVudERlZmF1bHQiLCJuYXZpZ2F0ZSIsInJvdXRlclNjcm9sbCIsImRlZmF1bHQiLCJzdGFydFRyYW5zaXRpb24iLCJmb3JtYXRTdHJpbmdPclVybCIsInVybE9iak9yU3RyaW5nIiwiZm9ybWF0VXJsIiwiTGluayIsImZvcndhcmRSZWYiLCJMaW5rQ29tcG9uZW50IiwicHJvcHMiLCJmb3J3YXJkZWRSZWYiLCJjaGlsZHJlbiIsImhyZWZQcm9wIiwiYXNQcm9wIiwiY2hpbGRyZW5Qcm9wIiwicHJlZmV0Y2hQcm9wIiwicGFzc0hyZWYiLCJvbkNsaWNrIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUVudGVyUHJvcCIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hTdGFydFByb3AiLCJsZWdhY3lCZWhhdmlvciIsInJlc3RQcm9wcyIsImpzeCIsInBhZ2VzUm91dGVyIiwidXNlQ29udGV4dCIsIlJvdXRlckNvbnRleHQiLCJhcHBSb3V0ZXIiLCJBcHBSb3V0ZXJDb250ZXh0IiwicHJlZmV0Y2hFbmFibGVkIiwiYXBwUHJlZmV0Y2hLaW5kIiwiUHJlZmV0Y2hLaW5kIiwiQVVUTyIsIkZVTEwiLCJjcmVhdGVQcm9wRXJyb3IiLCJhcmdzIiwiRXJyb3IiLCJrZXkiLCJleHBlY3RlZCIsImFjdHVhbCIsInJlcXVpcmVkUHJvcHNHdWFyZCIsInJlcXVpcmVkUHJvcHMiLCJrZXlzIiwiZm9yRWFjaCIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsIm9wdGlvbmFsUHJvcHMiLCJ2YWxUeXBlIiwiaGFzV2FybmVkIiwidXNlUmVmIiwiY3VycmVudCIsImNvbnNvbGUiLCJ3YXJuIiwicGF0aG5hbWUiLCJoYXNEeW5hbWljU2VnbWVudCIsInNwbGl0Iiwic29tZSIsInNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJ1c2VNZW1vIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsInJlc29sdmVIcmVmIiwicHJldmlvdXNIcmVmIiwicHJldmlvdXNBcyIsImNoaWxkIiwiQ2hpbGRyZW4iLCJvbmx5IiwidHlwZSIsImNoaWxkUmVmIiwicmVmIiwic2V0SW50ZXJzZWN0aW9uUmVmIiwiaXNWaXNpYmxlIiwicmVzZXRWaXNpYmxlIiwidXNlSW50ZXJzZWN0aW9uIiwicm9vdE1hcmdpbiIsInNldFJlZiIsInVzZUNhbGxiYWNrIiwiZWwiLCJ1c2VFZmZlY3QiLCJraW5kIiwiY2hpbGRQcm9wcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwcmlvcml0eSIsImlzQWJzb2x1dGVVcmwiLCJjdXJMb2NhbGUiLCJsb2NhbGVEb21haW4iLCJpc0xvY2FsZURvbWFpbiIsImdldERvbWFpbkxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwiY2xvbmVFbGVtZW50IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    },\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1ELHNCQUFzQixPQUFPUSxTQUFTLGVBQWVBLEtBQUtSLG1CQUFtQixJQUFJUSxLQUFLUixtQkFBbUIsQ0FBQ1MsSUFBSSxDQUFDQyxXQUFXLFNBQVNDLEVBQUU7SUFDdkksSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDbkJKLEdBQUc7WUFDQ0ssWUFBWTtZQUNaQyxlQUFlO2dCQUNYLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBSTtZQUM5QztRQUNKO0lBQ0osR0FBRztBQUNQO0FBQ0EsTUFBTVgscUJBQXFCLE9BQU9PLFNBQVMsZUFBZUEsS0FBS1Asa0JBQWtCLElBQUlPLEtBQUtQLGtCQUFrQixDQUFDUSxJQUFJLENBQUNDLFdBQVcsU0FBU1UsRUFBRTtJQUNwSSxPQUFPQyxhQUFhRDtBQUN4QjtBQUVBLElBQUksQ0FBQyxPQUFPdkIsUUFBUXlCLE9BQU8sS0FBSyxjQUFlLE9BQU96QixRQUFReUIsT0FBTyxLQUFLLFlBQVl6QixRQUFReUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPekIsUUFBUXlCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks1QixPQUFPQyxjQUFjLENBQUNDLFFBQVF5QixPQUFPLEVBQUUsY0FBYztRQUFFeEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPNkIsTUFBTSxDQUFDM0IsUUFBUXlCLE9BQU8sRUFBRXpCO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVF5QixPQUFPO0FBQ2xDLEVBRUEsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcz8xZTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogbnVsbCxcbiAgICBjYW5jZWxJZGxlQ2FsbGJhY2s6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICAgIH0sXG4gICAgY2FuY2VsSWRsZUNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbmNlbElkbGVDYWxsYmFjaztcbiAgICB9XG59KTtcbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihjYikge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHNlbGYuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2Ioe1xuICAgICAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIDEpO1xufTtcbmNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1pZGxlLWNhbGxiYWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/resolve-href.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n}));\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\");\nconst _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\", 1);\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0NBQThDO0lBQzFDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsZUFBZUMsbUJBQU9BLENBQUMsbUlBQXdDO0FBQ3JFLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGlJQUF1QztBQUNsRSxNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQyxxSEFBaUM7QUFDdkQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsNkZBQXFCO0FBQzVDLE1BQU1JLDBCQUEwQkosbUJBQU9BLENBQUMsbUhBQTRCO0FBQ3BFLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLHFJQUF5QztBQUNyRSxNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQyxpSEFBNEI7QUFDcEQsTUFBTU8saUJBQWlCUCxtQkFBT0EsQ0FBQyx5SUFBMkM7QUFDMUUsU0FBU0YsWUFBWVUsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFNBQVM7SUFDeEMsNENBQTRDO0lBQzVDLElBQUlDO0lBQ0osSUFBSUMsY0FBYyxPQUFPSCxTQUFTLFdBQVdBLE9BQU8sQ0FBQyxHQUFHUixXQUFXWSxvQkFBb0IsRUFBRUo7SUFDekYsNkRBQTZEO0lBQzdELG1EQUFtRDtJQUNuRCxNQUFNSyxnQkFBZ0JGLFlBQVlHLEtBQUssQ0FBQztJQUN4QyxNQUFNQyxxQkFBcUJGLGdCQUFnQkYsWUFBWUssS0FBSyxDQUFDSCxhQUFhLENBQUMsRUFBRSxDQUFDSSxNQUFNLElBQUlOO0lBQ3hGLE1BQU1PLFdBQVdILG1CQUFtQkksS0FBSyxDQUFDLEtBQUs7SUFDL0MsSUFBSSxDQUFDRCxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUMsRUFBR0osS0FBSyxDQUFDLGNBQWM7UUFDeENNLFFBQVFDLEtBQUssQ0FBQyxtQkFBbUJWLGNBQWMsdUNBQXVDSixPQUFPZSxRQUFRLEdBQUc7UUFDeEcsTUFBTUMsZ0JBQWdCLENBQUMsR0FBR3JCLE9BQU9zQix3QkFBd0IsRUFBRVQ7UUFDM0RKLGNBQWMsQ0FBQ0UsZ0JBQWdCQSxhQUFhLENBQUMsRUFBRSxHQUFHLEVBQUMsSUFBS1U7SUFDNUQ7SUFDQSwyREFBMkQ7SUFDM0QsSUFBSSxDQUFDLENBQUMsR0FBR25CLFlBQVlxQixVQUFVLEVBQUVkLGNBQWM7UUFDM0MsT0FBT0YsWUFBWTtZQUNmRTtTQUNILEdBQUdBO0lBQ1I7SUFDQSxJQUFJO1FBQ0FELE9BQU8sSUFBSWdCLElBQUlmLFlBQVlnQixVQUFVLENBQUMsT0FBT3BCLE9BQU9xQixNQUFNLEdBQUdyQixPQUFPZSxRQUFRLEVBQUU7SUFDbEYsRUFBRSxPQUFPTyxHQUFHO1FBQ1Isa0RBQWtEO1FBQ2xEbkIsT0FBTyxJQUFJZ0IsSUFBSSxLQUFLO0lBQ3hCO0lBQ0EsSUFBSTtRQUNBLE1BQU1JLFdBQVcsSUFBSUosSUFBSWYsYUFBYUQ7UUFDdENvQixTQUFTUixRQUFRLEdBQUcsQ0FBQyxHQUFHbkIsd0JBQXdCNEIsMEJBQTBCLEVBQUVELFNBQVNSLFFBQVE7UUFDN0YsSUFBSVUsaUJBQWlCO1FBQ3JCLElBQUksQ0FBQyxHQUFHM0IsUUFBUTRCLGNBQWMsRUFBRUgsU0FBU1IsUUFBUSxLQUFLUSxTQUFTSSxZQUFZLElBQUl6QixXQUFXO1lBQ3RGLE1BQU0wQixRQUFRLENBQUMsR0FBR3JDLGFBQWFzQyxzQkFBc0IsRUFBRU4sU0FBU0ksWUFBWTtZQUM1RSxNQUFNLEVBQUVHLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHaEMsZUFBZWlDLGFBQWEsRUFBRVQsU0FBU1IsUUFBUSxFQUFFUSxTQUFTUixRQUFRLEVBQUVhO1lBQ25HLElBQUlFLFFBQVE7Z0JBQ1JMLGlCQUFpQixDQUFDLEdBQUdoQyxXQUFXWSxvQkFBb0IsRUFBRTtvQkFDbERVLFVBQVVlO29CQUNWRyxNQUFNVixTQUFTVSxJQUFJO29CQUNuQkwsT0FBTyxDQUFDLEdBQUdsQyxNQUFNd0MsSUFBSSxFQUFFTixPQUFPRztnQkFDbEM7WUFDSjtRQUNKO1FBQ0Esb0VBQW9FO1FBQ3BFLE1BQU1JLGVBQWVaLFNBQVNhLE1BQU0sS0FBS2pDLEtBQUtpQyxNQUFNLEdBQUdiLFNBQVN0QixJQUFJLENBQUNRLEtBQUssQ0FBQ2MsU0FBU2EsTUFBTSxDQUFDMUIsTUFBTSxJQUFJYSxTQUFTdEIsSUFBSTtRQUNsSCxPQUFPQyxZQUFZO1lBQ2ZpQztZQUNBVixrQkFBa0JVO1NBQ3JCLEdBQUdBO0lBQ1IsRUFBRSxPQUFPYixHQUFHO1FBQ1IsT0FBT3BCLFlBQVk7WUFDZkU7U0FDSCxHQUFHQTtJQUNSO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT2xCLFFBQVFtRCxPQUFPLEtBQUssY0FBZSxPQUFPbkQsUUFBUW1ELE9BQU8sS0FBSyxZQUFZbkQsUUFBUW1ELE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT25ELFFBQVFtRCxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdEQsT0FBT0MsY0FBYyxDQUFDQyxRQUFRbUQsT0FBTyxFQUFFLGNBQWM7UUFBRWxELE9BQU87SUFBSztJQUNuRUgsT0FBT3VELE1BQU0sQ0FBQ3JELFFBQVFtRCxPQUFPLEVBQUVuRDtJQUMvQnNELE9BQU90RCxPQUFPLEdBQUdBLFFBQVFtRCxPQUFPO0FBQ2xDLEVBRUEsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcz8yZjllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVzb2x2ZUhyZWZcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVIcmVmO1xuICAgIH1cbn0pO1xuY29uc3QgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xuY29uc3QgX29taXQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdFwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfaXNsb2NhbHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfdXRpbHMxID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzXCIpO1xuY29uc3QgX2ludGVycG9sYXRlYXMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXNcIik7XG5mdW5jdGlvbiByZXNvbHZlSHJlZihyb3V0ZXIsIGhyZWYsIHJlc29sdmVBcykge1xuICAgIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gICAgbGV0IGJhc2U7XG4gICAgbGV0IHVybEFzU3RyaW5nID0gdHlwZW9mIGhyZWYgPT09IFwic3RyaW5nXCIgPyBocmVmIDogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKGhyZWYpO1xuICAgIC8vIHJlcGVhdGVkIHNsYXNoZXMgYW5kIGJhY2tzbGFzaGVzIGluIHRoZSBVUkwgYXJlIGNvbnNpZGVyZWRcbiAgICAvLyBpbnZhbGlkIGFuZCB3aWxsIG5ldmVyIG1hdGNoIGEgTmV4dC5qcyBwYWdlL2ZpbGVcbiAgICBjb25zdCB1cmxQcm90b01hdGNoID0gdXJsQXNTdHJpbmcubWF0Y2goL15bYS16QS1aXXsxLH06XFwvXFwvLyk7XG4gICAgY29uc3QgdXJsQXNTdHJpbmdOb1Byb3RvID0gdXJsUHJvdG9NYXRjaCA/IHVybEFzU3RyaW5nLnNsaWNlKHVybFByb3RvTWF0Y2hbMF0ubGVuZ3RoKSA6IHVybEFzU3RyaW5nO1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsQXNTdHJpbmdOb1Byb3RvLnNwbGl0KFwiP1wiLCAxKTtcbiAgICBpZiAoKHVybFBhcnRzWzBdIHx8IFwiXCIpLm1hdGNoKC8oXFwvXFwvfFxcXFwpLykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgaHJlZiAnXCIgKyB1cmxBc1N0cmluZyArIFwiJyBwYXNzZWQgdG8gbmV4dC9yb3V0ZXIgaW4gcGFnZTogJ1wiICsgcm91dGVyLnBhdGhuYW1lICsgXCInLiBSZXBlYXRlZCBmb3J3YXJkLXNsYXNoZXMgKC8vKSBvciBiYWNrc2xhc2hlcyBcXFxcIGFyZSBub3QgdmFsaWQgaW4gdGhlIGhyZWYuXCIpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsID0gKDAsIF91dGlscy5ub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMpKHVybEFzU3RyaW5nTm9Qcm90byk7XG4gICAgICAgIHVybEFzU3RyaW5nID0gKHVybFByb3RvTWF0Y2ggPyB1cmxQcm90b01hdGNoWzBdIDogXCJcIikgKyBub3JtYWxpemVkVXJsO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYmVjYXVzZSBpdCBjYW5ub3QgYmUgcm91dGVkIGJ5IHRoZSBOZXh0LmpzIHJvdXRlclxuICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKHVybEFzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBiYXNlID0gbmV3IFVSTCh1cmxBc1N0cmluZy5zdGFydHNXaXRoKFwiI1wiKSA/IHJvdXRlci5hc1BhdGggOiByb3V0ZXIucGF0aG5hbWUsIFwiaHR0cDovL25cIik7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICAvLyBmYWxsYmFjayB0byAvIGZvciBpbnZhbGlkIGFzUGF0aCB2YWx1ZXMgZS5nLiAvL1xuICAgICAgICBiYXNlID0gbmV3IFVSTChcIi9cIiwgXCJodHRwOi8vblwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybEFzU3RyaW5nLCBiYXNlKTtcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKGZpbmFsVXJsLnBhdGhuYW1lKTtcbiAgICAgICAgbGV0IGludGVycG9sYXRlZEFzID0gXCJcIjtcbiAgICAgICAgaWYgKCgwLCBfdXRpbHMxLmlzRHluYW1pY1JvdXRlKShmaW5hbFVybC5wYXRobmFtZSkgJiYgZmluYWxVcmwuc2VhcmNoUGFyYW1zICYmIHJlc29sdmVBcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSAoMCwgX3F1ZXJ5c3RyaW5nLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkpKGZpbmFsVXJsLnNlYXJjaFBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdCwgcGFyYW1zIH0gPSAoMCwgX2ludGVycG9sYXRlYXMuaW50ZXJwb2xhdGVBcykoZmluYWxVcmwucGF0aG5hbWUsIGZpbmFsVXJsLnBhdGhuYW1lLCBxdWVyeSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogKDAsIF9vbWl0Lm9taXQpKHF1ZXJ5LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpbiA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aCkgOiBmaW5hbFVybC5ocmVmO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXG4gICAgICAgIF0gOiByZXNvbHZlZEhyZWY7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS1ocmVmLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJyZXNvbHZlSHJlZiIsIl9xdWVyeXN0cmluZyIsInJlcXVpcmUiLCJfZm9ybWF0dXJsIiwiX29taXQiLCJfdXRpbHMiLCJfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCIsIl9pc2xvY2FsdXJsIiwiX3V0aWxzMSIsIl9pbnRlcnBvbGF0ZWFzIiwicm91dGVyIiwiaHJlZiIsInJlc29sdmVBcyIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsUHJvdG9NYXRjaCIsIm1hdGNoIiwidXJsQXNTdHJpbmdOb1Byb3RvIiwic2xpY2UiLCJsZW5ndGgiLCJ1cmxQYXJ0cyIsInNwbGl0IiwiY29uc29sZSIsImVycm9yIiwicGF0aG5hbWUiLCJub3JtYWxpemVkVXJsIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwiaXNMb2NhbFVSTCIsIlVSTCIsInN0YXJ0c1dpdGgiLCJhc1BhdGgiLCJfIiwiZmluYWxVcmwiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImludGVycG9sYXRlZEFzIiwiaXNEeW5hbWljUm91dGUiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJyZXN1bHQiLCJwYXJhbXMiLCJpbnRlcnBvbGF0ZUFzIiwiaGFzaCIsIm9taXQiLCJyZXNvbHZlZEhyZWYiLCJvcmlnaW4iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLG1GQUFPO0FBQzlCLE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsNkdBQXlCO0FBQzlELE1BQU1FLDBCQUEwQixPQUFPQyx5QkFBeUI7QUFDaEUsTUFBTUMsWUFBWSxJQUFJQztBQUN0QixNQUFNQyxTQUFTLEVBQUU7QUFDakIsU0FBU0MsZUFBZUMsT0FBTztJQUMzQixNQUFNQyxLQUFLO1FBQ1BDLE1BQU1GLFFBQVFFLElBQUksSUFBSTtRQUN0QkMsUUFBUUgsUUFBUUksVUFBVSxJQUFJO0lBQ2xDO0lBQ0EsTUFBTUMsV0FBV1AsT0FBT1EsSUFBSSxDQUFDLENBQUNDLE1BQU1BLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07SUFDcEYsSUFBSUs7SUFDSixJQUFJSCxVQUFVO1FBQ1ZHLFdBQVdaLFVBQVVQLEdBQUcsQ0FBQ2dCO1FBQ3pCLElBQUlHLFVBQVU7WUFDVixPQUFPQTtRQUNYO0lBQ0o7SUFDQSxNQUFNQyxXQUFXLElBQUlaO0lBQ3JCLE1BQU1hLFdBQVcsSUFBSWYscUJBQXFCLENBQUNnQjtRQUN2Q0EsUUFBUUMsT0FBTyxDQUFDLENBQUNDO1lBQ2IsTUFBTUMsV0FBV0wsU0FBU3BCLEdBQUcsQ0FBQ3dCLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN2QkYsU0FBU0U7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LFFBQVE4RCxPQUFPLEVBQUU5RDtJQUMvQmlFLE9BQU9qRSxPQUFPLEdBQUdBLFFBQVE4RCxPQUFPO0FBQ2xDLEVBRUEsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZUludGVyc2VjdGlvblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlSW50ZXJzZWN0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgX3JlcXVlc3RpZGxlY2FsbGJhY2sgPSByZXF1aXJlKFwiLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2tcIik7XG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuY29uc3QgaWRMaXN0ID0gW107XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSB7XG4gICAgICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxuICAgICAgICBtYXJnaW46IG9wdGlvbnMucm9vdE1hcmdpbiB8fCBcIlwiXG4gICAgfTtcbiAgICBjb25zdCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpPT57XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIGluc3RhbmNlID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgb2JzZXJ2ZXIsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgICBpZExpc3QucHVzaChpZCk7XG4gICAgb2JzZXJ2ZXJzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkLCBvYnNlcnZlciwgZWxlbWVudHMgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGlkTGlzdC5maW5kSW5kZXgoKG9iaik9Pm9iai5yb290ID09PSBpZC5yb290ICYmIG9iai5tYXJnaW4gPT09IGlkLm1hcmdpbik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlkTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbihwYXJhbSkge1xuICAgIGxldCB7IHJvb3RSZWYsIHJvb3RNYXJnaW4sIGRpc2FibGVkIH0gPSBwYXJhbTtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBlbGVtZW50UmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG51bGwpO1xuICAgIGNvbnN0IHNldEVsZW1lbnQgPSAoMCwgX3JlYWN0LnVzZUNhbGxiYWNrKSgoZWxlbWVudCk9PntcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICB9LCBbXSk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVub2JzZXJ2ZSA9IG9ic2VydmUoZWxlbWVudCwgKGlzVmlzaWJsZSk9PmlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdFJlZiA9PSBudWxsID8gdm9pZCAwIDogcm9vdFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVub2JzZXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdGlkbGVjYWxsYmFjay5yZXF1ZXN0SWRsZUNhbGxiYWNrKSgoKT0+c2V0VmlzaWJsZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RpZGxlY2FsbGJhY2suY2FuY2VsSWRsZUNhbGxiYWNrKShpZGxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgcm9vdFJlZixcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50XG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldEVsZW1lbnQsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIHJlc2V0VmlzaWJsZVxuICAgIF07XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pbnRlcnNlY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInVzZUludGVyc2VjdGlvbiIsIl9yZWFjdCIsInJlcXVpcmUiLCJfcmVxdWVzdGlkbGVjYWxsYmFjayIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlcnMiLCJNYXAiLCJpZExpc3QiLCJjcmVhdGVPYnNlcnZlciIsIm9wdGlvbnMiLCJpZCIsInJvb3QiLCJtYXJnaW4iLCJyb290TWFyZ2luIiwiZXhpc3RpbmciLCJmaW5kIiwib2JqIiwiaW5zdGFuY2UiLCJlbGVtZW50cyIsIm9ic2VydmVyIiwiZW50cmllcyIsImZvckVhY2giLCJlbnRyeSIsImNhbGxiYWNrIiwidGFyZ2V0IiwiaXNWaXNpYmxlIiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsInB1c2giLCJzZXQiLCJvYnNlcnZlIiwiZWxlbWVudCIsInVub2JzZXJ2ZSIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0IiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJwYXJhbSIsInJvb3RSZWYiLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVzZVN0YXRlIiwiZWxlbWVudFJlZiIsInVzZVJlZiIsInNldEVsZW1lbnQiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJ1c2VFZmZlY3QiLCJ0YWdOYW1lIiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRixrQkFBa0JHLE9BQU9FLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDLENBQUM7QUFDdEQsSUFBSUMsSUFBcUMsRUFBRTtJQUN2Q1AsZ0JBQWdCUSxXQUFXLEdBQUc7QUFDbEMsRUFFQSxzREFBc0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2FtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lLmpzPzk4YjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbXBTdGF0ZUNvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFtcFN0YXRlQ29udGV4dDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBBbXBTdGF0ZUNvbnRleHQgPSBfcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KHt9KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBBbXBTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkFtcFN0YXRlQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiQW1wU3RhdGVDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJkZWZhdWx0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0NBQThDO0lBQzFDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsWUFBWUMsS0FBSztJQUN0QixJQUFJLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRUMsV0FBVyxLQUFLLEVBQUUsR0FBR0gsVUFBVSxLQUFLLElBQUksQ0FBQyxJQUFJQTtJQUNyRixPQUFPQyxZQUFZQyxVQUFVQztBQUNqQyxFQUVBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLW1vZGUuanM/NjIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSW5BbXBNb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc0luQW1wTW9kZTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGlzSW5BbXBNb2RlKHBhcmFtKSB7XG4gICAgbGV0IHsgYW1wRmlyc3QgPSBmYWxzZSwgaHlicmlkID0gZmFsc2UsIGhhc1F1ZXJ5ID0gZmFsc2UgfSA9IHBhcmFtID09PSB2b2lkIDAgPyB7fSA6IHBhcmFtO1xuICAgIHJldHVybiBhbXBGaXJzdCB8fCBoeWJyaWQgJiYgaGFzUXVlcnk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFtcC1tb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJpc0luQW1wTW9kZSIsInBhcmFtIiwiYW1wRmlyc3QiLCJoeWJyaWQiLCJoYXNRdWVyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function() {\n        return escapeStringRegexp;\n    }\n}));\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTtBQUM3RDtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxrQkFBa0I7QUFDeEIsU0FBU0YsbUJBQW1CRyxHQUFHO0lBQzNCLCtHQUErRztJQUMvRyxJQUFJRixZQUFZRyxJQUFJLENBQUNELE1BQU07UUFDdkIsT0FBT0EsSUFBSUUsT0FBTyxDQUFDSCxpQkFBaUI7SUFDeEM7SUFDQSxPQUFPQztBQUNYLEVBRUEseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzP2RiZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVnZXhwIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZXNjYXBlLXN0cmluZy1yZWdleHBcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlU3RyaW5nUmVnZXhwXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVTdHJpbmdSZWdleHA7XG4gICAgfVxufSk7XG5jb25zdCByZUhhc1JlZ0V4cCA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dLztcbmNvbnN0IHJlUmVwbGFjZVJlZ0V4cCA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2c7XG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyKSB7XG4gICAgLy8gc2VlIGFsc286IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvMmRhMDI0YzNiNGY5OTQ3YTQ4NTE3NjM5ZGU3NTYwNDU3Y2Q0ZWM2Yy9lc2NhcGVSZWdFeHAuanMjTDIzXG4gICAgaWYgKHJlSGFzUmVnRXhwLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVSZXBsYWNlUmVnRXhwLCBcIlxcXFwkJlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLXJlZ2V4cC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZXNjYXBlU3RyaW5nUmVnZXhwIiwicmVIYXNSZWdFeHAiLCJyZVJlcGxhY2VSZWdFeHAiLCJzdHIiLCJ0ZXN0IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"number\") {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, onLoad, onLoadingComplete, placeholder = \"empty\", blurDataURL, fetchPriority, layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if (\"allSizes\" in c) {\n        config = c;\n    } else {\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        const layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = \"\";\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    let isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (!src || src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    if (priority) {\n        fetchPriority = \"high\";\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === \"export\" && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== \"empty\" && placeholder !== \"blur\" && !placeholder.startsWith(\"data:image/\")) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== \"empty\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === \"blur\" && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                \"jpeg\",\n                \"png\",\n                \"webp\",\n                \"avif\"\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if (\"ref\" in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if (typeof window !== \"undefined\" && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === \"empty\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== \"empty\" ? placeholder === \"blur\" ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || \"\",\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === \"blur\" && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (typeof window !== \"undefined\") {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? \"lazy\" : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding: \"async\",\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwrQ0FBOEM7SUFDMUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxZQUFZQyxtQkFBT0EsQ0FBQyxxR0FBbUI7QUFDN0MsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxtR0FBa0I7QUFDaEQsTUFBTUUsZUFBZUYsbUJBQU9BLENBQUMsK0ZBQWdCO0FBQzdDLE1BQU1HLHVCQUF1QjtJQUN6QjtJQUNBO0lBQ0FDO0NBQ0g7QUFDRCxTQUFTQyxnQkFBZ0JDLEdBQUc7SUFDeEIsT0FBT0EsSUFBSUMsT0FBTyxLQUFLSDtBQUMzQjtBQUNBLFNBQVNJLGtCQUFrQkYsR0FBRztJQUMxQixPQUFPQSxJQUFJQSxHQUFHLEtBQUtGO0FBQ3ZCO0FBQ0EsU0FBU0ssZUFBZUgsR0FBRztJQUN2QixPQUFPLE9BQU9BLFFBQVEsWUFBYUQsQ0FBQUEsZ0JBQWdCQyxRQUFRRSxrQkFBa0JGLElBQUc7QUFDcEY7QUFDQSxNQUFNSSxVQUFVLElBQUlDO0FBQ3BCLElBQUlDO0FBQ0osU0FBU0MsT0FBT0MsQ0FBQztJQUNiLElBQUksT0FBT0EsTUFBTSxhQUFhO1FBQzFCLE9BQU9BO0lBQ1g7SUFDQSxJQUFJLE9BQU9BLE1BQU0sVUFBVTtRQUN2QixPQUFPQyxPQUFPQyxRQUFRLENBQUNGLEtBQUtBLElBQUlHO0lBQ3BDO0lBQ0EsSUFBSSxPQUFPSCxNQUFNLFlBQVksV0FBV0ksSUFBSSxDQUFDSixJQUFJO1FBQzdDLE9BQU9LLFNBQVNMLEdBQUc7SUFDdkI7SUFDQSxPQUFPRztBQUNYO0FBQ0EsU0FBU0csVUFBVUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7SUFDbEMsSUFBSSxF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RyxVQUFVcEYsY0FBYztRQUMvRDtJQUNKO0lBQ0EsTUFBTTBGLGdCQUFnQjdHLGlCQUFpQjtRQUNuQ0M7UUFDQXZDO1FBQ0F3QztRQUNBeEIsT0FBT3lFO1FBQ1BoRCxTQUFTNkQ7UUFDVHJGO1FBQ0F5QjtJQUNKO0lBQ0EsSUFBSTZELElBQXFDLEVBQUU7UUFDdkMsSUFBSSxPQUFPaUIsV0FBVyxhQUFhO1lBQy9CLElBQUk0QjtZQUNKLElBQUk7Z0JBQ0FBLFVBQVUsSUFBSW5DLElBQUlrQyxjQUFjbkosR0FBRztZQUN2QyxFQUFFLE9BQU9xSixHQUFHO2dCQUNSRCxVQUFVLElBQUluQyxJQUFJa0MsY0FBY25KLEdBQUcsRUFBRXdILE9BQU84QixRQUFRLENBQUNDLElBQUk7WUFDN0Q7WUFDQW5KLFFBQVFvSixHQUFHLENBQUNKLFFBQVFHLElBQUksRUFBRTtnQkFDdEJ2SjtnQkFDQWdEO2dCQUNBUTtZQUNKO1FBQ0o7SUFDSjtJQUNBLE1BQU1pRyxRQUFRO1FBQ1YsR0FBR3pGLElBQUk7UUFDUGYsU0FBU2lELFNBQVMsU0FBU2pEO1FBQzNCUztRQUNBMUMsT0FBT3lFO1FBQ1B0QyxRQUFRdUM7UUFDUmdFLFVBQVU7UUFDVnhHO1FBQ0FHLE9BQU87WUFDSCxHQUFHaUYsUUFBUTtZQUNYLEdBQUdTLGdCQUFnQjtRQUN2QjtRQUNBOUgsT0FBT2tJLGNBQWNsSSxLQUFLO1FBQzFCMEIsUUFBUXdHLGNBQWN4RyxNQUFNO1FBQzVCM0MsS0FBS21KLGNBQWNuSixHQUFHO0lBQzFCO0lBQ0EsTUFBTTJKLE9BQU87UUFDVG5IO1FBQ0FRO1FBQ0FRO1FBQ0FKO0lBQ0o7SUFDQSxPQUFPO1FBQ0hxRztRQUNBRTtJQUNKO0FBQ0osRUFFQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2dldC1pbWctcHJvcHMuanM/YmJhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEltZ1Byb3BzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbWdQcm9wcztcbiAgICB9XG59KTtcbmNvbnN0IF93YXJub25jZSA9IHJlcXVpcmUoXCIuL3V0aWxzL3dhcm4tb25jZVwiKTtcbmNvbnN0IF9pbWFnZWJsdXJzdmcgPSByZXF1aXJlKFwiLi9pbWFnZS1ibHVyLXN2Z1wiKTtcbmNvbnN0IF9pbWFnZWNvbmZpZyA9IHJlcXVpcmUoXCIuL2ltYWdlLWNvbmZpZ1wiKTtcbmNvbnN0IFZBTElEX0xPQURJTkdfVkFMVUVTID0gW1xuICAgIFwibGF6eVwiLFxuICAgIFwiZWFnZXJcIixcbiAgICB1bmRlZmluZWRcbl07XG5mdW5jdGlvbiBpc1N0YXRpY1JlcXVpcmUoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5kZWZhdWx0ICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1N0YXRpY0ltYWdlRGF0YShzcmMpIHtcbiAgICByZXR1cm4gc3JjLnNyYyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbXBvcnQoc3JjKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCIgJiYgKGlzU3RhdGljUmVxdWlyZShzcmMpIHx8IGlzU3RhdGljSW1hZ2VEYXRhKHNyYykpO1xufVxuY29uc3QgYWxsSW1ncyA9IG5ldyBNYXAoKTtcbmxldCBwZXJmT2JzZXJ2ZXI7XG5mdW5jdGlvbiBnZXRJbnQoeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoeCkgPyB4IDogTmFOO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIgJiYgL15bMC05XSskLy50ZXN0KHgpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh4LCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBOYU47XG59XG5mdW5jdGlvbiBnZXRXaWR0aHMocGFyYW0sIHdpZHRoLCBzaXplcykge1xuICAgIGxldCB7IGRldmljZVNpemVzLCBhbGxTaXplcyB9ID0gcGFyYW07XG4gICAgaWYgKHNpemVzKSB7XG4gICAgICAgIC8vIEZpbmQgYWxsIHRoZSBcInZ3XCIgcGVyY2VudCBzaXplcyB1c2VkIGluIHRoZSBzaXplcyBwcm9wXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0V2lkdGhSZSA9IC8oXnxcXHMpKDE/XFxkP1xcZCl2dy9nO1xuICAgICAgICBjb25zdCBwZXJjZW50U2l6ZXMgPSBbXTtcbiAgICAgICAgZm9yKGxldCBtYXRjaDsgbWF0Y2ggPSB2aWV3cG9ydFdpZHRoUmUuZXhlYyhzaXplcyk7IG1hdGNoKXtcbiAgICAgICAgICAgIHBlcmNlbnRTaXplcy5wdXNoKHBhcnNlSW50KG1hdGNoWzJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcmNlbnRTaXplcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNtYWxsZXN0UmF0aW8gPSBNYXRoLm1pbiguLi5wZXJjZW50U2l6ZXMpICogMC4wMTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGhzOiBhbGxTaXplcy5maWx0ZXIoKHMpPT5zID49IGRldmljZVNpemVzWzBdICogc21hbGxlc3RSYXRpbyksXG4gICAgICAgICAgICAgICAga2luZDogXCJ3XCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMsXG4gICAgICAgICAgICBraW5kOiBcIndcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aHM6IGRldmljZVNpemVzLFxuICAgICAgICAgICAga2luZDogXCJ3XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGhzID0gW1xuICAgICAgICAuLi5uZXcgU2V0KC8vID4gVGhpcyBtZWFucyB0aGF0IG1vc3QgT0xFRCBzY3JlZW5zIHRoYXQgc2F5IHRoZXkgYXJlIDN4IHJlc29sdXRpb24sXG4gICAgICAgIC8vID4gYXJlIGFjdHVhbGx5IDN4IGluIHRoZSBncmVlbiBjb2xvciwgYnV0IG9ubHkgMS41eCBpbiB0aGUgcmVkIGFuZFxuICAgICAgICAvLyA+IGJsdWUgY29sb3JzLiBTaG93aW5nIGEgM3ggcmVzb2x1dGlvbiBpbWFnZSBpbiB0aGUgYXBwIHZzIGEgMnhcbiAgICAgICAgLy8gPiByZXNvbHV0aW9uIGltYWdlIHdpbGwgYmUgdmlzdWFsbHkgdGhlIHNhbWUsIHRob3VnaCB0aGUgM3ggaW1hZ2VcbiAgICAgICAgLy8gPiB0YWtlcyBzaWduaWZpY2FudGx5IG1vcmUgZGF0YS4gRXZlbiB0cnVlIDN4IHJlc29sdXRpb24gc2NyZWVucyBhcmVcbiAgICAgICAgLy8gPiB3YXN0ZWZ1bCBhcyB0aGUgaHVtYW4gZXllIGNhbm5vdCBzZWUgdGhhdCBsZXZlbCBvZiBkZXRhaWwgd2l0aG91dFxuICAgICAgICAvLyA+IHNvbWV0aGluZyBsaWtlIGEgbWFnbmlmeWluZyBnbGFzcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9ibG9nLnR3aXR0ZXIuY29tL2VuZ2luZWVyaW5nL2VuX3VzL3RvcGljcy9pbmZyYXN0cnVjdHVyZS8yMDE5L2NhcHBpbmctaW1hZ2UtZmlkZWxpdHktb24tdWx0cmEtaGlnaC1yZXNvbHV0aW9uLWRldmljZXMuaHRtbFxuICAgICAgICBbXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIHdpZHRoICogMiAvKiwgd2lkdGggKiAzKi8gXG4gICAgICAgIF0ubWFwKCh3KT0+YWxsU2l6ZXMuZmluZCgocCk9PnAgPj0gdykgfHwgYWxsU2l6ZXNbYWxsU2l6ZXMubGVuZ3RoIC0gMV0pKVxuICAgIF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGhzLFxuICAgICAgICBraW5kOiBcInhcIlxuICAgIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltZ0F0dHJzKHBhcmFtKSB7XG4gICAgbGV0IHsgY29uZmlnLCBzcmMsIHVub3B0aW1pemVkLCB3aWR0aCwgcXVhbGl0eSwgc2l6ZXMsIGxvYWRlciB9ID0gcGFyYW07XG4gICAgaWYgKHVub3B0aW1pemVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICBzcmNTZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNpemVzOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyB3aWR0aHMsIGtpbmQgfSA9IGdldFdpZHRocyhjb25maWcsIHdpZHRoLCBzaXplcyk7XG4gICAgY29uc3QgbGFzdCA9IHdpZHRocy5sZW5ndGggLSAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpemVzOiAhc2l6ZXMgJiYga2luZCA9PT0gXCJ3XCIgPyBcIjEwMHZ3XCIgOiBzaXplcyxcbiAgICAgICAgc3JjU2V0OiB3aWR0aHMubWFwKCh3LCBpKT0+bG9hZGVyKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHF1YWxpdHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdcbiAgICAgICAgICAgIH0pICsgXCIgXCIgKyAoa2luZCA9PT0gXCJ3XCIgPyB3IDogaSArIDEpICsga2luZCkuam9pbihcIiwgXCIpLFxuICAgICAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYHNyY2AgdGhlIGxhc3QgYXR0cmlidXRlIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBhdHRyaWJ1dGVzIGluIG9yZGVyLiBJZiB3ZSBrZWVwIGBzcmNgIHRoZSBmaXJzdCBvbmUsIFNhZmFyaSB3aWxsXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHN0YXJ0IHRvIGZldGNoIGBzcmNgLCBiZWZvcmUgYHNpemVzYCBhbmQgYHNyY1NldGAgYXJlIGV2ZW5cbiAgICAgICAgLy8gdXBkYXRlZCBieSBSZWFjdC4gVGhhdCBjYXVzZXMgbXVsdGlwbGUgdW5uZWNlc3NhcnkgcmVxdWVzdHMgaWYgYHNyY1NldGBcbiAgICAgICAgLy8gYW5kIGBzaXplc2AgYXJlIGRlZmluZWQuXG4gICAgICAgIC8vIFRoaXMgYnVnIGNhbm5vdCBiZSByZXByb2R1Y2VkIGluIENocm9tZSBvciBGaXJlZm94LlxuICAgICAgICBzcmM6IGxvYWRlcih7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoc1tsYXN0XVxuICAgICAgICB9KVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRJbWdQcm9wcyhwYXJhbSwgX3N0YXRlKSB7XG4gICAgbGV0IHsgc3JjLCBzaXplcywgdW5vcHRpbWl6ZWQgPSBmYWxzZSwgcHJpb3JpdHkgPSBmYWxzZSwgbG9hZGluZywgY2xhc3NOYW1lLCBxdWFsaXR5LCB3aWR0aCwgaGVpZ2h0LCBmaWxsID0gZmFsc2UsIHN0eWxlLCBvbkxvYWQsIG9uTG9hZGluZ0NvbXBsZXRlLCBwbGFjZWhvbGRlciA9IFwiZW1wdHlcIiwgYmx1ckRhdGFVUkwsIGZldGNoUHJpb3JpdHksIGxheW91dCwgb2JqZWN0Rml0LCBvYmplY3RQb3NpdGlvbiwgbGF6eUJvdW5kYXJ5LCBsYXp5Um9vdCwgLi4ucmVzdCB9ID0gcGFyYW07XG4gICAgY29uc3QgeyBpbWdDb25mLCBzaG93QWx0VGV4dCwgYmx1ckNvbXBsZXRlLCBkZWZhdWx0TG9hZGVyIH0gPSBfc3RhdGU7XG4gICAgbGV0IGNvbmZpZztcbiAgICBsZXQgYyA9IGltZ0NvbmYgfHwgX2ltYWdlY29uZmlnLmltYWdlQ29uZmlnRGVmYXVsdDtcbiAgICBpZiAoXCJhbGxTaXplc1wiIGluIGMpIHtcbiAgICAgICAgY29uZmlnID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhbGxTaXplcyA9IFtcbiAgICAgICAgICAgIC4uLmMuZGV2aWNlU2l6ZXMsXG4gICAgICAgICAgICAuLi5jLmltYWdlU2l6ZXNcbiAgICAgICAgXS5zb3J0KChhLCBiKT0+YSAtIGIpO1xuICAgICAgICBjb25zdCBkZXZpY2VTaXplcyA9IGMuZGV2aWNlU2l6ZXMuc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgIGFsbFNpemVzLFxuICAgICAgICAgICAgZGV2aWNlU2l6ZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGxvYWRlciA9IHJlc3QubG9hZGVyIHx8IGRlZmF1bHRMb2FkZXI7XG4gICAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPiBlbGVtZW50XG4gICAgZGVsZXRlIHJlc3QubG9hZGVyO1xuICAgIGRlbGV0ZSByZXN0LnNyY1NldDtcbiAgICAvLyBUaGlzIHNwZWNpYWwgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlIHVzZXJcbiAgICAvLyBkaWRuJ3QgZGVmaW5lIGEgXCJsb2FkZXJcIiBwcm9wIG9yIFwibG9hZGVyXCIgY29uZmlnLlxuICAgIGNvbnN0IGlzRGVmYXVsdExvYWRlciA9IFwiX19uZXh0X2ltZ19kZWZhdWx0XCIgaW4gbG9hZGVyO1xuICAgIGlmIChpc0RlZmF1bHRMb2FkZXIpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5sb2FkZXIgPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIG1pc3NpbmcgXCJsb2FkZXJcIiBwcm9wLicgKyBcIlxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS1taXNzaW5nLWxvYWRlclwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSB1c2VyIGRlZmluZWQgYSBcImxvYWRlclwiIHByb3Agb3IgY29uZmlnLlxuICAgICAgICAvLyBTaW5jZSB0aGUgY29uZmlnIG9iamVjdCBpcyBpbnRlcm5hbCBvbmx5LCB3ZVxuICAgICAgICAvLyBtdXN0IG5vdCBwYXNzIGl0IHRvIHRoZSB1c2VyLWRlZmluZWQgXCJsb2FkZXJcIi5cbiAgICAgICAgY29uc3QgY3VzdG9tSW1hZ2VMb2FkZXIgPSBsb2FkZXI7XG4gICAgICAgIGxvYWRlciA9IChvYmopPT57XG4gICAgICAgICAgICBjb25zdCB7IGNvbmZpZzogXywgLi4ub3B0cyB9ID0gb2JqO1xuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUltYWdlTG9hZGVyKG9wdHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAobGF5b3V0KSB7XG4gICAgICAgIGlmIChsYXlvdXQgPT09IFwiZmlsbFwiKSB7XG4gICAgICAgICAgICBmaWxsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXlvdXRUb1N0eWxlID0ge1xuICAgICAgICAgICAgaW50cmluc2ljOiB7XG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNwb25zaXZlOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbGF5b3V0VG9TaXplcyA9IHtcbiAgICAgICAgICAgIHJlc3BvbnNpdmU6IFwiMTAwdndcIixcbiAgICAgICAgICAgIGZpbGw6IFwiMTAwdndcIlxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsYXlvdXRTdHlsZSA9IGxheW91dFRvU3R5bGVbbGF5b3V0XTtcbiAgICAgICAgaWYgKGxheW91dFN0eWxlKSB7XG4gICAgICAgICAgICBzdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgICAgICAuLi5sYXlvdXRTdHlsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXlvdXRTaXplcyA9IGxheW91dFRvU2l6ZXNbbGF5b3V0XTtcbiAgICAgICAgaWYgKGxheW91dFNpemVzICYmICFzaXplcykge1xuICAgICAgICAgICAgc2l6ZXMgPSBsYXlvdXRTaXplcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhdGljU3JjID0gXCJcIjtcbiAgICBsZXQgd2lkdGhJbnQgPSBnZXRJbnQod2lkdGgpO1xuICAgIGxldCBoZWlnaHRJbnQgPSBnZXRJbnQoaGVpZ2h0KTtcbiAgICBsZXQgYmx1cldpZHRoO1xuICAgIGxldCBibHVySGVpZ2h0O1xuICAgIGlmIChpc1N0YXRpY0ltcG9ydChzcmMpKSB7XG4gICAgICAgIGNvbnN0IHN0YXRpY0ltYWdlRGF0YSA9IGlzU3RhdGljUmVxdWlyZShzcmMpID8gc3JjLmRlZmF1bHQgOiBzcmM7XG4gICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLnNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBzcmMuIFJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0aWNJbWFnZURhdGEuaGVpZ2h0IHx8ICFzdGF0aWNJbWFnZURhdGEud2lkdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIG9iamVjdCBzaG91bGQgb25seSBiZSBwYXNzZWQgdG8gdGhlIGltYWdlIGNvbXBvbmVudCBzcmMgcGFyYW1ldGVyIGlmIGl0IGNvbWVzIGZyb20gYSBzdGF0aWMgaW1hZ2UgaW1wb3J0LiBJdCBtdXN0IGluY2x1ZGUgaGVpZ2h0IGFuZCB3aWR0aC4gUmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeShzdGF0aWNJbWFnZURhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBibHVyV2lkdGggPSBzdGF0aWNJbWFnZURhdGEuYmx1cldpZHRoO1xuICAgICAgICBibHVySGVpZ2h0ID0gc3RhdGljSW1hZ2VEYXRhLmJsdXJIZWlnaHQ7XG4gICAgICAgIGJsdXJEYXRhVVJMID0gYmx1ckRhdGFVUkwgfHwgc3RhdGljSW1hZ2VEYXRhLmJsdXJEYXRhVVJMO1xuICAgICAgICBzdGF0aWNTcmMgPSBzdGF0aWNJbWFnZURhdGEuc3JjO1xuICAgICAgICBpZiAoIWZpbGwpIHtcbiAgICAgICAgICAgIGlmICghd2lkdGhJbnQgJiYgIWhlaWdodEludCkge1xuICAgICAgICAgICAgICAgIHdpZHRoSW50ID0gc3RhdGljSW1hZ2VEYXRhLndpZHRoO1xuICAgICAgICAgICAgICAgIGhlaWdodEludCA9IHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdpZHRoSW50ICYmICFoZWlnaHRJbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpbyA9IHdpZHRoSW50IC8gc3RhdGljSW1hZ2VEYXRhLndpZHRoO1xuICAgICAgICAgICAgICAgIGhlaWdodEludCA9IE1hdGgucm91bmQoc3RhdGljSW1hZ2VEYXRhLmhlaWdodCAqIHJhdGlvKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXdpZHRoSW50ICYmIGhlaWdodEludCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gaGVpZ2h0SW50IC8gc3RhdGljSW1hZ2VEYXRhLmhlaWdodDtcbiAgICAgICAgICAgICAgICB3aWR0aEludCA9IE1hdGgucm91bmQoc3RhdGljSW1hZ2VEYXRhLndpZHRoICogcmF0aW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNyYyA9IHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIgPyBzcmMgOiBzdGF0aWNTcmM7XG4gICAgbGV0IGlzTGF6eSA9ICFwcmlvcml0eSAmJiAobG9hZGluZyA9PT0gXCJsYXp5XCIgfHwgdHlwZW9mIGxvYWRpbmcgPT09IFwidW5kZWZpbmVkXCIpO1xuICAgIGlmICghc3JjIHx8IHNyYy5zdGFydHNXaXRoKFwiZGF0YTpcIikgfHwgc3JjLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSkge1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJJc1xuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIGlzTGF6eSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnVub3B0aW1pemVkKSB7XG4gICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzRGVmYXVsdExvYWRlciAmJiBzcmMuZW5kc1dpdGgoXCIuc3ZnXCIpICYmICFjb25maWcuZGFuZ2Vyb3VzbHlBbGxvd1NWRykge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdG8gbWFrZSBzdmcgc2VydmUgYXMtaXMgdG8gYXZvaWQgcHJveHlpbmdcbiAgICAgICAgLy8gdGhyb3VnaCB0aGUgYnVpbHQtaW4gSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJpb3JpdHkpIHtcbiAgICAgICAgZmV0Y2hQcmlvcml0eSA9IFwiaGlnaFwiO1xuICAgIH1cbiAgICBjb25zdCBxdWFsaXR5SW50ID0gZ2V0SW50KHF1YWxpdHkpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5vdXRwdXQgPT09IFwiZXhwb3J0XCIgJiYgaXNEZWZhdWx0TG9hZGVyICYmICF1bm9wdGltaXplZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgT3B0aW1pemF0aW9uIHVzaW5nIHRoZSBkZWZhdWx0IGxvYWRlciBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGB7IG91dHB1dDogJ2V4cG9ydCcgfWAuXFxuICBQb3NzaWJsZSBzb2x1dGlvbnM6XFxuICAgIC0gUmVtb3ZlIGB7IG91dHB1dDogJ2V4cG9ydCcgfWAgYW5kIHJ1biBcXFwibmV4dCBzdGFydFxcXCIgdG8gcnVuIHNlcnZlciBtb2RlIGluY2x1ZGluZyB0aGUgSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cXG4gICAgLSBDb25maWd1cmUgYHsgaW1hZ2VzOiB7IHVub3B0aW1pemVkOiB0cnVlIH0gfWAgaW4gYG5leHQuY29uZmlnLmpzYCB0byBkaXNhYmxlIHRoZSBJbWFnZSBPcHRpbWl6YXRpb24gQVBJLlxcbiAgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9leHBvcnQtaW1hZ2UtYXBpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjKSB7XG4gICAgICAgICAgICAvLyBSZWFjdCBkb2Vzbid0IHNob3cgdGhlIHN0YWNrIHRyYWNlIGFuZCB0aGVyZSdzXG4gICAgICAgICAgICAvLyBubyBgc3JjYCB0byBoZWxwIGlkZW50aWZ5IHdoaWNoIGltYWdlLCBzbyB3ZVxuICAgICAgICAgICAgLy8gaW5zdGVhZCBjb25zb2xlLmVycm9yKHJlZikgZHVyaW5nIG1vdW50LlxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGJvdGggXCJ3aWR0aFwiIGFuZCBcImZpbGxcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgYm90aCBcImhlaWdodFwiIGFuZCBcImZpbGxcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChzdHlsZSA9PSBudWxsID8gdm9pZCAwIDogc3R5bGUucG9zaXRpb24pICYmIHN0eWxlLnBvc2l0aW9uICE9PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUucG9zaXRpb25cIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIHBvc2l0aW9uIGFic29sdXRlIC0gaXQgY2Fubm90IGJlIG1vZGlmaWVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHN0eWxlID09IG51bGwgPyB2b2lkIDAgOiBzdHlsZS53aWR0aCkgJiYgc3R5bGUud2lkdGggIT09IFwiMTAwJVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLndpZHRoXCIgcHJvcGVydGllcy4gSW1hZ2VzIHdpdGggXCJmaWxsXCIgYWx3YXlzIHVzZSB3aWR0aCAxMDAlIC0gaXQgY2Fubm90IGJlIG1vZGlmaWVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHN0eWxlID09IG51bGwgPyB2b2lkIDAgOiBzdHlsZS5oZWlnaHQpICYmIHN0eWxlLmhlaWdodCAhPT0gXCIxMDAlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUuaGVpZ2h0XCIgcHJvcGVydGllcy4gSW1hZ2VzIHdpdGggXCJmaWxsXCIgYWx3YXlzIHVzZSBoZWlnaHQgMTAwJSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2lkdGhJbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaXMgbWlzc2luZyByZXF1aXJlZCBcIndpZHRoXCIgcHJvcGVydHkuJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTih3aWR0aEludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGludmFsaWQgXCJ3aWR0aFwiIHByb3BlcnR5LiBFeHBlY3RlZCBhIG51bWVyaWMgdmFsdWUgaW4gcGl4ZWxzIGJ1dCByZWNlaXZlZCBcIicgKyB3aWR0aCArICdcIi4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHRJbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaXMgbWlzc2luZyByZXF1aXJlZCBcImhlaWdodFwiIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oaGVpZ2h0SW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgaW52YWxpZCBcImhlaWdodFwiIHByb3BlcnR5LiBFeHBlY3RlZCBhIG51bWVyaWMgdmFsdWUgaW4gcGl4ZWxzIGJ1dCByZWNlaXZlZCBcIicgKyBoZWlnaHQgKyAnXCIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghVkFMSURfTE9BRElOR19WQUxVRVMuaW5jbHVkZXMobG9hZGluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBpbnZhbGlkIFwibG9hZGluZ1wiIHByb3BlcnR5LiBQcm92aWRlZCBcIicgKyBsb2FkaW5nICsgJ1wiIHNob3VsZCBiZSBvbmUgb2YgJyArIFZBTElEX0xPQURJTkdfVkFMVUVTLm1hcChTdHJpbmcpLmpvaW4oXCIsXCIpICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmlvcml0eSAmJiBsb2FkaW5nID09PSBcImxhenlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGJvdGggXCJwcmlvcml0eVwiIGFuZCBcImxvYWRpbmc9XFwnbGF6eVxcJ1wiIHByb3BlcnRpZXMuIE9ubHkgb25lIHNob3VsZCBiZSB1c2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gXCJlbXB0eVwiICYmIHBsYWNlaG9sZGVyICE9PSBcImJsdXJcIiAmJiAhcGxhY2Vob2xkZXIuc3RhcnRzV2l0aChcImRhdGE6aW1hZ2UvXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgaW52YWxpZCBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHkgXCInICsgcGxhY2Vob2xkZXIgKyAnXCIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyICE9PSBcImVtcHR5XCIpIHtcbiAgICAgICAgICAgIGlmICh3aWR0aEludCAmJiBoZWlnaHRJbnQgJiYgd2lkdGhJbnQgKiBoZWlnaHRJbnQgPCAxNjAwKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyBzbWFsbGVyIHRoYW4gNDB4NDAuIENvbnNpZGVyIHJlbW92aW5nIHRoZSBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09IFwiYmx1clwiICYmICFibHVyRGF0YVVSTCkge1xuICAgICAgICAgICAgY29uc3QgVkFMSURfQkxVUl9FWFQgPSBbXG4gICAgICAgICAgICAgICAgXCJqcGVnXCIsXG4gICAgICAgICAgICAgICAgXCJwbmdcIixcbiAgICAgICAgICAgICAgICBcIndlYnBcIixcbiAgICAgICAgICAgICAgICBcImF2aWZcIlxuICAgICAgICAgICAgXSAvLyBzaG91bGQgbWF0Y2ggbmV4dC1pbWFnZS1sb2FkZXJcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBcInBsYWNlaG9sZGVyPVxcJ2JsdXJcXCdcIiBwcm9wZXJ0eSBidXQgaXMgbWlzc2luZyB0aGUgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LlxcbiAgICAgICAgUG9zc2libGUgc29sdXRpb25zOlxcbiAgICAgICAgICAtIEFkZCBhIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eSwgdGhlIGNvbnRlbnRzIHNob3VsZCBiZSBhIHNtYWxsIERhdGEgVVJMIHRvIHJlcHJlc2VudCB0aGUgaW1hZ2VcXG4gICAgICAgICAgLSBDaGFuZ2UgdGhlIFwic3JjXCIgcHJvcGVydHkgdG8gYSBzdGF0aWMgaW1wb3J0IHdpdGggb25lIG9mIHRoZSBzdXBwb3J0ZWQgZmlsZSB0eXBlczogJyArIFZBTElEX0JMVVJfRVhULmpvaW4oXCIsXCIpICsgJyAoYW5pbWF0ZWQgaW1hZ2VzIG5vdCBzdXBwb3J0ZWQpXFxuICAgICAgICAgIC0gUmVtb3ZlIHRoZSBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHksIGVmZmVjdGl2ZWx5IG5vIGJsdXIgZWZmZWN0XFxuICAgICAgICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3BsYWNlaG9sZGVyLWJsdXItZGF0YS11cmwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJyZWZcIiBpbiByZXN0KSB7XG4gICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIHVzaW5nIHVuc3VwcG9ydGVkIFwicmVmXCIgcHJvcGVydHkuIENvbnNpZGVyIHVzaW5nIHRoZSBcIm9uTG9hZFwiIHByb3BlcnR5IGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1bm9wdGltaXplZCAmJiAhaXNEZWZhdWx0TG9hZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB1cmxTdHIgPSBsb2FkZXIoe1xuICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoSW50IHx8IDQwMCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5OiBxdWFsaXR5SW50IHx8IDc1XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCB1cmw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHVybCA9IG5ldyBVUkwodXJsU3RyKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIGlmICh1cmxTdHIgPT09IHNyYyB8fCB1cmwgJiYgdXJsLnBhdGhuYW1lID09PSBzcmMgJiYgIXVybC5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBhIFwibG9hZGVyXCIgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgd2lkdGguIFBsZWFzZSBpbXBsZW1lbnQgaXQgb3IgdXNlIHRoZSBcInVub3B0aW1pemVkXCIgcHJvcGVydHkgaW5zdGVhZC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXItd2lkdGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIHVzaW5nIGRlcHJlY2F0ZWQgXCJvbkxvYWRpbmdDb21wbGV0ZVwiIHByb3BlcnR5LiBQbGVhc2UgdXNlIHRoZSBcIm9uTG9hZFwiIHByb3BlcnR5IGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbbGVnYWN5S2V5LCBsZWdhY3lWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgb2JqZWN0Rml0LFxuICAgICAgICAgICAgb2JqZWN0UG9zaXRpb24sXG4gICAgICAgICAgICBsYXp5Qm91bmRhcnksXG4gICAgICAgICAgICBsYXp5Um9vdFxuICAgICAgICB9KSl7XG4gICAgICAgICAgICBpZiAobGVnYWN5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBsZWdhY3kgcHJvcCBcIicgKyBsZWdhY3lLZXkgKyAnXCIuIERpZCB5b3UgZm9yZ2V0IHRvIHJ1biB0aGUgY29kZW1vZD8nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtdXBncmFkZS10by0xM1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhcGVyZk9ic2VydmVyICYmIHdpbmRvdy5QZXJmb3JtYW5jZU9ic2VydmVyKSB7XG4gICAgICAgICAgICBwZXJmT2JzZXJ2ZXIgPSBuZXcgUGVyZm9ybWFuY2VPYnNlcnZlcigoZW50cnlMaXN0KT0+e1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cnlMaXN0LmdldEVudHJpZXMoKSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZW50cnlfZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIG1pc3NpbmcgXCJMYXJnZXN0Q29udGVudGZ1bFBhaW50XCIgY2xhc3Mgd2l0aCBcImVsZW1lbnRcIiBwcm9wXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ1NyYyA9IChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9lbnRyeV9lbGVtZW50ID0gZW50cnkuZWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbnRyeV9lbGVtZW50LnNyYykgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGNwSW1hZ2UgPSBhbGxJbWdzLmdldChpbWdTcmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGNwSW1hZ2UgJiYgIWxjcEltYWdlLnByaW9yaXR5ICYmIGxjcEltYWdlLnBsYWNlaG9sZGVyID09PSBcImVtcHR5XCIgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKFwiZGF0YTpcIikgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKFwiYmxvYjpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd2ViLmRldi9sY3AvI21lYXN1cmUtbGNwLWluLWphdmFzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBsY3BJbWFnZS5zcmMgKyAnXCIgd2FzIGRldGVjdGVkIGFzIHRoZSBMYXJnZXN0IENvbnRlbnRmdWwgUGFpbnQgKExDUCkuIFBsZWFzZSBhZGQgdGhlIFwicHJpb3JpdHlcIiBwcm9wZXJ0eSBpZiB0aGlzIGltYWdlIGlzIGFib3ZlIHRoZSBmb2xkLicgKyBcIlxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3ByaW9yaXR5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJsYXJnZXN0LWNvbnRlbnRmdWwtcGFpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciBidXQgZG9uJ3QgY3Jhc2ggdGhlIGFwcFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbWdTdHlsZSA9IE9iamVjdC5hc3NpZ24oZmlsbCA/IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIG9iamVjdEZpdCxcbiAgICAgICAgb2JqZWN0UG9zaXRpb25cbiAgICB9IDoge30sIHNob3dBbHRUZXh0ID8ge30gOiB7XG4gICAgICAgIGNvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICB9LCBzdHlsZSk7XG4gICAgY29uc3QgYmFja2dyb3VuZEltYWdlID0gIWJsdXJDb21wbGV0ZSAmJiBwbGFjZWhvbGRlciAhPT0gXCJlbXB0eVwiID8gcGxhY2Vob2xkZXIgPT09IFwiYmx1clwiID8gJ3VybChcImRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LCcgKyAoMCwgX2ltYWdlYmx1cnN2Zy5nZXRJbWFnZUJsdXJTdmcpKHtcbiAgICAgICAgd2lkdGhJbnQsXG4gICAgICAgIGhlaWdodEludCxcbiAgICAgICAgYmx1cldpZHRoLFxuICAgICAgICBibHVySGVpZ2h0LFxuICAgICAgICBibHVyRGF0YVVSTDogYmx1ckRhdGFVUkwgfHwgXCJcIixcbiAgICAgICAgb2JqZWN0Rml0OiBpbWdTdHlsZS5vYmplY3RGaXRcbiAgICB9KSArICdcIiknIDogJ3VybChcIicgKyBwbGFjZWhvbGRlciArICdcIiknIC8vIGFzc3VtZSBgZGF0YTppbWFnZS9gXG4gICAgIDogbnVsbDtcbiAgICBsZXQgcGxhY2Vob2xkZXJTdHlsZSA9IGJhY2tncm91bmRJbWFnZSA/IHtcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IGltZ1N0eWxlLm9iamVjdEZpdCB8fCBcImNvdmVyXCIsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogaW1nU3R5bGUub2JqZWN0UG9zaXRpb24gfHwgXCI1MCUgNTAlXCIsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwibm8tcmVwZWF0XCIsXG4gICAgICAgIGJhY2tncm91bmRJbWFnZVxuICAgIH0gOiB7fTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBpZiAocGxhY2Vob2xkZXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgJiYgcGxhY2Vob2xkZXIgPT09IFwiYmx1clwiICYmIChibHVyRGF0YVVSTCA9PSBudWxsID8gdm9pZCAwIDogYmx1ckRhdGFVUkwuc3RhcnRzV2l0aChcIi9cIikpKSB7XG4gICAgICAgICAgICAvLyBEdXJpbmcgYG5leHQgZGV2YCwgd2UgZG9uJ3Qgd2FudCB0byBnZW5lcmF0ZSBibHVyIHBsYWNlaG9sZGVycyB3aXRoIHdlYnBhY2tcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgY2FuIGRlbGF5IHN0YXJ0aW5nIHRoZSBkZXYgc2VydmVyLiBJbnN0ZWFkLCBgbmV4dC1pbWFnZS1sb2FkZXIuanNgXG4gICAgICAgICAgICAvLyB3aWxsIGlubGluZSBhIHNwZWNpYWwgdXJsIHRvIGxhemlseSBnZW5lcmF0ZSB0aGUgYmx1ciBwbGFjZWhvbGRlciBhdCByZXF1ZXN0IHRpbWUuXG4gICAgICAgICAgICBwbGFjZWhvbGRlclN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXCInICsgYmx1ckRhdGFVUkwgKyAnXCIpJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbWdBdHRyaWJ1dGVzID0gZ2VuZXJhdGVJbWdBdHRycyh7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgc3JjLFxuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgd2lkdGg6IHdpZHRoSW50LFxuICAgICAgICBxdWFsaXR5OiBxdWFsaXR5SW50LFxuICAgICAgICBzaXplcyxcbiAgICAgICAgbG9hZGVyXG4gICAgfSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IGZ1bGxVcmw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsSW1ncy5zZXQoZnVsbFVybC5ocmVmLCB7XG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgbG9hZGluZzogaXNMYXp5ID8gXCJsYXp5XCIgOiBsb2FkaW5nLFxuICAgICAgICBmZXRjaFByaW9yaXR5LFxuICAgICAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0SW50LFxuICAgICAgICBkZWNvZGluZzogXCJhc3luY1wiLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5pbWdTdHlsZSxcbiAgICAgICAgICAgIC4uLnBsYWNlaG9sZGVyU3R5bGVcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZXM6IGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgICAgIHNyY1NldDogaW1nQXR0cmlidXRlcy5zcmNTZXQsXG4gICAgICAgIHNyYzogaW1nQXR0cmlidXRlcy5zcmNcbiAgICB9O1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIGZpbGxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzLFxuICAgICAgICBtZXRhXG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWltZy1wcm9wcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0SW1nUHJvcHMiLCJfd2Fybm9uY2UiLCJyZXF1aXJlIiwiX2ltYWdlYmx1cnN2ZyIsIl9pbWFnZWNvbmZpZyIsIlZBTElEX0xPQURJTkdfVkFMVUVTIiwidW5kZWZpbmVkIiwiaXNTdGF0aWNSZXF1aXJlIiwic3JjIiwiZGVmYXVsdCIsImlzU3RhdGljSW1hZ2VEYXRhIiwiaXNTdGF0aWNJbXBvcnQiLCJhbGxJbWdzIiwiTWFwIiwicGVyZk9ic2VydmVyIiwiZ2V0SW50IiwieCIsIk51bWJlciIsImlzRmluaXRlIiwiTmFOIiwidGVzdCIsInBhcnNlSW50IiwiZ2V0V2lkdGhzIiwicGFyYW0iLCJ3aWR0aCIsInNpemVzIiwiZGV2aWNlU2l6ZXMiLCJhbGxTaXplcyIsInZpZXdwb3J0V2lkdGhSZSIsInBlcmNlbnRTaXplcyIsIm1hdGNoIiwiZXhlYyIsInB1c2giLCJsZW5ndGgiLCJzbWFsbGVzdFJhdGlvIiwiTWF0aCIsIm1pbiIsIndpZHRocyIsImZpbHRlciIsInMiLCJraW5kIiwiU2V0IiwibWFwIiwidyIsImZpbmQiLCJwIiwiZ2VuZXJhdGVJbWdBdHRycyIsImNvbmZpZyIsInVub3B0aW1pemVkIiwicXVhbGl0eSIsImxvYWRlciIsInNyY1NldCIsImxhc3QiLCJpIiwiam9pbiIsIl9zdGF0ZSIsInByaW9yaXR5IiwibG9hZGluZyIsImNsYXNzTmFtZSIsImhlaWdodCIsImZpbGwiLCJzdHlsZSIsIm9uTG9hZCIsIm9uTG9hZGluZ0NvbXBsZXRlIiwicGxhY2Vob2xkZXIiLCJibHVyRGF0YVVSTCIsImZldGNoUHJpb3JpdHkiLCJsYXlvdXQiLCJvYmplY3RGaXQiLCJvYmplY3RQb3NpdGlvbiIsImxhenlCb3VuZGFyeSIsImxhenlSb290IiwicmVzdCIsImltZ0NvbmYiLCJzaG93QWx0VGV4dCIsImJsdXJDb21wbGV0ZSIsImRlZmF1bHRMb2FkZXIiLCJjIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiaW1hZ2VTaXplcyIsInNvcnQiLCJhIiwiYiIsImlzRGVmYXVsdExvYWRlciIsIkVycm9yIiwiY3VzdG9tSW1hZ2VMb2FkZXIiLCJvYmoiLCJfIiwib3B0cyIsImxheW91dFRvU3R5bGUiLCJpbnRyaW5zaWMiLCJtYXhXaWR0aCIsInJlc3BvbnNpdmUiLCJsYXlvdXRUb1NpemVzIiwibGF5b3V0U3R5bGUiLCJsYXlvdXRTaXplcyIsInN0YXRpY1NyYyIsIndpZHRoSW50IiwiaGVpZ2h0SW50IiwiYmx1cldpZHRoIiwiYmx1ckhlaWdodCIsInN0YXRpY0ltYWdlRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyYXRpbyIsInJvdW5kIiwiaXNMYXp5Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwiZGFuZ2Vyb3VzbHlBbGxvd1NWRyIsInF1YWxpdHlJbnQiLCJwcm9jZXNzIiwib3V0cHV0IiwicG9zaXRpb24iLCJpc05hTiIsImluY2x1ZGVzIiwiU3RyaW5nIiwid2Fybk9uY2UiLCJWQUxJRF9CTFVSX0VYVCIsInVybFN0ciIsInVybCIsIlVSTCIsImVyciIsInBhdGhuYW1lIiwic2VhcmNoIiwibGVnYWN5S2V5IiwibGVnYWN5VmFsdWUiLCJlbnRyaWVzIiwid2luZG93IiwiUGVyZm9ybWFuY2VPYnNlcnZlciIsImVudHJ5TGlzdCIsImVudHJ5IiwiZ2V0RW50cmllcyIsIl9lbnRyeV9lbGVtZW50IiwiaW1nU3JjIiwiZWxlbWVudCIsImxjcEltYWdlIiwib2JzZXJ2ZSIsInR5cGUiLCJidWZmZXJlZCIsImNvbnNvbGUiLCJlcnJvciIsImltZ1N0eWxlIiwiYXNzaWduIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiY29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJnZXRJbWFnZUJsdXJTdmciLCJwbGFjZWhvbGRlclN0eWxlIiwiYmFja2dyb3VuZFNpemUiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwiaW1nQXR0cmlidXRlcyIsImZ1bGxVcmwiLCJlIiwibG9jYXRpb24iLCJocmVmIiwic2V0IiwicHJvcHMiLCJkZWNvZGluZyIsIm1ldGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    defaultHead: function() {\n        return defaultHead;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                const srcMessage = c.props[\"src\"] ? '<script> tag with src=\"' + c.props[\"src\"] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props[\"href\"] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiJxREFFYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsYUFBYTtRQUNULE9BQU9BO0lBQ1g7SUFDQUMsU0FBUztRQUNMLE9BQU9PO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLDRCQUE0QkQsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxNQUFNRyxTQUFTLFdBQVcsR0FBR0YsMEJBQTBCRyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLG1GQUFPO0FBQ3hFLE1BQU1LLGNBQWMsV0FBVyxHQUFHTix5QkFBeUJLLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsNkZBQWU7QUFDcEYsTUFBTU0sMkJBQTJCTixtQkFBT0EsQ0FBQywySEFBOEI7QUFDdkUsTUFBTU8sbUNBQW1DUCxtQkFBT0EsQ0FBQyw2SUFBdUM7QUFDeEYsTUFBTVEsV0FBV1IsbUJBQU9BLENBQUMsdUZBQVk7QUFDckMsTUFBTVMsWUFBWVQsbUJBQU9BLENBQUMscUdBQW1CO0FBQzdDLFNBQVNWLFlBQVlvQixTQUFTO0lBQzFCLElBQUlBLGNBQWMsS0FBSyxHQUFHQSxZQUFZO0lBQ3RDLE1BQU1DLE9BQU87UUFDVCxXQUFXLEdBQUksSUFBR1QsWUFBWVUsR0FBRyxFQUFFLFFBQVE7WUFDdkND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VSxFQUFFakUseUJBQXlCa0UsZUFBZTtJQUNoRixNQUFNQyxjQUFjLENBQUMsR0FBR3RFLE9BQU9vRSxVQUFVLEVBQUVoRSxpQ0FBaUNtRSxrQkFBa0I7SUFDOUYsT0FBcUIsV0FBSCxHQUFJLElBQUd4RSxZQUFZVSxHQUFHLEVBQUVQLFlBQVlkLE9BQU8sRUFBRTtRQUMzRG9GLHlCQUF5QnhCO1FBQ3pCc0IsYUFBYUE7UUFDYi9ELFdBQVcsQ0FBQyxHQUFHRixTQUFTb0UsV0FBVyxFQUFFTjtRQUNyQzdDLFVBQVVBO0lBQ2Q7QUFDSjtLQVZhMkM7QUFXYixNQUFNdEUsV0FBV3NFO0FBRWpCLElBQUksQ0FBQyxPQUFPakYsUUFBUUksT0FBTyxLQUFLLGNBQWUsT0FBT0osUUFBUUksT0FBTyxLQUFLLFlBQVlKLFFBQVFJLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0osUUFBUUksT0FBTyxDQUFDc0YsVUFBVSxLQUFLLGFBQWE7SUFDcks1RixPQUFPQyxjQUFjLENBQUNDLFFBQVFJLE9BQU8sRUFBRSxjQUFjO1FBQUVILE9BQU87SUFBSztJQUNuRUgsT0FBTzZGLE1BQU0sQ0FBQzNGLFFBQVFJLE9BQU8sRUFBRUo7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUUksT0FBTztBQUNsQyxFQUVBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaGVhZC5qcz9mYjVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRlZmF1bHRIZWFkOiBudWxsLFxuICAgIGRlZmF1bHQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZGVmYXVsdEhlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEhlYWQ7XG4gICAgfSxcbiAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9zaWRlZWZmZWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9zaWRlLWVmZmVjdFwiKSk7XG5jb25zdCBfYW1wY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4vaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfYW1wbW9kZSA9IHJlcXVpcmUoXCIuL2FtcC1tb2RlXCIpO1xuY29uc3QgX3dhcm5vbmNlID0gcmVxdWlyZShcIi4vdXRpbHMvd2Fybi1vbmNlXCIpO1xuZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlKSB7XG4gICAgaWYgKGluQW1wTW9kZSA9PT0gdm9pZCAwKSBpbkFtcE1vZGUgPSBmYWxzZTtcbiAgICBjb25zdCBoZWFkID0gW1xuICAgICAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibWV0YVwiLCB7XG4gICAgICAgICAgICBjaGFyU2V0OiBcInV0Zi04XCJcbiAgICAgICAgfSlcbiAgICBdO1xuICAgIGlmICghaW5BbXBNb2RlKSB7XG4gICAgICAgIGhlYWQucHVzaCgvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibWV0YVwiLCB7XG4gICAgICAgICAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIndpZHRoPWRldmljZS13aWR0aFwiXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWQ7XG59XG5mdW5jdGlvbiBvbmx5UmVhY3RFbGVtZW50KGxpc3QsIGNoaWxkKSB7XG4gICAgLy8gUmVhY3QgY2hpbGRyZW4gY2FuIGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIiBpbiB0aGlzIGNhc2Ugd2UgaWdub3JlIHRoZW0gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjaGlsZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgLy8gQWRkcyBzdXBwb3J0IGZvciBSZWFjdC5GcmFnbWVudFxuICAgIGlmIChjaGlsZC50eXBlID09PSBfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gbGlzdC5jb25jYXQoLy8gQHRzLWV4cGVjdC1lcnJvciBAdHlwZXMvcmVhY3QgZG9lcyBub3QgcmVtb3ZlIGZyYWdtZW50cyBidXQgdGhpcyBjb3VsZCBhbHNvIHJldHVybiBSZWFjdFBvcnRhbFtdXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGQucHJvcHMuY2hpbGRyZW4pLnJlZHVjZSgvLyBAdHMtZXhwZWN0LWVycm9yIEB0eXBlcy9yZWFjdCBkb2VzIG5vdCByZW1vdmUgZnJhZ21lbnRzIGJ1dCB0aGlzIGNvdWxkIGFsc28gcmV0dXJuIFJlYWN0UG9ydGFsW11cbiAgICAgICAgKGZyYWdtZW50TGlzdCwgZnJhZ21lbnRDaGlsZCk9PntcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0LmNvbmNhdChmcmFnbWVudENoaWxkKTtcbiAgICAgICAgfSwgW10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KGNoaWxkKTtcbn1cbmNvbnN0IE1FVEFUWVBFUyA9IFtcbiAgICBcIm5hbWVcIixcbiAgICBcImh0dHBFcXVpdlwiLFxuICAgIFwiY2hhclNldFwiLFxuICAgIFwiaXRlbVByb3BcIlxuXTtcbi8qXG4gcmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgaGVhZCBjaGlsZCBlbGVtZW50c1xuIHdoaWNoIHNob3VsZG4ndCBiZSBkdXBsaWNhdGVkLCBsaWtlIDx0aXRsZS8+XG4gQWxzbyBhZGRzIHN1cHBvcnQgZm9yIGRlZHVwbGljYXRlZCBga2V5YCBwcm9wZXJ0aWVzXG4qLyBmdW5jdGlvbiB1bmlxdWUoKSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB0YWdzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1ldGFUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZXRhQ2F0ZWdvcmllcyA9IHt9O1xuICAgIHJldHVybiAoaCk9PntcbiAgICAgICAgbGV0IGlzVW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhhc0tleSA9IGZhbHNlO1xuICAgICAgICBpZiAoaC5rZXkgJiYgdHlwZW9mIGgua2V5ICE9PSBcIm51bWJlclwiICYmIGgua2V5LmluZGV4T2YoXCIkXCIpID4gMCkge1xuICAgICAgICAgICAgaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGgua2V5LnNsaWNlKGgua2V5LmluZGV4T2YoXCIkXCIpICsgMSk7XG4gICAgICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICBzd2l0Y2goaC50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgICAgICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3MuYWRkKGgudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSBNRVRBVFlQRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhdHlwZSA9IE1FVEFUWVBFU1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoLnByb3BzLmhhc093blByb3BlcnR5KG1ldGF0eXBlKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhdHlwZSA9PT0gXCJjaGFyU2V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFUeXBlcy5hZGQobWV0YXR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBoLnByb3BzW21ldGF0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gfHwgbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gXCJuYW1lXCIgfHwgIWhhc0tleSkgJiYgY2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5hZGQoY2F0ZWdvcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSA9IGNhdGVnb3JpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVW5pcXVlO1xuICAgIH07XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gaGVhZENoaWxkcmVuRWxlbWVudHMgTGlzdCBvZiBjaGlsZHJlbiBvZiA8SGVhZD5cbiAqLyBmdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzKGhlYWRDaGlsZHJlbkVsZW1lbnRzLCBwcm9wcykge1xuICAgIGNvbnN0IHsgaW5BbXBNb2RlIH0gPSBwcm9wcztcbiAgICByZXR1cm4gaGVhZENoaWxkcmVuRWxlbWVudHMucmVkdWNlKG9ubHlSZWFjdEVsZW1lbnQsIFtdKS5yZXZlcnNlKCkuY29uY2F0KGRlZmF1bHRIZWFkKGluQW1wTW9kZSkucmV2ZXJzZSgpKS5maWx0ZXIodW5pcXVlKCkpLnJldmVyc2UoKS5tYXAoKGMsIGkpPT57XG4gICAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiICYmIHByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlaRV9GT05UUyAmJiAhaW5BbXBNb2RlKSB7XG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSBcImxpbmtcIiAmJiBjLnByb3BzW1wiaHJlZlwiXSAmJiAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzXCIsXG4gICAgICAgICAgICAgICAgXCJodHRwczovL3VzZS50eXBla2l0Lm5ldC9cIlxuICAgICAgICAgICAgXS5zb21lKCh1cmwpPT5jLnByb3BzW1wiaHJlZlwiXS5zdGFydHNXaXRoKHVybCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmMucHJvcHMgfHwge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiZGF0YS1ocmVmXCJdID0gbmV3UHJvcHNbXCJocmVmXCJdO1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiaHJlZlwiXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBhdHRyaWJ1dGUgdG8gbWFrZSBpdCBlYXN5IHRvIGlkZW50aWZ5IG9wdGltaXplZCB0YWdzXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbXCJkYXRhLW9wdGltaXplZC1mb250c1wiXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgLy8gb21pdCBKU09OLUxEIHN0cnVjdHVyZWQgZGF0YSBzbmlwcGV0cyBmcm9tIHRoZSB3YXJuaW5nXG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSBcInNjcmlwdFwiICYmIGMucHJvcHNbXCJ0eXBlXCJdICE9PSBcImFwcGxpY2F0aW9uL2xkK2pzb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNyY01lc3NhZ2UgPSBjLnByb3BzW1wic3JjXCJdID8gJzxzY3JpcHQ+IHRhZyB3aXRoIHNyYz1cIicgKyBjLnByb3BzW1wic3JjXCJdICsgJ1wiJyA6IFwiaW5saW5lIDxzY3JpcHQ+XCI7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoXCJEbyBub3QgYWRkIDxzY3JpcHQ+IHRhZ3MgdXNpbmcgbmV4dC9oZWFkIChzZWUgXCIgKyBzcmNNZXNzYWdlICsgXCIpLiBVc2UgbmV4dC9zY3JpcHQgaW5zdGVhZC4gXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uby1zY3JpcHQtdGFncy1pbi1oZWFkLWNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYy50eXBlID09PSBcImxpbmtcIiAmJiBjLnByb3BzW1wicmVsXCJdID09PSBcInN0eWxlc2hlZXRcIikge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdEbyBub3QgYWRkIHN0eWxlc2hlZXRzIHVzaW5nIG5leHQvaGVhZCAoc2VlIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIj4gdGFnIHdpdGggaHJlZj1cIicgKyBjLnByb3BzW1wiaHJlZlwiXSArICdcIikuIFVzZSBEb2N1bWVudCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXN0eWxlc2hlZXRzLWluLWhlYWQtY29tcG9uZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGMsIHtcbiAgICAgICAgICAgIGtleVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaW5qZWN0cyBlbGVtZW50cyB0byBgPGhlYWQ+YCBvZiB5b3VyIHBhZ2UuXG4gKiBUbyBhdm9pZCBkdXBsaWNhdGVkIGB0YWdzYCBpbiBgPGhlYWQ+YCB5b3UgY2FuIHVzZSB0aGUgYGtleWAgcHJvcGVydHksIHdoaWNoIHdpbGwgbWFrZSBzdXJlIGV2ZXJ5IHRhZyBpcyBvbmx5IHJlbmRlcmVkIG9uY2UuXG4gKi8gZnVuY3Rpb24gSGVhZChwYXJhbSkge1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJhbTtcbiAgICBjb25zdCBhbXBTdGF0ZSA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2FtcGNvbnRleHRzaGFyZWRydW50aW1lLkFtcFN0YXRlQ29udGV4dCk7XG4gICAgY29uc3QgaGVhZE1hbmFnZXIgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lLkhlYWRNYW5hZ2VyQ29udGV4dCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX3NpZGVlZmZlY3QuZGVmYXVsdCwge1xuICAgICAgICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogcmVkdWNlQ29tcG9uZW50cyxcbiAgICAgICAgaGVhZE1hbmFnZXI6IGhlYWRNYW5hZ2VyLFxuICAgICAgICBpbkFtcE1vZGU6ICgwLCBfYW1wbW9kZS5pc0luQW1wTW9kZSkoYW1wU3RhdGUpLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn1cbmNvbnN0IF9kZWZhdWx0ID0gSGVhZDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJkZWZhdWx0SGVhZCIsImRlZmF1bHQiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX2pzeHJ1bnRpbWUiLCJfcmVhY3QiLCJfIiwiX3NpZGVlZmZlY3QiLCJfYW1wY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfaGVhZG1hbmFnZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9hbXBtb2RlIiwiX3dhcm5vbmNlIiwiaW5BbXBNb2RlIiwiaGVhZCIsImpzeCIsImNoYXJTZXQiLCJwdXNoIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJ0eXBlIiwiRnJhZ21lbnQiLCJjb25jYXQiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJwcm9wcyIsImNoaWxkcmVuIiwicmVkdWNlIiwiZnJhZ21lbnRMaXN0IiwiZnJhZ21lbnRDaGlsZCIsIk1FVEFUWVBFUyIsInVuaXF1ZSIsImtleXMiLCJTZXQiLCJ0YWdzIiwibWV0YVR5cGVzIiwibWV0YUNhdGVnb3JpZXMiLCJoIiwiaXNVbmlxdWUiLCJoYXNLZXkiLCJrZXkiLCJpbmRleE9mIiwic2xpY2UiLCJoYXMiLCJhZGQiLCJpIiwibGVuIiwibGVuZ3RoIiwibWV0YXR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhdGVnb3J5IiwiY2F0ZWdvcmllcyIsInJlZHVjZUNvbXBvbmVudHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInJldmVyc2UiLCJmaWx0ZXIiLCJtYXAiLCJjIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9PUFRJTUlaRV9GT05UUyIsInNvbWUiLCJ1cmwiLCJzdGFydHNXaXRoIiwibmV3UHJvcHMiLCJ1bmRlZmluZWQiLCJjbG9uZUVsZW1lbnQiLCJzcmNNZXNzYWdlIiwid2Fybk9uY2UiLCJIZWFkIiwicGFyYW0iLCJhbXBTdGF0ZSIsInVzZUNvbnRleHQiLCJBbXBTdGF0ZUNvbnRleHQiLCJoZWFkTWFuYWdlciIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiaXNJbkFtcE1vZGUiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : \"\";\n    const preserveAspectRatio = viewBox ? \"none\" : objectFit === \"contain\" ? \"xMidYMid\" : objectFit === \"cover\" ? \"xMidYMid slice\" : \"none\";\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUFnQjtBQUNqQkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNBLGdCQUFnQkMsS0FBSztJQUMxQixJQUFJLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUUsR0FBR047SUFDN0UsTUFBTU8sTUFBTTtJQUNaLE1BQU1DLFdBQVdMLFlBQVlBLFlBQVksS0FBS0Y7SUFDOUMsTUFBTVEsWUFBWUwsYUFBYUEsYUFBYSxLQUFLRjtJQUNqRCxNQUFNUSxVQUFVRixZQUFZQyxZQUFZLGtCQUFrQkQsV0FBVyxNQUFNQyxZQUFZLE1BQU07SUFDN0YsTUFBTUUsc0JBQXNCRCxVQUFVLFNBQVNKLGNBQWMsWUFBWSxhQUFhQSxjQUFjLFVBQVUsbUJBQW1CO0lBQ2pJLE9BQU8sK0NBQStDSSxVQUFVLDhGQUE4RkgsTUFBTSxvUUFBb1FBLE1BQU0sZ0dBQWdHSSxzQkFBc0Isd0NBQXdDTixjQUFjO0FBQzlsQixFQUVBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmcuanM/OTU3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgc2hhcmVkIGZ1bmN0aW9uLCB1c2VkIG9uIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIsIHRvIGdlbmVyYXRlIGEgU1ZHIGJsdXIgcGxhY2Vob2xkZXIuXG4gKi8gXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJbWFnZUJsdXJTdmdcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEltYWdlQmx1clN2ZztcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGdldEltYWdlQmx1clN2ZyhwYXJhbSkge1xuICAgIGxldCB7IHdpZHRoSW50LCBoZWlnaHRJbnQsIGJsdXJXaWR0aCwgYmx1ckhlaWdodCwgYmx1ckRhdGFVUkwsIG9iamVjdEZpdCB9ID0gcGFyYW07XG4gICAgY29uc3Qgc3RkID0gMjA7XG4gICAgY29uc3Qgc3ZnV2lkdGggPSBibHVyV2lkdGggPyBibHVyV2lkdGggKiA0MCA6IHdpZHRoSW50O1xuICAgIGNvbnN0IHN2Z0hlaWdodCA9IGJsdXJIZWlnaHQgPyBibHVySGVpZ2h0ICogNDAgOiBoZWlnaHRJbnQ7XG4gICAgY29uc3Qgdmlld0JveCA9IHN2Z1dpZHRoICYmIHN2Z0hlaWdodCA/IFwidmlld0JveD0nMCAwIFwiICsgc3ZnV2lkdGggKyBcIiBcIiArIHN2Z0hlaWdodCArIFwiJ1wiIDogXCJcIjtcbiAgICBjb25zdCBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gdmlld0JveCA/IFwibm9uZVwiIDogb2JqZWN0Rml0ID09PSBcImNvbnRhaW5cIiA/IFwieE1pZFlNaWRcIiA6IG9iamVjdEZpdCA9PT0gXCJjb3ZlclwiID8gXCJ4TWlkWU1pZCBzbGljZVwiIDogXCJub25lXCI7XG4gICAgcmV0dXJuIFwiJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgXCIgKyB2aWV3Qm94ICsgXCIlM0UlM0NmaWx0ZXIgaWQ9J2InIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0nc1JHQiclM0UlM0NmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249J1wiICsgc3RkICsgXCInLyUzRSUzQ2ZlQ29sb3JNYXRyaXggdmFsdWVzPScxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxMDAgLTEnIHJlc3VsdD0ncycvJTNFJTNDZmVGbG9vZCB4PScwJyB5PScwJyB3aWR0aD0nMTAwJTI1JyBoZWlnaHQ9JzEwMCUyNScvJTNFJTNDZmVDb21wb3NpdGUgb3BlcmF0b3I9J291dCcgaW49J3MnLyUzRSUzQ2ZlQ29tcG9zaXRlIGluMj0nU291cmNlR3JhcGhpYycvJTNFJTNDZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSdcIiArIHN0ZCArIFwiJy8lM0UlM0MvZmlsdGVyJTNFJTNDaW1hZ2Ugd2lkdGg9JzEwMCUyNScgaGVpZ2h0PScxMDAlMjUnIHg9JzAnIHk9JzAnIHByZXNlcnZlQXNwZWN0UmF0aW89J1wiICsgcHJlc2VydmVBc3BlY3RSYXRpbyArIFwiJyBzdHlsZT0nZmlsdGVyOiB1cmwoJTIzYik7JyBocmVmPSdcIiArIGJsdXJEYXRhVVJMICsgXCInLyUzRSUzQy9zdmclM0VcIjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtYmx1ci1zdmcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldEltYWdlQmx1clN2ZyIsInBhcmFtIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0IiwiYmx1ckRhdGFVUkwiLCJvYmplY3RGaXQiLCJzdGQiLCJzdmdXaWR0aCIsInN2Z0hlaWdodCIsInZpZXdCb3giLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function() {\n        return ImageConfigContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = \"ImageConfigContext\";\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDN0MsTUFBTUYscUJBQXFCRyxPQUFPRyxPQUFPLENBQUNDLGFBQWEsQ0FBQ0YsYUFBYUcsa0JBQWtCO0FBQ3ZGLElBQUlDLElBQXFDLEVBQUU7SUFDdkNULG1CQUFtQlUsV0FBVyxHQUFHO0FBQ3JDLEVBRUEsK0RBQStEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcz8yNzhiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1hZ2VDb25maWdDb250ZXh0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBJbWFnZUNvbmZpZ0NvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX2ltYWdlY29uZmlnID0gcmVxdWlyZShcIi4vaW1hZ2UtY29uZmlnXCIpO1xuY29uc3QgSW1hZ2VDb25maWdDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChfaW1hZ2Vjb25maWcuaW1hZ2VDb25maWdEZWZhdWx0KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBJbWFnZUNvbmZpZ0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIkltYWdlQ29uZmlnQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJfaW1hZ2Vjb25maWciLCJkZWZhdWx0IiwiY3JlYXRlQ29udGV4dCIsImltYWdlQ29uZmlnRGVmYXVsdCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function() {\n        return imageConfigDefault;\n    }\n});\nconst VALID_LOADERS = [\n    \"default\",\n    \"imgix\",\n    \"cloudinary\",\n    \"akamai\",\n    \"custom\"\n];\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: \"/_next/image\",\n    loader: \"default\",\n    loaderFile: \"\",\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        \"image/webp\"\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: \"inline\",\n    remotePatterns: [],\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLG9CQUFvQjtRQUNoQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNRCxnQkFBZ0I7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMscUJBQXFCO0lBQ3ZCTyxhQUFhO1FBQ1Q7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0RDLFlBQVk7UUFDUjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDREMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFlBQVk7SUFDWkMsU0FBUyxFQUFFO0lBQ1hDLHFCQUFxQjtJQUNyQkMsaUJBQWlCO0lBQ2pCQyxTQUFTO1FBQ0w7S0FDSDtJQUNEQyxxQkFBcUI7SUFDckJDLHVCQUF1QjtJQUN2QkMsd0JBQXdCO0lBQ3hCQyxnQkFBZ0IsRUFBRTtJQUNsQkMsYUFBYTtBQUNqQixHQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLmpzPzMxMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBWQUxJRF9MT0FERVJTOiBudWxsLFxuICAgIGltYWdlQ29uZmlnRGVmYXVsdDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBWQUxJRF9MT0FERVJTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFZBTElEX0xPQURFUlM7XG4gICAgfSxcbiAgICBpbWFnZUNvbmZpZ0RlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW1hZ2VDb25maWdEZWZhdWx0O1xuICAgIH1cbn0pO1xuY29uc3QgVkFMSURfTE9BREVSUyA9IFtcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImltZ2l4XCIsXG4gICAgXCJjbG91ZGluYXJ5XCIsXG4gICAgXCJha2FtYWlcIixcbiAgICBcImN1c3RvbVwiXG5dO1xuY29uc3QgaW1hZ2VDb25maWdEZWZhdWx0ID0ge1xuICAgIGRldmljZVNpemVzOiBbXG4gICAgICAgIDY0MCxcbiAgICAgICAgNzUwLFxuICAgICAgICA4MjgsXG4gICAgICAgIDEwODAsXG4gICAgICAgIDEyMDAsXG4gICAgICAgIDE5MjAsXG4gICAgICAgIDIwNDgsXG4gICAgICAgIDM4NDBcbiAgICBdLFxuICAgIGltYWdlU2l6ZXM6IFtcbiAgICAgICAgMTYsXG4gICAgICAgIDMyLFxuICAgICAgICA0OCxcbiAgICAgICAgNjQsXG4gICAgICAgIDk2LFxuICAgICAgICAxMjgsXG4gICAgICAgIDI1NixcbiAgICAgICAgMzg0XG4gICAgXSxcbiAgICBwYXRoOiBcIi9fbmV4dC9pbWFnZVwiLFxuICAgIGxvYWRlcjogXCJkZWZhdWx0XCIsXG4gICAgbG9hZGVyRmlsZTogXCJcIixcbiAgICBkb21haW5zOiBbXSxcbiAgICBkaXNhYmxlU3RhdGljSW1hZ2VzOiBmYWxzZSxcbiAgICBtaW5pbXVtQ2FjaGVUVEw6IDYwLFxuICAgIGZvcm1hdHM6IFtcbiAgICAgICAgXCJpbWFnZS93ZWJwXCJcbiAgICBdLFxuICAgIGRhbmdlcm91c2x5QWxsb3dTVkc6IGZhbHNlLFxuICAgIGNvbnRlbnRTZWN1cml0eVBvbGljeTogXCJzY3JpcHQtc3JjICdub25lJzsgZnJhbWUtc3JjICdub25lJzsgc2FuZGJveDtcIixcbiAgICBjb250ZW50RGlzcG9zaXRpb25UeXBlOiBcImlubGluZVwiLFxuICAgIHJlbW90ZVBhdHRlcm5zOiBbXSxcbiAgICB1bm9wdGltaXplZDogZmFsc2Vcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJWQUxJRF9MT0FERVJTIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGV2aWNlU2l6ZXMiLCJpbWFnZVNpemVzIiwicGF0aCIsImxvYWRlciIsImxvYWRlckZpbGUiLCJkb21haW5zIiwiZGlzYWJsZVN0YXRpY0ltYWdlcyIsIm1pbmltdW1DYWNoZVRUTCIsImZvcm1hdHMiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwiY29udGVudFNlY3VyaXR5UG9saWN5IiwiY29udGVudERpc3Bvc2l0aW9uVHlwZSIsInJlbW90ZVBhdHRlcm5zIiwidW5vcHRpbWl6ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-external.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getImageProps: function() {\n        return getImageProps;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nconst getImageProps = (imgProps)=>{\n    const { props } = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader.default,\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}\n    });\n    // Normally we don't care about undefined props because we pass to JSX,\n    // but this exported function could be used by the end user for anything\n    // so we delete undefined props to clean it up a little.\n    for (const [key, value] of Object.entries(props)){\n        if (value === undefined) {\n            delete props[key];\n        }\n    }\n    return {\n        props\n    };\n};\nconst _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsU0FBUztRQUNMLE9BQU9PO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLGlHQUFpQjtBQUM5QyxNQUFNRSxrQkFBa0JGLG1CQUFPQSxDQUFDLDRHQUE4QjtBQUM5RCxNQUFNRyxlQUFlLFdBQVcsR0FBR0oseUJBQXlCSyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLGtIQUFtQztBQUN6RyxNQUFNVixnQkFBZ0IsQ0FBQ2U7SUFDbkIsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUdMLGFBQWFNLFdBQVcsRUFBRUYsVUFBVTtRQUN0REcsZUFBZUwsYUFBYVosT0FBTztRQUNuQyw0Q0FBNEM7UUFDNUNrQixTQUFTQyw0T0FBNkI7SUFDMUM7SUFDQSx1RUFBdUU7SUFDdkUsd0VBQXdFO0lBQ3hFLHdEQUF3RDtJQUN4RCxLQUFLLE1BQU0sQ0FBQ0csS0FBS3pCLE1BQU0sSUFBSUgsT0FBTzZCLE9BQU8sQ0FBQ1IsT0FBTztRQUM3QyxJQUFJbEIsVUFBVTJCLFdBQVc7WUFDckIsT0FBT1QsS0FBSyxDQUFDTyxJQUFJO1FBQ3JCO0lBQ0o7SUFDQSxPQUFPO1FBQ0hQO0lBQ0o7QUFDSjtBQUNBLE1BQU1SLFdBQVdJLGdCQUFnQmMsS0FBSyxFQUV0QywwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsLmpzPzY4Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRJbWFnZVByb3BzOiBudWxsLFxuICAgIGRlZmF1bHQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZ2V0SW1hZ2VQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbWFnZVByb3BzO1xuICAgIH0sXG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfZ2V0aW1ncHJvcHMgPSByZXF1aXJlKFwiLi9nZXQtaW1nLXByb3BzXCIpO1xuY29uc3QgX2ltYWdlY29tcG9uZW50ID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9pbWFnZS1jb21wb25lbnRcIik7XG5jb25zdCBfaW1hZ2Vsb2FkZXIgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXJcIikpO1xuY29uc3QgZ2V0SW1hZ2VQcm9wcyA9IChpbWdQcm9wcyk9PntcbiAgICBjb25zdCB7IHByb3BzIH0gPSAoMCwgX2dldGltZ3Byb3BzLmdldEltZ1Byb3BzKShpbWdQcm9wcywge1xuICAgICAgICBkZWZhdWx0TG9hZGVyOiBfaW1hZ2Vsb2FkZXIuZGVmYXVsdCxcbiAgICAgICAgLy8gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGRlZmluZSBwbHVnaW5cbiAgICAgICAgaW1nQ29uZjogcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFNcbiAgICB9KTtcbiAgICAvLyBOb3JtYWxseSB3ZSBkb24ndCBjYXJlIGFib3V0IHVuZGVmaW5lZCBwcm9wcyBiZWNhdXNlIHdlIHBhc3MgdG8gSlNYLFxuICAgIC8vIGJ1dCB0aGlzIGV4cG9ydGVkIGZ1bmN0aW9uIGNvdWxkIGJlIHVzZWQgYnkgdGhlIGVuZCB1c2VyIGZvciBhbnl0aGluZ1xuICAgIC8vIHNvIHdlIGRlbGV0ZSB1bmRlZmluZWQgcHJvcHMgdG8gY2xlYW4gaXQgdXAgYSBsaXR0bGUuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKXtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzXG4gICAgfTtcbn07XG5jb25zdCBfZGVmYXVsdCA9IF9pbWFnZWNvbXBvbmVudC5JbWFnZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtZXh0ZXJuYWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0SW1hZ2VQcm9wcyIsImRlZmF1bHQiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfZ2V0aW1ncHJvcHMiLCJfaW1hZ2Vjb21wb25lbnQiLCJfaW1hZ2Vsb2FkZXIiLCJfIiwiaW1nUHJvcHMiLCJwcm9wcyIsImdldEltZ1Byb3BzIiwiZGVmYXVsdExvYWRlciIsImltZ0NvbmYiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0lNQUdFX09QVFMiLCJrZXkiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwiSW1hZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : \"\");\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNDLGNBQWNDLEtBQUs7SUFDeEIsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxPQUFPLEVBQUUsR0FBR0o7SUFDdEMsSUFBSUssSUFBcUMsRUFBRTtRQUN2QyxNQUFNQyxnQkFBZ0IsRUFBRTtRQUN4Qix5REFBeUQ7UUFDekQsSUFBSSxDQUFDSixLQUFLSSxjQUFjQyxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDSixPQUFPRyxjQUFjQyxJQUFJLENBQUM7UUFDL0IsSUFBSUQsY0FBY0UsTUFBTSxHQUFHLEdBQUc7WUFDMUIsTUFBTSxJQUFJQyxNQUFNLHNDQUFzQ0gsY0FBY0ksSUFBSSxDQUFDLFFBQVEsZ0dBQWdHQyxLQUFLQyxTQUFTLENBQUM7Z0JBQzVMVjtnQkFDQUM7Z0JBQ0FDO1lBQ0o7UUFDSjtRQUNBLElBQUlGLElBQUlXLFVBQVUsQ0FBQyxPQUFPO1lBQ3RCLE1BQU0sSUFBSUosTUFBTSwwQkFBMEJQLE1BQU07UUFDcEQ7UUFDQSxJQUFJLENBQUNBLElBQUlXLFVBQVUsQ0FBQyxRQUFTWixDQUFBQSxPQUFPYSxPQUFPLElBQUliLE9BQU9jLGNBQWMsR0FBRztZQUNuRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0FBLFlBQVksSUFBSUMsSUFBSWY7WUFDeEIsRUFBRSxPQUFPZ0IsS0FBSztnQkFDVkMsUUFBUUMsS0FBSyxDQUFDRjtnQkFDZCxNQUFNLElBQUlULE1BQU0sMEJBQTBCUCxNQUFNO1lBQ3BEO1lBQ0EsSUFBSUcsSUFDK0IsRUFBRTtnQkFDakMsdUVBQXVFO2dCQUN2RSxNQUFNLEVBQUVrQixRQUFRLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsK0dBQXdCO2dCQUNyRCxJQUFJLENBQUNELFNBQVN0QixPQUFPYSxPQUFPLEVBQUViLE9BQU9jLGNBQWMsRUFBRUMsWUFBWTtvQkFDN0QsTUFBTSxJQUFJUCxNQUFNLHVCQUF1QlAsTUFBTSxrQ0FBa0NjLFVBQVVTLFFBQVEsR0FBRyxnRUFBZ0U7Z0JBQ3hLO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT3hCLE9BQU95QixJQUFJLEdBQUcsVUFBVUMsbUJBQW1CekIsT0FBTyxRQUFRQyxRQUFRLFFBQVNDLENBQUFBLFdBQVcsRUFBQyxJQUFNQyxDQUFBQSxNQUE4QixHQUFHLENBQXdDLEdBQUcsRUFBQztBQUNyTDtBQUNBLCtEQUErRDtBQUMvRCwyREFBMkQ7QUFDM0ROLGNBQWM4QixrQkFBa0IsR0FBRztBQUNuQyxNQUFNL0IsV0FBV0MsZUFFakIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanM/YzBhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0O1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gZGVmYXVsdExvYWRlcihwYXJhbSkge1xuICAgIGxldCB7IGNvbmZpZywgc3JjLCB3aWR0aCwgcXVhbGl0eSB9ID0gcGFyYW07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCBtaXNzaW5nVmFsdWVzID0gW107XG4gICAgICAgIC8vIHRoZXNlIHNob3VsZCBhbHdheXMgYmUgcHJvdmlkZWQgYnV0IG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgICAgICBpZiAoIXNyYykgbWlzc2luZ1ZhbHVlcy5wdXNoKFwic3JjXCIpO1xuICAgICAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goXCJ3aWR0aFwiKTtcbiAgICAgICAgaWYgKG1pc3NpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmV4dCBJbWFnZSBPcHRpbWl6YXRpb24gcmVxdWlyZXMgXCIgKyBtaXNzaW5nVmFsdWVzLmpvaW4oXCIsIFwiKSArIFwiIHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgYG5leHQvaW1hZ2VgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKFwiLy9cIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHNyYyBcIicgKyBzcmMgKyAnXCIgb24gYG5leHQvaW1hZ2VgLCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKC8vKSBtdXN0IGJlIGNoYW5nZWQgdG8gYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoXCIvXCIpICYmIChjb25maWcuZG9tYWlucyB8fCBjb25maWcucmVtb3RlUGF0dGVybnMpKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkU3JjO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJyArIHNyYyArICdcIiBvbiBgbmV4dC9pbWFnZWAsIGlmIHVzaW5nIHJlbGF0aXZlIGltYWdlIGl0IG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgc2xhc2ggXCIvXCIgb3IgYmUgYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIiAmJiAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gXCJlZGdlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFzTWF0Y2ggfSA9IHJlcXVpcmUoXCIuL21hdGNoLXJlbW90ZS1wYXR0ZXJuXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzTWF0Y2goY29uZmlnLmRvbWFpbnMsIGNvbmZpZy5yZW1vdGVQYXR0ZXJucywgcGFyc2VkU3JjKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNyYyBwcm9wIChcIiArIHNyYyArICcpIG9uIGBuZXh0L2ltYWdlYCwgaG9zdG5hbWUgXCInICsgcGFyc2VkU3JjLmhvc3RuYW1lICsgJ1wiIGlzIG5vdCBjb25maWd1cmVkIHVuZGVyIGltYWdlcyBpbiB5b3VyIGBuZXh0LmNvbmZpZy5qc2BcXG4nICsgXCJTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1ob3N0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uZmlnLnBhdGggKyBcIj91cmw9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoc3JjKSArIFwiJnc9XCIgKyB3aWR0aCArIFwiJnE9XCIgKyAocXVhbGl0eSB8fCA3NSkgKyAocHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEID8gXCImZHBsPVwiICsgcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEIDogXCJcIik7XG59XG4vLyBXZSB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgdGhlIGltcG9ydCBpcyB0aGUgZGVmYXVsdCBsb2FkZXJcbi8vIG9yIGEgY3VzdG9tIGxvYWRlciBkZWZpbmVkIGJ5IHRoZSB1c2VyIGluIG5leHQuY29uZmlnLmpzXG5kZWZhdWx0TG9hZGVyLl9fbmV4dF9pbWdfZGVmYXVsdCA9IHRydWU7XG5jb25zdCBfZGVmYXVsdCA9IGRlZmF1bHRMb2FkZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RlZmF1bHQiLCJkZWZhdWx0TG9hZGVyIiwicGFyYW0iLCJjb25maWciLCJzcmMiLCJ3aWR0aCIsInF1YWxpdHkiLCJwcm9jZXNzIiwibWlzc2luZ1ZhbHVlcyIsInB1c2giLCJsZW5ndGgiLCJFcnJvciIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhcnRzV2l0aCIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInBhcnNlZFNyYyIsIlVSTCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImVudiIsIk5FWFRfUlVOVElNRSIsImhhc01hdGNoIiwicmVxdWlyZSIsImhvc3RuYW1lIiwicGF0aCIsImVuY29kZVVSSUNvbXBvbmVudCIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIl9fbmV4dF9pbWdfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    },\n    hasMatch: function() {\n        return hasMatch;\n    }\n});\nconst _micromatch = __webpack_require__(/*! next/dist/compiled/micromatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        const actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _micromatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _micromatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\").test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUMsVUFBVTtRQUNOLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLGNBQWNDLG1CQUFPQSxDQUFDLGdIQUErQjtBQUMzRCxTQUFTVCxtQkFBbUJVLE9BQU8sRUFBRUMsR0FBRztJQUNwQyxJQUFJRCxRQUFRRSxRQUFRLEtBQUtDLFdBQVc7UUFDaEMsTUFBTUMsY0FBY0gsSUFBSUMsUUFBUSxDQUFDRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzNDLElBQUlMLFFBQVFFLFFBQVEsS0FBS0UsYUFBYTtZQUNsQyxPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUlKLFFBQVFNLElBQUksS0FBS0gsV0FBVztRQUM1QixJQUFJSCxRQUFRTSxJQUFJLEtBQUtMLElBQUlLLElBQUksRUFBRTtZQUMzQixPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUlOLFFBQVFPLFFBQVEsS0FBS0osV0FBVztRQUNoQyxNQUFNLElBQUlLLE1BQU0sK0NBQStDQyxLQUFLQyxTQUFTLENBQUNWO0lBQ2xGLE9BQU87UUFDSCxJQUFJLENBQUMsQ0FBQyxHQUFHRixZQUFZYSxNQUFNLEVBQUVYLFFBQVFPLFFBQVEsRUFBRUssSUFBSSxDQUFDWCxJQUFJTSxRQUFRLEdBQUc7WUFDL0QsT0FBTztRQUNYO0lBQ0o7SUFDQSxJQUFJTTtJQUNKLElBQUksQ0FBQyxDQUFDLEdBQUdmLFlBQVlhLE1BQU0sRUFBRSxDQUFDRSxvQkFBb0JiLFFBQVFjLFFBQVEsS0FBSyxPQUFPRCxvQkFBb0IsTUFBTUQsSUFBSSxDQUFDWCxJQUFJYSxRQUFRLEdBQUc7UUFDeEgsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBU3ZCLFNBQVN3QixPQUFPLEVBQUVDLGNBQWMsRUFBRWYsR0FBRztJQUMxQyxPQUFPYyxRQUFRRSxJQUFJLENBQUMsQ0FBQ0MsU0FBU2pCLElBQUlNLFFBQVEsS0FBS1csV0FBV0YsZUFBZUMsSUFBSSxDQUFDLENBQUNFLElBQUk3QixtQkFBbUI2QixHQUFHbEI7QUFDN0csRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLmpzPzBjOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRjaFJlbW90ZVBhdHRlcm46IG51bGwsXG4gICAgaGFzTWF0Y2g6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgbWF0Y2hSZW1vdGVQYXR0ZXJuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoUmVtb3RlUGF0dGVybjtcbiAgICB9LFxuICAgIGhhc01hdGNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhhc01hdGNoO1xuICAgIH1cbn0pO1xuY29uc3QgX21pY3JvbWF0Y2ggPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2hcIik7XG5mdW5jdGlvbiBtYXRjaFJlbW90ZVBhdHRlcm4ocGF0dGVybiwgdXJsKSB7XG4gICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IHVybC5wcm90b2NvbC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGlmIChwYXR0ZXJuLnByb3RvY29sICE9PSBhY3R1YWxQcm90bykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGF0dGVybi5wb3J0ICE9PSB1cmwucG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLmhvc3RuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiBzaG91bGQgZGVmaW5lIGhvc3RuYW1lIGJ1dCBmb3VuZFxcblwiICsgSlNPTi5zdHJpbmdpZnkocGF0dGVybikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKDAsIF9taWNyb21hdGNoLm1ha2VSZSkocGF0dGVybi5ob3N0bmFtZSkudGVzdCh1cmwuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wYXR0ZXJuX3BhdGhuYW1lO1xuICAgIGlmICghKDAsIF9taWNyb21hdGNoLm1ha2VSZSkoKF9wYXR0ZXJuX3BhdGhuYW1lID0gcGF0dGVybi5wYXRobmFtZSkgIT0gbnVsbCA/IF9wYXR0ZXJuX3BhdGhuYW1lIDogXCIqKlwiKS50ZXN0KHVybC5wYXRobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc01hdGNoKGRvbWFpbnMsIHJlbW90ZVBhdHRlcm5zLCB1cmwpIHtcbiAgICByZXR1cm4gZG9tYWlucy5zb21lKChkb21haW4pPT51cmwuaG9zdG5hbWUgPT09IGRvbWFpbikgfHwgcmVtb3RlUGF0dGVybnMuc29tZSgocCk9Pm1hdGNoUmVtb3RlUGF0dGVybihwLCB1cmwpKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwibWF0Y2hSZW1vdGVQYXR0ZXJuIiwiaGFzTWF0Y2giLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfbWljcm9tYXRjaCIsInJlcXVpcmUiLCJwYXR0ZXJuIiwidXJsIiwicHJvdG9jb2wiLCJ1bmRlZmluZWQiLCJhY3R1YWxQcm90byIsInNsaWNlIiwicG9ydCIsImhvc3RuYW1lIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwibWFrZVJlIiwidGVzdCIsIl9wYXR0ZXJuX3BhdGhuYW1lIiwicGF0aG5hbWUiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsaURBQWdEO0lBQzVDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRixnQkFBZ0JHLE9BQU9FLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDO0FBQ25ELElBQUlDLElBQXFDLEVBQUU7SUFDdkNQLGNBQWNRLFdBQVcsR0FBRztBQUNoQyxFQUVBLHlEQUF5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanM/OGZhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvdXRlckNvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJvdXRlckNvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgUm91dGVyQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVyQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUm91dGVyQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfIiwiZGVmYXVsdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || \"\";\n    let pathname = urlObj.pathname || \"\";\n    let hash = urlObj.hash || \"\";\n    let query = urlObj.query || \"\";\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5QztBQUM1QjtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUlOO0FBQ0EsU0FBU0ksUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVYsT0FBT0MsY0FBYyxDQUFDUSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFOLFNBQVM7SUFDYkcsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLDRCQUE0QkMsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1DLGVBQWUsV0FBVyxHQUFHRiwwQkFBMEJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsMEdBQWU7QUFDdEYsTUFBTUcsbUJBQW1CO0FBQ3pCLFNBQVNiLFVBQVVjLE1BQU07SUFDckIsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBTztJQUNYTixPQUFPQSxPQUFPTyxtQkFBbUJQLE1BQU1RLE9BQU8sQ0FBQyxRQUFRLE9BQU8sTUFBTTtJQUNwRSxJQUFJVCxPQUFPTyxJQUFJLEVBQUU7UUFDYkEsT0FBT04sT0FBT0QsT0FBT08sSUFBSTtJQUM3QixPQUFPLElBQUlMLFVBQVU7UUFDakJLLE9BQU9OLE9BQVEsRUFBQ0MsU0FBU1EsT0FBTyxDQUFDLE9BQU8sTUFBTVIsV0FBVyxNQUFNQSxRQUFPO1FBQ3RFLElBQUlGLE9BQU9XLElBQUksRUFBRTtZQUNiSixRQUFRLE1BQU1QLE9BQU9XLElBQUk7UUFDN0I7SUFDSjtJQUNBLElBQUlMLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3BDQSxRQUFRTSxPQUFPZixhQUFhZ0Isc0JBQXNCLENBQUNQO0lBQ3ZEO0lBQ0EsSUFBSVEsU0FBU2QsT0FBT2MsTUFBTSxJQUFJUixTQUFTLE1BQU1BLFNBQVM7SUFDdEQsSUFBSUgsWUFBWSxDQUFDQSxTQUFTWSxRQUFRLENBQUMsTUFBTVosWUFBWTtJQUNyRCxJQUFJSCxPQUFPZ0IsT0FBTyxJQUFJLENBQUMsQ0FBQ2IsWUFBWUosaUJBQWlCa0IsSUFBSSxDQUFDZCxTQUFRLEtBQU1JLFNBQVMsT0FBTztRQUNwRkEsT0FBTyxPQUFRQSxDQUFBQSxRQUFRLEVBQUM7UUFDeEIsSUFBSUgsWUFBWUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxXQUFXLE1BQU1BO0lBQzFELE9BQU8sSUFBSSxDQUFDRyxNQUFNO1FBQ2RBLE9BQU87SUFDWDtJQUNBLElBQUlGLFFBQVFBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsT0FBTyxNQUFNQTtJQUMxQyxJQUFJUyxVQUFVQSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUtBLFNBQVMsTUFBTUE7SUFDaERWLFdBQVdBLFNBQVNLLE9BQU8sQ0FBQyxTQUFTRDtJQUNyQ00sU0FBU0EsT0FBT0wsT0FBTyxDQUFDLEtBQUs7SUFDN0IsT0FBTyxLQUFLTixXQUFXSSxPQUFPSCxXQUFXVSxTQUFTVDtBQUN0RDtBQUNBLE1BQU1sQixnQkFBZ0I7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxTQUFTQyxxQkFBcUI4QixHQUFHO0lBQzdCLElBQUlDLElBQXNDLEVBQUU7UUFDeEMsSUFBSUQsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUN6Q3JDLE9BQU91QyxJQUFJLENBQUNGLEtBQUtHLE9BQU8sQ0FBQyxDQUFDQztnQkFDdEIsSUFBSSxDQUFDbkMsY0FBY29DLFFBQVEsQ0FBQ0QsTUFBTTtvQkFDOUJFLFFBQVFDLElBQUksQ0FBQyx1REFBdURIO2dCQUN4RTtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU9wQyxVQUFVZ0M7QUFDckIsRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLmpzPzdiNTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0VXJsOiBudWxsLFxuICAgIHVybE9iamVjdEtleXM6IG51bGwsXG4gICAgZm9ybWF0V2l0aFZhbGlkYXRpb246IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZm9ybWF0VXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFVybDtcbiAgICB9LFxuICAgIHVybE9iamVjdEtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXJsT2JqZWN0S2V5cztcbiAgICB9LFxuICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFdpdGhWYWxpZGF0aW9uO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3F1ZXJ5c3RyaW5nID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4vcXVlcnlzdHJpbmdcIikpO1xuY29uc3Qgc2xhc2hlZFByb3RvY29scyA9IC9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztcbmZ1bmN0aW9uIGZvcm1hdFVybCh1cmxPYmopIHtcbiAgICBsZXQgeyBhdXRoLCBob3N0bmFtZSB9ID0gdXJsT2JqO1xuICAgIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCBcIlwiO1xuICAgIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCBcIlwiO1xuICAgIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgXCJcIjtcbiAgICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgXCJcIjtcbiAgICBsZXQgaG9zdCA9IGZhbHNlO1xuICAgIGF1dGggPSBhdXRoID8gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpLnJlcGxhY2UoLyUzQS9pLCBcIjpcIikgKyBcIkBcIiA6IFwiXCI7XG4gICAgaWYgKHVybE9iai5ob3N0KSB7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3Q7XG4gICAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgICAgICBob3N0ID0gYXV0aCArICh+aG9zdG5hbWUuaW5kZXhPZihcIjpcIikgPyBcIltcIiArIGhvc3RuYW1lICsgXCJdXCIgOiBob3N0bmFtZSk7XG4gICAgICAgIGlmICh1cmxPYmoucG9ydCkge1xuICAgICAgICAgICAgaG9zdCArPSBcIjpcIiArIHVybE9iai5wb3J0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcXVlcnkgPSBTdHJpbmcoX3F1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkpKTtcbiAgICB9XG4gICAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgcXVlcnkgJiYgXCI/XCIgKyBxdWVyeSB8fCBcIlwiO1xuICAgIGlmIChwcm90b2NvbCAmJiAhcHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpKSBwcm90b2NvbCArPSBcIjpcIjtcbiAgICBpZiAodXJsT2JqLnNsYXNoZXMgfHwgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xzLnRlc3QocHJvdG9jb2wpKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgICAgICBob3N0ID0gXCIvL1wiICsgKGhvc3QgfHwgXCJcIik7XG4gICAgICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gXCIvXCIpIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgICAgIGhvc3QgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSBcIiNcIikgaGFzaCA9IFwiI1wiICsgaGFzaDtcbiAgICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gXCI/XCIpIHNlYXJjaCA9IFwiP1wiICsgc2VhcmNoO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBlbmNvZGVVUklDb21wb25lbnQpO1xuICAgIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKFwiI1wiLCBcIiUyM1wiKTtcbiAgICByZXR1cm4gXCJcIiArIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn1cbmNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICAgXCJhdXRoXCIsXG4gICAgXCJoYXNoXCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJob3N0bmFtZVwiLFxuICAgIFwiaHJlZlwiLFxuICAgIFwicGF0aFwiLFxuICAgIFwicGF0aG5hbWVcIixcbiAgICBcInBvcnRcIixcbiAgICBcInByb3RvY29sXCIsXG4gICAgXCJxdWVyeVwiLFxuICAgIFwic2VhcmNoXCIsXG4gICAgXCJzbGFzaGVzXCJcbl07XG5mdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGlmICghdXJsT2JqZWN0S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXRVcmwodXJsKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJmb3JtYXRVcmwiLCJ1cmxPYmplY3RLZXlzIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsIl9xdWVyeXN0cmluZyIsIl8iLCJzbGFzaGVkUHJvdG9jb2xzIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhhc2giLCJxdWVyeSIsImhvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwiaW5kZXhPZiIsInBvcnQiLCJTdHJpbmciLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwiZW5kc1dpdGgiLCJzbGFzaGVzIiwidGVzdCIsInVybCIsInByb2Nlc3MiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nconst _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nconst _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGlCQUFpQjtRQUNiLE9BQU9RLGNBQWNSLGVBQWU7SUFDeEM7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT1EsV0FBV1IsY0FBYztJQUNwQztBQUNKO0FBQ0EsTUFBTU8sZ0JBQWdCRSxtQkFBT0EsQ0FBQyw4R0FBaUI7QUFDL0MsTUFBTUQsYUFBYUMsbUJBQU9BLENBQUMsd0dBQWMsR0FFekMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanM/ZjUyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldFNvcnRlZFJvdXRlczogbnVsbCxcbiAgICBpc0R5bmFtaWNSb3V0ZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBnZXRTb3J0ZWRSb3V0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NvcnRlZHJvdXRlcy5nZXRTb3J0ZWRSb3V0ZXM7XG4gICAgfSxcbiAgICBpc0R5bmFtaWNSb3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlO1xuICAgIH1cbn0pO1xuY29uc3QgX3NvcnRlZHJvdXRlcyA9IHJlcXVpcmUoXCIuL3NvcnRlZC1yb3V0ZXNcIik7XG5jb25zdCBfaXNkeW5hbWljID0gcmVxdWlyZShcIi4vaXMtZHluYW1pY1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0U29ydGVkUm91dGVzIiwiaXNEeW5hbWljUm91dGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfc29ydGVkcm91dGVzIiwiX2lzZHluYW1pYyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function() {\n        return interpolateAs;\n    }\n}));\nconst _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat, optional } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGlEQUFnRDtJQUM1Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsOEdBQWlCO0FBQy9DLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDBHQUFlO0FBQzNDLFNBQVNGLGNBQWNJLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxLQUFLO0lBQzNDLElBQUlDLG9CQUFvQjtJQUN4QixNQUFNQyxlQUFlLENBQUMsR0FBR0wsWUFBWU0sYUFBYSxFQUFFTDtJQUNwRCxNQUFNTSxnQkFBZ0JGLGFBQWFHLE1BQU07SUFDekMsTUFBTUMsaUJBQ04sQ0FBQ1AsZUFBZUQsUUFBUSxDQUFDLEdBQUdILGNBQWNZLGVBQWUsRUFBRUwsY0FBY0gsY0FBYyxFQUFDLEtBQU0sZ0RBQWdEO0lBQzlJLHNFQUFzRTtJQUN0RUM7SUFDQUMsb0JBQW9CSDtJQUNwQixNQUFNVSxTQUFTcEIsT0FBT3FCLElBQUksQ0FBQ0w7SUFDM0IsSUFBSSxDQUFDSSxPQUFPRSxLQUFLLENBQUMsQ0FBQ0M7UUFDZixJQUFJcEIsUUFBUWUsY0FBYyxDQUFDSyxNQUFNLElBQUk7UUFDckMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHVCxhQUFhLENBQUNPLE1BQU07UUFDakQsaUNBQWlDO1FBQ2pDLDBEQUEwRDtRQUMxRCxJQUFJRyxXQUFXLE1BQU9GLENBQUFBLFNBQVMsUUFBUSxFQUFDLElBQUtELFFBQVE7UUFDckQsSUFBSUUsVUFBVTtZQUNWQyxXQUFXLENBQUMsQ0FBQ3ZCLFFBQVEsTUFBTSxFQUFDLElBQUssTUFBTXVCLFdBQVc7UUFDdEQ7UUFDQSxJQUFJRixVQUFVLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ3pCLFFBQVFBLFFBQVE7WUFDekNBO1NBQ0g7UUFDRCxPQUFPLENBQUNzQixZQUFZRixTQUFTTCxjQUFhLEtBQU0sNkNBQTZDO1FBQzVGTCxDQUFBQSxvQkFBb0JBLGtCQUFrQmdCLE9BQU8sQ0FBQ0gsVUFBVUYsU0FBU3JCLE1BQU0yQixHQUFHLENBQzNFLHVEQUF1RDtRQUN2RCxrREFBa0Q7UUFDbEQsb0NBQW9DO1FBQ3BDLENBQUNDLFVBQVVDLG1CQUFtQkQsVUFBVUUsSUFBSSxDQUFDLE9BQU9ELG1CQUFtQjdCLFdBQVcsR0FBRTtJQUN4RixJQUFJO1FBQ0FVLG9CQUFvQixHQUFHLG1DQUFtQzs7SUFFOUQsdUVBQXVFO0lBQ3ZFLGtEQUFrRDtJQUNsRDtJQUNBLE9BQU87UUFDSE87UUFDQWMsUUFBUXJCO0lBQ1o7QUFDSixFQUVBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVycG9sYXRlLWFzLmpzP2QwZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRlcnBvbGF0ZUFzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZUFzO1xuICAgIH1cbn0pO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3JvdXRlLXJlZ2V4XCIpO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIHtcbiAgICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSBcIlwiO1xuICAgIGNvbnN0IGR5bmFtaWNSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG4gICAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHM7XG4gICAgY29uc3QgZHluYW1pY01hdGNoZXMgPSAvLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4gICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogXCJcIikgfHwgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5O1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gcm91dGU7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3Vwcyk7XG4gICAgaWYgKCFwYXJhbXMuZXZlcnkoKHBhcmFtKT0+e1xuICAgICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgXCJcIjtcbiAgICAgICAgY29uc3QgeyByZXBlYXQsIG9wdGlvbmFsIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXTtcbiAgICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gXCJbXCIgKyAocmVwZWF0ID8gXCIuLi5cIiA6IFwiXCIpICsgcGFyYW0gKyBcIl1cIjtcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICByZXBsYWNlZCA9ICghdmFsdWUgPyBcIi9cIiA6IFwiXCIpICsgXCJbXCIgKyByZXBsYWNlZCArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPSBpbnRlcnBvbGF0ZWRSb3V0ZS5yZXBsYWNlKHJlcGxhY2VkLCByZXBlYXQgPyB2YWx1ZS5tYXAoLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuICAgICAgICAvLyBwYXRoIGRlbGltaXRlciBlc2NhcGVkIHNpbmNlIHRoZXkgYXJlIGJlaW5nIGluc2VydGVkXG4gICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXG4gICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuICAgICAgICAoc2VnbWVudCk9PmVuY29kZVVSSUNvbXBvbmVudChzZWdtZW50KSkuam9pbihcIi9cIikgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSB8fCBcIi9cIik7XG4gICAgfSkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUgPSBcIlwiIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG4gICAgICAgIDtcbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZVxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVycG9sYXRlLWFzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJpbnRlcnBvbGF0ZUFzIiwiX3JvdXRlbWF0Y2hlciIsInJlcXVpcmUiLCJfcm91dGVyZWdleCIsInJvdXRlIiwiYXNQYXRobmFtZSIsInF1ZXJ5IiwiaW50ZXJwb2xhdGVkUm91dGUiLCJkeW5hbWljUmVnZXgiLCJnZXRSb3V0ZVJlZ2V4IiwiZHluYW1pY0dyb3VwcyIsImdyb3VwcyIsImR5bmFtaWNNYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwicGFyYW1zIiwia2V5cyIsImV2ZXJ5IiwicGFyYW0iLCJyZXBlYXQiLCJvcHRpb25hbCIsInJlcGxhY2VkIiwiQXJyYXkiLCJpc0FycmF5IiwicmVwbGFjZSIsIm1hcCIsInNlZ21lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwicmVzdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function() {\n        return isDynamicRoute;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {\n        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;\n    }\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsa0RBQWlEO0lBQzdDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsc0JBQXNCQyxtQkFBT0EsQ0FBQyx3SkFBdUQ7QUFDM0YscUNBQXFDO0FBQ3JDLE1BQU1DLGFBQWE7QUFDbkIsU0FBU0gsZUFBZUksS0FBSztJQUN6QixJQUFJLENBQUMsR0FBR0gsb0JBQW9CSSwwQkFBMEIsRUFBRUQsUUFBUTtRQUM1REEsUUFBUSxDQUFDLEdBQUdILG9CQUFvQkssbUNBQW1DLEVBQUVGLE9BQU9HLGdCQUFnQjtJQUNoRztJQUNBLE9BQU9KLFdBQVdLLElBQUksQ0FBQ0o7QUFDM0IsRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLmpzPzQ2ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0R5bmFtaWNSb3V0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNEeW5hbWljUm91dGU7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJjZXB0aW9ucm91dGVzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3NlcnZlci9mdXR1cmUvaGVscGVycy9pbnRlcmNlcHRpb24tcm91dGVzXCIpO1xuLy8gSWRlbnRpZnkgL1twYXJhbV0vIGluIHJvdXRlIHN0cmluZ1xuY29uc3QgVEVTVF9ST1VURSA9IC9cXC9cXFtbXi9dKz9cXF0oPz1cXC98JCkvO1xuZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGUpIHtcbiAgICBpZiAoKDAsIF9pbnRlcmNlcHRpb25yb3V0ZXMuaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgpKHJvdXRlKSkge1xuICAgICAgICByb3V0ZSA9ICgwLCBfaW50ZXJjZXB0aW9ucm91dGVzLmV4dHJhY3RJbnRlcmNlcHRpb25Sb3V0ZUluZm9ybWF0aW9uKShyb3V0ZSkuaW50ZXJjZXB0ZWRSb3V0ZTtcbiAgICB9XG4gICAgcmV0dXJuIFRFU1RfUk9VVEUudGVzdChyb3V0ZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWR5bmFtaWMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImlzRHluYW1pY1JvdXRlIiwiX2ludGVyY2VwdGlvbnJvdXRlcyIsInJlcXVpcmUiLCJURVNUX1JPVVRFIiwicm91dGUiLCJpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCIsImV4dHJhY3RJbnRlcmNlcHRpb25Sb3V0ZUluZm9ybWF0aW9uIiwiaW50ZXJjZXB0ZWRSb3V0ZSIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCw4Q0FBNkM7SUFDekNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxxRkFBYTtBQUNwQyxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyw4R0FBa0M7QUFDL0QsU0FBU0YsV0FBV0ksR0FBRztJQUNuQixnRUFBZ0U7SUFDaEUsSUFBSSxDQUFDLENBQUMsR0FBR0gsT0FBT0ksYUFBYSxFQUFFRCxNQUFNLE9BQU87SUFDNUMsSUFBSTtRQUNBLDREQUE0RDtRQUM1RCxNQUFNRSxpQkFBaUIsQ0FBQyxHQUFHTCxPQUFPTSxpQkFBaUI7UUFDbkQsTUFBTUMsV0FBVyxJQUFJQyxJQUFJTCxLQUFLRTtRQUM5QixPQUFPRSxTQUFTRSxNQUFNLEtBQUtKLGtCQUFrQixDQUFDLEdBQUdILGFBQWFRLFdBQVcsRUFBRUgsU0FBU0ksUUFBUTtJQUNoRyxFQUFFLE9BQU9DLEdBQUc7UUFDUixPQUFPO0lBQ1g7QUFDSixFQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybC5qcz81ZDI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMb2NhbFVSTFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNMb2NhbFVSTDtcbiAgICB9XG59KTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aFwiKTtcbmZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsKSB7XG4gICAgLy8gcHJldmVudCBhIGh5ZHJhdGlvbiBtaXNtYXRjaCBvbiBocmVmIGZvciB1cmwgd2l0aCBhbmNob3IgcmVmc1xuICAgIGlmICghKDAsIF91dGlscy5pc0Fic29sdXRlVXJsKSh1cmwpKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICAgICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbik7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmICgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHJlc29sdmVkLnBhdGhuYW1lKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWxvY2FsLXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaXNMb2NhbFVSTCIsIl91dGlscyIsInJlcXVpcmUiLCJfaGFzYmFzZXBhdGgiLCJ1cmwiLCJpc0Fic29sdXRlVXJsIiwibG9jYXRpb25PcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiVVJMIiwib3JpZ2luIiwiaGFzQmFzZVBhdGgiLCJwYXRobmFtZSIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsd0NBQXVDO0lBQ25DSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsS0FBS0MsTUFBTSxFQUFFQyxJQUFJO0lBQ3RCLE1BQU1DLFVBQVUsQ0FBQztJQUNqQlQsT0FBT1EsSUFBSSxDQUFDRCxRQUFRRyxPQUFPLENBQUMsQ0FBQ0M7UUFDekIsSUFBSSxDQUFDSCxLQUFLSSxRQUFRLENBQUNELE1BQU07WUFDckJGLE9BQU8sQ0FBQ0UsSUFBSSxHQUFHSixNQUFNLENBQUNJLElBQUk7UUFDOUI7SUFDSjtJQUNBLE9BQU9GO0FBQ1gsRUFFQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9vbWl0LmpzP2ZiNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvbWl0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvbWl0O1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gb21pdChvYmplY3QsIGtleXMpIHtcbiAgICBjb25zdCBvbWl0dGVkID0ge307XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBvbWl0dGVkW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvbWl0dGVkO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbWl0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJvbWl0Iiwib2JqZWN0Iiwia2V5cyIsIm9taXR0ZWQiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    },\n    assign: function() {\n        return assign;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxTQUFTRix1QkFBdUJTLFlBQVk7SUFDeEMsTUFBTUMsUUFBUSxDQUFDO0lBQ2ZELGFBQWFFLE9BQU8sQ0FBQyxDQUFDYixPQUFPYztRQUN6QixJQUFJLE9BQU9GLEtBQUssQ0FBQ0UsSUFBSSxLQUFLLGFBQWE7WUFDbkNGLEtBQUssQ0FBQ0UsSUFBSSxHQUFHZDtRQUNqQixPQUFPLElBQUllLE1BQU1DLE9BQU8sQ0FBQ0osS0FBSyxDQUFDRSxJQUFJLEdBQUc7WUFDbENGLEtBQUssQ0FBQ0UsSUFBSSxDQUFDRyxJQUFJLENBQUNqQjtRQUNwQixPQUFPO1lBQ0hZLEtBQUssQ0FBQ0UsSUFBSSxHQUFHO2dCQUNURixLQUFLLENBQUNFLElBQUk7Z0JBQ1ZkO2FBQ0g7UUFDTDtJQUNKO0lBQ0EsT0FBT1k7QUFDWDtBQUNBLFNBQVNNLHVCQUF1QkMsS0FBSztJQUNqQyxJQUFJLE9BQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0MsTUFBTUQsVUFBVSxPQUFPQSxVQUFVLFdBQVc7UUFDdkcsT0FBT0UsT0FBT0Y7SUFDbEIsT0FBTztRQUNILE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU2hCLHVCQUF1Qm1CLFFBQVE7SUFDcEMsTUFBTUMsU0FBUyxJQUFJQztJQUNuQjNCLE9BQU80QixPQUFPLENBQUNILFVBQVVULE9BQU8sQ0FBQyxDQUFDTTtRQUM5QixJQUFJLENBQUNMLEtBQUtkLE1BQU0sR0FBR21CO1FBQ25CLElBQUlKLE1BQU1DLE9BQU8sQ0FBQ2hCLFFBQVE7WUFDdEJBLE1BQU1hLE9BQU8sQ0FBQyxDQUFDYSxPQUFPSCxPQUFPSSxNQUFNLENBQUNiLEtBQUtJLHVCQUF1QlE7UUFDcEUsT0FBTztZQUNISCxPQUFPSyxHQUFHLENBQUNkLEtBQUtJLHVCQUF1QmxCO1FBQzNDO0lBQ0o7SUFDQSxPQUFPdUI7QUFDWDtBQUNBLFNBQVNuQixPQUFPRSxNQUFNO0lBQ2xCLElBQUksSUFBSXVCLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsbUJBQW1CLElBQUlqQixNQUFNYyxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSSxPQUFPLEdBQUdBLE9BQU9KLE1BQU1JLE9BQU87UUFDbEhELGdCQUFnQixDQUFDQyxPQUFPLEVBQUUsR0FBR0gsU0FBUyxDQUFDRyxLQUFLO0lBQ2hEO0lBQ0FELGlCQUFpQm5CLE9BQU8sQ0FBQyxDQUFDRjtRQUN0QkksTUFBTW1CLElBQUksQ0FBQ3ZCLGFBQWF3QixJQUFJLElBQUl0QixPQUFPLENBQUMsQ0FBQ0MsTUFBTVIsT0FBTzhCLE1BQU0sQ0FBQ3RCO1FBQzdESCxhQUFhRSxPQUFPLENBQUMsQ0FBQ2IsT0FBT2MsTUFBTVIsT0FBT3FCLE1BQU0sQ0FBQ2IsS0FBS2Q7SUFDMUQ7SUFDQSxPQUFPTTtBQUNYLEVBRUEsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanM/MDE0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnk6IG51bGwsXG4gICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtczogbnVsbCxcbiAgICBhc3NpZ246IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5O1xuICAgIH0sXG4gICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zO1xuICAgIH0sXG4gICAgYXNzaWduOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFzc2lnbjtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3QgcXVlcnkgPSB7fTtcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeVtrZXldID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgICAgICAgcXVlcnlba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSBbXG4gICAgICAgICAgICAgICAgcXVlcnlba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBxdWVyeTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0ocGFyYW0pIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4ocGFyYW0pIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyh1cmxRdWVyeSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBPYmplY3QuZW50cmllcyh1cmxRdWVyeSkuZm9yRWFjaCgocGFyYW0pPT57XG4gICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBwYXJhbTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKT0+cmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlYXJjaFBhcmFtc0xpc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIHNlYXJjaFBhcmFtc0xpc3RbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBzZWFyY2hQYXJhbXNMaXN0LmZvckVhY2goKHNlYXJjaFBhcmFtcyk9PntcbiAgICAgICAgQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMua2V5cygpKS5mb3JFYWNoKChrZXkpPT50YXJnZXQuZGVsZXRlKGtleSkpO1xuICAgICAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PnRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiYXNzaWduIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJmb3JFYWNoIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwidXJsUXVlcnkiLCJyZXN1bHQiLCJVUkxTZWFyY2hQYXJhbXMiLCJlbnRyaWVzIiwiaXRlbSIsImFwcGVuZCIsInNldCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZWFyY2hQYXJhbXNMaXN0IiwiX2tleSIsImZyb20iLCJrZXlzIiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function() {\n        return getRouteMatcher;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    let { re, groups } = param;\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMscUZBQWE7QUFDcEMsU0FBU0YsZ0JBQWdCRyxLQUFLO0lBQzFCLElBQUksRUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Y7SUFDckIsT0FBTyxDQUFDRztRQUNKLE1BQU1DLGFBQWFILEdBQUdJLElBQUksQ0FBQ0Y7UUFDM0IsSUFBSSxDQUFDQyxZQUFZO1lBQ2IsT0FBTztRQUNYO1FBQ0EsTUFBTUUsU0FBUyxDQUFDTjtZQUNaLElBQUk7Z0JBQ0EsT0FBT08sbUJBQW1CUDtZQUM5QixFQUFFLE9BQU9RLEdBQUc7Z0JBQ1IsTUFBTSxJQUFJVixPQUFPVyxXQUFXLENBQUM7WUFDakM7UUFDSjtRQUNBLE1BQU1DLFNBQVMsQ0FBQztRQUNoQm5CLE9BQU9vQixJQUFJLENBQUNULFFBQVFVLE9BQU8sQ0FBQyxDQUFDQztZQUN6QixNQUFNQyxJQUFJWixNQUFNLENBQUNXLFNBQVM7WUFDMUIsTUFBTUUsSUFBSVgsVUFBVSxDQUFDVSxFQUFFRSxHQUFHLENBQUM7WUFDM0IsSUFBSUQsTUFBTUUsV0FBVztnQkFDakJQLE1BQU0sQ0FBQ0csU0FBUyxHQUFHLENBQUNFLEVBQUVHLE9BQU8sQ0FBQyxPQUFPSCxFQUFFSSxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLENBQUNDLFFBQVFmLE9BQU9lLFVBQVVQLEVBQUVRLE1BQU0sR0FBRztvQkFDdkZoQixPQUFPUztpQkFDVixHQUFHVCxPQUFPUztZQUNmO1FBQ0o7UUFDQSxPQUFPTDtJQUNYO0FBQ0osRUFFQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLmpzP2M4NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRSb3V0ZU1hdGNoZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFJvdXRlTWF0Y2hlcjtcbiAgICB9XG59KTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGdldFJvdXRlTWF0Y2hlcihwYXJhbSkge1xuICAgIGxldCB7IHJlLCBncm91cHMgfSA9IHBhcmFtO1xuICAgIHJldHVybiAocGF0aG5hbWUpPT57XG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlID0gKHBhcmFtKT0+e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgX3V0aWxzLkRlY29kZUVycm9yKFwiZmFpbGVkIHRvIGRlY29kZSBwYXJhbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaCgoc2x1Z05hbWUpPT57XG4gICAgICAgICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXTtcbiAgICAgICAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZihcIi9cIikgPyBtLnNwbGl0KFwiL1wiKS5tYXAoKGVudHJ5KT0+ZGVjb2RlKGVudHJ5KSkgOiBnLnJlcGVhdCA/IFtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlKG0pXG4gICAgICAgICAgICAgICAgXSA6IGRlY29kZShtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtbWF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0Um91dGVNYXRjaGVyIiwiX3V0aWxzIiwicmVxdWlyZSIsInBhcmFtIiwicmUiLCJncm91cHMiLCJwYXRobmFtZSIsInJvdXRlTWF0Y2giLCJleGVjIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiXyIsIkRlY29kZUVycm9yIiwicGFyYW1zIiwia2V5cyIsImZvckVhY2giLCJzbHVnTmFtZSIsImciLCJtIiwicG9zIiwidW5kZWZpbmVkIiwiaW5kZXhPZiIsInNwbGl0IiwibWFwIiwiZW50cnkiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRouteRegex: function() {\n        return getRouteRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\nconst _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                const [usedMarker] = segment.split(paramMatches[0]);\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLG9CQUFvQjtRQUNoQixPQUFPQTtJQUNYO0lBQ0FDLHlCQUF5QjtRQUNyQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyxzQkFBc0JDLG1CQUFPQSxDQUFDLHdKQUF1RDtBQUMzRixNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDLHFHQUFxQjtBQUNuRCxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLDhIQUF5QjtBQUM5RCxNQUFNRywwQkFBMEI7QUFDaEMsTUFBTUMsa0NBQWtDO0FBQ3hDOzs7Ozs7O0NBT0MsR0FBRyxTQUFTQyxlQUFlQyxLQUFLO0lBQzdCLE1BQU1DLFdBQVdELE1BQU1FLFVBQVUsQ0FBQyxRQUFRRixNQUFNRyxRQUFRLENBQUM7SUFDekQsSUFBSUYsVUFBVTtRQUNWRCxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzVCO0lBQ0EsTUFBTUMsU0FBU0wsTUFBTUUsVUFBVSxDQUFDO0lBQ2hDLElBQUlHLFFBQVE7UUFDUkwsUUFBUUEsTUFBTUksS0FBSyxDQUFDO0lBQ3hCO0lBQ0EsT0FBTztRQUNIRSxLQUFLTjtRQUNMSztRQUNBSjtJQUNKO0FBQ0o7QUFDQSxTQUFTTSxxQkFBcUJDLEtBQUs7SUFD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LE9BQU87Z0JBQ0gsT0FBTyxNQUFNLENBQUMsR0FBRzVELGNBQWM2QixrQkFBa0IsRUFBRVI7WUFDdkQ7UUFDSixHQUFHUyxJQUFJLENBQUM7UUFDUmU7SUFDSjtBQUNKO0FBQ0EsU0FBU3ZELG1CQUFtQnlDLGVBQWUsRUFBRThCLGNBQWM7SUFDdkQsTUFBTUMsU0FBU1IsMEJBQTBCdkIsaUJBQWlCOEI7SUFDMUQsT0FBTztRQUNILEdBQUd4RSxjQUFjMEMsZ0JBQWdCO1FBQ2pDZ0MsWUFBWSxNQUFNRCxPQUFPTix1QkFBdUIsR0FBRztRQUNuRFgsV0FBV2lCLE9BQU9qQixTQUFTO0lBQy9CO0FBQ0o7QUFDQSxTQUFTdEQsd0JBQXdCd0MsZUFBZSxFQUFFaUMsT0FBTztJQUNyRCxNQUFNLEVBQUU3QyxrQkFBa0IsRUFBRSxHQUFHUCxxQkFBcUJtQjtJQUNwRCxNQUFNLEVBQUVrQyxXQUFXLElBQUksRUFBRSxHQUFHRDtJQUM1QixJQUFJN0MsdUJBQXVCLEtBQUs7UUFDNUIsSUFBSStDLGdCQUFnQkQsV0FBVyxPQUFPO1FBQ3RDLE9BQU87WUFDSEYsWUFBWSxPQUFPRyxnQkFBZ0I7UUFDdkM7SUFDSjtJQUNBLE1BQU0sRUFBRVYsdUJBQXVCLEVBQUUsR0FBR0YsMEJBQTBCdkIsaUJBQWlCO0lBQy9FLElBQUlvQyx1QkFBdUJGLFdBQVcsZUFBZTtJQUNyRCxPQUFPO1FBQ0hGLFlBQVksTUFBTVAsMEJBQTBCVyx1QkFBdUI7SUFDdkU7QUFDSixFQUVBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LmpzP2VhYzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRSb3V0ZVJlZ2V4OiBudWxsLFxuICAgIGdldE5hbWVkUm91dGVSZWdleDogbnVsbCxcbiAgICBnZXROYW1lZE1pZGRsZXdhcmVSZWdleDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBnZXRSb3V0ZVJlZ2V4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFJvdXRlUmVnZXg7XG4gICAgfSxcbiAgICBnZXROYW1lZFJvdXRlUmVnZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0TmFtZWRSb3V0ZVJlZ2V4O1xuICAgIH0sXG4gICAgZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJjZXB0aW9ucm91dGVzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3NlcnZlci9mdXR1cmUvaGVscGVycy9pbnRlcmNlcHRpb24tcm91dGVzXCIpO1xuY29uc3QgX2VzY2FwZXJlZ2V4cCA9IHJlcXVpcmUoXCIuLi8uLi9lc2NhcGUtcmVnZXhwXCIpO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCA9IFwibnh0UFwiO1xuY29uc3QgTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCA9IFwibnh0SVwiO1xuLyoqXG4gKiBQYXJzZXMgYSBnaXZlbiBwYXJhbWV0ZXIgZnJvbSBhIHJvdXRlIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjYW4gYmUgdXNlZFxuICogdG8gZ2VuZXJhdGUgdGhlIHBhcmFtZXRyaXplZCByb3V0ZS4gRXhhbXBsZXM6XG4gKiAgIC0gYFsuLi5zbHVnXWAgLT4gYHsga2V5OiAnc2x1ZycsIHJlcGVhdDogdHJ1ZSwgb3B0aW9uYWw6IHRydWUgfWBcbiAqICAgLSBgLi4uc2x1Z2AgLT4gYHsga2V5OiAnc2x1ZycsIHJlcGVhdDogdHJ1ZSwgb3B0aW9uYWw6IGZhbHNlIH1gXG4gKiAgIC0gYFtmb29dYCAtPiBgeyBrZXk6ICdmb28nLCByZXBlYXQ6IGZhbHNlLCBvcHRpb25hbDogdHJ1ZSB9YFxuICogICAtIGBiYXJgIC0+IGB7IGtleTogJ2JhcicsIHJlcGVhdDogZmFsc2UsIG9wdGlvbmFsOiBmYWxzZSB9YFxuICovIGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtKSB7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKFwiW1wiKSAmJiBwYXJhbS5lbmRzV2l0aChcIl1cIik7XG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICBjb25zdCByZXBlYXQgPSBwYXJhbS5zdGFydHNXaXRoKFwiLi4uXCIpO1xuICAgIGlmIChyZXBlYXQpIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zbGljZSgzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBwYXJhbSxcbiAgICAgICAgcmVwZWF0LFxuICAgICAgICBvcHRpb25hbFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQYXJhbWV0cml6ZWRSb3V0ZShyb3V0ZSkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHJvdXRlKS5zbGljZSgxKS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgbGV0IGdyb3VwSW5kZXggPSAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtZXRlcml6ZWRSb3V0ZTogc2VnbWVudHMubWFwKChzZWdtZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgbWFya2VyTWF0Y2ggPSBfaW50ZXJjZXB0aW9ucm91dGVzLklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLmZpbmQoKG0pPT5zZWdtZW50LnN0YXJ0c1dpdGgobSkpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1NYXRjaGVzID0gc2VnbWVudC5tYXRjaCgvXFxbKCg/OlxcWy4qXFxdKXwuKylcXF0vKSAvLyBDaGVjayBmb3IgcGFyYW1ldGVyc1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKG1hcmtlck1hdGNoICYmIHBhcmFtTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihwYXJhbU1hdGNoZXNbMV0pO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGdyb3VwSW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShtYXJrZXJNYXRjaCkgKyBcIihbXi9dKz8pXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCByZXBlYXQsIG9wdGlvbmFsIH0gPSBwYXJzZVBhcmFtZXRlcihwYXJhbU1hdGNoZXNbMV0pO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGdyb3VwSW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGVhdCA/IG9wdGlvbmFsID8gXCIoPzovKC4rPykpP1wiIDogXCIvKC4rPylcIiA6IFwiLyhbXi9dKz8pXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIiArICgwLCBfZXNjYXBlcmVnZXhwLmVzY2FwZVN0cmluZ1JlZ2V4cCkoc2VnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmpvaW4oXCJcIiksXG4gICAgICAgIGdyb3Vwc1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSkge1xuICAgIGNvbnN0IHsgcGFyYW1ldGVyaXplZFJvdXRlLCBncm91cHMgfSA9IGdldFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmU6IG5ldyBSZWdFeHAoXCJeXCIgKyBwYXJhbWV0ZXJpemVkUm91dGUgKyBcIig/Oi8pPyRcIiksXG4gICAgICAgIGdyb3VwczogZ3JvdXBzXG4gICAgfTtcbn1cbi8qKlxuICogQnVpbGRzIGEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsXG4gKiBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAqLyBmdW5jdGlvbiBidWlsZEdldFNhZmVSb3V0ZUtleSgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGxldCByb3V0ZUtleSA9IFwiXCI7XG4gICAgICAgIGxldCBqID0gKytpO1xuICAgICAgICB3aGlsZShqID4gMCl7XG4gICAgICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgKGogLSAxKSAlIDI2KTtcbiAgICAgICAgICAgIGogPSBNYXRoLmZsb29yKChqIC0gMSkgLyAyNik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlS2V5O1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTYWZlS2V5RnJvbVNlZ21lbnQocGFyYW0pIHtcbiAgICBsZXQgeyBpbnRlcmNlcHRpb25NYXJrZXIsIGdldFNhZmVSb3V0ZUtleSwgc2VnbWVudCwgcm91dGVLZXlzLCBrZXlQcmVmaXggfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50KTtcbiAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csIFwiXCIpO1xuICAgIGlmIChrZXlQcmVmaXgpIHtcbiAgICAgICAgY2xlYW5lZEtleSA9IFwiXCIgKyBrZXlQcmVmaXggKyBjbGVhbmVkS2V5O1xuICAgIH1cbiAgICBsZXQgaW52YWxpZEtleSA9IGZhbHNlO1xuICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgIC8vIHNhZmUga2V5XG4gICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgaW52YWxpZEtleSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zbGljZSgwLCAxKSkpKSB7XG4gICAgICAgIGludmFsaWRLZXkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICBjbGVhbmVkS2V5ID0gZ2V0U2FmZVJvdXRlS2V5KCk7XG4gICAgfVxuICAgIGlmIChrZXlQcmVmaXgpIHtcbiAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0gXCJcIiArIGtleVByZWZpeCArIGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBrZXk7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBzZWdtZW50IGhhcyBhbiBpbnRlcmNlcHRpb24gbWFya2VyLCBtYWtlIHN1cmUgdGhhdCdzIHBhcnQgb2YgdGhlIHJlZ2V4IHBhdHRlcm5cbiAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSB0aGF0IHRoZSByb3V0ZSB3aXRoIHRoZSBpbnRlcmNlcHRpb24gbWFya2VyIGRvZXNuJ3QgaW5jb3JyZWN0bHkgbWF0Y2hcbiAgICAvLyB0aGUgbm9uLWludGVyY2VwdGVkIHJvdXRlIChpZSAvYXBwLyguKVt1c2VybmFtZV0gc2hvdWxkIG5vdCBtYXRjaCAvYXBwL1t1c2VybmFtZV0pXG4gICAgY29uc3QgaW50ZXJjZXB0aW9uUHJlZml4ID0gaW50ZXJjZXB0aW9uTWFya2VyID8gKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShpbnRlcmNlcHRpb25NYXJrZXIpIDogXCJcIjtcbiAgICByZXR1cm4gcmVwZWF0ID8gb3B0aW9uYWwgPyBcIig/Oi9cIiArIGludGVyY2VwdGlvblByZWZpeCArIFwiKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+Lis/KSk/XCIgOiBcIi9cIiArIGludGVyY2VwdGlvblByZWZpeCArIFwiKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+Lis/KVwiIDogXCIvXCIgKyBpbnRlcmNlcHRpb25QcmVmaXggKyBcIig/PFwiICsgY2xlYW5lZEtleSArIFwiPlteL10rPylcIjtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUocm91dGUsIHByZWZpeFJvdXRlS2V5cykge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHJvdXRlKS5zbGljZSgxKS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gYnVpbGRHZXRTYWZlUm91dGVLZXkoKTtcbiAgICBjb25zdCByb3V0ZUtleXMgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZTogc2VnbWVudHMubWFwKChzZWdtZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaGFzSW50ZXJjZXB0aW9uTWFya2VyID0gX2ludGVyY2VwdGlvbnJvdXRlcy5JTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5zb21lKChtKT0+c2VnbWVudC5zdGFydHNXaXRoKG0pKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtTWF0Y2hlcyA9IHNlZ21lbnQubWF0Y2goL1xcWygoPzpcXFsuKlxcXSl8LispXFxdLykgLy8gQ2hlY2sgZm9yIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmIChoYXNJbnRlcmNlcHRpb25NYXJrZXIgJiYgcGFyYW1NYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3VzZWRNYXJrZXJdID0gc2VnbWVudC5zcGxpdChwYXJhbU1hdGNoZXNbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTYWZlS2V5RnJvbVNlZ21lbnQoe1xuICAgICAgICAgICAgICAgICAgICBnZXRTYWZlUm91dGVLZXksXG4gICAgICAgICAgICAgICAgICAgIGludGVyY2VwdGlvbk1hcmtlcjogdXNlZE1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudDogcGFyYW1NYXRjaGVzWzFdLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgIGtleVByZWZpeDogcHJlZml4Um91dGVLZXlzID8gTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2FmZUtleUZyb21TZWdtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2FmZVJvdXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50OiBwYXJhbU1hdGNoZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlS2V5cyxcbiAgICAgICAgICAgICAgICAgICAga2V5UHJlZml4OiBwcmVmaXhSb3V0ZUtleXMgPyBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCIgKyAoMCwgX2VzY2FwZXJlZ2V4cC5lc2NhcGVTdHJpbmdSZWdleHApKHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICByb3V0ZUtleXNcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TmFtZWRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgcHJlZml4Um91dGVLZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSwgcHJlZml4Um91dGVLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmdldFJvdXRlUmVnZXgobm9ybWFsaXplZFJvdXRlKSxcbiAgICAgICAgbmFtZWRSZWdleDogXCJeXCIgKyByZXN1bHQubmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgKyBcIig/Oi8pPyRcIixcbiAgICAgICAgcm91dGVLZXlzOiByZXN1bHQucm91dGVLZXlzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkTWlkZGxld2FyZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGFyYW1ldGVyaXplZFJvdXRlIH0gPSBnZXRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUpO1xuICAgIGNvbnN0IHsgY2F0Y2hBbGwgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGlmIChwYXJhbWV0ZXJpemVkUm91dGUgPT09IFwiL1wiKSB7XG4gICAgICAgIGxldCBjYXRjaEFsbFJlZ2V4ID0gY2F0Y2hBbGwgPyBcIi4qXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZWRSZWdleDogXCJeL1wiICsgY2F0Y2hBbGxSZWdleCArIFwiJFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHsgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgfSA9IGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlLCBmYWxzZSk7XG4gICAgbGV0IGNhdGNoQWxsR3JvdXBlZFJlZ2V4ID0gY2F0Y2hBbGwgPyBcIig/OigvLiopPylcIiA6IFwiXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZWRSZWdleDogXCJeXCIgKyBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSArIGNhdGNoQWxsR3JvdXBlZFJlZ2V4ICsgXCIkXCJcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1yZWdleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJnZXRSb3V0ZVJlZ2V4IiwiZ2V0TmFtZWRSb3V0ZVJlZ2V4IiwiZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXgiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJjZXB0aW9ucm91dGVzIiwicmVxdWlyZSIsIl9lc2NhcGVyZWdleHAiLCJfcmVtb3ZldHJhaWxpbmdzbGFzaCIsIk5FWFRfUVVFUllfUEFSQU1fUFJFRklYIiwiTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCIsInBhcnNlUGFyYW1ldGVyIiwicGFyYW0iLCJvcHRpb25hbCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNsaWNlIiwicmVwZWF0Iiwia2V5IiwiZ2V0UGFyYW1ldHJpemVkUm91dGUiLCJyb3V0ZSIsInNlZ21lbnRzIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInNwbGl0IiwiZ3JvdXBzIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsIm1hcCIsInNlZ21lbnQiLCJtYXJrZXJNYXRjaCIsIklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTIiwiZmluZCIsIm0iLCJwYXJhbU1hdGNoZXMiLCJtYXRjaCIsInBvcyIsImVzY2FwZVN0cmluZ1JlZ2V4cCIsImpvaW4iLCJub3JtYWxpemVkUm91dGUiLCJyZSIsIlJlZ0V4cCIsImJ1aWxkR2V0U2FmZVJvdXRlS2V5IiwiaSIsInJvdXRlS2V5IiwiaiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIk1hdGgiLCJmbG9vciIsImdldFNhZmVLZXlGcm9tU2VnbWVudCIsImludGVyY2VwdGlvbk1hcmtlciIsImdldFNhZmVSb3V0ZUtleSIsInJvdXRlS2V5cyIsImtleVByZWZpeCIsImNsZWFuZWRLZXkiLCJyZXBsYWNlIiwiaW52YWxpZEtleSIsImxlbmd0aCIsImlzTmFOIiwicGFyc2VJbnQiLCJpbnRlcmNlcHRpb25QcmVmaXgiLCJnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlIiwicHJlZml4Um91dGVLZXlzIiwibmFtZWRQYXJhbWV0ZXJpemVkUm91dGUiLCJoYXNJbnRlcmNlcHRpb25NYXJrZXIiLCJzb21lIiwidXNlZE1hcmtlciIsInVuZGVmaW5lZCIsInByZWZpeFJvdXRlS2V5IiwicmVzdWx0IiwibmFtZWRSZWdleCIsIm9wdGlvbnMiLCJjYXRjaEFsbCIsImNhdGNoQWxsUmVnZXgiLCJjYXRjaEFsbEdyb3VwZWRSZWdleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function() {\n        return getSortedRoutes;\n    }\n}));\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix) {\n        if (prefix === void 0) prefix = \"/\";\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\" + prefix + c + \"/\")).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\"));\n        }\n        if (!this.placeholder) {\n            const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\"));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\"));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(\"Catch-all must be the last part of the URL.\");\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith(\"...\")) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n            }\n            if (segmentName.startsWith(\".\")) {\n                throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                    }\n                    if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                        throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = \"[[...]]\";\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = \"[...]\";\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = \"[]\";\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvc29ydGVkLXJvdXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUM7SUFDRkMsT0FBT0MsT0FBTyxFQUFFO1FBQ1osSUFBSSxDQUFDQyxPQUFPLENBQUNELFFBQVFFLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLFVBQVUsRUFBRSxFQUFFO0lBQ3pEO0lBQ0FDLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUN2QjtJQUNBQSxRQUFRQyxNQUFNLEVBQUU7UUFDWixJQUFJQSxXQUFXLEtBQUssR0FBR0EsU0FBUztRQUNoQyxNQUFNQyxnQkFBZ0I7ZUFDZixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSTtTQUN4QixDQUFDQyxJQUFJO1FBQ04sSUFBSSxJQUFJLENBQUNDLFFBQVEsS0FBSyxNQUFNO1lBQ3hCSixjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxPQUFPO1FBQ3REO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFlBQVksS0FBSyxNQUFNO1lBQzVCUCxjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxVQUFVO1FBQ3pEO1FBQ0EsSUFBSSxJQUFJLENBQUNFLG9CQUFvQixLQUFLLE1BQU07WUFDcENSLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLFlBQVk7UUFDM0Q7UUFDQSxNQUFNRyxTQUFTVCxjQUFjVSxHQUFHLENBQUMsQ0FBQ0MsSUFBSSxJQUFJLENBQUNWLFFBQVEsQ0FBQ2IsR0FBRyxDQUFDdUIsR0FBR2IsT0FBTyxDQUFDLEtBQUtDLFNBQVNZLElBQUksTUFBTUMsTUFBTSxDQUFDLENBQUNDLE1BQU1DLE9BQU87bUJBQ3JHRDttQkFDQUM7YUFDTixFQUFFLEVBQUU7UUFDVCxJQUFJLElBQUksQ0FBQ1YsUUFBUSxLQUFLLE1BQU07WUFDeEJLLE9BQU9NLElBQUksSUFBSSxJQUFJLENBQUNkLFFBQVEsQ0FBQ2IsR0FBRyxDQUFDLE1BQU1VLE9BQU8sQ0FBQ0MsU0FBUyxNQUFNLElBQUksQ0FBQ0ssUUFBUSxHQUFHO1FBQ2xGO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ1ksV0FBVyxFQUFFO1lBQ25CLE1BQU1DLElBQUlsQixXQUFXLE1BQU0sTUFBTUEsT0FBT21CLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDbEQsSUFBSSxJQUFJLENBQUNWLG9CQUFvQixJQUFJLE1BQU07Z0JBQ25DLE1BQU0sSUFBSVcsTUFBTSx5RkFBeUZGLElBQUksWUFBWUEsSUFBSSxVQUFVLElBQUksQ0FBQ1Qsb0JBQW9CLEdBQUc7WUFDdks7WUFDQUMsT0FBT1csT0FBTyxDQUFDSDtRQUNuQjtRQUNBLElBQUksSUFBSSxDQUFDVixZQUFZLEtBQUssTUFBTTtZQUM1QkUsT0FBT00sSUFBSSxJQUFJLElBQUksQ0FBQ2QsUUFBUSxDQUFDYixHQUFHLENBQUMsU0FBU1UsT0FBTyxDQUFDQyxTQUFTLFNBQVMsSUFBSSxDQUFDUSxZQUFZLEdBQUc7UUFDNUY7UUFDQSxJQUFJLElBQUksQ0FBQ0Msb0JBQW9CLEtBQUssTUFBTTtZQUNwQ0MsT0FBT00sSUFBSSxJQUFJLElBQUksQ0FBQ2QsUUFBUSxDQUFDYixHQUFHLENBQUMsV0FBV1UsT0FBTyxDQUFDQyxTQUFTLFVBQVUsSUFBSSxDQUFDUyxvQkFBb0IsR0FBRztRQUN2RztRQUNBLE9BQU9DO0lBQ1g7SUFDQWhCLFFBQVE0QixRQUFRLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFO1FBQ3JDLElBQUlGLFNBQVNHLE1BQU0sS0FBSyxHQUFHO1lBQ3ZCLElBQUksQ0FBQ1IsV0FBVyxHQUFHO1lBQ25CO1FBQ0o7UUFDQSxJQUFJTyxZQUFZO1lBQ1osTUFBTSxJQUFJSixNQUFNO1FBQ3BCO1FBQ0Esd0NBQXdDO1FBQ3hDLElBQUlNLGNBQWNKLFFBQVEsQ0FBQyxFQUFFO1FBQzdCLDZDQUE2QztRQUM3QyxJQUFJSSxZQUFZQyxVQUFVLENBQUMsUUFBUUQsWUFBWUUsUUFBUSxDQUFDLE1BQU07WUFDMUQsOENBQThDO1lBQzlDLElBQUlDLGNBQWNILFlBQVlQLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDeEMsSUFBSVcsYUFBYTtZQUNqQixJQUFJRCxZQUFZRixVQUFVLENBQUMsUUFBUUUsWUFBWUQsUUFBUSxDQUFDLE1BQU07Z0JBQzFELHVEQUF1RDtnQkFDdkRDLGNBQWNBLFlBQVlWLEtBQUssQ0FBQyxHQUFHLENBQUM7Z0JBQ3BDVyxhQUFhO1lBQ2pCO1lBQ0EsSUFBSUQsWUFBWUYsVUFBVSxDQUFDLFFBQVE7Z0JBQy9CLHdDQUF3QztnQkFDeENFLGNBQWNBLFlBQVlFLFNBQVMsQ0FBQztnQkFDcENQLGFBQWE7WUFDakI7WUFDQSxJQUFJSyxZQUFZRixVQUFVLENBQUMsUUFBUUUsWUFBWUQsUUFBUSxDQUFDLE1BQU07Z0JBQzFELE1BQU0sSUFBSVIsTUFBTSw4REFBOERTLGNBQWM7WUFDaEc7WUFDQSxJQUFJQSxZQUFZRixVQUFVLENBQUMsTUFBTTtnQkFDN0IsTUFBTSxJQUFJUCxNQUFNLDBEQUEwRFMsY0FBYztZQUM1RjtZQUNBLFNBQVNHLFdBQVdDLFlBQVksRUFBRUMsUUFBUTtnQkFDdEMsSUFBSUQsaUJBQWlCLE1BQU07b0JBQ3ZCLDZFQUE2RTtvQkFDN0UsaUNBQWlDO29CQUNqQyx3QkFBd0I7b0JBQ3hCLHNCQUFzQjtvQkFDdEIsd0ZBQXdGO29CQUN4RixJQUFJQSxpQkFBaUJDLFVBQVU7d0JBQzNCLHdIQUF3SDt3QkFDeEgsTUFBTSxJQUFJZCxNQUFNLHFFQUFxRWEsZUFBZSxZQUFZQyxXQUFXO29CQUMvSDtnQkFDSjtnQkFDQVgsVUFBVVksT0FBTyxDQUFDLENBQUNDO29CQUNmLElBQUlBLFNBQVNGLFVBQVU7d0JBQ25CLE1BQU0sSUFBSWQsTUFBTSx5Q0FBeUNjLFdBQVc7b0JBQ3hFO29CQUNBLElBQUlFLEtBQUtDLE9BQU8sQ0FBQyxPQUFPLFFBQVFYLFlBQVlXLE9BQU8sQ0FBQyxPQUFPLEtBQUs7d0JBQzVELE1BQU0sSUFBSWpCLE1BQU0scUNBQXFDZ0IsT0FBTyxZQUFZRixXQUFXO29CQUN2RjtnQkFDSjtnQkFDQVgsVUFBVVAsSUFBSSxDQUFDa0I7WUFDbkI7WUFDQSxJQUFJVixZQUFZO2dCQUNaLElBQUlNLFlBQVk7b0JBQ1osSUFBSSxJQUFJLENBQUN0QixZQUFZLElBQUksTUFBTTt3QkFDM0IsTUFBTSxJQUFJWSxNQUFNLDBGQUEwRixJQUFJLENBQUNaLFlBQVksR0FBRyxhQUFhYyxRQUFRLENBQUMsRUFBRSxHQUFHO29CQUM3SjtvQkFDQVUsV0FBVyxJQUFJLENBQUN2QixvQkFBb0IsRUFBRW9CO29CQUN0Qyw2REFBNkQ7b0JBQzdELElBQUksQ0FBQ3BCLG9CQUFvQixHQUFHb0I7b0JBQzVCLG9GQUFvRjtvQkFDcEZILGNBQWM7Z0JBQ2xCLE9BQU87b0JBQ0gsSUFBSSxJQUFJLENBQUNqQixvQkFBb0IsSUFBSSxNQUFNO3dCQUNuQyxNQUFNLElBQUlXLE1BQU0sMkZBQTJGLElBQUksQ0FBQ1gsb0JBQW9CLEdBQUcsY0FBY2EsUUFBUSxDQUFDLEVBQUUsR0FBRztvQkFDdks7b0JBQ0FVLFdBQVcsSUFBSSxDQUFDeEIsWUFBWSxFQUFFcUI7b0JBQzlCLDZEQUE2RDtvQkFDN0QsSUFBSSxDQUFDckIsWUFBWSxHQUFHcUI7b0JBQ3BCLGtGQUFrRjtvQkFDbEZILGNBQWM7Z0JBQ2xCO1lBQ0osT0FBTztnQkFDSCxJQUFJSSxZQUFZO29CQUNaLE1BQU0sSUFBSVYsTUFBTSx1REFBdURFLFFBQVEsQ0FBQyxFQUFFLEdBQUc7Z0JBQ3pGO2dCQUNBVSxXQUFXLElBQUksQ0FBQzNCLFFBQVEsRUFBRXdCO2dCQUMxQiw2REFBNkQ7Z0JBQzdELElBQUksQ0FBQ3hCLFFBQVEsR0FBR3dCO2dCQUNoQiwrRUFBK0U7Z0JBQy9FSCxjQUFjO1lBQ2xCO1FBQ0o7UUFDQSxpRkFBaUY7UUFDakYsSUFBSSxDQUFDLElBQUksQ0FBQ3hCLFFBQVEsQ0FBQ29DLEdBQUcsQ0FBQ1osY0FBYztZQUNqQyxJQUFJLENBQUN4QixRQUFRLENBQUNxQyxHQUFHLENBQUNiLGFBQWEsSUFBSW5DO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDVyxRQUFRLENBQUNiLEdBQUcsQ0FBQ3FDLGFBQWFoQyxPQUFPLENBQUM0QixTQUFTSCxLQUFLLENBQUMsSUFBSUksV0FBV0M7SUFDekU7SUFDQWdCLGFBQWE7UUFDVCxJQUFJLENBQUN2QixXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDZixRQUFRLEdBQUcsSUFBSXVDO1FBQ3BCLElBQUksQ0FBQ3BDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNHLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLG9CQUFvQixHQUFHO0lBQ2hDO0FBQ0o7QUFDQSxTQUFTbkIsZ0JBQWdCb0QsZUFBZTtJQUNwQyxrRkFBa0Y7SUFDbEYsNEVBQTRFO0lBQzVFLDJDQUEyQztJQUMzQyx5RUFBeUU7SUFDekUsMkJBQTJCO0lBQzNCLG9DQUFvQztJQUNwQyw4RUFBOEU7SUFDOUUsd0VBQXdFO0lBQ3hFLGdIQUFnSDtJQUNoSCw0RUFBNEU7SUFDNUUsTUFBTUMsT0FBTyxJQUFJcEQ7SUFDakIsNkZBQTZGO0lBQzdGbUQsZ0JBQWdCUCxPQUFPLENBQUMsQ0FBQ1MsV0FBV0QsS0FBS25ELE1BQU0sQ0FBQ29EO0lBQ2hELDRHQUE0RztJQUM1RyxPQUFPRCxLQUFLN0MsTUFBTTtBQUN0QixFQUVBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3NvcnRlZC1yb3V0ZXMuanM/MmY3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFNvcnRlZFJvdXRlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0U29ydGVkUm91dGVzO1xuICAgIH1cbn0pO1xuY2xhc3MgVXJsTm9kZSB7XG4gICAgaW5zZXJ0KHVybFBhdGgpIHtcbiAgICAgICAgdGhpcy5faW5zZXJ0KHVybFBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKSwgW10sIGZhbHNlKTtcbiAgICB9XG4gICAgc21vb3NoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc21vb3NoKCk7XG4gICAgfVxuICAgIF9zbW9vc2gocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgcHJlZml4ID0gXCIvXCI7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUGF0aHMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmNoaWxkcmVuLmtleXMoKVxuICAgICAgICBdLnNvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuc2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIltdXCIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIlsuLi5dXCIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW5QYXRocy5zcGxpY2UoY2hpbGRyZW5QYXRocy5pbmRleE9mKFwiW1suLi5dXVwiKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGVzID0gY2hpbGRyZW5QYXRocy5tYXAoKGMpPT50aGlzLmNoaWxkcmVuLmdldChjKS5fc21vb3NoKFwiXCIgKyBwcmVmaXggKyBjICsgXCIvXCIpKS5yZWR1Y2UoKHByZXYsIGN1cnIpPT5bXG4gICAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgICAuLi5jdXJyXG4gICAgICAgICAgICBdLCBbXSk7XG4gICAgICAgIGlmICh0aGlzLnNsdWdOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICByb3V0ZXMucHVzaCguLi50aGlzLmNoaWxkcmVuLmdldChcIltdXCIpLl9zbW9vc2gocHJlZml4ICsgXCJbXCIgKyB0aGlzLnNsdWdOYW1lICsgXCJdL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBjb25zdCByID0gcHJlZml4ID09PSBcIi9cIiA/IFwiL1wiIDogcHJlZml4LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgZGVmaW5lIGEgcm91dGUgd2l0aCB0aGUgc2FtZSBzcGVjaWZpY2l0eSBhcyBhIG9wdGlvbmFsIGNhdGNoLWFsbCByb3V0ZSAoXCInICsgciArICdcIiBhbmQgXCInICsgciArIFwiW1suLi5cIiArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyAnXV1cIikuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZXMudW5zaGlmdChyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KFwiWy4uLl1cIikuX3Ntb29zaChwcmVmaXggKyBcIlsuLi5cIiArIHRoaXMucmVzdFNsdWdOYW1lICsgXCJdL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KFwiW1suLi5dXVwiKS5fc21vb3NoKHByZWZpeCArIFwiW1suLi5cIiArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyBcIl1dL1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlcztcbiAgICB9XG4gICAgX2luc2VydCh1cmxQYXRocywgc2x1Z05hbWVzLCBpc0NhdGNoQWxsKSB7XG4gICAgICAgIGlmICh1cmxQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYXRjaEFsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2F0Y2gtYWxsIG11c3QgYmUgdGhlIGxhc3QgcGFydCBvZiB0aGUgVVJMLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbmV4dCBzZWdtZW50IGluIHRoZSB1cmxQYXRocyBsaXN0XG4gICAgICAgIGxldCBuZXh0U2VnbWVudCA9IHVybFBhdGhzWzBdO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2VnbWVudCBtYXRjaGVzIGBbc29tZXRoaW5nXWBcbiAgICAgICAgaWYgKG5leHRTZWdtZW50LnN0YXJ0c1dpdGgoXCJbXCIpICYmIG5leHRTZWdtZW50LmVuZHNXaXRoKFwiXVwiKSkge1xuICAgICAgICAgICAgLy8gU3RyaXAgYFtgIGFuZCBgXWAsIGxlYXZpbmcgb25seSBgc29tZXRoaW5nYFxuICAgICAgICAgICAgbGV0IHNlZ21lbnROYW1lID0gbmV4dFNlZ21lbnQuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgbGV0IGlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiW1wiKSAmJiBzZWdtZW50TmFtZS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBvcHRpb25hbCBgW2AgYW5kIGBdYCwgbGVhdmluZyBvbmx5IGBzb21ldGhpbmdgXG4gICAgICAgICAgICAgICAgc2VnbWVudE5hbWUgPSBzZWdtZW50TmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIi4uLlwiKSkge1xuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGAuLi5gLCBsZWF2aW5nIG9ubHkgYHNvbWV0aGluZ2BcbiAgICAgICAgICAgICAgICBzZWdtZW50TmFtZSA9IHNlZ21lbnROYW1lLnN1YnN0cmluZygzKTtcbiAgICAgICAgICAgICAgICBpc0NhdGNoQWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiW1wiKSB8fCBzZWdtZW50TmFtZS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWdtZW50IG5hbWVzIG1heSBub3Qgc3RhcnQgb3IgZW5kIHdpdGggZXh0cmEgYnJhY2tldHMgKCdcIiArIHNlZ21lbnROYW1lICsgXCInKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWdtZW50IG5hbWVzIG1heSBub3Qgc3RhcnQgd2l0aCBlcnJvbmVvdXMgcGVyaW9kcyAoJ1wiICsgc2VnbWVudE5hbWUgKyBcIicpLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVNsdWcocHJldmlvdXNTbHVnLCBuZXh0U2x1Zykge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1NsdWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNwZWNpZmljIHNlZ21lbnQgYWxyZWFkeSBoYXMgYSBzbHVnIGJ1dCB0aGUgc2x1ZyBpcyBub3QgYHNvbWV0aGluZ2BcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBjb2xsaXNpb25zIGxpa2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhZ2VzL1twb3N0XS9pbmRleC5qc1xuICAgICAgICAgICAgICAgICAgICAvLyBwYWdlcy9baWRdL2luZGV4LmpzXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgY3VycmVudGx5IG11bHRpcGxlIGR5bmFtaWMgcGFyYW1zIG9uIHRoZSBzYW1lIHNlZ21lbnQgbGV2ZWwgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU2x1ZyAhPT0gbmV4dFNsdWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZXJyb3Igc2VlbXMgdG8gYmUgY29uZnVzaW5nIGZvciB1c2VycywgbmVlZHMgYW4gZXJyb3IgbGluaywgdGhlIGRlc2NyaXB0aW9uIGNhbiBiZSBiYXNlZCBvbiBhYm92ZSBjb21tZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCB1c2UgZGlmZmVyZW50IHNsdWcgbmFtZXMgZm9yIHRoZSBzYW1lIGR5bmFtaWMgcGF0aCAoJ1wiICsgcHJldmlvdXNTbHVnICsgXCInICE9PSAnXCIgKyBuZXh0U2x1ZyArIFwiJykuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5mb3JFYWNoKChzbHVnKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2x1ZyA9PT0gbmV4dFNsdWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBoYXZlIHRoZSBzYW1lIHNsdWcgbmFtZSBcIicgKyBuZXh0U2x1ZyArICdcIiByZXBlYXQgd2l0aGluIGEgc2luZ2xlIGR5bmFtaWMgcGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbHVnLnJlcGxhY2UoL1xcVy9nLCBcIlwiKSA9PT0gbmV4dFNlZ21lbnQucmVwbGFjZSgvXFxXL2csIFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgaGF2ZSB0aGUgc2x1ZyBuYW1lcyBcIicgKyBzbHVnICsgJ1wiIGFuZCBcIicgKyBuZXh0U2x1ZyArICdcIiBkaWZmZXIgb25seSBieSBub24td29yZCBzeW1ib2xzIHdpdGhpbiBhIHNpbmdsZSBkeW5hbWljIHBhdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5wdXNoKG5leHRTbHVnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCB1c2UgYm90aCBhbiByZXF1aXJlZCBhbmQgb3B0aW9uYWwgY2F0Y2gtYWxsIHJvdXRlIGF0IHRoZSBzYW1lIGxldmVsIChcIlsuLi4nICsgdGhpcy5yZXN0U2x1Z05hbWUgKyAnXVwiIGFuZCBcIicgKyB1cmxQYXRoc1swXSArICdcIiApLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgPSBzZWdtZW50TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dFNlZ21lbnQgaXMgb3ZlcndyaXR0ZW4gdG8gW1suLi5dXSBzbyB0aGF0IGl0IGNhbiBsYXRlciBiZSBzb3J0ZWQgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbWy4uLl1dXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBib3RoIGFuIG9wdGlvbmFsIGFuZCByZXF1aXJlZCBjYXRjaC1hbGwgcm91dGUgYXQgdGhlIHNhbWUgbGV2ZWwgKFwiW1suLi4nICsgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSArICddXVwiIGFuZCBcIicgKyB1cmxQYXRoc1swXSArICdcIikuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2x1Zyh0aGlzLnJlc3RTbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdFNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHRTZWdtZW50IGlzIG92ZXJ3cml0dGVuIHRvIFsuLi5dIHNvIHRoYXQgaXQgY2FuIGxhdGVyIGJlIHNvcnRlZCBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNlZ21lbnQgPSBcIlsuLi5dXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbmFsIHJvdXRlIHBhcmFtZXRlcnMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIChcIicgKyB1cmxQYXRoc1swXSArICdcIikuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5zbHVnTmFtZSwgc2VnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIHNsdWdOYW1lIGlzIGtlcHQgYXMgaXQgY2FuIG9ubHkgYmUgb25lIHBhcnRpY3VsYXIgc2x1Z05hbWVcbiAgICAgICAgICAgICAgICB0aGlzLnNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgLy8gbmV4dFNlZ21lbnQgaXMgb3ZlcndyaXR0ZW4gdG8gW10gc28gdGhhdCBpdCBjYW4gbGF0ZXIgYmUgc29ydGVkIHNwZWNpZmljYWxseVxuICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgVXJsTm9kZSBkb2Vzbid0IGhhdmUgdGhlIG5leHRTZWdtZW50IHlldCB3ZSBjcmVhdGUgYSBuZXcgY2hpbGQgVXJsTm9kZVxuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4uaGFzKG5leHRTZWdtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zZXQobmV4dFNlZ21lbnQsIG5ldyBVcmxOb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZ2V0KG5leHRTZWdtZW50KS5faW5zZXJ0KHVybFBhdGhzLnNsaWNlKDEpLCBzbHVnTmFtZXMsIGlzQ2F0Y2hBbGwpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zbHVnTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzdFNsdWdOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U29ydGVkUm91dGVzKG5vcm1hbGl6ZWRQYWdlcykge1xuICAgIC8vIEZpcnN0IHRoZSBVcmxOb2RlIGlzIGNyZWF0ZWQsIGFuZCBldmVyeSBVcmxOb2RlIGNhbiBoYXZlIG9ubHkgMSBkeW5hbWljIHNlZ21lbnRcbiAgICAvLyBFZyB5b3UgY2FuJ3QgaGF2ZSBwYWdlcy9bcG9zdF0vYWJjLmpzIGFuZCBwYWdlcy9baGVsbG9dL3NvbWV0aGluZy1lbHNlLmpzXG4gICAgLy8gT25seSAxIGR5bmFtaWMgc2VnbWVudCBwZXIgbmVzdGluZyBsZXZlbFxuICAgIC8vIFNvIGluIHRoZSBjYXNlIHRoYXQgaXMgdGVzdC9pbnRlZ3JhdGlvbi9keW5hbWljLXJvdXRpbmcgaXQnbGwgYmUgdGhpczpcbiAgICAvLyBwYWdlcy9bcG9zdF0vY29tbWVudHMuanNcbiAgICAvLyBwYWdlcy9ibG9nL1twb3N0XS9jb21tZW50L1tpZF0uanNcbiAgICAvLyBCb3RoIGFyZSBmaW5lIGJlY2F1c2UgYHBhZ2VzL1twb3N0XWAgYW5kIGBwYWdlcy9ibG9nYCBhcmUgb24gdGhlIHNhbWUgbGV2ZWxcbiAgICAvLyBTbyBpbiB0aGlzIGNhc2UgYFVybE5vZGVgIGNyZWF0ZWQgaGVyZSBoYXMgYHRoaXMuc2x1Z05hbWUgPT09ICdwb3N0J2BcbiAgICAvLyBBbmQgc2luY2UgeW91ciBQUiBwYXNzZWQgdGhyb3VnaCBgc2x1Z05hbWVgIGFzIGFuIGFycmF5IGJhc2ljYWxseSBpdCdkIGluY2x1ZGluZyBpdCBpbiB0b28gbWFueSBwb3NzaWJpbGl0aWVzXG4gICAgLy8gSW5zdGVhZCB3aGF0IGhhcyB0byBiZSBwYXNzZWQgdGhyb3VnaCBpcyB0aGUgdXB3YXJkcyBwYXRoJ3MgZHluYW1pYyBuYW1lc1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgVXJsTm9kZSgpO1xuICAgIC8vIEhlcmUgdGhlIGByb290YCBnZXRzIGluamVjdGVkIG11bHRpcGxlIHBhdGhzLCBhbmQgaW5zZXJ0IHdpbGwgYnJlYWsgdGhlbSB1cCBpbnRvIHN1YmxldmVsc1xuICAgIG5vcm1hbGl6ZWRQYWdlcy5mb3JFYWNoKChwYWdlUGF0aCk9PnJvb3QuaW5zZXJ0KHBhZ2VQYXRoKSk7XG4gICAgLy8gU21vb3NoIHdpbGwgdGhlbiBzb3J0IHRob3NlIHN1YmxldmVscyB1cCB0byB0aGUgcG9pbnQgd2hlcmUgeW91IGdldCB0aGUgY29ycmVjdCByb3V0ZSBkZWZpbml0aW9uIHByaW9yaXR5XG4gICAgcmV0dXJuIHJvb3Quc21vb3NoKCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRlZC1yb3V0ZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldFNvcnRlZFJvdXRlcyIsIlVybE5vZGUiLCJpbnNlcnQiLCJ1cmxQYXRoIiwiX2luc2VydCIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInNtb29zaCIsIl9zbW9vc2giLCJwcmVmaXgiLCJjaGlsZHJlblBhdGhzIiwiY2hpbGRyZW4iLCJrZXlzIiwic29ydCIsInNsdWdOYW1lIiwic3BsaWNlIiwiaW5kZXhPZiIsInJlc3RTbHVnTmFtZSIsIm9wdGlvbmFsUmVzdFNsdWdOYW1lIiwicm91dGVzIiwibWFwIiwiYyIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwicHVzaCIsInBsYWNlaG9sZGVyIiwiciIsInNsaWNlIiwiRXJyb3IiLCJ1bnNoaWZ0IiwidXJsUGF0aHMiLCJzbHVnTmFtZXMiLCJpc0NhdGNoQWxsIiwibGVuZ3RoIiwibmV4dFNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzZWdtZW50TmFtZSIsImlzT3B0aW9uYWwiLCJzdWJzdHJpbmciLCJoYW5kbGVTbHVnIiwicHJldmlvdXNTbHVnIiwibmV4dFNsdWciLCJmb3JFYWNoIiwic2x1ZyIsInJlcGxhY2UiLCJoYXMiLCJzZXQiLCJjb25zdHJ1Y3RvciIsIk1hcCIsIm5vcm1hbGl6ZWRQYWdlcyIsInJvb3QiLCJwYWdlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst isServer = typeof window === \"undefined\";\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(()=>{\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(()=>{\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(()=>{\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0FBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxtRkFBTztBQUM5QixNQUFNQyxXQUFXLE9BQU9DLFdBQVc7QUFDbkMsTUFBTUMsNEJBQTRCRixXQUFXLEtBQUssSUFBSUYsT0FBT0ssZUFBZTtBQUM1RSxNQUFNQyxzQkFBc0JKLFdBQVcsS0FBSyxJQUFJRixPQUFPTyxTQUFTO0FBQ2hFLFNBQVNSLFdBQVdTLEtBQUs7O0lBQ3JCLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyx1QkFBdUIsRUFBRSxHQUFHRjtJQUNqRCxTQUFTRztRQUNMLElBQUlGLGVBQWVBLFlBQVlHLGdCQUFnQixFQUFFO1lBQzdDLE1BQU1DLGVBQWViLE9BQU9jLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDQyxNQUFNQyxJQUFJLENBQUNSLFlBQVlHLGdCQUFnQixFQUFFTSxNQUFNLENBQUNDO1lBQzdGVixZQUFZVyxVQUFVLENBQUNWLHdCQUF3QkcsY0FBY0w7UUFDakU7SUFDSjtJQUNBLElBQUlOLFVBQVU7UUFDVixJQUFJbUI7UUFDSlosZUFBZSxPQUFPLEtBQUssSUFBSSxDQUFDWSxnQ0FBZ0NaLFlBQVlHLGdCQUFnQixLQUFLLE9BQU8sS0FBSyxJQUFJUyw4QkFBOEJDLEdBQUcsQ0FBQ2QsTUFBTWUsUUFBUTtRQUNqS1o7SUFDSjtJQUNBUCwwQkFBMEI7UUFDdEIsSUFBSWlCO1FBQ0paLGVBQWUsT0FBTyxLQUFLLElBQUksQ0FBQ1ksZ0NBQWdDWixZQUFZRyxnQkFBZ0IsS0FBSyxPQUFPLEtBQUssSUFBSVMsOEJBQThCQyxHQUFHLENBQUNkLE1BQU1lLFFBQVE7UUFDakssT0FBTztZQUNILElBQUlGO1lBQ0paLGVBQWUsT0FBTyxLQUFLLElBQUksQ0FBQ1ksZ0NBQWdDWixZQUFZRyxnQkFBZ0IsS0FBSyxPQUFPLEtBQUssSUFBSVMsOEJBQThCRyxNQUFNLENBQUNoQixNQUFNZSxRQUFRO1FBQ3hLO0lBQ0o7SUFDQSxrRkFBa0Y7SUFDbEYsb0ZBQW9GO0lBQ3BGLGdFQUFnRTtJQUNoRSxxRkFBcUY7SUFDckYsbUZBQW1GO0lBQ25GbkIsMEJBQTBCO1FBQ3RCLElBQUlLLGFBQWE7WUFDYkEsWUFBWWdCLGNBQWMsR0FBR2Q7UUFDakM7UUFDQSxPQUFPO1lBQ0gsSUFBSUYsYUFBYTtnQkFDYkEsWUFBWWdCLGNBQWMsR0FBR2Q7WUFDakM7UUFDSjtJQUNKO0lBQ0FMLG9CQUFvQjtRQUNoQixJQUFJRyxlQUFlQSxZQUFZZ0IsY0FBYyxFQUFFO1lBQzNDaEIsWUFBWWdCLGNBQWM7WUFDMUJoQixZQUFZZ0IsY0FBYyxHQUFHO1FBQ2pDO1FBQ0EsT0FBTztZQUNILElBQUloQixlQUFlQSxZQUFZZ0IsY0FBYyxFQUFFO2dCQUMzQ2hCLFlBQVlnQixjQUFjO2dCQUMxQmhCLFlBQVlnQixjQUFjLEdBQUc7WUFDakM7UUFDSjtJQUNKO0lBQ0EsT0FBTztBQUNYLEVBRUEsdUNBQXVDO0dBbkQ5QjFCOztRQWFMSztRQWFBQTtRQVVBRTs7O0tBcENLUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvc2lkZS1lZmZlY3QuanM/NDA4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFNpZGVFZmZlY3Q7XG4gICAgfVxufSk7XG5jb25zdCBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0ID0gaXNTZXJ2ZXIgPyAoKT0+e30gOiBfcmVhY3QudXNlTGF5b3V0RWZmZWN0O1xuY29uc3QgdXNlQ2xpZW50T25seUVmZmVjdCA9IGlzU2VydmVyID8gKCk9Pnt9IDogX3JlYWN0LnVzZUVmZmVjdDtcbmZ1bmN0aW9uIFNpZGVFZmZlY3QocHJvcHMpIHtcbiAgICBjb25zdCB7IGhlYWRNYW5hZ2VyLCByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZSB9ID0gcHJvcHM7XG4gICAgZnVuY3Rpb24gZW1pdENoYW5nZSgpIHtcbiAgICAgICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRFbGVtZW50cyA9IF9yZWFjdC5DaGlsZHJlbi50b0FycmF5KEFycmF5LmZyb20oaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykuZmlsdGVyKEJvb2xlYW4pKTtcbiAgICAgICAgICAgIGhlYWRNYW5hZ2VyLnVwZGF0ZUhlYWQocmVkdWNlQ29tcG9uZW50c1RvU3RhdGUoaGVhZEVsZW1lbnRzLCBwcm9wcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgICB2YXIgX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXM7XG4gICAgICAgIGhlYWRNYW5hZ2VyID09IG51bGwgPyB2b2lkIDAgOiAoX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMgPSBoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMuYWRkKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgZW1pdENoYW5nZSgpO1xuICAgIH1cbiAgICB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIHZhciBfaGVhZE1hbmFnZXJfbW91bnRlZEluc3RhbmNlcztcbiAgICAgICAgaGVhZE1hbmFnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IChfaGVhZE1hbmFnZXJfbW91bnRlZEluc3RhbmNlcyA9IGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZE1hbmFnZXJfbW91bnRlZEluc3RhbmNlcy5hZGQocHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHZhciBfaGVhZE1hbmFnZXJfbW91bnRlZEluc3RhbmNlcztcbiAgICAgICAgICAgIGhlYWRNYW5hZ2VyID09IG51bGwgPyB2b2lkIDAgOiAoX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMgPSBoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMuZGVsZXRlKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvLyBXZSBuZWVkIHRvIGNhbGwgYHVwZGF0ZUhlYWRgIG1ldGhvZCB3aGVuZXZlciB0aGUgYFNpZGVFZmZlY3RgIGlzIHRyaWdnZXIgaW4gYWxsXG4gICAgLy8gbGlmZS1jeWNsZXM6IG1vdW50LCB1cGRhdGUsIHVubW91bnQuIEhvd2V2ZXIsIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBgU2lkZUVmZmVjdGBzXG4gICAgLy8gYmVpbmcgcmVuZGVyZWQsIHdlIG9ubHkgdHJpZ2dlciB0aGUgbWV0aG9kIGZyb20gdGhlIGxhc3Qgb25lLlxuICAgIC8vIFRoaXMgaXMgZW5zdXJlZCBieSBrZWVwaW5nIHRoZSBsYXN0IHVuZmx1c2hlZCBgdXBkYXRlSGVhZGAgaW4gdGhlIGBfcGVuZGluZ1VwZGF0ZWBcbiAgICAvLyBzaW5nbGV0b24gaW4gdGhlIGxheW91dCBlZmZlY3QgcGFzcywgYW5kIGFjdHVhbGx5IHRyaWdnZXIgaXQgaW4gdGhlIGVmZmVjdCBwYXNzLlxuICAgIHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGhlYWRNYW5hZ2VyKSB7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IGVtaXRDaGFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAoaGVhZE1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IGVtaXRDaGFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdXNlQ2xpZW50T25seUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKCk7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lkZS1lZmZlY3QuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIlNpZGVFZmZlY3QiLCJfcmVhY3QiLCJyZXF1aXJlIiwiaXNTZXJ2ZXIiLCJ3aW5kb3ciLCJ1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlQ2xpZW50T25seUVmZmVjdCIsInVzZUVmZmVjdCIsInByb3BzIiwiaGVhZE1hbmFnZXIiLCJyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZSIsImVtaXRDaGFuZ2UiLCJtb3VudGVkSW5zdGFuY2VzIiwiaGVhZEVsZW1lbnRzIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwiQm9vbGVhbiIsInVwZGF0ZUhlYWQiLCJfaGVhZE1hbmFnZXJfbW91bnRlZEluc3RhbmNlcyIsImFkZCIsImNoaWxkcmVuIiwiZGVsZXRlIiwiX3BlbmRpbmdVcGRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    DecodeError: function() {\n        return DecodeError;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== \"undefined\";\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.name = \"PageNotFoundError\";\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQWtCTjtBQUNBLFNBQVNrQixRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJeEIsT0FBT0MsY0FBYyxDQUFDc0IsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRcEIsU0FBUztJQUNiRyxZQUFZO1FBQ1IsT0FBT0E7SUFDWDtJQUNBQyxVQUFVO1FBQ04sT0FBT0E7SUFDWDtJQUNBQyxlQUFlO1FBQ1gsT0FBT0E7SUFDWDtJQUNBQyxtQkFBbUI7UUFDZixPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU9BO0lBQ1g7SUFDQUMsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsMEJBQTBCO1FBQ3RCLE9BQU9BO0lBQ1g7SUFDQUMscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsSUFBSTtRQUNBLE9BQU9BO0lBQ1g7SUFDQUMsSUFBSTtRQUNBLE9BQU9BO0lBQ1g7SUFDQUMsYUFBYTtRQUNULE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxtQkFBbUI7UUFDZixPQUFPQTtJQUNYO0lBQ0FDLG1CQUFtQjtRQUNmLE9BQU9BO0lBQ1g7SUFDQUMseUJBQXlCO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTWhCLGFBQWE7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELFNBQVNDLFNBQVNzQixFQUFFO0lBQ2hCLElBQUlDLE9BQU87SUFDWCxJQUFJQztJQUNKLE9BQU87UUFDSCxJQUFJLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQU87WUFDbkZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHSixTQUFTLENBQUNJLEtBQUs7UUFDaEM7UUFDQSxJQUFJLENBQUNQLE1BQU07WUFDUEEsT0FBTztZQUNQQyxTQUFTRixNQUFNTTtRQUNuQjtRQUNBLE9BQU9KO0lBQ1g7QUFDSjtBQUNBLDBEQUEwRDtBQUMxRCxnRUFBZ0U7QUFDaEUsTUFBTU8scUJBQXFCO0FBQzNCLE1BQU05QixnQkFBZ0IsQ0FBQytCLE1BQU1ELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUNyRCxTQUFTOUI7SUFDTCxNQUFNLEVBQUVnQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFLEdBQUdDLE9BQU9DLFFBQVE7SUFDcEQsT0FBT0osV0FBVyxPQUFPQyxXQUFZQyxDQUFBQSxPQUFPLE1BQU1BLE9BQU8sRUFBQztBQUM5RDtBQUNBLFNBQVNqQztJQUNMLE1BQU0sRUFBRW9DLElBQUksRUFBRSxHQUFHRixPQUFPQyxRQUFRO0lBQ2hDLE1BQU1FLFNBQVN0QztJQUNmLE9BQU9xQyxLQUFLRSxTQUFTLENBQUNELE9BQU9iLE1BQU07QUFDdkM7QUFDQSxTQUFTdkIsZUFBZXNDLFNBQVM7SUFDN0IsT0FBTyxPQUFPQSxjQUFjLFdBQVdBLFlBQVlBLFVBQVVDLFdBQVcsSUFBSUQsVUFBVXZCLElBQUksSUFBSTtBQUNsRztBQUNBLFNBQVNkLFVBQVV1QyxHQUFHO0lBQ2xCLE9BQU9BLElBQUlDLFFBQVEsSUFBSUQsSUFBSUUsV0FBVztBQUMxQztBQUNBLFNBQVN4Qyx5QkFBeUIwQixHQUFHO0lBQ2pDLE1BQU1lLFdBQVdmLElBQUlnQixLQUFLLENBQUM7SUFDM0IsTUFBTUMsYUFBYUYsUUFBUSxDQUFDLEVBQUU7SUFDOUIsT0FBT0UsV0FBVSw0REFBNEQ7SUFDN0UsMENBQTBDO0tBQ3pDQyxPQUFPLENBQUMsT0FBTyxLQUFLQSxPQUFPLENBQUMsVUFBVSxPQUFRSCxDQUFBQSxRQUFRLENBQUMsRUFBRSxHQUFHLE1BQU1BLFNBQVNJLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUMsT0FBTyxFQUFDO0FBQ3RHO0FBQ0EsZUFBZTdDLG9CQUFvQjhDLEdBQUcsRUFBRUMsR0FBRztJQUN2QyxJQUFJQyxJQUFxQyxFQUFFO1FBQ3ZDLElBQUlDO1FBQ0osSUFBSSxDQUFDQSxpQkFBaUJILElBQUlJLFNBQVMsS0FBSyxPQUFPLEtBQUssSUFBSUQsZUFBZUUsZUFBZSxFQUFFO1lBQ3BGLE1BQU1DLFVBQVUsTUFBTXZELGVBQWVpRCxPQUFPO1lBQzVDLE1BQU0sSUFBSU8sTUFBTUQ7UUFDcEI7SUFDSjtJQUNBLGlEQUFpRDtJQUNqRCxNQUFNZixNQUFNVSxJQUFJVixHQUFHLElBQUlVLElBQUlBLEdBQUcsSUFBSUEsSUFBSUEsR0FBRyxDQUFDVixHQUFHO0lBQzdDLElBQUksQ0FBQ1MsSUFBSUssZUFBZSxFQUFFO1FBQ3RCLElBQUlKLElBQUlBLEdBQUcsSUFBSUEsSUFBSVosU0FBUyxFQUFFO1lBQzFCLCtCQUErQjtZQUMvQixPQUFPO2dCQUNIbUIsV0FBVyxNQUFNdEQsb0JBQW9CK0MsSUFBSVosU0FBUyxFQUFFWSxJQUFJQSxHQUFHO1lBQy9EO1FBQ0o7UUFDQSxPQUFPLENBQUM7SUFDWjtJQUNBLE1BQU1RLFFBQVEsTUFBTVQsSUFBSUssZUFBZSxDQUFDSjtJQUN4QyxJQUFJVixPQUFPdkMsVUFBVXVDLE1BQU07UUFDdkIsT0FBT2tCO0lBQ1g7SUFDQSxJQUFJLENBQUNBLE9BQU87UUFDUixNQUFNSCxVQUFVLE1BQU12RCxlQUFlaUQsT0FBTyxpRUFBaUVTLFFBQVE7UUFDckgsTUFBTSxJQUFJRixNQUFNRDtJQUNwQjtJQUNBLElBQUlKLElBQXFDLEVBQUU7UUFDdkMsSUFBSTdELE9BQU9xRSxJQUFJLENBQUNELE9BQU9uQyxNQUFNLEtBQUssS0FBSyxDQUFDMkIsSUFBSUEsR0FBRyxFQUFFO1lBQzdDVSxRQUFRQyxJQUFJLENBQUMsS0FBSzdELGVBQWVpRCxPQUFPO1FBQzVDO0lBQ0o7SUFDQSxPQUFPUztBQUNYO0FBQ0EsTUFBTXRELEtBQUssT0FBTzBELGdCQUFnQjtBQUNsQyxNQUFNekQsS0FBS0QsTUFBTTtJQUNiO0lBQ0E7SUFDQTtDQUNILENBQUMyRCxLQUFLLENBQUMsQ0FBQ0MsU0FBUyxPQUFPRixXQUFXLENBQUNFLE9BQU8sS0FBSztBQUNqRCxNQUFNMUQsb0JBQW9Ca0Q7QUFDMUI7QUFDQSxNQUFNakQsdUJBQXVCaUQ7QUFDN0I7QUFDQSxNQUFNaEQsMEJBQTBCZ0Q7SUFDNUJTLFlBQVlDLElBQUksQ0FBQztRQUNiLEtBQUs7UUFDTCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3BELElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3dDLE9BQU8sR0FBRyxrQ0FBa0NXO0lBQ3JEO0FBQ0o7QUFDQSxNQUFNekQsMEJBQTBCK0M7SUFDNUJTLFlBQVlDLElBQUksRUFBRVgsT0FBTyxDQUFDO1FBQ3RCLEtBQUs7UUFDTCxJQUFJLENBQUNBLE9BQU8sR0FBRywwQ0FBMENXLE9BQU8sTUFBTVg7SUFDMUU7QUFDSjtBQUNBLE1BQU03QyxnQ0FBZ0M4QztJQUNsQ1MsYUFBYTtRQUNULEtBQUs7UUFDTCxJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ1osT0FBTyxHQUFHO0lBQ25CO0FBQ0o7QUFDQSxTQUFTNUMsZUFBZXlELEtBQUs7SUFDekIsT0FBT0MsS0FBS0MsU0FBUyxDQUFDO1FBQ2xCZixTQUFTYSxNQUFNYixPQUFPO1FBQ3RCZ0IsT0FBT0gsTUFBTUcsS0FBSztJQUN0QjtBQUNKLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcz9lN2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgV0VCX1ZJVEFMUzogbnVsbCxcbiAgICBleGVjT25jZTogbnVsbCxcbiAgICBpc0Fic29sdXRlVXJsOiBudWxsLFxuICAgIGdldExvY2F0aW9uT3JpZ2luOiBudWxsLFxuICAgIGdldFVSTDogbnVsbCxcbiAgICBnZXREaXNwbGF5TmFtZTogbnVsbCxcbiAgICBpc1Jlc1NlbnQ6IG51bGwsXG4gICAgbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzOiBudWxsLFxuICAgIGxvYWRHZXRJbml0aWFsUHJvcHM6IG51bGwsXG4gICAgU1A6IG51bGwsXG4gICAgU1Q6IG51bGwsXG4gICAgRGVjb2RlRXJyb3I6IG51bGwsXG4gICAgTm9ybWFsaXplRXJyb3I6IG51bGwsXG4gICAgUGFnZU5vdEZvdW5kRXJyb3I6IG51bGwsXG4gICAgTWlzc2luZ1N0YXRpY1BhZ2U6IG51bGwsXG4gICAgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I6IG51bGwsXG4gICAgc3RyaW5naWZ5RXJyb3I6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgV0VCX1ZJVEFMUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBXRUJfVklUQUxTO1xuICAgIH0sXG4gICAgZXhlY09uY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZXhlY09uY2U7XG4gICAgfSxcbiAgICBpc0Fic29sdXRlVXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzb2x1dGVVcmw7XG4gICAgfSxcbiAgICBnZXRMb2NhdGlvbk9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRMb2NhdGlvbk9yaWdpbjtcbiAgICB9LFxuICAgIGdldFVSTDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRVUkw7XG4gICAgfSxcbiAgICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNwbGF5TmFtZTtcbiAgICB9LFxuICAgIGlzUmVzU2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc1Jlc1NlbnQ7XG4gICAgfSxcbiAgICBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzO1xuICAgIH0sXG4gICAgbG9hZEdldEluaXRpYWxQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzO1xuICAgIH0sXG4gICAgU1A6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU1A7XG4gICAgfSxcbiAgICBTVDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTVDtcbiAgICB9LFxuICAgIERlY29kZUVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERlY29kZUVycm9yO1xuICAgIH0sXG4gICAgTm9ybWFsaXplRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTm9ybWFsaXplRXJyb3I7XG4gICAgfSxcbiAgICBQYWdlTm90Rm91bmRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYWdlTm90Rm91bmRFcnJvcjtcbiAgICB9LFxuICAgIE1pc3NpbmdTdGF0aWNQYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1pc3NpbmdTdGF0aWNQYWdlO1xuICAgIH0sXG4gICAgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I7XG4gICAgfSxcbiAgICBzdHJpbmdpZnlFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlFcnJvcjtcbiAgICB9XG59KTtcbmNvbnN0IFdFQl9WSVRBTFMgPSBbXG4gICAgXCJDTFNcIixcbiAgICBcIkZDUFwiLFxuICAgIFwiRklEXCIsXG4gICAgXCJJTlBcIixcbiAgICBcIkxDUFwiLFxuICAgIFwiVFRGQlwiXG5dO1xuZnVuY3Rpb24gZXhlY09uY2UoZm4pIHtcbiAgICBsZXQgdXNlZCA9IGZhbHNlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXNlZCkge1xuICAgICAgICAgICAgdXNlZCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG4vLyBTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4vLyBBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi87XG5jb25zdCBpc0Fic29sdXRlVXJsID0gKHVybCk9PkFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KHVybCk7XG5mdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIHJldHVybiBwcm90b2NvbCArIFwiLy9cIiArIGhvc3RuYW1lICsgKHBvcnQgPyBcIjpcIiArIHBvcnQgOiBcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKENvbXBvbmVudCkge1xuICAgIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiID8gQ29tcG9uZW50IDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiVW5rbm93blwiO1xufVxuZnVuY3Rpb24gaXNSZXNTZW50KHJlcykge1xuICAgIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybCkge1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KFwiP1wiKTtcbiAgICBjb25zdCB1cmxOb1F1ZXJ5ID0gdXJsUGFydHNbMF07XG4gICAgcmV0dXJuIHVybE5vUXVlcnkvLyBmaXJzdCB3ZSByZXBsYWNlIGFueSBub24tZW5jb2RlZCBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmRcbiAgICAvLyB0aGVuIG5vcm1hbGl6ZSByZXBlYXRlZCBmb3J3YXJkIHNsYXNoZXNcbiAgICAucmVwbGFjZSgvXFxcXC9nLCBcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIikgKyAodXJsUGFydHNbMV0gPyBcIj9cIiArIHVybFBhcnRzLnNsaWNlKDEpLmpvaW4oXCI/XCIpIDogXCJcIik7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgY3R4KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YXIgX0FwcF9wcm90b3R5cGU7XG4gICAgICAgIGlmICgoX0FwcF9wcm90b3R5cGUgPSBBcHAucHJvdG90eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX0FwcF9wcm90b3R5cGUuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1wiJyArIGdldERpc3BsYXlOYW1lKEFwcCkgKyAnLmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gICAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCBjdHguY3R4ICYmIGN0eC5jdHgucmVzO1xuICAgIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgICAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpO1xuICAgIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnXCInICsgZ2V0RGlzcGxheU5hbWUoQXBwKSArICcuZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIicgKyBwcm9wcyArICdcIiBpbnN0ZWFkLic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXCIgKyBnZXREaXNwbGF5TmFtZShBcHApICsgXCIgcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gYGdldEluaXRpYWxQcm9wc2AuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5jb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IFNUID0gU1AgJiYgW1xuICAgIFwibWFya1wiLFxuICAgIFwibWVhc3VyZVwiLFxuICAgIFwiZ2V0RW50cmllc0J5TmFtZVwiXG5dLmV2ZXJ5KChtZXRob2QpPT50eXBlb2YgcGVyZm9ybWFuY2VbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiKTtcbmNsYXNzIERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuY2xhc3MgTm9ybWFsaXplRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5jbGFzcyBQYWdlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYWdlKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFTk9FTlRcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJQYWdlTm90Rm91bmRFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkNhbm5vdCBmaW5kIG1vZHVsZSBmb3IgcGFnZTogXCIgKyBwYWdlO1xuICAgIH1cbn1cbmNsYXNzIE1pc3NpbmdTdGF0aWNQYWdlIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhZ2UsIG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkZhaWxlZCB0byBsb2FkIHN0YXRpYyBmaWxlIGZvciBwYWdlOiBcIiArIHBhZ2UgKyBcIiBcIiArIG1lc3NhZ2U7XG4gICAgfVxufVxuY2xhc3MgTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFTk9FTlRcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJDYW5ub3QgZmluZCB0aGUgbWlkZGxld2FyZSBtb2R1bGVcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJXRUJfVklUQUxTIiwiZXhlY09uY2UiLCJpc0Fic29sdXRlVXJsIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJnZXRVUkwiLCJnZXREaXNwbGF5TmFtZSIsImlzUmVzU2VudCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJTUCIsIlNUIiwiRGVjb2RlRXJyb3IiLCJOb3JtYWxpemVFcnJvciIsIlBhZ2VOb3RGb3VuZEVycm9yIiwiTWlzc2luZ1N0YXRpY1BhZ2UiLCJNaWRkbGV3YXJlTm90Rm91bmRFcnJvciIsInN0cmluZ2lmeUVycm9yIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZm4iLCJ1c2VkIiwicmVzdWx0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJ1cmwiLCJ0ZXN0IiwicHJvdG9jb2wiLCJob3N0bmFtZSIsInBvcnQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJvcmlnaW4iLCJzdWJzdHJpbmciLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsInJlcyIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJ1cmxQYXJ0cyIsInNwbGl0IiwidXJsTm9RdWVyeSIsInJlcGxhY2UiLCJzbGljZSIsImpvaW4iLCJBcHAiLCJjdHgiLCJwcm9jZXNzIiwiX0FwcF9wcm90b3R5cGUiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsImtleXMiLCJjb25zb2xlIiwid2FybiIsInBlcmZvcm1hbmNlIiwiZXZlcnkiLCJtZXRob2QiLCJjb25zdHJ1Y3RvciIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.jsx":
/*!**************************!*\
  !*** ./src/app/page.jsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var _page_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./page.module.css */ \"(app-pages-browser)/./src/app/page.module.css\");\n/* harmony import */ var _page_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_page_module_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var mqtt__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! mqtt */ \"(app-pages-browser)/../node_modules/mqtt/dist/mqtt.esm.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n//import logo from \"@/../public/icon/icons8-delete.svg\";\n\n// ws://192.168.0.34:9001\nconst conn = {\n    title: \"CONNECT\",\n    css: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().connect)\n};\nconst disconn = {\n    title: \"DISCONNECT\",\n    css: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().disconnect)\n};\nlet client;\nfunction subscribe() {\n    client.subscribe(subTopic, (err)=>{\n        if (err) {\n            console.log(err);\n        }\n    });\n}\nfunction check(para) {\n    if (para.checked == true) {\n        console.log(\"checked\");\n        client.publish(\"home/1\", \"led on\");\n    } else {\n        console.log(\"unchecked\");\n        client.publish(\"home/1\", \"led off\");\n    }\n}\nasync function buttons() {\n    let res;\n    await fetch(\"http://147.135.51.66:1111/buttons\", {\n        method: \"GET\"\n    }).then(async function(resp) {\n        await resp.text().then((text)=>{\n            res = JSON.parse(text);\n        });\n    });\n    return res;\n}\nfunction Home() {\n    _s();\n    let url = \"ws://147.135.51.66:9001\";\n    const [butn, setButn] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(conn);\n    const [subMessage, setSubMessage] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(\"\");\n    const [pubMessage, setPubMessage] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(\"\");\n    const [btnList, setbtnList] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({});\n    const [btnArry, setbtnArry] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const [deleted, setDeleted] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(\"\");\n    async function Delete(id) {\n        console.log(id);\n        let resp = \"\";\n        await fetch(\"http://147.135.51.66:1111/delete\", {\n            method: \"POST\",\n            headers: {\n                Accept: \"application/json\",\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                id: id\n            })\n        }).then(async function(a) {\n            await a.text().then((t)=>{\n                resp = t;\n            });\n        });\n        setDeleted(id);\n    }\n    function toggleConnection() {\n        if (butn === conn) {\n            client = mqtt__WEBPACK_IMPORTED_MODULE_4__[\"default\"].connect(url);\n            client.on(\"connect\", ()=>{\n                setButn(disconn);\n                console.log(\"connected\");\n            });\n            client.on(\"message\", (topic, message)=>{\n                console.log(subMessage);\n                setSubMessage((prv)=>{\n                    return prv + message.toString() + \"\\n\";\n                });\n            });\n        } else {\n            client.end();\n            setButn(conn);\n            setSubMessage(\"\");\n        }\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        async function a() {\n            const e = await buttons();\n            setbtnList(e);\n            setbtnArry(Object.keys(e));\n            console.log(e);\n            console.log(btnArry);\n        }\n        a();\n    }, [\n        deleted\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().continer),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().box),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().title),\n                        children: \"Home1\"\n                    }, void 0, false, {\n                        fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                        lineNumber: 113,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"\".concat((_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().btn), \" \").concat(butn.css),\n                        onClick: toggleConnection,\n                        children: [\n                            butn.title,\n                            console.log(butn.title)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                        lineNumber: 114,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                lineNumber: 112,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().buttons),\n                children: btnArry.map((btn, index)=>{\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        id: btn,\n                        className: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().btnbordar),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                children: btnList[btn].panelName\n                            }, void 0, false, {\n                                fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                                lineNumber: 127,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                onClick: ()=>{\n                                    Delete(btn);\n                                },\n                                className: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().icon),\n                                src: \"icon/icons8-delete.svg\",\n                                alt: \"\"\n                            }, void 0, false, {\n                                fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                                lineNumber: 128,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().checkboxwrapper),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"checkbox\",\n                                        id: index,\n                                        className: \"\".concat((_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().tgl), \" \").concat((_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().tglskewed))\n                                    }, void 0, false, {\n                                        fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                                        lineNumber: 137,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        for: index,\n                                        \"data-tg-on\": \"ON\",\n                                        \"data-tg-off\": \"OFF\",\n                                        className: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().tglbtn)\n                                    }, void 0, false, {\n                                        fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                                        lineNumber: 142,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                                lineNumber: 136,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, btn, true, {\n                        fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                        lineNumber: 126,\n                        columnNumber: 13\n                    }, this);\n                })\n            }, void 0, false, {\n                fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                lineNumber: 123,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().divbtn),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    href: \"/Add-Button\",\n                    className: (_page_module_css__WEBPACK_IMPORTED_MODULE_5___default().link),\n                    children: \"+\"\n                }, void 0, false, {\n                    fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                    lineNumber: 155,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n                lineNumber: 154,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/jon/IOT/IOT/frontend/V 1.0/my-app/src/app/page.jsx\",\n        lineNumber: 111,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"KAxChvoxiYj9ErCU5I8HbkDiD48=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ozs7Z0JBeUJkOzs7Ozs7MEJBR0YsOERBQUNOO2dCQUFJQyxXQUFXL0QsZ0VBQWE7MEJBQzNCLDRFQUFDQyxpREFBSUE7b0JBQUN5RixNQUFLO29CQUFjM0IsV0FBVy9ELDhEQUFXOzhCQUFFOzs7Ozs7Ozs7Ozs7Ozs7OztBQU16RDtHQWhId0I4QjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3BhZ2UuanN4P2Q0NjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgSW1hZ2UgZnJvbSBcIm5leHQvaW1hZ2VcIjtcbmltcG9ydCBzdHlsZXMgZnJvbSBcIi4vcGFnZS5tb2R1bGUuY3NzXCI7XG5pbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG4vL2ltcG9ydCBsb2dvIGZyb20gXCJALy4uL3B1YmxpYy9pY29uL2ljb25zOC1kZWxldGUuc3ZnXCI7XG5cbmltcG9ydCBtcXR0IGZyb20gXCJtcXR0XCI7XG4vLyB3czovLzE5Mi4xNjguMC4zNDo5MDAxXG5cbmNvbnN0IGNvbm4gPSB7XG4gIHRpdGxlOiBcIkNPTk5FQ1RcIixcbiAgY3NzOiBzdHlsZXMuY29ubmVjdCxcbn07XG5jb25zdCBkaXNjb25uID0ge1xuICB0aXRsZTogXCJESVNDT05ORUNUXCIsXG4gIGNzczogc3R5bGVzLmRpc2Nvbm5lY3QsXG59O1xubGV0IGNsaWVudDtcblxuZnVuY3Rpb24gc3Vic2NyaWJlKCkge1xuICBjbGllbnQuc3Vic2NyaWJlKHN1YlRvcGljLCAoZXJyKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaGVjayhwYXJhKSB7XG4gIGlmIChwYXJhLmNoZWNrZWQgPT0gdHJ1ZSkge1xuICAgIGNvbnNvbGUubG9nKFwiY2hlY2tlZFwiKTtcbiAgICBjbGllbnQucHVibGlzaChcImhvbWUvMVwiLCBcImxlZCBvblwiKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhcInVuY2hlY2tlZFwiKTtcbiAgICBjbGllbnQucHVibGlzaChcImhvbWUvMVwiLCBcImxlZCBvZmZcIik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1dHRvbnMoKSB7XG4gIGxldCByZXM7XG4gIGF3YWl0IGZldGNoKFwiaHR0cDovLzE0Ny4xMzUuNTEuNjY6MTExMS9idXR0b25zXCIsIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gIH0pLnRoZW4oYXN5bmMgZnVuY3Rpb24gKHJlc3ApIHtcbiAgICBhd2FpdCByZXNwLnRleHQoKS50aGVuKCh0ZXh0KSA9PiB7XG4gICAgICByZXMgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIGxldCB1cmwgPSBcIndzOi8vMTQ3LjEzNS41MS42Njo5MDAxXCI7XG5cbiAgY29uc3QgW2J1dG4sIHNldEJ1dG5dID0gdXNlU3RhdGUoY29ubik7XG5cbiAgY29uc3QgW3N1Yk1lc3NhZ2UsIHNldFN1Yk1lc3NhZ2VdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtwdWJNZXNzYWdlLCBzZXRQdWJNZXNzYWdlXSA9IHVzZVN0YXRlKFwiXCIpO1xuXG4gIGNvbnN0IFtidG5MaXN0LCBzZXRidG5MaXN0XSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgW2J0bkFycnksIHNldGJ0bkFycnldID0gdXNlU3RhdGUoW10pO1xuXG4gIGNvbnN0IFtkZWxldGVkLCBzZXREZWxldGVkXSA9IHVzZVN0YXRlKFwiXCIpO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIERlbGV0ZShpZCkge1xuICAgIGNvbnNvbGUubG9nKGlkKTtcbiAgICBsZXQgcmVzcCA9IFwiXCI7XG4gICAgYXdhaXQgZmV0Y2goXCJodHRwOi8vMTQ3LjEzNS41MS42NjoxMTExL2RlbGV0ZVwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGlkOiBpZCB9KSxcbiAgICB9KS50aGVuKGFzeW5jIGZ1bmN0aW9uIChhKSB7XG4gICAgICBhd2FpdCBhLnRleHQoKS50aGVuKCh0KSA9PiB7XG4gICAgICAgIHJlc3AgPSB0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc2V0RGVsZXRlZChpZCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2dnbGVDb25uZWN0aW9uKCkge1xuICAgIGlmIChidXRuID09PSBjb25uKSB7XG4gICAgICBjbGllbnQgPSBtcXR0LmNvbm5lY3QodXJsKTtcblxuICAgICAgY2xpZW50Lm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICAgIHNldEJ1dG4oZGlzY29ubik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY29ubmVjdGVkXCIpO1xuICAgICAgfSk7XG4gICAgICBjbGllbnQub24oXCJtZXNzYWdlXCIsICh0b3BpYywgbWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhzdWJNZXNzYWdlKTtcbiAgICAgICAgc2V0U3ViTWVzc2FnZSgocHJ2KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHBydiArIG1lc3NhZ2UudG9TdHJpbmcoKSArIFwiXFxuXCI7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsaWVudC5lbmQoKTtcbiAgICAgIHNldEJ1dG4oY29ubik7XG4gICAgICBzZXRTdWJNZXNzYWdlKFwiXCIpO1xuICAgIH1cbiAgfVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIGEoKSB7XG4gICAgICBjb25zdCBlID0gYXdhaXQgYnV0dG9ucygpO1xuICAgICAgc2V0YnRuTGlzdChlKTtcbiAgICAgIHNldGJ0bkFycnkoT2JqZWN0LmtleXMoZSkpO1xuICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICBjb25zb2xlLmxvZyhidG5BcnJ5KTtcbiAgICB9XG4gICAgYSgpO1xuICB9LCBbZGVsZXRlZF0pO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29udGluZXJ9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ib3h9PlxuICAgICAgICA8aDEgY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9PkhvbWUxPC9oMT5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzTmFtZT17YCR7c3R5bGVzLmJ0bn0gJHtidXRuLmNzc31gfVxuICAgICAgICAgIG9uQ2xpY2s9e3RvZ2dsZUNvbm5lY3Rpb259XG4gICAgICAgID5cbiAgICAgICAgICB7YnV0bi50aXRsZX1cbiAgICAgICAgICB7Y29uc29sZS5sb2coYnV0bi50aXRsZSl9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYnV0dG9uc30+XG4gICAgICAgIHtidG5BcnJ5Lm1hcCgoYnRuLCBpbmRleCkgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGtleT17YnRufSBpZD17YnRufSBjbGFzc05hbWU9e3N0eWxlcy5idG5ib3JkYXJ9PlxuICAgICAgICAgICAgICA8aDM+e2J0bkxpc3RbYnRuXS5wYW5lbE5hbWV9PC9oMz5cbiAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgIERlbGV0ZShidG4pO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuaWNvbn1cbiAgICAgICAgICAgICAgICBzcmM9e1wiaWNvbi9pY29uczgtZGVsZXRlLnN2Z1wifVxuICAgICAgICAgICAgICAgIGFsdD1cIlwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2hlY2tib3h3cmFwcGVyfT5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICBpZD17aW5kZXh9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake3N0eWxlcy50Z2x9ICR7c3R5bGVzLnRnbHNrZXdlZH1gfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPGxhYmVsXG4gICAgICAgICAgICAgICAgICBmb3I9e2luZGV4fVxuICAgICAgICAgICAgICAgICAgZGF0YS10Zy1vbj1cIk9OXCJcbiAgICAgICAgICAgICAgICAgIGRhdGEtdGctb2ZmPVwiT0ZGXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnRnbGJ0bn1cbiAgICAgICAgICAgICAgICA+PC9sYWJlbD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRpdmJ0bn0+XG4gICAgICAgIDxMaW5rIGhyZWY9XCIvQWRkLUJ1dHRvblwiIGNsYXNzTmFtZT17c3R5bGVzLmxpbmt9PlxuICAgICAgICAgICtcbiAgICAgICAgPC9MaW5rPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiSW1hZ2UiLCJzdHlsZXMiLCJMaW5rIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJtcXR0IiwiY29ubiIsInRpdGxlIiwiY3NzIiwiY29ubmVjdCIsImRpc2Nvbm4iLCJkaXNjb25uZWN0IiwiY2xpZW50Iiwic3Vic2NyaWJlIiwic3ViVG9waWMiLCJlcnIiLCJjb25zb2xlIiwibG9nIiwiY2hlY2siLCJwYXJhIiwiY2hlY2tlZCIsInB1Ymxpc2giLCJidXR0b25zIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJ0aGVuIiwicmVzcCIsInRleHQiLCJKU09OIiwicGFyc2UiLCJIb21lIiwidXJsIiwiYnV0biIsInNldEJ1dG4iLCJzdWJNZXNzYWdlIiwic2V0U3ViTWVzc2FnZSIsInB1Yk1lc3NhZ2UiLCJzZXRQdWJNZXNzYWdlIiwiYnRuTGlzdCIsInNldGJ0bkxpc3QiLCJidG5BcnJ5Iiwic2V0YnRuQXJyeSIsImRlbGV0ZWQiLCJzZXREZWxldGVkIiwiRGVsZXRlIiwiaWQiLCJoZWFkZXJzIiwiQWNjZXB0IiwiYm9keSIsInN0cmluZ2lmeSIsImEiLCJ0IiwidG9nZ2xlQ29ubmVjdGlvbiIsIm9uIiwidG9waWMiLCJtZXNzYWdlIiwicHJ2IiwidG9TdHJpbmciLCJlbmQiLCJlIiwiT2JqZWN0Iiwia2V5cyIsImRpdiIsImNsYXNzTmFtZSIsImNvbnRpbmVyIiwiYm94IiwiaDEiLCJidXR0b24iLCJidG4iLCJvbkNsaWNrIiwibWFwIiwiaW5kZXgiLCJidG5ib3JkYXIiLCJoMyIsInBhbmVsTmFtZSIsImltZyIsImljb24iLCJzcmMiLCJhbHQiLCJjaGVja2JveHdyYXBwZXIiLCJpbnB1dCIsInR5cGUiLCJ0Z2wiLCJ0Z2xza2V3ZWQiLCJsYWJlbCIsImZvciIsImRhdGEtdGctb24iLCJkYXRhLXRnLW9mZiIsInRnbGJ0biIsImRpdmJ0biIsImhyZWYiLCJsaW5rIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwyREFBMkQsVUFBVTtBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsR0FBRztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRCxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOENBQThDLGdEQUFnRCxNQUFNLGFBQWE7O0FBRWpIO0FBQ0EsK0NBQStDLGtDQUFrQyxPQUFPOztBQUV4Rix1R0FBdUcsY0FBYyxVQUFVLGdHQUFnRyxrQkFBa0IsVUFBVSxVQUFVOztBQUVyUTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9mOTM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTtcblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMiA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMiB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTsgLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxKSB7XG4gICAgICAvLyBUT0RPOiBDcmVhdGUgYSBjb252ZW50aW9uIGZvciBuYW1pbmcgY2xpZW50IHJlZmVyZW5jZXMgd2l0aCBkZWJ1ZyBpbmZvLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJ0NhY2hlJztcbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFViQxKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShwYXJlbnRUeXBlKTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFViQxKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdrZXknKSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsgIT09ICdrZXknO1xuICAgICAgfSk7XG4gICAgICB2YXIgYmVmb3JlRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7a2V5OiBzb21lS2V5LCAnICsga2V5cy5qb2luKCc6IC4uLiwgJykgKyAnOiAuLi59JyA6ICd7a2V5OiBzb21lS2V5fSc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSkge1xuICAgICAgICB2YXIgYWZ0ZXJFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3snICsga2V5cy5qb2luKCc6IC4uLiwgJykgKyAnOiAuLi59JyA6ICd7fSc7XG5cbiAgICAgICAgZXJyb3IoJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIHsuLi5wcm9wc30gLz5cXG4nICsgJ1JlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsIGJlZm9yZUV4YW1wbGUsIGNvbXBvbmVudE5hbWUsIGFmdGVyRXhhbXBsZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYgPSBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVY7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/YzM4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzllZWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/process/browser.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2Fhome%2Fjon%2FIOT%2FIOT%2Ffrontend%2FV%201.0%2Fmy-app%2Fsrc%2Fapp%2Fpage.jsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);